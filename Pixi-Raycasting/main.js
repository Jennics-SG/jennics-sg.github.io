/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@pixi/color/lib/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/Color.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar colord = __webpack_require__(/*! @pixi/colord */ \"./node_modules/@pixi/colord/index.js\"), namesPlugin = __webpack_require__(/*! @pixi/colord/plugins/names */ \"./node_modules/@pixi/colord/plugins/names.js\");\ncolord.extend([namesPlugin]);\nconst _Color = class _Color2 {\n  /**\n   * @param {PIXI.ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see PIXI.Color.value\n   */\n  setValue(value) {\n    return this.value = value, this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link PIXI.Color.multiply multiply},\n   *   {@link PIXI.Color.premultiply premultiply} or {@link PIXI.Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   * @type {PIXI.ColorSource}\n   */\n  set value(value) {\n    if (value instanceof _Color2)\n      this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);\n    else {\n      if (value === null)\n        throw new Error(\"Cannot set PIXI.Color#value to null\");\n      (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  cloneSource(value) {\n    return typeof value == \"string\" || typeof value == \"number\" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == \"object\" && value !== null ? { ...value } : value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    if (type1 !== typeof value2)\n      return !1;\n    if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number)\n      return value1 === value2;\n    if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n      return value1.length !== value2.length ? !1 : value1.every((v, i) => v === value2[i]);\n    if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1), keys2 = Object.keys(value2);\n      return keys1.length !== keys2.length ? !1 : keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    return out = out ?? [], out[0] = Math.round(r * 255), out[1] = Math.round(g * 255), out[2] = Math.round(b * 255), out;\n  }\n  toRgbArray(out) {\n    out = out ?? [];\n    const [r, g, b] = this._components;\n    return out[0] = r, out[1] = g, out[2] = b, out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {PIXI.ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color2.temp.setValue(value)._components;\n    return this._components[0] *= r, this._components[1] *= g, this._components[2] *= b, this._components[3] *= a, this.refreshInt(), this._value = null, this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {PIXI.Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = !0) {\n    return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = !0) {\n    if (alpha === 1)\n      return (255 << 24) + this._int;\n    if (alpha === 0)\n      return applyToRGB ? 0 : this._int;\n    let r = this._int >> 16 & 255, g = this._int >> 8 & 255, b = this._int & 255;\n    return applyToRGB && (r = r * alpha + 0.5 | 0, g = g * alpha + 0.5 | 0, b = b * alpha + 0.5 | 0), (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaString = Math.round(this._components[3] * 255).toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    return this._components[3] = this._clamp(alpha), this;\n  }\n  /**\n   * Rounds the specified color according to the step. This action is destructive, and will\n   * override the previous `value` property to be `null`. The alpha component is not rounded.\n   * @param steps - Number of steps which will be used as a cap when rounding colors\n   * @deprecated since 7.3.0\n   */\n  round(steps) {\n    const [r, g, b] = this._components;\n    return this._components[0] = Math.round(r * steps) / steps, this._components[1] = Math.round(g * steps) / steps, this._components[2] = Math.round(b * steps) / steps, this.refreshInt(), this._value = null, this;\n  }\n  toArray(out) {\n    out = out ?? [];\n    const [r, g, b, a] = this._components;\n    return out[0] = r, out[1] = g, out[2] = b, out[3] = a, out;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  normalize(value) {\n    let r, g, b, a;\n    if ((typeof value == \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255, g = (int >> 8 & 255) / 255, b = (int & 255) / 255, a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)\n      value = this._clamp(value), [r, g, b, a = 1] = value;\n    else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)\n      value = this._clamp(value, 0, 255), [r, g, b, a = 255] = value, r /= 255, g /= 255, b /= 255, a /= 255;\n    else if (typeof value == \"string\" || typeof value == \"object\") {\n      if (typeof value == \"string\") {\n        const match = _Color2.HEX_PATTERN.exec(value);\n        match && (value = `#${match[2]}`);\n      }\n      const color = colord.colord(value);\n      color.isValid() && ({ r, g, b, a } = color.rgba, r /= 255, g /= 255, b /= 255);\n    }\n    if (r !== void 0)\n      this._components[0] = r, this._components[1] = g, this._components[2] = b, this._components[3] = a, this.refreshInt();\n    else\n      throw new Error(`Unable to convert color ${value}`);\n  }\n  /** Refresh the internal color rgb number */\n  refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    return typeof value == \"number\" ? Math.min(Math.max(value, min), max) : (value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    }), value);\n  }\n};\n_Color.shared = new _Color(), /**\n* Temporary Color object for static uses internally.\n* As to not conflict with Color.shared.\n* @ignore\n*/\n_Color.temp = new _Color(), /** Pattern for hex strings */\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\nexports.Color = Color;\n//# sourceMappingURL=Color.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/color/lib/Color.js?");

/***/ }),

/***/ "./node_modules/@pixi/color/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Color = __webpack_require__(/*! ./Color.js */ \"./node_modules/@pixi/color/lib/Color.js\");\nexports.Color = Color.Color;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/color/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/colord/index.js":
/*!********************************************!*\
  !*** ./node_modules/@pixi/colord/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("Object.defineProperty(exports, \"__esModule\", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));// removed by dead control flow\n{ var t, n, e; }},p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};// removed by dead control flow\n{ var t, n, e, u; }},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,c=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},\"hsl\"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):\"\",\"#\"+i(t)+i(e)+i(u)+s;// removed by dead control flow\n{ var r, t, e, u, o, s; }},r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";// removed by dead control flow\n{ var r, t, n, e, u; }},r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";// removed by dead control flow\n{ var r, t, n, e, u; }},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};// removed by dead control flow\n{ var r; }},r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});// removed by dead control flow\n{ var r; }},r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);// removed by dead control flow\n{ var t; }},r.prototype.hue=function(r){var t=p(this.rgba);return\"number\"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/colord/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/colord/plugins/names.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/colord/plugins/names.js ***!
  \****************************************************/
/***/ ((module) => {

eval("module.exports=function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,o=r[this.toHex()];if(o)return o;if(null==f?void 0:f.closest){var n=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=n,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/colord/plugins/names.js?");

/***/ }),

/***/ "./node_modules/@pixi/constants/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/constants/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nvar ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", ENV2[ENV2.WEBGL = 1] = \"WEBGL\", ENV2[ENV2.WEBGL2 = 2] = \"WEBGL2\", ENV2))(ENV || {}), RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = \"UNKNOWN\", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = \"WEBGL\", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = \"CANVAS\", RENDERER_TYPE2))(RENDERER_TYPE || {}), BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = \"COLOR\", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = \"DEPTH\", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = \"STENCIL\", BUFFER_BITS2))(BUFFER_BITS || {}), BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => (BLEND_MODES2[BLEND_MODES2.NORMAL = 0] = \"NORMAL\", BLEND_MODES2[BLEND_MODES2.ADD = 1] = \"ADD\", BLEND_MODES2[BLEND_MODES2.MULTIPLY = 2] = \"MULTIPLY\", BLEND_MODES2[BLEND_MODES2.SCREEN = 3] = \"SCREEN\", BLEND_MODES2[BLEND_MODES2.OVERLAY = 4] = \"OVERLAY\", BLEND_MODES2[BLEND_MODES2.DARKEN = 5] = \"DARKEN\", BLEND_MODES2[BLEND_MODES2.LIGHTEN = 6] = \"LIGHTEN\", BLEND_MODES2[BLEND_MODES2.COLOR_DODGE = 7] = \"COLOR_DODGE\", BLEND_MODES2[BLEND_MODES2.COLOR_BURN = 8] = \"COLOR_BURN\", BLEND_MODES2[BLEND_MODES2.HARD_LIGHT = 9] = \"HARD_LIGHT\", BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", BLEND_MODES2[BLEND_MODES2.DIFFERENCE = 11] = \"DIFFERENCE\", BLEND_MODES2[BLEND_MODES2.EXCLUSION = 12] = \"EXCLUSION\", BLEND_MODES2[BLEND_MODES2.HUE = 13] = \"HUE\", BLEND_MODES2[BLEND_MODES2.SATURATION = 14] = \"SATURATION\", BLEND_MODES2[BLEND_MODES2.COLOR = 15] = \"COLOR\", BLEND_MODES2[BLEND_MODES2.LUMINOSITY = 16] = \"LUMINOSITY\", BLEND_MODES2[BLEND_MODES2.NORMAL_NPM = 17] = \"NORMAL_NPM\", BLEND_MODES2[BLEND_MODES2.ADD_NPM = 18] = \"ADD_NPM\", BLEND_MODES2[BLEND_MODES2.SCREEN_NPM = 19] = \"SCREEN_NPM\", BLEND_MODES2[BLEND_MODES2.NONE = 20] = \"NONE\", BLEND_MODES2[BLEND_MODES2.SRC_OVER = 0] = \"SRC_OVER\", BLEND_MODES2[BLEND_MODES2.SRC_IN = 21] = \"SRC_IN\", BLEND_MODES2[BLEND_MODES2.SRC_OUT = 22] = \"SRC_OUT\", BLEND_MODES2[BLEND_MODES2.SRC_ATOP = 23] = \"SRC_ATOP\", BLEND_MODES2[BLEND_MODES2.DST_OVER = 24] = \"DST_OVER\", BLEND_MODES2[BLEND_MODES2.DST_IN = 25] = \"DST_IN\", BLEND_MODES2[BLEND_MODES2.DST_OUT = 26] = \"DST_OUT\", BLEND_MODES2[BLEND_MODES2.DST_ATOP = 27] = \"DST_ATOP\", BLEND_MODES2[BLEND_MODES2.ERASE = 26] = \"ERASE\", BLEND_MODES2[BLEND_MODES2.SUBTRACT = 28] = \"SUBTRACT\", BLEND_MODES2[BLEND_MODES2.XOR = 29] = \"XOR\", BLEND_MODES2))(BLEND_MODES || {}), DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = \"POINTS\", DRAW_MODES2[DRAW_MODES2.LINES = 1] = \"LINES\", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = \"LINE_LOOP\", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = \"LINE_STRIP\", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = \"TRIANGLES\", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\", DRAW_MODES2))(DRAW_MODES || {}), FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = \"RGBA\", FORMATS2[FORMATS2.RGB = 6407] = \"RGB\", FORMATS2[FORMATS2.RG = 33319] = \"RG\", FORMATS2[FORMATS2.RED = 6403] = \"RED\", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = \"RGB_INTEGER\", FORMATS2[FORMATS2.RG_INTEGER = 33320] = \"RG_INTEGER\", FORMATS2[FORMATS2.RED_INTEGER = 36244] = \"RED_INTEGER\", FORMATS2[FORMATS2.ALPHA = 6406] = \"ALPHA\", FORMATS2[FORMATS2.LUMINANCE = 6409] = \"LUMINANCE\", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\", FORMATS2))(FORMATS || {}), TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = \"TEXTURE_2D\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\", TARGETS2))(TARGETS || {}), TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", TYPES2[TYPES2.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", TYPES2[TYPES2.BYTE = 5120] = \"BYTE\", TYPES2[TYPES2.SHORT = 5122] = \"SHORT\", TYPES2[TYPES2.INT = 5124] = \"INT\", TYPES2[TYPES2.FLOAT = 5126] = \"FLOAT\", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", TYPES2[TYPES2.HALF_FLOAT = 36193] = \"HALF_FLOAT\", TYPES2))(TYPES || {}), SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = \"FLOAT\", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = \"INT\", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = \"UINT\", SAMPLER_TYPES2))(SAMPLER_TYPES || {}), SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = \"NEAREST\", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = \"LINEAR\", SCALE_MODES2))(SCALE_MODES || {}), WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = \"CLAMP\", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = \"REPEAT\", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\", WRAP_MODES2))(WRAP_MODES || {}), MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = \"OFF\", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = \"POW2\", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = \"ON\", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = \"ON_MANUAL\", MIPMAP_MODES2))(MIPMAP_MODES || {}), ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = \"NPM\", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = \"UNPACK\", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = \"PMA\", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\", ALPHA_MODES2))(ALPHA_MODES || {}), CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = \"NO\", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = \"YES\", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = \"AUTO\", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = \"BLEND\", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = \"CLEAR\", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = \"BLIT\", CLEAR_MODES2))(CLEAR_MODES || {}), GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = \"AUTO\", GC_MODES2[GC_MODES2.MANUAL = 1] = \"MANUAL\", GC_MODES2))(GC_MODES || {}), PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = \"lowp\", PRECISION2.MEDIUM = \"mediump\", PRECISION2.HIGH = \"highp\", PRECISION2))(PRECISION || {}), MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = \"NONE\", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = \"SCISSOR\", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = \"STENCIL\", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = \"SPRITE\", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = \"COLOR\", MASK_TYPES2))(MASK_TYPES || {}), COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => (COLOR_MASK_BITS2[COLOR_MASK_BITS2.RED = 1] = \"RED\", COLOR_MASK_BITS2[COLOR_MASK_BITS2.GREEN = 2] = \"GREEN\", COLOR_MASK_BITS2[COLOR_MASK_BITS2.BLUE = 4] = \"BLUE\", COLOR_MASK_BITS2[COLOR_MASK_BITS2.ALPHA = 8] = \"ALPHA\", COLOR_MASK_BITS2))(COLOR_MASK_BITS || {}), MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = \"NONE\", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = \"LOW\", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = \"MEDIUM\", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = \"HIGH\", MSAA_QUALITY2))(MSAA_QUALITY || {}), BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => (BUFFER_TYPE2[BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", BUFFER_TYPE2[BUFFER_TYPE2.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", BUFFER_TYPE2[BUFFER_TYPE2.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\", BUFFER_TYPE2))(BUFFER_TYPE || {});\nexports.ALPHA_MODES = ALPHA_MODES;\nexports.BLEND_MODES = BLEND_MODES;\nexports.BUFFER_BITS = BUFFER_BITS;\nexports.BUFFER_TYPE = BUFFER_TYPE;\nexports.CLEAR_MODES = CLEAR_MODES;\nexports.COLOR_MASK_BITS = COLOR_MASK_BITS;\nexports.DRAW_MODES = DRAW_MODES;\nexports.ENV = ENV;\nexports.FORMATS = FORMATS;\nexports.GC_MODES = GC_MODES;\nexports.MASK_TYPES = MASK_TYPES;\nexports.MIPMAP_MODES = MIPMAP_MODES;\nexports.MSAA_QUALITY = MSAA_QUALITY;\nexports.PRECISION = PRECISION;\nexports.RENDERER_TYPE = RENDERER_TYPE;\nexports.SAMPLER_TYPES = SAMPLER_TYPES;\nexports.SCALE_MODES = SCALE_MODES;\nexports.TARGETS = TARGETS;\nexports.TYPES = TYPES;\nexports.WRAP_MODES = WRAP_MODES;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/constants/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/IRenderer.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/core/lib/IRenderer.js ***!
  \**************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=IRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/IRenderer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/Renderer.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/core/lib/Renderer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ \"./node_modules/@pixi/core/lib/shader/UniformGroup.js\"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ \"./node_modules/@pixi/core/lib/system/SystemManager.js\");\nconst _Renderer = class _Renderer2 extends SystemManager.SystemManager {\n  /**\n   * @param {PIXI.IRendererOptions} [options] - See {@link PIXI.settings.RENDER_OPTIONS} for defaults.\n   */\n  constructor(options) {\n    super(), this.type = constants.RENDERER_TYPE.WEBGL, options = Object.assign({}, settings.settings.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup.UniformGroup({\n      projectionMatrix: new math.Matrix()\n    }, !0);\n    const systemConfig = {\n      runners: [\n        \"init\",\n        \"destroy\",\n        \"contextChange\",\n        \"resolutionChange\",\n        \"reset\",\n        \"update\",\n        \"postrender\",\n        \"prerender\",\n        \"resize\"\n      ],\n      systems: _Renderer2.__systems,\n      priority: [\n        \"_view\",\n        \"textureGenerator\",\n        \"background\",\n        \"_plugin\",\n        \"startup\",\n        // low level WebGL systems\n        \"context\",\n        \"state\",\n        \"texture\",\n        \"buffer\",\n        \"geometry\",\n        \"framebuffer\",\n        \"transformFeedback\",\n        // high level pixi specific rendering\n        \"mask\",\n        \"scissor\",\n        \"stencil\",\n        \"projection\",\n        \"textureGC\",\n        \"filter\",\n        \"renderTexture\",\n        \"batch\",\n        \"objectRenderer\",\n        \"_multisample\"\n      ]\n    };\n    this.setup(systemConfig), \"useContextAlpha\" in options && (utils.deprecation(\"7.0.0\", \"options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead\"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== \"notMultiplied\", options.backgroundAlpha = options.useContextAlpha === !1 ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);\n  }\n  /**\n   * Create renderer if WebGL is available. Overrideable\n   * by the **@pixi/canvas-renderer** package to allow fallback.\n   * throws error if WebGL is not available.\n   * @param options\n   * @private\n   */\n  static test(options) {\n    return options?.forceCanvas ? !1 : utils.isWebGLSupported();\n  }\n  /**\n   * Renders the object to its WebGL view.\n   * @param displayObject - The object to be rendered.\n   * @param {object} [options] - Object to use for render options.\n   * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.\n   * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.\n   * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.\n   * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?\n   */\n  render(displayObject, options) {\n    this.objectRenderer.render(displayObject, options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight) {\n    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);\n  }\n  /**\n   * Resets the WebGL state so you can render things however you fancy!\n   * @returns Returns itself.\n   */\n  reset() {\n    return this.runners.reset.emit(), this;\n  }\n  /** Clear the frame buffer. */\n  clear() {\n    this.renderTexture.bind(), this.renderTexture.clear();\n  }\n  /**\n   * Removes everything from the renderer (event listeners, spritebatch, etc...)\n   * @param [removeView=false] - Removes the Canvas element from the DOM.\n   *  See: https://github.com/pixijs/pixijs/issues/2233\n   */\n  destroy(removeView = !1) {\n    this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {\n      _view: removeView\n    }), super.destroy();\n  }\n  /** Collection of plugins */\n  get plugins() {\n    return this._plugin.plugins;\n  }\n  /** The number of msaa samples of the canvas. */\n  get multisample() {\n    return this._multisample.multisample;\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this._view.element.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this._view.element.height;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this._view.resolution;\n  }\n  set resolution(value) {\n    this._view.resolution = value, this.runners.resolutionChange.emit(value);\n  }\n  /** Whether CSS dimensions of canvas view should be resized to screen dimensions automatically. */\n  get autoDensity() {\n    return this._view.autoDensity;\n  }\n  /** The canvas element that everything is drawn to.*/\n  get view() {\n    return this._view.element;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   * @member {PIXI.Rectangle}\n   */\n  get screen() {\n    return this._view.screen;\n  }\n  /** the last object rendered by the renderer. Useful for other plugins like interaction managers */\n  get lastObjectRendered() {\n    return this.objectRenderer.lastObjectRendered;\n  }\n  /** Flag if we are rendering to the screen vs renderTexture */\n  get renderingToScreen() {\n    return this.objectRenderer.renderingToScreen;\n  }\n  /** When logging Pixi to the console, this is the name we will show */\n  get rendererLogId() {\n    return `WebGL ${this.context.webGLVersion}`;\n  }\n  /**\n   * This sets weather the screen is totally cleared between each frame withthe background color and alpha\n   * @deprecated since 7.0.0\n   */\n  get clearBeforeRender() {\n    return utils.deprecation(\"7.0.0\", \"renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.\"), this.background.clearBeforeRender;\n  }\n  /**\n   * Pass-thru setting for the canvas' context `alpha` property. This is typically\n   * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.\n   * @deprecated since 7.0.0\n   * @member {boolean}\n   */\n  get useContextAlpha() {\n    return utils.deprecation(\"7.0.0\", \"renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.\"), this.context.useContextAlpha;\n  }\n  /**\n   * readonly drawing buffer preservation\n   * we can only know this if Pixi created the context\n   * @deprecated since 7.0.0\n   */\n  get preserveDrawingBuffer() {\n    return utils.deprecation(\"7.0.0\", \"renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context\"), this.context.preserveDrawingBuffer;\n  }\n  /**\n   * The background color to fill if not transparent\n   * @member {number}\n   * @deprecated since 7.0.0\n   */\n  get backgroundColor() {\n    return utils.deprecation(\"7.0.0\", \"renderer.backgroundColor has been deprecated, use renderer.background.color instead.\"), this.background.color;\n  }\n  set backgroundColor(value) {\n    utils.deprecation(\"7.0.0\", \"renderer.backgroundColor has been deprecated, use renderer.background.color instead.\"), this.background.color = value;\n  }\n  /**\n   * The background color alpha. Setting this to 0 will make the canvas transparent.\n   * @member {number}\n   * @deprecated since 7.0.0\n   */\n  get backgroundAlpha() {\n    return utils.deprecation(\"7.0.0\", \"renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.\"), this.background.alpha;\n  }\n  /**\n   * @deprecated since 7.0.0\n   */\n  set backgroundAlpha(value) {\n    utils.deprecation(\"7.0.0\", \"renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.\"), this.background.alpha = value;\n  }\n  /**\n   * @deprecated since 7.0.0\n   */\n  get powerPreference() {\n    return utils.deprecation(\"7.0.0\", \"renderer.powerPreference has been deprecated, we can only know this if pixi creates the context\"), this.context.powerPreference;\n  }\n  /**\n   * Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n   * @param displayObject - The displayObject the object will be generated from.\n   * @param {IGenerateTextureOptions} options - Generate texture options.\n   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,\n   *        if no region is specified, defaults to the local bounds of the displayObject.\n   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.\n   * @returns A texture of the graphics object.\n   */\n  generateTexture(displayObject, options) {\n    return this.textureGenerator.generateTexture(displayObject, options);\n  }\n};\n_Renderer.extension = {\n  type: extensions.ExtensionType.Renderer,\n  priority: 1\n}, /**\n* Collection of installed plugins. These are included by default in PIXI, but can be excluded\n* by creating a custom build. Consult the README for more information about creating custom\n* builds and excluding plugins.\n* @private\n*/\n_Renderer.__plugins = {}, /**\n* The collection of installed systems.\n* @private\n*/\n_Renderer.__systems = {};\nlet Renderer = _Renderer;\nextensions.extensions.handleByMap(extensions.ExtensionType.RendererPlugin, Renderer.__plugins);\nextensions.extensions.handleByMap(extensions.ExtensionType.RendererSystem, Renderer.__systems);\nextensions.extensions.add(Renderer);\nexports.Renderer = Renderer;\n//# sourceMappingURL=Renderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/Renderer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/autoDetectRenderer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/autoDetectRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nconst renderers = [];\nextensions.extensions.handleByList(extensions.ExtensionType.Renderer, renderers);\nfunction autoDetectRenderer(options) {\n  for (const RendererType of renderers)\n    if (RendererType.test(options))\n      return new RendererType(options);\n  throw new Error(\"Unable to auto-detect a suitable renderer.\");\n}\nexports.autoDetectRenderer = autoDetectRenderer;\n//# sourceMappingURL=autoDetectRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/autoDetectRenderer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/background/BackgroundSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/background/BackgroundSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nclass BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = !0, this._backgroundColor = new color.Color(0), this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param {PIXI.IRendererOptions} options - the options for the background colors\n   */\n  init(options) {\n    this.clearBeforeRender = options.clearBeforeRender;\n    const { backgroundColor, background, backgroundAlpha } = options, color2 = background ?? backgroundColor;\n    color2 !== void 0 && (this.color = color2), this.alpha = backgroundAlpha;\n  }\n  /**\n   * The background color to fill if not transparent.\n   * @member {PIXI.ColorSource}\n   */\n  get color() {\n    return this._backgroundColor.value;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /**\n   * The background color alpha. Setting this to 0 will make the canvas transparent.\n   * @member {number}\n   */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color object. */\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  destroy() {\n  }\n}\nBackgroundSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.backgroundAlpha}\n   * @default 1\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link PIXI.IRendererOptions.backgroundColor}\n   * @default 0x000000\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  backgroundColor: 0,\n  /**\n   * {@link PIXI.IRendererOptions.clearBeforeRender}\n   * @default true\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  clearBeforeRender: !0\n}, /** @ignore */\nBackgroundSystem.extension = {\n  type: [\n    extensions.ExtensionType.RendererSystem,\n    extensions.ExtensionType.CanvasRendererSystem\n  ],\n  name: \"background\"\n};\nextensions.extensions.add(BackgroundSystem);\nexports.BackgroundSystem = BackgroundSystem;\n//# sourceMappingURL=BackgroundSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/background/BackgroundSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchDrawCall.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nclass BatchDrawCall {\n  constructor() {\n    this.texArray = null, this.blend = 0, this.type = constants.DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n  }\n}\nexports.BatchDrawCall = BatchDrawCall;\n//# sourceMappingURL=BatchDrawCall.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchDrawCall.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchGeometry.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchGeometry.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ \"./node_modules/@pixi/core/lib/geometry/Buffer.js\"), Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ \"./node_modules/@pixi/core/lib/geometry/Geometry.js\");\nclass BatchGeometry extends Geometry.Geometry {\n  /**\n   * @param {boolean} [_static=false] - Optimization flag, where `false`\n   *        is updated every frame, `true` doesn't change frame-to-frame.\n   */\n  constructor(_static = !1) {\n    super(), this._buffer = new Buffer.Buffer(null, _static, !1), this._indexBuffer = new Buffer.Buffer(null, _static, !0), this.addAttribute(\"aVertexPosition\", this._buffer, 2, !1, constants.TYPES.FLOAT).addAttribute(\"aTextureCoord\", this._buffer, 2, !1, constants.TYPES.FLOAT).addAttribute(\"aColor\", this._buffer, 4, !0, constants.TYPES.UNSIGNED_BYTE).addAttribute(\"aTextureId\", this._buffer, 1, !0, constants.TYPES.FLOAT).addIndex(this._indexBuffer);\n  }\n}\nexports.BatchGeometry = BatchGeometry;\n//# sourceMappingURL=BatchGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchGeometry.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchRenderer.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchRenderer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), ViewableBuffer = __webpack_require__(/*! ../geometry/ViewableBuffer.js */ \"./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js\"), checkMaxIfStatementsInShader = __webpack_require__(/*! ../shader/utils/checkMaxIfStatementsInShader.js */ \"./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js\"), State = __webpack_require__(/*! ../state/State.js */ \"./node_modules/@pixi/core/lib/state/State.js\"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), BatchDrawCall = __webpack_require__(/*! ./BatchDrawCall.js */ \"./node_modules/@pixi/core/lib/batch/BatchDrawCall.js\"), BatchGeometry = __webpack_require__(/*! ./BatchGeometry.js */ \"./node_modules/@pixi/core/lib/batch/BatchGeometry.js\"), BatchShaderGenerator = __webpack_require__(/*! ./BatchShaderGenerator.js */ \"./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js\"), BatchTextureArray = __webpack_require__(/*! ./BatchTextureArray.js */ \"./node_modules/@pixi/core/lib/batch/BatchTextureArray.js\"), canUploadSameBuffer = __webpack_require__(/*! ./canUploadSameBuffer.js */ \"./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js\"), maxRecommendedTextures = __webpack_require__(/*! ./maxRecommendedTextures.js */ \"./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js\"), ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ \"./node_modules/@pixi/core/lib/batch/ObjectRenderer.js\"), texture$1 = __webpack_require__(/*! ./texture.frag.js */ \"./node_modules/@pixi/core/lib/batch/texture.frag.js\"), texture = __webpack_require__(/*! ./texture.vert.js */ \"./node_modules/@pixi/core/lib/batch/texture.vert.js\");\nconst _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer.ObjectRenderer {\n  /**\n   * This will hook onto the renderer's `contextChange`\n   * and `prerender` signals.\n   * @param {PIXI.Renderer} renderer - The renderer this works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry.BatchGeometry, this.vertexSize = 6, this.state = State.State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on(\"prerender\", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];\n  }\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @default 32\n   */\n  static get defaultMaxTextures() {\n    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures.maxRecommendedTextures(32), this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   */\n  static get canUploadSameBuffer() {\n    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer.canUploadSameBuffer(), this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  /**\n   * @see PIXI.BatchRenderer#maxTextures\n   * @deprecated since 7.1.0\n   * @readonly\n   */\n  get MAX_TEXTURES() {\n    return utils.deprecation(\"7.1.0\", \"BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures\"), this.maxTextures;\n  }\n  /**\n   * The default vertex shader source\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return texture.default;\n  }\n  /**\n   * The default fragment shader source\n   * @readonly\n   */\n  static get defaultFragmentTemplate() {\n    return texture$1.default;\n  }\n  /**\n   * Set the shader generator.\n   * @param {object} [options]\n   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n   */\n  setShaderGenerator({\n    vertex = _BatchRenderer2.defaultVertexSrc,\n    fragment = _BatchRenderer2.defaultFragmentTemplate\n  } = {}) {\n    this.shaderGenerator = new BatchShaderGenerator.BatchShaderGenerator(vertex, fragment);\n  }\n  /**\n   * Handles the `contextChange` signal.\n   *\n   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.\n   */\n  contextChange() {\n    const gl = this.renderer.gl;\n    settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(\n      gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n      _BatchRenderer2.defaultMaxTextures\n    ), this.maxTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(\n      this.maxTextures,\n      gl\n    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] = new this.geometryClass();\n    this.initFlushBuffers();\n  }\n  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    for (; _drawCallPool.length < MAX_SPRITES; )\n      _drawCallPool.push(new BatchDrawCall.BatchDrawCall());\n    for (; _textureArrayPool.length < MAX_TA; )\n      _textureArrayPool.push(new BatchTextureArray.BatchTextureArray());\n    for (let i = 0; i < this.maxTextures; i++)\n      this._tempBoundTextures[i] = null;\n  }\n  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n  onPrerender() {\n    this._flushId = 0;\n  }\n  /**\n   * Buffers the \"batchable\" object. It need not be rendered immediately.\n   * @param {PIXI.DisplayObject} element - the element to render when\n   *    using this renderer\n   */\n  render(element) {\n    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture.BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i), start = i, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);\n    }\n    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);\n    for (let i = 0; i < boundTextures.length; i++)\n      boundTextures[i] = null;\n    BaseTexture.BaseTexture._globalBatch = TICK;\n  }\n  /**\n   * Populating drawcalls for rendering\n   * @param texArray\n   * @param start\n   * @param finish\n   */\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this, drawCalls = _BatchRenderer2._drawCallPool;\n    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex, drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i], tex = sprite._texture.baseTexture, spriteBlendMode = utils.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null, start < i && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;\n    }\n    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;\n  }\n  /**\n   * Bind textures for current rendering\n   * @param texArray\n   */\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++)\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]), texArray.elements[j] = null;\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const { texArray, type, size, start, blend } = drawCalls[i];\n      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  /** Renders the content _now_ and empties the current batch. */\n  flush() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }\n  /** Starts a new sprite batch. */\n  start() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }\n  /** Stops and flushes the current batch. */\n  stop() {\n    this.flush();\n  }\n  /** Destroys this `BatchRenderer`. It cannot be used again. */\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] && this._packedGeometries[i].destroy();\n    this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();\n  }\n  /**\n   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n   * @param size - minimum capacity required\n   * @returns - buffer than can hold atleast `size` floats\n   */\n  getAttributeBuffer(size) {\n    const roundedP2 = utils.nextPow2(Math.ceil(size / 8)), roundedSizeIndex = utils.log2(roundedP2), roundedSize = roundedP2 * 8;\n    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._aBuffers[roundedSize];\n    return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer.ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;\n  }\n  /**\n   * Fetches an index buffer from `this._iBuffers` that can\n   * have at least `size` capacity.\n   * @param size - minimum required capacity\n   * @returns - buffer that can fit `size` indices.\n   */\n  getIndexBuffer(size) {\n    const roundedP2 = utils.nextPow2(Math.ceil(size / 12)), roundedSizeIndex = utils.log2(roundedP2), roundedSize = roundedP2 * 12;\n    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._iBuffers[roundedSizeIndex];\n    return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;\n  }\n  /**\n   * Takes the four batching parameters of `element`, interleaves\n   * and pushes them into the batching attribute/index buffers given.\n   *\n   * It uses these properties: `vertexData` `uvs`, `textureId` and\n   * `indicies`. It also uses the \"tint\" of the base-texture, if\n   * present.\n   * @param {PIXI.DisplayObject} element - element being rendered\n   * @param attributeBuffer - attribute buffer.\n   * @param indexBuffer - index buffer\n   * @param aIndex - number of floats already in the attribute buffer\n   * @param iIndex - number of indices already in `indexBuffer`\n   */\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = color.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n    for (let i = 0; i < vertexData.length; i += 2)\n      float32View[aIndex++] = vertexData[i], float32View[aIndex++] = vertexData[i + 1], float32View[aIndex++] = uvs[i], float32View[aIndex++] = uvs[i + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;\n    for (let i = 0; i < indicies.length; i++)\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n  }\n};\n_BatchRenderer.defaultBatchSize = 4096, /** @ignore */\n_BatchRenderer.extension = {\n  name: \"batch\",\n  type: extensions.ExtensionType.RendererPlugin\n}, /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create \"batches\" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n* @member {PIXI.BatchDrawCall[]}\n*/\n_BatchRenderer._drawCallPool = [], /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create \"batches\" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n* @member {PIXI.BatchTextureArray[]}\n*/\n_BatchRenderer._textureArrayPool = [];\nlet BatchRenderer = _BatchRenderer;\nextensions.extensions.add(BatchRenderer);\nexports.BatchRenderer = BatchRenderer;\n//# sourceMappingURL=BatchRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchRenderer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), Program = __webpack_require__(/*! ../shader/Program.js */ \"./node_modules/@pixi/core/lib/shader/Program.js\"), Shader = __webpack_require__(/*! ../shader/Shader.js */ \"./node_modules/@pixi/core/lib/shader/Shader.js\"), UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ \"./node_modules/@pixi/core/lib/shader/UniformGroup.js\");\nclass BatchShaderGenerator {\n  /**\n   * @param vertexSrc - Vertex shader\n   * @param fragTemplate - Fragment shader template\n   */\n  constructor(vertexSrc, fragTemplate) {\n    if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate.includes(\"%count%\"))\n      throw new Error('Fragment template must contain \"%count%\".');\n    if (!fragTemplate.includes(\"%forloop%\"))\n      throw new Error('Fragment template must contain \"%forloop%\".');\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++)\n        sampleValues[i] = i;\n      this.defaultGroupCache[maxTextures] = UniformGroup.UniformGroup.from({ uSamplers: sampleValues }, !0);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures)), this.programCache[maxTextures] = new Program.Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new math.Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader.Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = \"\";\n    src += `\n`, src += `\n`;\n    for (let i = 0; i < maxTextures; i++)\n      i > 0 && (src += `\nelse `), i < maxTextures - 1 && (src += `if(vTextureId < ${i}.5)`), src += `\n{`, src += `\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`, src += `\n}`;\n    return src += `\n`, src += `\n`, src;\n  }\n}\nexports.BatchShaderGenerator = BatchShaderGenerator;\n//# sourceMappingURL=BatchShaderGenerator.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchSystem.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchSystem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ \"./node_modules/@pixi/core/lib/batch/ObjectRenderer.js\");\nclass BatchSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.emptyRenderer = new ObjectRenderer.ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;\n  }\n  /**\n   * Changes the current renderer to the one given in parameter\n   * @param objectRenderer - The object renderer to use.\n   */\n  setObjectRenderer(objectRenderer) {\n    this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());\n  }\n  /**\n   * This should be called if you wish to do some custom rendering\n   * It will basically render anything that may be batched up such as sprites\n   */\n  flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  /** Reset the system to an empty renderer */\n  reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  /**\n   * Handy function for batch renderers: copies bound textures in first maxTextures locations to array\n   * sets actual _batchLocation for them\n   * @param arr - arr copy destination\n   * @param maxTextures - number of copied elements\n   */\n  copyBoundTextures(arr, maxTextures) {\n    const { boundTextures } = this.renderer.texture;\n    for (let i = maxTextures - 1; i >= 0; --i)\n      arr[i] = boundTextures[i] || null, arr[i] && (arr[i]._batchLocation = i);\n  }\n  /**\n   * Assigns batch locations to textures in array based on boundTextures state.\n   * All textures in texArray should have `_batchEnabled = _batchId`,\n   * and their count should be less than `maxTextures`.\n   * @param texArray - textures to bound\n   * @param boundTextures - current state of bound textures\n   * @param batchId - marker for _batchEnabled param of textures in texArray\n   * @param maxTextures - number of texture locations to manipulate\n   */\n  boundArray(texArray, boundTextures, batchId, maxTextures) {\n    const { elements, ids, count } = texArray;\n    let j = 0;\n    for (let i = 0; i < count; i++) {\n      const tex = elements[i], loc = tex._batchLocation;\n      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {\n        ids[i] = loc;\n        continue;\n      }\n      for (; j < maxTextures; ) {\n        const bound = boundTextures[j];\n        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {\n          j++;\n          continue;\n        }\n        ids[i] = j, tex._batchLocation = j, boundTextures[j] = tex;\n        break;\n      }\n    }\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.renderer = null;\n  }\n}\nBatchSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"batch\"\n};\nextensions.extensions.add(BatchSystem);\nexports.BatchSystem = BatchSystem;\n//# sourceMappingURL=BatchSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchTextureArray.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass BatchTextureArray {\n  constructor() {\n    this.elements = [], this.ids = [], this.count = 0;\n  }\n  clear() {\n    for (let i = 0; i < this.count; i++)\n      this.elements[i] = null;\n    this.count = 0;\n  }\n}\nexports.BatchTextureArray = BatchTextureArray;\n//# sourceMappingURL=BatchTextureArray.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/BatchTextureArray.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/ObjectRenderer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass ObjectRenderer {\n  /**\n   * @param renderer - The renderer this manager works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /** Stub method that should be used to empty the current batch by rendering objects now. */\n  flush() {\n  }\n  /** Generic destruction method that frees all resources. This should be called by subclasses. */\n  destroy() {\n    this.renderer = null;\n  }\n  /**\n   * Stub method that initializes any state required before\n   * rendering starts. It is different from the `prerender`\n   * signal, which occurs every frame, in that it is called\n   * whenever an object requests _this_ renderer specifically.\n   */\n  start() {\n  }\n  /** Stops the renderer. It should free up any state and become dormant. */\n  stop() {\n    this.flush();\n  }\n  /**\n   * Keeps the object to render. It doesn't have to be\n   * rendered immediately.\n   * @param {PIXI.DisplayObject} _object - The object to render.\n   */\n  render(_object) {\n  }\n}\nexports.ObjectRenderer = ObjectRenderer;\n//# sourceMappingURL=ObjectRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/ObjectRenderer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nfunction canUploadSameBuffer() {\n  return !settings.isMobile.apple.device;\n}\nexports.canUploadSameBuffer = canUploadSameBuffer;\n//# sourceMappingURL=canUploadSameBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nfunction maxRecommendedTextures(max) {\n  let allowMax = !0;\n  const navigator = settings.settings.ADAPTER.getNavigator();\n  if (settings.isMobile.tablet || settings.isMobile.phone) {\n    if (settings.isMobile.apple.device) {\n      const match = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      match && parseInt(match[1], 10) < 11 && (allowMax = !1);\n    }\n    if (settings.isMobile.android.device) {\n      const match = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      match && parseInt(match[1], 10) < 7 && (allowMax = !1);\n    }\n  }\n  return allowMax ? max : 4;\n}\nexports.maxRecommendedTextures = maxRecommendedTextures;\n//# sourceMappingURL=maxRecommendedTextures.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture.frag.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture.frag.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`;\nexports[\"default\"] = defaultFragment;\n//# sourceMappingURL=texture.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/texture.frag.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture.vert.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture.vert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`;\nexports[\"default\"] = defaultVertex;\n//# sourceMappingURL=texture.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/batch/texture.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/context/ContextSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/context/ContextSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nlet CONTEXT_UID_COUNTER = 0;\nclass ContextSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n      uint32Indices: !1\n    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  /**\n   * `true` if the context is lost\n   * @readonly\n   */\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */\n  contextChange(gl) {\n    this.gl = gl, this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n  }\n  init(options) {\n    if (options.context)\n      this.initFromContext(options.context);\n    else {\n      const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;\n      this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({\n        alpha,\n        premultipliedAlpha,\n        antialias: options.antialias,\n        stencil: !0,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference\n      });\n    }\n  }\n  /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */\n  initFromContext(gl) {\n    this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl);\n    const view = this.renderer.view;\n    view.addEventListener !== void 0 && (view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1));\n  }\n  /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param {object} options - context attributes\n   */\n  initFromOptions(options) {\n    const gl = this.createContext(this.renderer.view, options);\n    this.initFromContext(gl);\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param canvas - the canvas element that we will get the context from\n   * @param options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  createContext(canvas, options) {\n    let gl;\n    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2 && (gl = canvas.getContext(\"webgl2\", options)), gl)\n      this.webGLVersion = 2;\n    else if (this.webGLVersion = 1, gl = canvas.getContext(\"webgl\", options) || canvas.getContext(\"experimental-webgl\", options), !gl)\n      throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n    return this.gl = gl, this.getExtensions(), this.gl;\n  }\n  /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */\n  getExtensions() {\n    const { gl } = this, common = {\n      loseContext: gl.getExtension(\"WEBGL_lose_context\"),\n      anisotropicFiltering: gl.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n      s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      // eslint-disable-line camelcase\n      etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: gl.getExtension(\"WEBGL_compressed_texture_astc\"),\n      bptc: gl.getExtension(\"EXT_texture_compression_bptc\")\n    };\n    this.webGLVersion === 1 ? Object.assign(this.extensions, common, {\n      drawBuffers: gl.getExtension(\"WEBGL_draw_buffers\"),\n      depthTexture: gl.getExtension(\"WEBGL_depth_texture\"),\n      vertexArrayObject: gl.getExtension(\"OES_vertex_array_object\") || gl.getExtension(\"MOZ_OES_vertex_array_object\") || gl.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n      uint32ElementIndex: gl.getExtension(\"OES_element_index_uint\"),\n      // Floats and half-floats\n      floatTexture: gl.getExtension(\"OES_texture_float\"),\n      floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n      textureHalfFloat: gl.getExtension(\"OES_texture_half_float\"),\n      textureHalfFloatLinear: gl.getExtension(\"OES_texture_half_float_linear\")\n    }) : this.webGLVersion === 2 && Object.assign(this.extensions, common, {\n      // Floats and half-floats\n      colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\")\n    });\n  }\n  /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n  handleContextLost(event) {\n    event.preventDefault(), setTimeout(() => {\n      this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();\n    }, 0);\n  }\n  /** Handles a restored webgl context. */\n  handleContextRestored() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const view = this.renderer.view;\n    this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener(\"webglcontextlost\", this.handleContextLost), view.removeEventListener(\"webglcontextrestored\", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n  }\n  /** Handle the post-render runner event. */\n  postrender() {\n    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();\n  }\n  /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes(), isWebGl2 = \"WebGL2RenderingContext\" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;\n    isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    const hasuint32 = isWebGl2 || !!gl.getExtension(\"OES_element_index_uint\");\n    this.supports.uint32Indices = hasuint32, hasuint32 || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n  }\n}\nContextSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.context}\n   * @default null\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  context: null,\n  /**\n   * {@link PIXI.IRendererOptions.antialias}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  antialias: !1,\n  /**\n   * {@link PIXI.IRendererOptions.premultipliedAlpha}\n   * @default true\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  premultipliedAlpha: !0,\n  /**\n   * {@link PIXI.IRendererOptions.preserveDrawingBuffer}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  preserveDrawingBuffer: !1,\n  /**\n   * {@link PIXI.IRendererOptions.powerPreference}\n   * @default default\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  powerPreference: \"default\"\n}, /** @ignore */\nContextSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"context\"\n};\nextensions.extensions.add(ContextSystem);\nexports.ContextSystem = ContextSystem;\n//# sourceMappingURL=ContextSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/context/ContextSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/Filter.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/Filter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Program = __webpack_require__(/*! ../shader/Program.js */ \"./node_modules/@pixi/core/lib/shader/Program.js\"), Shader = __webpack_require__(/*! ../shader/Shader.js */ \"./node_modules/@pixi/core/lib/shader/Shader.js\"), State = __webpack_require__(/*! ../state/State.js */ \"./node_modules/@pixi/core/lib/state/State.js\"), defaultFilter$1 = __webpack_require__(/*! ./defaultFilter.frag.js */ \"./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js\"), defaultFilter = __webpack_require__(/*! ./defaultFilter.vert.js */ \"./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js\");\nconst _Filter = class _Filter2 extends Shader.Shader {\n  /**\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   */\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.Program.from(\n      vertexSrc || _Filter2.defaultVertexSrc,\n      fragmentSrc || _Filter2.defaultFragmentSrc\n    );\n    super(program, uniforms), this.padding = 0, this.resolution = _Filter2.defaultResolution, this.multisample = _Filter2.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new State.State();\n  }\n  /**\n   * Applies the filter\n   * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTexture} input - The input render target.\n   * @param {PIXI.RenderTexture} output - The target to output to.\n   * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.\n   * @param {object} [_currentState] - It's current state of filter.\n   *        There are some useful properties in the currentState :\n   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n   */\n  apply(filterManager, input, output, clearMode, _currentState) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Sets the blend mode of the filter.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  /**\n   * The resolution of the filter. Setting this to be lower will lower the quality but\n   * increase the performance of the filter.\n   * If set to `null` or `0`, the resolution of the current render target is used.\n   * @default PIXI.Filter.defaultResolution\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._resolution = value;\n  }\n  /**\n   * The default vertex shader source\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return defaultFilter.default;\n  }\n  /**\n   * The default fragment shader source\n   * @readonly\n   */\n  static get defaultFragmentSrc() {\n    return defaultFilter$1.default;\n  }\n};\n_Filter.defaultResolution = 1, /**\n* Default filter samples for any filter.\n* @static\n* @type {PIXI.MSAA_QUALITY|null}\n* @default PIXI.MSAA_QUALITY.NONE\n*/\n_Filter.defaultMultisample = constants.MSAA_QUALITY.NONE;\nlet Filter = _Filter;\nexports.Filter = Filter;\n//# sourceMappingURL=Filter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/Filter.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterState.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterState.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\");\nclass FilterState {\n  constructor() {\n    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = constants.MSAA_QUALITY.NONE, this.sourceFrame = new math.Rectangle(), this.destinationFrame = new math.Rectangle(), this.bindingSourceFrame = new math.Rectangle(), this.bindingDestinationFrame = new math.Rectangle(), this.filters = [], this.transform = null;\n  }\n  /** Clears the state */\n  clear() {\n    this.target = null, this.filters = null, this.renderTexture = null;\n  }\n}\nexports.FilterState = FilterState;\n//# sourceMappingURL=FilterState.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/FilterState.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterSystem.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterSystem.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), RenderTexturePool = __webpack_require__(/*! ../renderTexture/RenderTexturePool.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js\"), UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ \"./node_modules/@pixi/core/lib/shader/UniformGroup.js\"), Quad = __webpack_require__(/*! ../utils/Quad.js */ \"./node_modules/@pixi/core/lib/utils/Quad.js\"), QuadUv = __webpack_require__(/*! ../utils/QuadUv.js */ \"./node_modules/@pixi/core/lib/utils/QuadUv.js\"), FilterState = __webpack_require__(/*! ./FilterState.js */ \"./node_modules/@pixi/core/lib/filters/FilterState.js\");\nconst tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()], tempMatrix = new math.Matrix();\nclass FilterSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool.RenderTexturePool(), this.statePool = [], this.quad = new Quad.Quad(), this.quadUv = new QuadUv.QuadUv(), this.tempRect = new math.Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup.UniformGroup({\n      outputFrame: new math.Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      // legacy variables\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n   * input render-texture for the rest of the filtering pipeline.\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param filters - The filters to apply.\n   */\n  push(target, filters) {\n    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState.FilterState(), renderTextureSystem = renderer.renderTexture;\n    let currentResolution, currentMultisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;\n    } else\n      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;\n    let resolution = filters[0].resolution || currentResolution, multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? !0;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? !0);\n    }\n    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    renderer.projection.transform && this.transformAABB(\n      tempMatrix.copyFrom(renderer.projection.transform).invert(),\n      sourceFrameProjected\n    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(\n      state.sourceFrame,\n      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n      renderTextureSystem.sourceFrame,\n      renderTextureSystem.destinationFrame,\n      renderer.projection.transform\n    ), state.renderTexture = this.getOptimalFilterTexture(\n      state.sourceFrame.width,\n      state.sourceFrame.height,\n      resolution,\n      multisample\n    ), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /** Pops off the filter and applies it. */\n  pop() {\n    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;\n    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    if (this.renderer.framebuffer.blit(), filters.length === 1)\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);\n    else {\n      let flip = state.renderTexture, flop = this.getOptimalFilterTexture(\n        flip.width,\n        flip.height,\n        state.resolution\n      );\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        i === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(\n          flip.width,\n          flip.height,\n          state.resolution\n        ), flop.filterFrame = flip.filterFrame), filters[i].apply(this, flip, flop, constants.CLEAR_MODES.CLEAR, state);\n        const t = flip;\n        flip = flop, flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state), i > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);\n    }\n    state.clear(), this.statePool.push(state);\n  }\n  /**\n   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n   */\n  bindAndClear(filterTexture, clearMode = constants.CLEAR_MODES.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else\n      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(\n        filterTexture,\n        this.activeState.bindingSourceFrame,\n        this.activeState.bindingDestinationFrame\n      );\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /**\n   * Draws a filter using the default rendering process.\n   *\n   * This should be called only by {@link PIXI.Filter#apply}.\n   * @param filter - The filter to draw.\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP));\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(\n      destinationFrame.width,\n      0,\n      0,\n      destinationFrame.height,\n      sourceFrame.x,\n      sourceFrame.y\n    ), worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);\n    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;\n  }\n  /** Destroys this Filter System. */\n  destroy() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture in real pixels.\n   * @param minHeight - The minimum height of the render texture in real pixels.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns - The new render texture.\n   */\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  /**\n   * Gets extra render texture to use inside current filter\n   * To be compliant with older filters, you can use params in any order\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input == \"number\") {\n      const swap = input;\n      input = resolution, resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(\n      input.width,\n      input.height,\n      resolution || input.resolution,\n      multisample || constants.MSAA_QUALITY.NONE\n    );\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Frees a render texture back into the pool.\n   * @param renderTexture - The renderTarget to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  /** Empties the texture pool. */\n  emptyPool() {\n    this.texturePool.clear(!0);\n  }\n  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * @param matrix - first param\n   * @param rect - second param\n   */\n  transformAABB(matrix, rect) {\n    const lt = tempPoints[0], lb = tempPoints[1], rt = tempPoints[2], rb = tempPoints[3];\n    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {\n      if (transform) {\n        const { a, b, c, d } = transform;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n          return;\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(\n        bindingDestinationFrame.width / bindingSourceFrame.width,\n        bindingDestinationFrame.height / bindingSourceFrame.height\n      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);\n    }\n  }\n}\nFilterSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.extensions.add(FilterSystem);\nexports.FilterSystem = FilterSystem;\n//# sourceMappingURL=FilterSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/FilterSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/IFilterTarget.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/IFilterTarget.js ***!
  \**************************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=IFilterTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/IFilterTarget.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultFragment = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`;\nexports[\"default\"] = defaultFragment;\n//# sourceMappingURL=defaultFilter.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`;\nexports[\"default\"] = defaultVertex;\n//# sourceMappingURL=defaultFilter.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), TextureMatrix = __webpack_require__(/*! ../../textures/TextureMatrix.js */ \"./node_modules/@pixi/core/lib/textures/TextureMatrix.js\"), Filter = __webpack_require__(/*! ../Filter.js */ \"./node_modules/@pixi/core/lib/filters/Filter.js\"), spriteMaskFilter$1 = __webpack_require__(/*! ./spriteMaskFilter.frag.js */ \"./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js\"), spriteMaskFilter = __webpack_require__(/*! ./spriteMaskFilter.vert.js */ \"./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js\");\nclass SpriteMaskFilter extends Filter.Filter {\n  /** @ignore */\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    let sprite = null;\n    typeof vertexSrc != \"string\" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || spriteMaskFilter.default, fragmentSrc || spriteMaskFilter$1.default, uniforms), this.maskSprite = sprite, this.maskMatrix = new math.Matrix();\n  }\n  /**\n   * Sprite mask\n   * @type {PIXI.DisplayObject}\n   */\n  get maskSprite() {\n    return this._maskSprite;\n  }\n  set maskSprite(value) {\n    this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = !1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it.\n   */\n  apply(filterManager, input, output, clearMode) {\n    const maskSprite = this._maskSprite, tex = maskSprite._texture;\n    tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix.TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));\n  }\n}\nexports.SpriteMaskFilter = SpriteMaskFilter;\n//# sourceMappingURL=SpriteMaskFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar fragment = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`;\nexports[\"default\"] = fragment;\n//# sourceMappingURL=spriteMaskFilter.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar vertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`;\nexports[\"default\"] = vertex;\n//# sourceMappingURL=spriteMaskFilter.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/default.vert.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/default.vert.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`;\nexports[\"default\"] = $defaultVertex;\n//# sourceMappingURL=default.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/fragments/default.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`;\nexports[\"default\"] = $defaultFilterVertex;\n//# sourceMappingURL=defaultFilter.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _default = __webpack_require__(/*! ./default.vert.js */ \"./node_modules/@pixi/core/lib/fragments/default.vert.js\"), defaultFilter = __webpack_require__(/*! ./defaultFilter.vert.js */ \"./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js\");\nconst defaultVertex = _default.default, defaultFilterVertex = defaultFilter.default;\nexports.defaultFilterVertex = defaultFilterVertex;\nexports.defaultVertex = defaultVertex;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/fragments/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\");\nclass Framebuffer {\n  /**\n   * @param width - Width of the frame buffer\n   * @param height - Height of the frame buffer\n   */\n  constructor(width, height) {\n    if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)\n      throw new Error(\"Framebuffer width or height is zero\");\n    this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new runner.Runner(\"disposeFramebuffer\"), this.multisample = constants.MSAA_QUALITY.NONE;\n  }\n  /**\n   * Reference to the colorTexture.\n   * @readonly\n   */\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  /**\n   * Add texture to the colorTexture array.\n   * @param index - Index of the array to add the texture to\n   * @param texture - Texture to add to the array\n   */\n  addColorTexture(index = 0, texture) {\n    return this.colorTextures[index] = texture || new BaseTexture.BaseTexture(null, {\n      scaleMode: constants.SCALE_MODES.NEAREST,\n      resolution: 1,\n      mipmap: constants.MIPMAP_MODES.OFF,\n      width: this.width,\n      height: this.height\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /**\n   * Add a depth texture to the frame buffer.\n   * @param texture - Texture to add.\n   */\n  addDepthTexture(texture) {\n    return this.depthTexture = texture || new BaseTexture.BaseTexture(null, {\n      scaleMode: constants.SCALE_MODES.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: constants.MIPMAP_MODES.OFF,\n      format: constants.FORMATS.DEPTH_COMPONENT,\n      type: constants.TYPES.UNSIGNED_SHORT\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /** Enable depth on the frame buffer. */\n  enableDepth() {\n    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /** Enable stencil on the frame buffer. */\n  enableStencil() {\n    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /**\n   * Resize the frame buffer\n   * @param width - Width of the frame buffer to resize to\n   * @param height - Height of the frame buffer to resize to\n   */\n  resize(width, height) {\n    if (width = Math.round(width), height = Math.round(height), !width || !height)\n      throw new Error(\"Framebuffer width and height must not be zero\");\n    if (!(width === this.width && height === this.height)) {\n      this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;\n      for (let i = 0; i < this.colorTextures.length; i++) {\n        const texture = this.colorTextures[i], resolution = texture.resolution;\n        texture.setSize(width / resolution, height / resolution);\n      }\n      if (this.depthTexture) {\n        const resolution = this.depthTexture.resolution;\n        this.depthTexture.setSize(width / resolution, height / resolution);\n      }\n    }\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys and removes the depth texture added to this framebuffer. */\n  destroyDepthTexture() {\n    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n  }\n}\nexports.Framebuffer = Framebuffer;\n//# sourceMappingURL=Framebuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), Framebuffer = __webpack_require__(/*! ./Framebuffer.js */ \"./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js\"), GLFramebuffer = __webpack_require__(/*! ./GLFramebuffer.js */ \"./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js\");\nconst tempRectangle = new math.Rectangle();\nclass FramebufferSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer.Framebuffer(10, 10), this.msaaSamples = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0);\n    const gl = this.gl = this.renderer.gl;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new math.Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {\n      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;\n      settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = !1, gl.drawBuffers = () => {\n      }), nativeDepthTextureExtension || (this.writeDepthTexture = !1);\n    } else\n      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);\n  }\n  /**\n   * Bind a framebuffer.\n   * @param framebuffer\n   * @param frame - frame, default is framebuffer size\n   * @param mipLevel - optional mip level to set on the framebuffer - defaults to 0\n   */\n  bind(framebuffer, frame, mipLevel = 0) {\n    const { gl } = this;\n    if (framebuffer) {\n      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);\n      this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));\n      for (let i = 0; i < framebuffer.colorTextures.length; i++) {\n        const tex = framebuffer.colorTextures[i];\n        this.renderer.texture.unbind(tex.parentTextureArray || tex);\n      }\n      if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {\n        const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale = mipWidth / frame.width;\n        this.setViewport(\n          frame.x * scale,\n          frame.y * scale,\n          mipWidth,\n          mipHeight\n        );\n      } else {\n        const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;\n        this.setViewport(0, 0, mipWidth, mipHeight);\n      }\n    } else\n      this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n  }\n  /**\n   * Set the WebGLRenderingContext's viewport.\n   * @param x - X position of viewport\n   * @param y - Y position of viewport\n   * @param width - Width of viewport\n   * @param height - Height of viewport\n   */\n  setViewport(x, y, width, height) {\n    const v = this.viewport;\n    x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), (v.width !== width || v.height !== height || v.x !== x || v.y !== y) && (v.x = x, v.y = y, v.width = width, v.height = height, this.gl.viewport(x, y, width, height));\n  }\n  /**\n   * Get the size of the current width and height. Returns object with `width` and `height` values.\n   * @readonly\n   */\n  get size() {\n    return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n  }\n  /**\n   * Clear the color of the context\n   * @param r - Red value from 0 to 1\n   * @param g - Green value from 0 to 1\n   * @param b - Blue value from 0 to 1\n   * @param a - Alpha value from 0 to 1\n   * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n   */\n  clear(r, g, b, a, mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH) {\n    const { gl } = this;\n    gl.clearColor(r, g, b, a), gl.clear(mask);\n  }\n  /**\n   * Initialize framebuffer for this context\n   * @protected\n   * @param framebuffer\n   * @returns - created GLFramebuffer\n   */\n  initFramebuffer(framebuffer) {\n    const { gl } = this, fbo = new GLFramebuffer.GLFramebuffer(gl.createFramebuffer());\n    return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;\n  }\n  /**\n   * Resize the framebuffer\n   * @param framebuffer\n   * @protected\n   */\n  resizeFramebuffer(framebuffer) {\n    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (fbo.stencil) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      let stencilFormat;\n      this.renderer.context.webGLVersion === 1 ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8, fbo.msaaBuffer ? gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        stencilFormat,\n        framebuffer.width,\n        framebuffer.height\n      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);\n    }\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    gl.drawBuffers || (count = Math.min(count, 1));\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,\n        framebuffer.width,\n        framebuffer.height\n      ));\n    }\n    framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);\n  }\n  /**\n   * Update the framebuffer\n   * @param framebuffer\n   * @param mipLevel\n   * @protected\n   */\n  updateFramebuffer(framebuffer, mipLevel) {\n    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    gl.drawBuffers || (count = Math.min(count, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));\n    const activeTextures = [];\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,\n        framebuffer.width,\n        framebuffer.height\n      ), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0 + i,\n        texture.target,\n        parentTexture._glTextures[this.CONTEXT_UID].texture,\n        mipLevel\n      ), activeTextures.push(gl.COLOR_ATTACHMENT0 + i));\n    }\n    if (activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {\n      const depthTexture = framebuffer.depthTexture;\n      this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_ATTACHMENT,\n        gl.TEXTURE_2D,\n        depthTexture._glTextures[this.CONTEXT_UID].texture,\n        mipLevel\n      );\n    }\n    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {\n      fbo.stencil = fbo.stencil || gl.createRenderbuffer();\n      let stencilAttachment, stencilFormat;\n      this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        stencilFormat,\n        framebuffer.width,\n        framebuffer.height\n      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);\n    } else\n      fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);\n  }\n  /**\n   * Returns true if the frame buffer can be multisampled.\n   * @param framebuffer\n   */\n  canMultisampleFramebuffer(framebuffer) {\n    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;\n  }\n  /**\n   * Detects number of samples that is not more than a param but as close to it as possible\n   * @param samples - number of samples\n   * @returns - recommended number of samples\n   */\n  detectSamples(samples) {\n    const { msaaSamples } = this;\n    let res = constants.MSAA_QUALITY.NONE;\n    if (samples <= 1 || msaaSamples === null)\n      return res;\n    for (let i = 0; i < msaaSamples.length; i++)\n      if (msaaSamples[i] <= samples) {\n        res = msaaSamples[i];\n        break;\n      }\n    return res === 1 && (res = constants.MSAA_QUALITY.NONE), res;\n  }\n  /**\n   * Only works with WebGL2\n   *\n   * blits framebuffer to another of the same or bigger size\n   * after that target framebuffer is bound\n   *\n   * Fails with WebGL warning if blits multisample framebuffer to different size\n   * @param framebuffer - by default it blits \"into itself\", from renderBuffer to texture.\n   * @param sourcePixels - source rectangle in pixels\n   * @param destPixels - dest rectangle in pixels, assumed to be the same as sourcePixels\n   */\n  blit(framebuffer, sourcePixels, destPixels) {\n    const { current, renderer, gl, CONTEXT_UID } = this;\n    if (renderer.context.webGLVersion !== 2 || !current)\n      return;\n    const fbo = current.glFramebuffers[CONTEXT_UID];\n    if (!fbo)\n      return;\n    if (!framebuffer) {\n      if (!fbo.msaaBuffer)\n        return;\n      const colorTexture = current.colorTextures[0];\n      if (!colorTexture)\n        return;\n      fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer.Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);\n    }\n    sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);\n    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;\n    this.bind(framebuffer), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer), gl.blitFramebuffer(\n      sourcePixels.left,\n      sourcePixels.top,\n      sourcePixels.right,\n      sourcePixels.bottom,\n      destPixels.left,\n      destPixels.top,\n      destPixels.right,\n      destPixels.bottom,\n      gl.COLOR_BUFFER_BIT,\n      sameSize ? gl.NEAREST : gl.LINEAR\n    ), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);\n  }\n  /**\n   * Disposes framebuffer.\n   * @param framebuffer - framebuffer that has to be disposed of\n   * @param contextLost - If context was lost, we suppress all delete function calls\n   */\n  disposeFramebuffer(framebuffer, contextLost) {\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;\n    if (!fbo)\n      return;\n    delete framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const index = this.managedFramebuffers.indexOf(framebuffer);\n    index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);\n  }\n  /**\n   * Disposes all framebuffers, but not textures bound to them.\n   * @param [contextLost=false] - If context was lost, we suppress all delete function calls\n   */\n  disposeAll(contextLost) {\n    const list = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (let i = 0; i < list.length; i++)\n      this.disposeFramebuffer(list[i], contextLost);\n  }\n  /**\n   * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.\n   * Used by MaskSystem, when its time to use stencil mask for Graphics element.\n   *\n   * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.\n   * @private\n   */\n  forceStencil() {\n    const framebuffer = this.current;\n    if (!framebuffer)\n      return;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (!fbo || fbo.stencil && framebuffer.stencil)\n      return;\n    framebuffer.stencil = !0;\n    const w = framebuffer.width, h = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);\n    let stencilAttachment, stencilFormat;\n    this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w, h) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w, h), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);\n  }\n  /** Resets framebuffer stored state, binds screen framebuffer. Should be called before renderTexture reset(). */\n  reset() {\n    this.current = this.unknownFramebuffer, this.viewport = new math.Rectangle();\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nFramebufferSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"framebuffer\"\n};\nextensions.extensions.add(FramebufferSystem);\nexports.FramebufferSystem = FramebufferSystem;\n//# sourceMappingURL=FramebufferSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nclass GLFramebuffer {\n  constructor(framebuffer) {\n    this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = constants.MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n  }\n}\nexports.GLFramebuffer = GLFramebuffer;\n//# sourceMappingURL=GLFramebuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nclass MultisampleSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange(gl) {\n    let samples;\n    if (this.renderer.context.webGLVersion === 1) {\n      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    } else {\n      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);\n    }\n    samples >= constants.MSAA_QUALITY.HIGH ? this.multisample = constants.MSAA_QUALITY.HIGH : samples >= constants.MSAA_QUALITY.MEDIUM ? this.multisample = constants.MSAA_QUALITY.MEDIUM : samples >= constants.MSAA_QUALITY.LOW ? this.multisample = constants.MSAA_QUALITY.LOW : this.multisample = constants.MSAA_QUALITY.NONE;\n  }\n  destroy() {\n  }\n}\nMultisampleSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"_multisample\"\n};\nextensions.extensions.add(MultisampleSystem);\nexports.MultisampleSystem = MultisampleSystem;\n//# sourceMappingURL=MultisampleSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Attribute.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Attribute.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nclass Attribute {\n  /**\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.\n   * @param normalized - should the data be normalized.\n   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param [instance=false] - Whether the geometry is instanced.\n   * @param [divisor=1] - Divisor to use when doing instanced rendering\n   */\n  constructor(buffer, size = 0, normalized = !1, type = constants.TYPES.FLOAT, stride, start, instance, divisor = 1) {\n    this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;\n  }\n  /** Destroys the Attribute. */\n  destroy() {\n    this.buffer = null;\n  }\n  /**\n   * Helper function that creates an Attribute based on the information provided\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param [normalized=false] - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @returns - A new {@link PIXI.Attribute} based on the information provided\n   */\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\nexports.Attribute = Attribute;\n//# sourceMappingURL=Attribute.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/Attribute.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Buffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\");\nlet UID = 0;\nclass Buffer {\n  /**\n   * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.\n   * @param _static - `true` for static buffer\n   * @param index - `true` for index buffer\n   */\n  constructor(data, _static = !0, index = !1) {\n    this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new runner.Runner(\"disposeBuffer\");\n  }\n  // TODO could explore flagging only a partial upload?\n  /**\n   * Flags this buffer as requiring an upload to the GPU.\n   * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.\n   */\n  update(data) {\n    data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys the buffer. */\n  destroy() {\n    this.dispose(), this.data = null;\n  }\n  /**\n   * Flags whether this is an index buffer.\n   *\n   * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n   * the buffer of type `ARRAY_BUFFER`.\n   *\n   * For backwards compatibility.\n   */\n  set index(value) {\n    this.type = value ? constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : constants.BUFFER_TYPE.ARRAY_BUFFER;\n  }\n  get index() {\n    return this.type === constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n  }\n  /**\n   * Helper function that creates a buffer based on an array or TypedArray\n   * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.\n   * @returns - A new Buffer based on the data provided.\n   */\n  static from(data) {\n    return data instanceof Array && (data = new Float32Array(data)), new Buffer(data);\n  }\n}\nexports.Buffer = Buffer;\n//# sourceMappingURL=Buffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/Buffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/BufferSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/BufferSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), GLBuffer = __webpack_require__(/*! ./GLBuffer.js */ \"./node_modules/@pixi/core/lib/geometry/GLBuffer.js\");\nclass BufferSystem {\n  /**\n   * @param {PIXI.Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.renderer = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const { gl } = this;\n    gl.bindBuffer(type, null);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(buffer, index) {\n    const { gl, CONTEXT_UID } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */\n  bindBufferRange(buffer, index, offset) {\n    const { gl, CONTEXT_UID } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {PIXI.Buffer} buffer - the buffer to update\n   */\n  update(buffer) {\n    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID !== glBuffer.updateID)\n      if (glBuffer.updateID = buffer._updateID, gl.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength)\n        gl.bufferSubData(buffer.type, 0, buffer.data);\n      else {\n        const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n        glBuffer.byteLength = buffer.data.byteLength, gl.bufferData(buffer.type, buffer.data, drawType);\n      }\n  }\n  /**\n   * Disposes buffer\n   * @param {PIXI.Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id])\n      return;\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl = this.gl;\n    buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);\n  }\n  /**\n   * dispose all WebGL resources of all managed buffers\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++)\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const { CONTEXT_UID, gl } = this;\n    return buffer._glBuffers[CONTEXT_UID] = new GLBuffer.GLBuffer(gl.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"buffer\"\n};\nextensions.extensions.add(BufferSystem);\nexports.BufferSystem = BufferSystem;\n//# sourceMappingURL=BufferSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/BufferSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GLBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GLBuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass GLBuffer {\n  constructor(buffer) {\n    this.buffer = buffer || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n  }\n}\nexports.GLBuffer = GLBuffer;\n//# sourceMappingURL=GLBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/GLBuffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Geometry.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Geometry.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), Attribute = __webpack_require__(/*! ./Attribute.js */ \"./node_modules/@pixi/core/lib/geometry/Attribute.js\"), Buffer = __webpack_require__(/*! ./Buffer.js */ \"./node_modules/@pixi/core/lib/geometry/Buffer.js\"), interleaveTypedArrays = __webpack_require__(/*! ./utils/interleaveTypedArrays.js */ \"./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js\");\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet UID = 0;\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nclass Geometry {\n  /**\n   * @param buffers - An array of buffers. optional.\n   * @param attributes - Of the geometry, optional structure of the attributes layout\n   */\n  constructor(buffers = [], attributes = {}) {\n    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new runner.Runner(\"disposeGeometry\"), this.refCount = 0;\n  }\n  /**\n   *\n   * Adds an attribute to the geometry\n   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!\n   * @param id - the name of the attribute (matching up to a shader)\n   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param normalized - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param instance - Instancing flag\n   * @returns - Returns self, useful for chaining.\n   */\n  addAttribute(id, buffer, size = 0, normalized = !1, type, stride, start, instance = !1) {\n    if (!buffer)\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer.Buffer(buffer));\n    const ids = id.split(\"|\");\n    if (ids.length > 1) {\n      for (let i = 0; i < ids.length; i++)\n        this.addAttribute(ids[i], buffer, size, normalized, type);\n      return this;\n    }\n    let bufferIndex = this.buffers.indexOf(buffer);\n    return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  }\n  /**\n   *\n   * Adds an index buffer to the geometry\n   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.\n   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n   * @returns - Returns self, useful for chaining.\n   */\n  addIndex(buffer) {\n    return buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer.Buffer(buffer)), buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * This function modifies the structure so that all current attributes become interleaved into a single buffer\n   * This can be useful if your model remains static as it offers a little performance boost\n   * @returns - Returns self, useful for chaining.\n   */\n  interleave() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    const arrays = [], sizes = [], interleavedBuffer = new Buffer.Buffer();\n    let i;\n    for (i in this.attributes) {\n      const attribute = this.attributes[i], buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0;\n    }\n    for (interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes), i = 0; i < this.buffers.length; i++)\n      this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();\n    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }\n  /** Get the size of the geometries, in vertices. */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys the geometry. */\n  destroy() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }\n  /**\n   * Returns a clone of the geometry.\n   * @returns - A new clone of this geometry.\n   */\n  clone() {\n    const geometry = new Geometry();\n    for (let i = 0; i < this.buffers.length; i++)\n      geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));\n    for (const i in this.attributes) {\n      const attrib = this.attributes[i];\n      geometry.attributes[i] = new Attribute.Attribute(\n        attrib.buffer,\n        attrib.size,\n        attrib.normalized,\n        attrib.type,\n        attrib.stride,\n        attrib.start,\n        attrib.instance\n      );\n    }\n    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;\n  }\n  /**\n   * Merges an array of geometries into a new single one.\n   *\n   * Geometry attribute styles must match for this operation to work.\n   * @param geometries - array of geometries to merge\n   * @returns - Shiny new geometry!\n   */\n  static merge(geometries) {\n    const geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [];\n    let geometry;\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0;\n    }\n    for (let i = 0; i < geometry.buffers.length; i++)\n      arrays[i] = new map[utils.getBufferType(geometry.buffers[i].data)](sizes[i]), geometryOut.buffers[i] = new Buffer.Buffer(arrays[i]);\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        arrays[j].set(geometry.buffers[j].data, offsets[j]), offsets[j] += geometry.buffers[j].data.length;\n    }\n    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;\n      for (let i = 0; i < geometry.buffers.length; i++)\n        if (geometry.buffers[i] !== geometry.indexBuffer) {\n          bufferIndexToCount = i;\n          break;\n        }\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4);\n      }\n      for (let i = 0; i < geometries.length; i++) {\n        const indexBufferData = geometries[i].indexBuffer.data;\n        for (let j = 0; j < indexBufferData.length; j++)\n          geometryOut.indexBuffer.data[j + offset2] += offset;\n        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  }\n}\nexports.Geometry = Geometry;\n//# sourceMappingURL=Geometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/Geometry.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GeometrySystem.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nclass GeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0);\n    const gl = this.gl = this.renderer.gl, context = this.renderer.context;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = !1, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension(\"ANGLE_instanced_arrays\");\n      instanceExt ? (gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b), gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e), gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d)) : this.hasInstance = !1;\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param shader - Instance of shader to use vao for.\n   */\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const { gl } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = !1;\n    vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = !0);\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  reset() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes)\n      if (!geometryAttributes[j])\n        throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = [\"g\", geometry.id];\n    for (const i in attribs)\n      shaderAttributes[i] && strings.push(i, shaderAttributes[i].location);\n    return strings.join(\"-\");\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param shader - Instance of the shader.\n   * @param incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, shader, incRefCount = !0) {\n    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;\n    program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao)\n      return vaoObjectHash[program.id] = vao, vao;\n    const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};\n    for (const j in buffers)\n      tempStride[j] = 0, tempStart[j] = 0;\n    for (const j in attributes)\n      !attributes[j].size && program.attributeData[j] ? attributes[j].size = program.attributeData[j].size : attributes[j].size || console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n    for (const j in attributes) {\n      const attribute = attributes[j], attribSize = attribute.size;\n      attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type]);\n    }\n    vao = gl.createVertexArray(), gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer), incRefCount && buffer._glBuffers[CONTEXT_UID].refCount++;\n    }\n    return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl.bindVertexArray(null), bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER), vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  disposeGeometry(geometry, contextLost) {\n    if (!this.managedGeometries[geometry.id])\n      return;\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;\n    if (geometry.disposeRunner.remove(this), !!vaos) {\n      if (bufferSystem)\n        for (let i = 0; i < buffers.length; i++) {\n          const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n          buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i], contextLost));\n        }\n      if (!contextLost) {\n        for (const vaoId in vaos)\n          if (vaoId[0] === \"g\") {\n            const vao = vaos[vaoId];\n            this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao);\n          }\n      }\n      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++)\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;\n    geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j], buffer = buffers[attribute.buffer], glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        lastBuffer !== glBuffer && (bufferSystem.bind(buffer), lastBuffer = glBuffer);\n        const location = program.attributeData[j].location;\n        if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(\n          location,\n          attribute.size,\n          attribute.type || gl.FLOAT,\n          attribute.normalized,\n          attribute.stride,\n          attribute.start\n        ), attribute.instance)\n          if (this.hasInstance)\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          else\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param type - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(type, size, start, instanceCount) {\n    const { gl } = this, geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn(\"unsupported index buffer type: uint32\");\n    } else\n      geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize());\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"geometry\"\n};\nextensions.extensions.add(GeometrySystem);\nexports.GeometrySystem = GeometrySystem;\n//# sourceMappingURL=GeometrySystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/GeometrySystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    typeof sizeOrBuffer == \"number\" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n  }\n  /** View on the raw binary data as a `Uint16Array`. */\n  get uint16View() {\n    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n  }\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\nexports.ViewableBuffer = ViewableBuffer;\n//# sourceMappingURL=ViewableBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\");\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0, stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++)\n    stride += sizes[i], outSize += arrays[i].length;\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null, littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i], array = arrays[i], type = utils.getBufferType(array);\n    views[type] || (views[type] = new map[type](buffer)), out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\nexports.interleaveTypedArrays = interleaveTypedArrays;\n//# sourceMappingURL=interleaveTypedArrays.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/core/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ./settings.js */ \"./node_modules/@pixi/core/lib/settings.js\");\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), ticker = __webpack_require__(/*! @pixi/ticker */ \"./node_modules/@pixi/ticker/lib/index.js\"), utils$1 = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), autoDetectRenderer = __webpack_require__(/*! ./autoDetectRenderer.js */ \"./node_modules/@pixi/core/lib/autoDetectRenderer.js\"), BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ \"./node_modules/@pixi/core/lib/background/BackgroundSystem.js\"), BatchDrawCall = __webpack_require__(/*! ./batch/BatchDrawCall.js */ \"./node_modules/@pixi/core/lib/batch/BatchDrawCall.js\"), BatchGeometry = __webpack_require__(/*! ./batch/BatchGeometry.js */ \"./node_modules/@pixi/core/lib/batch/BatchGeometry.js\"), BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ \"./node_modules/@pixi/core/lib/batch/BatchRenderer.js\"), BatchShaderGenerator = __webpack_require__(/*! ./batch/BatchShaderGenerator.js */ \"./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js\"), BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ \"./node_modules/@pixi/core/lib/batch/BatchSystem.js\"), BatchTextureArray = __webpack_require__(/*! ./batch/BatchTextureArray.js */ \"./node_modules/@pixi/core/lib/batch/BatchTextureArray.js\"), ObjectRenderer = __webpack_require__(/*! ./batch/ObjectRenderer.js */ \"./node_modules/@pixi/core/lib/batch/ObjectRenderer.js\"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ \"./node_modules/@pixi/core/lib/context/ContextSystem.js\"), Filter = __webpack_require__(/*! ./filters/Filter.js */ \"./node_modules/@pixi/core/lib/filters/Filter.js\"), FilterState = __webpack_require__(/*! ./filters/FilterState.js */ \"./node_modules/@pixi/core/lib/filters/FilterState.js\"), FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ \"./node_modules/@pixi/core/lib/filters/FilterSystem.js\");\n__webpack_require__(/*! ./filters/IFilterTarget.js */ \"./node_modules/@pixi/core/lib/filters/IFilterTarget.js\");\nvar SpriteMaskFilter = __webpack_require__(/*! ./filters/spriteMask/SpriteMaskFilter.js */ \"./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js\"), index = __webpack_require__(/*! ./fragments/index.js */ \"./node_modules/@pixi/core/lib/fragments/index.js\"), Framebuffer = __webpack_require__(/*! ./framebuffer/Framebuffer.js */ \"./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js\"), FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ \"./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js\"), GLFramebuffer = __webpack_require__(/*! ./framebuffer/GLFramebuffer.js */ \"./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js\"), MultisampleSystem = __webpack_require__(/*! ./framebuffer/MultisampleSystem.js */ \"./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js\"), Attribute = __webpack_require__(/*! ./geometry/Attribute.js */ \"./node_modules/@pixi/core/lib/geometry/Attribute.js\"), Buffer = __webpack_require__(/*! ./geometry/Buffer.js */ \"./node_modules/@pixi/core/lib/geometry/Buffer.js\"), BufferSystem = __webpack_require__(/*! ./geometry/BufferSystem.js */ \"./node_modules/@pixi/core/lib/geometry/BufferSystem.js\"), Geometry = __webpack_require__(/*! ./geometry/Geometry.js */ \"./node_modules/@pixi/core/lib/geometry/Geometry.js\"), GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ \"./node_modules/@pixi/core/lib/geometry/GeometrySystem.js\"), ViewableBuffer = __webpack_require__(/*! ./geometry/ViewableBuffer.js */ \"./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js\");\n__webpack_require__(/*! ./IRenderer.js */ \"./node_modules/@pixi/core/lib/IRenderer.js\");\nvar MaskData = __webpack_require__(/*! ./mask/MaskData.js */ \"./node_modules/@pixi/core/lib/mask/MaskData.js\"), MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ \"./node_modules/@pixi/core/lib/mask/MaskSystem.js\"), ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ \"./node_modules/@pixi/core/lib/mask/ScissorSystem.js\"), StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ \"./node_modules/@pixi/core/lib/mask/StencilSystem.js\"), PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ \"./node_modules/@pixi/core/lib/plugin/PluginSystem.js\"), ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ \"./node_modules/@pixi/core/lib/projection/ProjectionSystem.js\"), ObjectRendererSystem = __webpack_require__(/*! ./render/ObjectRendererSystem.js */ \"./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js\"), Renderer = __webpack_require__(/*! ./Renderer.js */ \"./node_modules/@pixi/core/lib/Renderer.js\"), BaseRenderTexture = __webpack_require__(/*! ./renderTexture/BaseRenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js\"), GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ \"./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js\"), RenderTexture = __webpack_require__(/*! ./renderTexture/RenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js\"), RenderTexturePool = __webpack_require__(/*! ./renderTexture/RenderTexturePool.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js\"), RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js\"), GLProgram = __webpack_require__(/*! ./shader/GLProgram.js */ \"./node_modules/@pixi/core/lib/shader/GLProgram.js\"), Program = __webpack_require__(/*! ./shader/Program.js */ \"./node_modules/@pixi/core/lib/shader/Program.js\"), Shader = __webpack_require__(/*! ./shader/Shader.js */ \"./node_modules/@pixi/core/lib/shader/Shader.js\"), ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ \"./node_modules/@pixi/core/lib/shader/ShaderSystem.js\"), UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ \"./node_modules/@pixi/core/lib/shader/UniformGroup.js\"), checkMaxIfStatementsInShader = __webpack_require__(/*! ./shader/utils/checkMaxIfStatementsInShader.js */ \"./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js\"), generateProgram = __webpack_require__(/*! ./shader/utils/generateProgram.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateProgram.js\"), generateUniformBufferSync = __webpack_require__(/*! ./shader/utils/generateUniformBufferSync.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js\"), getTestContext = __webpack_require__(/*! ./shader/utils/getTestContext.js */ \"./node_modules/@pixi/core/lib/shader/utils/getTestContext.js\"), uniformParsers = __webpack_require__(/*! ./shader/utils/uniformParsers.js */ \"./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js\"), unsafeEvalSupported = __webpack_require__(/*! ./shader/utils/unsafeEvalSupported.js */ \"./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js\"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ \"./node_modules/@pixi/core/lib/startup/StartupSystem.js\"), State = __webpack_require__(/*! ./state/State.js */ \"./node_modules/@pixi/core/lib/state/State.js\"), StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ \"./node_modules/@pixi/core/lib/state/StateSystem.js\");\n__webpack_require__(/*! ./system/ISystem.js */ \"./node_modules/@pixi/core/lib/system/ISystem.js\");\n__webpack_require__(/*! ./systems.js */ \"./node_modules/@pixi/core/lib/systems.js\");\nvar BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), GLTexture = __webpack_require__(/*! ./textures/GLTexture.js */ \"./node_modules/@pixi/core/lib/textures/GLTexture.js\");\n__webpack_require__(/*! ./textures/resources/index.js */ \"./node_modules/@pixi/core/lib/textures/resources/index.js\");\nvar Texture = __webpack_require__(/*! ./textures/Texture.js */ \"./node_modules/@pixi/core/lib/textures/Texture.js\"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ \"./node_modules/@pixi/core/lib/textures/TextureGCSystem.js\"), TextureMatrix = __webpack_require__(/*! ./textures/TextureMatrix.js */ \"./node_modules/@pixi/core/lib/textures/TextureMatrix.js\"), TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ \"./node_modules/@pixi/core/lib/textures/TextureSystem.js\"), TextureUvs = __webpack_require__(/*! ./textures/TextureUvs.js */ \"./node_modules/@pixi/core/lib/textures/TextureUvs.js\"), TransformFeedback = __webpack_require__(/*! ./transformFeedback/TransformFeedback.js */ \"./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js\"), TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ \"./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js\"), Quad = __webpack_require__(/*! ./utils/Quad.js */ \"./node_modules/@pixi/core/lib/utils/Quad.js\"), QuadUv = __webpack_require__(/*! ./utils/QuadUv.js */ \"./node_modules/@pixi/core/lib/utils/QuadUv.js\"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ \"./node_modules/@pixi/core/lib/view/ViewSystem.js\"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ \"./node_modules/@pixi/core/lib/system/SystemManager.js\"), BaseImageResource = __webpack_require__(/*! ./textures/resources/BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\"), Resource = __webpack_require__(/*! ./textures/resources/Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\"), AbstractMultiResource = __webpack_require__(/*! ./textures/resources/AbstractMultiResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js\"), ArrayResource = __webpack_require__(/*! ./textures/resources/ArrayResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js\"), autoDetectResource = __webpack_require__(/*! ./textures/resources/autoDetectResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js\"), BufferResource = __webpack_require__(/*! ./textures/resources/BufferResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BufferResource.js\"), CanvasResource = __webpack_require__(/*! ./textures/resources/CanvasResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js\"), CubeResource = __webpack_require__(/*! ./textures/resources/CubeResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/CubeResource.js\"), ImageBitmapResource = __webpack_require__(/*! ./textures/resources/ImageBitmapResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js\"), ImageResource = __webpack_require__(/*! ./textures/resources/ImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ImageResource.js\"), SVGResource = __webpack_require__(/*! ./textures/resources/SVGResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/SVGResource.js\"), VideoResource = __webpack_require__(/*! ./textures/resources/VideoResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/VideoResource.js\");\nfunction _interopNamespaceDefault(e) {\n  var n = /* @__PURE__ */ Object.create(null);\n  return e && Object.keys(e).forEach(function(k) {\n    if (k !== \"default\") {\n      var d = Object.getOwnPropertyDescriptor(e, k);\n      Object.defineProperty(n, k, d.get ? d : {\n        enumerable: !0,\n        get: function() {\n          return e[k];\n        }\n      });\n    }\n  }), n.default = e, n;\n}\nvar utils__namespace = /* @__PURE__ */ _interopNamespaceDefault(utils$1);\nconst VERSION = \"7.4.3\";\nexports.utils = utils__namespace;\nexports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;\nexports.BackgroundSystem = BackgroundSystem.BackgroundSystem;\nexports.BatchDrawCall = BatchDrawCall.BatchDrawCall;\nexports.BatchGeometry = BatchGeometry.BatchGeometry;\nexports.BatchRenderer = BatchRenderer.BatchRenderer;\nexports.BatchShaderGenerator = BatchShaderGenerator.BatchShaderGenerator;\nexports.BatchSystem = BatchSystem.BatchSystem;\nexports.BatchTextureArray = BatchTextureArray.BatchTextureArray;\nexports.ObjectRenderer = ObjectRenderer.ObjectRenderer;\nexports.ContextSystem = ContextSystem.ContextSystem;\nexports.Filter = Filter.Filter;\nexports.FilterState = FilterState.FilterState;\nexports.FilterSystem = FilterSystem.FilterSystem;\nexports.SpriteMaskFilter = SpriteMaskFilter.SpriteMaskFilter;\nexports.defaultFilterVertex = index.defaultFilterVertex;\nexports.defaultVertex = index.defaultVertex;\nexports.Framebuffer = Framebuffer.Framebuffer;\nexports.FramebufferSystem = FramebufferSystem.FramebufferSystem;\nexports.GLFramebuffer = GLFramebuffer.GLFramebuffer;\nexports.MultisampleSystem = MultisampleSystem.MultisampleSystem;\nexports.Attribute = Attribute.Attribute;\nexports.Buffer = Buffer.Buffer;\nexports.BufferSystem = BufferSystem.BufferSystem;\nexports.Geometry = Geometry.Geometry;\nexports.GeometrySystem = GeometrySystem.GeometrySystem;\nexports.ViewableBuffer = ViewableBuffer.ViewableBuffer;\nexports.MaskData = MaskData.MaskData;\nexports.MaskSystem = MaskSystem.MaskSystem;\nexports.ScissorSystem = ScissorSystem.ScissorSystem;\nexports.StencilSystem = StencilSystem.StencilSystem;\nexports.PluginSystem = PluginSystem.PluginSystem;\nexports.ProjectionSystem = ProjectionSystem.ProjectionSystem;\nexports.ObjectRendererSystem = ObjectRendererSystem.ObjectRendererSystem;\nexports.Renderer = Renderer.Renderer;\nexports.BaseRenderTexture = BaseRenderTexture.BaseRenderTexture;\nexports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;\nexports.RenderTexture = RenderTexture.RenderTexture;\nexports.RenderTexturePool = RenderTexturePool.RenderTexturePool;\nexports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;\nexports.GLProgram = GLProgram.GLProgram;\nexports.IGLUniformData = GLProgram.IGLUniformData;\nexports.Program = Program.Program;\nexports.Shader = Shader.Shader;\nexports.ShaderSystem = ShaderSystem.ShaderSystem;\nexports.UniformGroup = UniformGroup.UniformGroup;\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;\nexports.generateProgram = generateProgram.generateProgram;\nexports.createUBOElements = generateUniformBufferSync.createUBOElements;\nexports.generateUniformBufferSync = generateUniformBufferSync.generateUniformBufferSync;\nexports.getUBOData = generateUniformBufferSync.getUBOData;\nexports.getTestContext = getTestContext.getTestContext;\nexports.uniformParsers = uniformParsers.uniformParsers;\nexports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;\nexports.StartupSystem = StartupSystem.StartupSystem;\nexports.State = State.State;\nexports.StateSystem = StateSystem.StateSystem;\nexports.BaseTexture = BaseTexture.BaseTexture;\nexports.GLTexture = GLTexture.GLTexture;\nexports.Texture = Texture.Texture;\nexports.TextureGCSystem = TextureGCSystem.TextureGCSystem;\nexports.TextureMatrix = TextureMatrix.TextureMatrix;\nexports.TextureSystem = TextureSystem.TextureSystem;\nexports.TextureUvs = TextureUvs.TextureUvs;\nexports.TransformFeedback = TransformFeedback.TransformFeedback;\nexports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;\nexports.Quad = Quad.Quad;\nexports.QuadUv = QuadUv.QuadUv;\nexports.ViewSystem = ViewSystem.ViewSystem;\nexports.SystemManager = SystemManager.SystemManager;\nexports.BaseImageResource = BaseImageResource.BaseImageResource;\nexports.Resource = Resource.Resource;\nexports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;\nexports.ArrayResource = ArrayResource.ArrayResource;\nexports.INSTALLED = autoDetectResource.INSTALLED;\nexports.autoDetectResource = autoDetectResource.autoDetectResource;\nexports.BufferResource = BufferResource.BufferResource;\nexports.CanvasResource = CanvasResource.CanvasResource;\nexports.CubeResource = CubeResource.CubeResource;\nexports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;\nexports.ImageResource = ImageResource.ImageResource;\nexports.SVGResource = SVGResource.SVGResource;\nexports.VideoResource = VideoResource.VideoResource;\nexports.VERSION = VERSION;\nObject.keys(color).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return color[k];\n    }\n  });\n});\nObject.keys(constants).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return constants[k];\n    }\n  });\n});\nObject.keys(extensions).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return extensions[k];\n    }\n  });\n});\nObject.keys(math).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return math[k];\n    }\n  });\n});\nObject.keys(runner).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return runner[k];\n    }\n  });\n});\nObject.keys(settings).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return settings[k];\n    }\n  });\n});\nObject.keys(ticker).forEach(function(k) {\n  k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {\n    enumerable: !0,\n    get: function() {\n      return ticker[k];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass AbstractMaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.maskStack = [], this.glConst = 0;\n  }\n  /** Gets count of masks of certain type. */\n  getStackLength() {\n    return this.maskStack.length;\n  }\n  /**\n   * Changes the mask stack that is used by this System.\n   * @param {PIXI.MaskData[]} maskStack - The mask stack\n   */\n  setMaskStack(maskStack) {\n    const { gl } = this.renderer, curStackLen = this.getStackLength();\n    this.maskStack = maskStack;\n    const newStackLen = this.getStackLength();\n    newStackLen !== curStackLen && (newStackLen === 0 ? gl.disable(this.glConst) : (gl.enable(this.glConst), this._useCurrent()));\n  }\n  /**\n   * Setup renderer to use the current mask data.\n   * @private\n   */\n  _useCurrent() {\n  }\n  /** Destroys the mask stack. */\n  destroy() {\n    this.renderer = null, this.maskStack = null;\n  }\n}\nexports.AbstractMaskSystem = AbstractMaskSystem;\n//# sourceMappingURL=AbstractMaskSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskData.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskData.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Filter = __webpack_require__(/*! ../filters/Filter.js */ \"./node_modules/@pixi/core/lib/filters/Filter.js\");\nclass MaskData {\n  /**\n   * Create MaskData\n   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n   */\n  constructor(maskObject = null) {\n    this.type = constants.MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = maskObject || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = Filter.Filter.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  /**\n   * The sprite mask filter.\n   * If set to `null`, the default sprite mask filter is used.\n   * @default null\n   */\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;\n  }\n  /** Resets the mask data after popMask(). */\n  reset() {\n    this.pooled && (this.maskObject = null, this.type = constants.MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }\n  /**\n   * Copies counters from maskData above, called from pushMask().\n   * @param maskAbove\n   */\n  copyCountersOrReset(maskAbove) {\n    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }\n}\nexports.MaskData = MaskData;\n//# sourceMappingURL=MaskData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/mask/MaskData.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskSystem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), SpriteMaskFilter = __webpack_require__(/*! ../filters/spriteMask/SpriteMaskFilter.js */ \"./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js\"), MaskData = __webpack_require__(/*! ./MaskData.js */ \"./node_modules/@pixi/core/lib/mask/MaskData.js\");\nclass MaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  /**\n   * Changes the mask stack that is used by this System.\n   * @param maskStack - The mask stack\n   */\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);\n  }\n  /**\n   * Enables the mask and appends it to the current mask stack.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n   * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n   */\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData.MaskData();\n      d.pooled = !0, d.maskObject = maskDataOrTarget, maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)\n      switch (maskData.type) {\n        case constants.MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case constants.MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case constants.MASK_TYPES.SPRITE:\n          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);\n          break;\n        case constants.MASK_TYPES.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    maskData.type === constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData);\n  }\n  /**\n   * Removes the last mask from the mask stack and doesn't return it.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n   */\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!(!maskData || maskData._target !== target)) {\n      if (maskData.enabled)\n        switch (maskData.type) {\n          case constants.MASK_TYPES.SCISSOR:\n            this.renderer.scissor.pop(maskData);\n            break;\n          case constants.MASK_TYPES.STENCIL:\n            this.renderer.stencil.pop(maskData.maskObject);\n            break;\n          case constants.MASK_TYPES.SPRITE:\n            this.popSpriteMask(maskData);\n            break;\n          case constants.MASK_TYPES.COLOR:\n            this.popColorMask(maskData);\n            break;\n          default:\n            break;\n        }\n      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {\n        const maskCurrent = this.maskStack[this.maskStack.length - 1];\n        maskCurrent.type === constants.MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);\n      }\n    }\n  }\n  /**\n   * Sets type of MaskData based on its maskObject.\n   * @param maskData\n   */\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    maskObject ? maskObject.isSprite ? maskData.type = constants.MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = constants.MASK_TYPES.SCISSOR : maskData.type = constants.MASK_TYPES.STENCIL : maskData.type = constants.MASK_TYPES.COLOR;\n  }\n  /**\n   * Applies the Mask and adds it to the current filter stack.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  pushSpriteMask(maskData) {\n    const { maskObject } = maskData, target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(!0), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;\n  }\n  /**\n   * Removes the last filter from the filter stack and doesn't return it.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }\n  /**\n   * Pushes the color mask.\n   * @param maskData - The mask data\n   */\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  /**\n   * Pops the color mask.\n   * @param maskData - The mask data\n   */\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"mask\"\n};\nextensions.extensions.add(MaskSystem);\nexports.MaskSystem = MaskSystem;\n//# sourceMappingURL=MaskSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/mask/MaskSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/ScissorSystem.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/ScissorSystem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ \"./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js\");\nconst tempMatrix = new math.Matrix(), rectPool = [], _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem.AbstractMaskSystem {\n  /**\n   * @param {PIXI.Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    return maskData ? maskData._scissorCounter : 0;\n  }\n  /**\n   * evaluates _boundsTransformed, _scissorRect for MaskData\n   * @param maskData\n   */\n  calcScissorRect(maskData) {\n    if (maskData._scissorRectLocal)\n      return;\n    const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(!0, rectPool.pop() ?? new math.Rectangle());\n    this.roundFrameToPixels(\n      rect,\n      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n      renderTextureSystem.sourceFrame,\n      renderTextureSystem.destinationFrame,\n      renderer.projection.transform\n    ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix)\n      return !1;\n    const { a, b, c, d } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  /**\n   * Test, whether the object can be scissor mask with current renderer projection.\n   * Calls \"calcScissorRect()\" if its true.\n   * @param maskData - mask data\n   * @returns whether Whether the object can be scissor mask\n   */\n  testScissor(maskData) {\n    const { maskObject } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))\n      return !1;\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    _ScissorSystem2.isMatrixRotated(transform) || (transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(\n      bindingDestinationFrame.width / bindingSourceFrame.width,\n      bindingDestinationFrame.height / bindingSourceFrame.height\n    ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));\n  }\n  /**\n   * Applies the Mask and adds it to the current stencil stack.\n   * @author alvin\n   * @param maskData - The mask data.\n   */\n  push(maskData) {\n    maskData._scissorRectLocal || this.calcScissorRect(maskData);\n    const { gl } = this.renderer;\n    maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();\n  }\n  /**\n   * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n   * last mask in the stack.\n   *\n   * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n   * @param maskData - The mask data.\n   */\n  pop(maskData) {\n    const { gl } = this.renderer;\n    maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);\n  }\n  /**\n   * Setup renderer to use the current scissor data.\n   * @private\n   */\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    this.renderer.renderTexture.current ? y = rect.y : y = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\n_ScissorSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"scissor\"\n};\nlet ScissorSystem = _ScissorSystem;\nextensions.extensions.add(ScissorSystem);\nexports.ScissorSystem = ScissorSystem;\n//# sourceMappingURL=ScissorSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/mask/ScissorSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/StencilSystem.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/StencilSystem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ \"./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js\");\nclass StencilSystem extends AbstractMaskSystem.AbstractMaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    return maskData ? maskData._stencilCounter : 0;\n  }\n  /**\n   * Applies the Mask and adds it to the current stencil stack.\n   * @param maskData - The mask data\n   */\n  push(maskData) {\n    const maskObject = maskData.maskObject, { gl } = this.renderer, prevMaskCount = maskData._stencilCounter;\n    prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl.clearStencil(0), gl.clear(gl.STENCIL_BUFFER_BIT), gl.enable(gl.STENCIL_TEST)), maskData._stencilCounter++;\n    const colorMask = maskData._colorMask;\n    colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(\n      (colorMask & 1) !== 0,\n      (colorMask & 2) !== 0,\n      (colorMask & 4) !== 0,\n      (colorMask & 8) !== 0\n    )), this._useCurrent();\n  }\n  /**\n   * Pops stencil mask. MaskData is already removed from stack\n   * @param {PIXI.DisplayObject} maskObject - object of popped mask data\n   */\n  pop(maskObject) {\n    const gl = this.renderer.gl;\n    if (this.getStackLength() === 0)\n      gl.disable(gl.STENCIL_TEST);\n    else {\n      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;\n      colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(\n        (colorMask & 1) !== 0,\n        (colorMask & 2) !== 0,\n        (colorMask & 4) !== 0,\n        (colorMask & 8) !== 0\n      )), this._useCurrent();\n    }\n  }\n  /**\n   * Setup renderer to use the current stencil data.\n   * @private\n   */\n  _useCurrent() {\n    const gl = this.renderer.gl;\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  }\n}\nStencilSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"stencil\"\n};\nextensions.extensions.add(StencilSystem);\nexports.StencilSystem = StencilSystem;\n//# sourceMappingURL=StencilSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/mask/StencilSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/plugin/PluginSystem.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/plugin/PluginSystem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\");\nclass PluginSystem {\n  constructor(renderer) {\n    this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {\n      extract: {\n        enumerable: !1,\n        get() {\n          return utils.deprecation(\"7.0.0\", \"renderer.plugins.extract has moved to renderer.extract\"), renderer.extract;\n        }\n      },\n      prepare: {\n        enumerable: !1,\n        get() {\n          return utils.deprecation(\"7.0.0\", \"renderer.plugins.prepare has moved to renderer.prepare\"), renderer.prepare;\n        }\n      },\n      interaction: {\n        enumerable: !1,\n        get() {\n          return utils.deprecation(\"7.0.0\", \"renderer.plugins.interaction has been deprecated, use renderer.events\"), renderer.events;\n        }\n      }\n    });\n  }\n  /**\n   * Initialize the plugins.\n   * @protected\n   */\n  init() {\n    const staticMap = this.rendererPlugins;\n    for (const o in staticMap)\n      this.plugins[o] = new staticMap[o](this.renderer);\n  }\n  destroy() {\n    for (const o in this.plugins)\n      this.plugins[o].destroy(), this.plugins[o] = null;\n  }\n}\nPluginSystem.extension = {\n  type: [\n    extensions.ExtensionType.RendererSystem,\n    extensions.ExtensionType.CanvasRendererSystem\n  ],\n  name: \"_plugin\"\n};\nextensions.extensions.add(PluginSystem);\nexports.PluginSystem = PluginSystem;\n//# sourceMappingURL=PluginSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/plugin/PluginSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/projection/ProjectionSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\");\nclass ProjectionSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new math.Matrix(), this.transform = null;\n  }\n  /**\n   * Updates the projection-matrix based on the sourceFrame → destinationFrame mapping provided.\n   *\n   * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because\n   * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.\n   *\n   * NOTE-2: {@link PIXI.RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture.\n   * It is expected\n   * that you dirty the current bindings when calling this manually.\n   * @param destinationFrame - The rectangle in the render-target to render the contents into. If rendering to the canvas,\n   *  the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.\n   * @param sourceFrame - The rectangle in world space that contains the contents being rendered.\n   * @param resolution - The resolution of the render-target, which is the ratio of\n   *  world-space (or CSS) pixels to physical pixels.\n   * @param root - Whether the render-target is the screen. This is required because rendering to textures\n   *  is y-flipped (i.e. upside down relative to the screen).\n   */\n  update(destinationFrame, sourceFrame, resolution, root) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);\n    const renderer = this.renderer;\n    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);\n  }\n  /**\n   * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.\n   * @param _destinationFrame - The destination frame in the render-target.\n   * @param sourceFrame - The source frame in world space.\n   * @param _resolution - The render-target's resolution, i.e. ratio of CSS to physical pixels.\n   * @param root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection\n   *  is y-flipped.\n   */\n  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {\n    const pm = this.projectionMatrix, sign = root ? -1 : 1;\n    pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign - sourceFrame.y * pm.d;\n  }\n  /**\n   * Sets the transform of the active render target to the given matrix.\n   * @param _matrix - The transformation matrix\n   */\n  setTransform(_matrix) {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nProjectionSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"projection\"\n};\nextensions.extensions.add(ProjectionSystem);\nexports.ProjectionSystem = ProjectionSystem;\n//# sourceMappingURL=ProjectionSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/projection/ProjectionSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nclass ObjectRendererSystem {\n  // renderers scene graph!\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the object to its WebGL view.\n   * @param displayObject - The object to be rendered.\n   * @param options - the options to be passed to the renderer\n   */\n  render(displayObject, options) {\n    const renderer = this.renderer;\n    let renderTexture, clear, transform, skipUpdateTransform;\n    if (options && (renderTexture = options.renderTexture, clear = options.clear, transform = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit(\"prerender\"), renderer.projection.transform = transform, !renderer.context.isLost) {\n      if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {\n        const cacheParent = displayObject.enableTempParent();\n        displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);\n      }\n      renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit(\"postrender\");\n    }\n  }\n  destroy() {\n    this.renderer = null, this.lastObjectRendered = null;\n  }\n}\nObjectRendererSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"objectRenderer\"\n};\nextensions.extensions.add(ObjectRendererSystem);\nexports.ObjectRendererSystem = ObjectRendererSystem;\n//# sourceMappingURL=ObjectRendererSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Framebuffer = __webpack_require__(/*! ../framebuffer/Framebuffer.js */ \"./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js\"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\");\nclass BaseRenderTexture extends BaseTexture.BaseTexture {\n  /**\n   * @param options\n   * @param {number} [options.width=100] - The width of the base render texture.\n   * @param {number} [options.height=100] - The height of the base render texture.\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}\n   *   for possible values.\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio\n   *   of the texture being generated.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.\n   */\n  constructor(options = {}) {\n    if (typeof options == \"number\") {\n      const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];\n      options = { width, height, scaleMode, resolution };\n    }\n    options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = constants.MSAA_QUALITY.NONE), super(null, options), this.mipmap = constants.MIPMAP_MODES.OFF, this.valid = !0, this._clear = new color.Color([0, 0, 0, 0]), this.framebuffer = new Framebuffer.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];\n  }\n  /** Color when clearning the texture. */\n  set clearColor(value) {\n    this._clear.setValue(value);\n  }\n  get clearColor() {\n    return this._clear.value;\n  }\n  /**\n   * Color object when clearning the texture.\n   * @readonly\n   * @since 7.2.0\n   */\n  get clear() {\n    return this._clear;\n  }\n  /**\n   * Shortcut to `this.framebuffer.multisample`.\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  /**\n   * Resizes the BaseRenderTexture.\n   * @param desiredWidth - The desired width to resize to.\n   * @param desiredHeight - The desired height to resize to.\n   */\n  resize(desiredWidth, desiredHeight) {\n    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }\n  /**\n   * Frees the texture and framebuffer from WebGL memory without destroying this texture object.\n   * This means you can still use the texture later which will upload it to GPU\n   * memory again.\n   * @fires PIXI.BaseTexture#dispose\n   */\n  dispose() {\n    this.framebuffer.dispose(), super.dispose();\n  }\n  /** Destroys this texture. */\n  destroy() {\n    super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n  }\n}\nexports.BaseRenderTexture = BaseRenderTexture;\n//# sourceMappingURL=BaseRenderTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js\");\nconst tempTransform = new math.Transform(), tempRect = new math.Rectangle();\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer, this._tempMatrix = new math.Matrix();\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n   * @param displayObject - The displayObject the object will be generated from.\n   * @param {IGenerateTextureOptions} options - Generate texture options.\n   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,\n   *        if no region is specified, defaults to the local bounds of the displayObject.\n   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.\n   * @returns a shiny new texture of the display object passed in\n   */\n  generateTexture(displayObject, options) {\n    const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect) || displayObject.getLocalBounds(tempRect, !0), resolution = textureOptions.resolution || this.renderer.resolution;\n    region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);\n    const renderTexture = RenderTexture.RenderTexture.create(textureOptions);\n    this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;\n    const transform = displayObject.transform;\n    return displayObject.transform = tempTransform, this.renderer.render(displayObject, {\n      renderTexture,\n      transform: this._tempMatrix,\n      skipUpdateTransform: !!displayObject.parent,\n      blit: !0\n    }), displayObject.transform = transform, renderTexture;\n  }\n  destroy() {\n  }\n}\nGenerateTextureSystem.extension = {\n  type: [\n    extensions.ExtensionType.RendererSystem,\n    extensions.ExtensionType.CanvasRendererSystem\n  ],\n  name: \"textureGenerator\"\n};\nextensions.extensions.add(GenerateTextureSystem);\nexports.GenerateTextureSystem = GenerateTextureSystem;\n//# sourceMappingURL=GenerateTextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Texture = __webpack_require__(/*! ../textures/Texture.js */ \"./node_modules/@pixi/core/lib/textures/Texture.js\"), BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js\");\nclass RenderTexture extends Texture.Texture {\n  /**\n   * @param baseRenderTexture - The base texture object that this texture uses.\n   * @param frame - The rectangle frame of the texture to show.\n   */\n  constructor(baseRenderTexture, frame) {\n    super(baseRenderTexture, frame), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();\n  }\n  /**\n   * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.\n   * @readonly\n   */\n  get framebuffer() {\n    return this.baseTexture.framebuffer;\n  }\n  /**\n   * Shortcut to `this.framebuffer.multisample`.\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  /**\n   * Resizes the RenderTexture.\n   * @param desiredWidth - The desired width to resize to.\n   * @param desiredHeight - The desired height to resize to.\n   * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n   */\n  resize(desiredWidth, desiredHeight, resizeBaseTexture = !0) {\n    const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;\n    this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();\n  }\n  /**\n   * Changes the resolution of baseTexture, but does not change framebuffer size.\n   * @param resolution - The new resolution to apply to RenderTexture\n   */\n  setResolution(resolution) {\n    const { baseTexture } = this;\n    baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, !1));\n  }\n  /**\n   * A short hand way of creating a render texture.\n   * @param options - Options\n   * @param {number} [options.width=100] - The width of the render texture\n   * @param {number} [options.height=100] - The height of the render texture\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}\n   *    for possible values\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture\n   *    being generated\n   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer\n   * @returns The new render texture\n   */\n  static create(options) {\n    return new RenderTexture(new BaseRenderTexture.BaseRenderTexture(options));\n  }\n}\nexports.RenderTexture = RenderTexture;\n//# sourceMappingURL=RenderTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js\"), RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js\");\nclass RenderTexturePool {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.\n   */\n  constructor(textureOptions) {\n    this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param realWidth - Width of texture in pixels.\n   * @param realHeight - Height of texture in pixels.\n   * @param multisample - Number of samples of the framebuffer.\n   */\n  createTexture(realWidth, realHeight, multisample = constants.MSAA_QUALITY.NONE) {\n    const baseRenderTexture = new BaseRenderTexture.BaseRenderTexture(Object.assign({\n      width: realWidth,\n      height: realHeight,\n      resolution: 1,\n      multisample\n    }, this.textureOptions));\n    return new RenderTexture.RenderTexture(baseRenderTexture);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {\n    let key;\n    minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = utils.nextPow2(minWidth), minHeight = utils.nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key += multisample * 4294967296)) : key = multisample > 1 ? -multisample : -1, this.texturePool[key] || (this.texturePool[key] = []);\n    let renderTexture = this.texturePool[key].pop();\n    return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   *\n   * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   *  It overrides, it does not multiply\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    const filterTexture = this.getOptimalTexture(\n      input.width,\n      input.height,\n      resolution || input.resolution,\n      multisample || constants.MSAA_QUALITY.NONE\n    );\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = renderTexture.filterPoolKey;\n    renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture);\n  }\n  /**\n   * Alias for returnTexture, to be compliant with FilterSystem interface.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.returnTexture(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    if (destroyTextures = destroyTextures !== !1, destroyTextures)\n      for (const i in this.texturePool) {\n        const textures = this.texturePool[i];\n        if (textures)\n          for (let j = 0; j < textures.length; j++)\n            textures[j].destroy(!0);\n      }\n    this.texturePool = {};\n  }\n  /**\n   * If screen size was changed, drops all screen-sized textures,\n   * sets new screen size, sets `enableFullScreen` to true\n   *\n   * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`\n   * @param size - Initial size of screen.\n   */\n  setScreenSize(size) {\n    if (!(size.width === this._pixelsWidth && size.height === this._pixelsHeight)) {\n      this.enableFullScreen = size.width > 0 && size.height > 0;\n      for (const i in this.texturePool) {\n        if (!(Number(i) < 0))\n          continue;\n        const textures = this.texturePool[i];\n        if (textures)\n          for (let j = 0; j < textures.length; j++)\n            textures[j].destroy(!0);\n        this.texturePool[i] = [];\n      }\n      this._pixelsWidth = size.width, this._pixelsHeight = size.height;\n    }\n  }\n}\nRenderTexturePool.SCREEN_KEY = -1;\nexports.RenderTexturePool = RenderTexturePool;\n//# sourceMappingURL=RenderTexturePool.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\");\nconst tempRect = new math.Rectangle(), tempRect2 = new math.Rectangle();\nclass RenderTextureSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new math.Rectangle(), this.destinationFrame = new math.Rectangle(), this.viewportFrame = new math.Rectangle();\n  }\n  contextChange() {\n    const attributes = this.renderer?.gl.getContextAttributes();\n    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n  }\n  /**\n   * Bind the current render texture.\n   * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.\n   * @param sourceFrame - Part of world that is mapped to the renderTexture.\n   * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.\n   */\n  bind(renderTexture = null, sourceFrame, destinationFrame) {\n    const renderer = this.renderer;\n    this.current = renderTexture;\n    let baseTexture, framebuffer, resolution;\n    renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (tempRect.width = renderTexture.frame.width, tempRect.height = renderTexture.frame.height, sourceFrame = tempRect), destinationFrame || (tempRect2.x = renderTexture.frame.x, tempRect2.y = renderTexture.frame.y, tempRect2.width = sourceFrame.width, tempRect2.height = sourceFrame.height, destinationFrame = tempRect2), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (tempRect.width = renderer._view.screen.width, tempRect.height = renderer._view.screen.height, sourceFrame = tempRect), destinationFrame || (destinationFrame = tempRect, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));\n    const viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);\n  }\n  /**\n   * Erases the render texture and fills the drawing area with a colour.\n   * @param clearColor - The color as rgba, default to use the renderer backgroundColor\n   * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n   */\n  clear(clearColor, mask) {\n    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color$1 = color.Color.shared.setValue(clearColor || fallbackColor);\n    (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color$1.premultiply(color$1.alpha);\n    const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      let { x, y, width, height } = this.viewportFrame;\n      x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x, y, width, height);\n    }\n    this.renderer.framebuffer.clear(color$1.red, color$1.green, color$1.blue, color$1.alpha, mask), clearMask && this.renderer.scissor.pop();\n  }\n  resize() {\n    this.bind(null);\n  }\n  /** Resets render-texture state. */\n  reset() {\n    this.bind(null);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nRenderTextureSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"renderTexture\"\n};\nextensions.extensions.add(RenderTextureSystem);\nexports.RenderTextureSystem = RenderTextureSystem;\n//# sourceMappingURL=RenderTextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/settings.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/core/lib/settings.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ \"./node_modules/@pixi/core/lib/batch/BatchRenderer.js\"), Filter = __webpack_require__(/*! ./filters/Filter.js */ \"./node_modules/@pixi/core/lib/filters/Filter.js\"), Program = __webpack_require__(/*! ./shader/Program.js */ \"./node_modules/@pixi/core/lib/shader/Program.js\");\n__webpack_require__(/*! ./systems.js */ \"./node_modules/@pixi/core/lib/systems.js\");\nvar BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ \"./node_modules/@pixi/core/lib/context/ContextSystem.js\"), BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ \"./node_modules/@pixi/core/lib/background/BackgroundSystem.js\"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ \"./node_modules/@pixi/core/lib/view/ViewSystem.js\"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ \"./node_modules/@pixi/core/lib/startup/StartupSystem.js\"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ \"./node_modules/@pixi/core/lib/textures/TextureGCSystem.js\");\nsettings.settings.PREFER_ENV = constants.ENV.WEBGL2;\nsettings.settings.STRICT_TEXTURE_CACHE = !1;\nsettings.settings.RENDER_OPTIONS = {\n  ...ContextSystem.ContextSystem.defaultOptions,\n  ...BackgroundSystem.BackgroundSystem.defaultOptions,\n  ...ViewSystem.ViewSystem.defaultOptions,\n  ...StartupSystem.StartupSystem.defaultOptions\n};\nObject.defineProperties(settings.settings, {\n  /**\n   * @static\n   * @name WRAP_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.WRAP_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.wrapMode\n   */\n  WRAP_MODE: {\n    get() {\n      return BaseTexture.BaseTexture.defaultOptions.wrapMode;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode\"), BaseTexture.BaseTexture.defaultOptions.wrapMode = value;\n    }\n  },\n  /**\n   * @static\n   * @name SCALE_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.SCALE_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.scaleMode\n   */\n  SCALE_MODE: {\n    get() {\n      return BaseTexture.BaseTexture.defaultOptions.scaleMode;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode\"), BaseTexture.BaseTexture.defaultOptions.scaleMode = value;\n    }\n  },\n  /**\n   * @static\n   * @name MIPMAP_TEXTURES\n   * @memberof PIXI.settings\n   * @type {PIXI.MIPMAP_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.mipmap\n   */\n  MIPMAP_TEXTURES: {\n    get() {\n      return BaseTexture.BaseTexture.defaultOptions.mipmap;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap\"), BaseTexture.BaseTexture.defaultOptions.mipmap = value;\n    }\n    // MIPMAP_MODES.POW2,\n  },\n  /**\n   * @static\n   * @name ANISOTROPIC_LEVEL\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.anisotropicLevel\n   */\n  ANISOTROPIC_LEVEL: {\n    get() {\n      return BaseTexture.BaseTexture.defaultOptions.anisotropicLevel;\n    },\n    set(value) {\n      utils.deprecation(\n        \"7.1.0\",\n        \"settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel\"\n      ), BaseTexture.BaseTexture.defaultOptions.anisotropicLevel = value;\n    }\n  },\n  /**\n   * Default filter resolution.\n   * @static\n   * @name FILTER_RESOLUTION\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @type {number|null}\n   * @see PIXI.Filter.defaultResolution\n   */\n  FILTER_RESOLUTION: {\n    get() {\n      return utils.deprecation(\"7.1.0\", \"settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution\"), Filter.Filter.defaultResolution;\n    },\n    set(value) {\n      Filter.Filter.defaultResolution = value;\n    }\n  },\n  /**\n   * Default filter samples.\n   * @static\n   * @name FILTER_MULTISAMPLE\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @type {PIXI.MSAA_QUALITY}\n   * @see PIXI.Filter.defaultMultisample\n   */\n  FILTER_MULTISAMPLE: {\n    get() {\n      return utils.deprecation(\"7.1.0\", \"settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample\"), Filter.Filter.defaultMultisample;\n    },\n    set(value) {\n      Filter.Filter.defaultMultisample = value;\n    }\n  },\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @name SPRITE_MAX_TEXTURES\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @see PIXI.BatchRenderer.defaultMaxTextures\n   * @type {number}\n   */\n  SPRITE_MAX_TEXTURES: {\n    get() {\n      return BatchRenderer.BatchRenderer.defaultMaxTextures;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures\"), BatchRenderer.BatchRenderer.defaultMaxTextures = value;\n    }\n  },\n  /**\n   * The default sprite batch size.\n   *\n   * The default aims to balance desktop and mobile devices.\n   * @static\n   * @name SPRITE_BATCH_SIZE\n   * @memberof PIXI.settings\n   * @see PIXI.BatchRenderer.defaultBatchSize\n   * @deprecated since 7.1.0\n   * @type {number}\n   */\n  SPRITE_BATCH_SIZE: {\n    get() {\n      return BatchRenderer.BatchRenderer.defaultBatchSize;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize\"), BatchRenderer.BatchRenderer.defaultBatchSize = value;\n    }\n  },\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   * @name CAN_UPLOAD_SAME_BUFFER\n   * @memberof PIXI.settings\n   * @see PIXI.BatchRenderer.canUploadSameBuffer\n   * @deprecated since 7.1.0\n   * @type {boolean}\n   */\n  CAN_UPLOAD_SAME_BUFFER: {\n    get() {\n      return BatchRenderer.BatchRenderer.canUploadSameBuffer;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer\"), BatchRenderer.BatchRenderer.canUploadSameBuffer = value;\n    }\n  },\n  /**\n   * Default Garbage Collection mode.\n   * @static\n   * @name GC_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.GC_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultMode\n   */\n  GC_MODE: {\n    get() {\n      return TextureGCSystem.TextureGCSystem.defaultMode;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode\"), TextureGCSystem.TextureGCSystem.defaultMode = value;\n    }\n  },\n  /**\n   * Default Garbage Collection max idle.\n   * @static\n   * @name GC_MAX_IDLE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultMaxIdle\n   */\n  GC_MAX_IDLE: {\n    get() {\n      return TextureGCSystem.TextureGCSystem.defaultMaxIdle;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle\"), TextureGCSystem.TextureGCSystem.defaultMaxIdle = value;\n    }\n  },\n  /**\n   * Default Garbage Collection maximum check count.\n   * @static\n   * @name GC_MAX_CHECK_COUNT\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultCheckCountMax\n   */\n  GC_MAX_CHECK_COUNT: {\n    get() {\n      return TextureGCSystem.TextureGCSystem.defaultCheckCountMax;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax\"), TextureGCSystem.TextureGCSystem.defaultCheckCountMax = value;\n    }\n  },\n  /**\n   * Default specify float precision in vertex shader.\n   * @static\n   * @name PRECISION_VERTEX\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @deprecated since 7.1.0\n   * @see PIXI.Program.defaultVertexPrecision\n   */\n  PRECISION_VERTEX: {\n    get() {\n      return Program.Program.defaultVertexPrecision;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision\"), Program.Program.defaultVertexPrecision = value;\n    }\n  },\n  /**\n   * Default specify float precision in fragment shader.\n   * @static\n   * @name PRECISION_FRAGMENT\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @deprecated since 7.1.0\n   * @see PIXI.Program.defaultFragmentPrecision\n   */\n  PRECISION_FRAGMENT: {\n    get() {\n      return Program.Program.defaultFragmentPrecision;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision\"), Program.Program.defaultFragmentPrecision = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/settings.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/GLProgram.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/GLProgram.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass IGLUniformData {\n}\nclass GLProgram {\n  /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */\n  constructor(program, uniformData) {\n    this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n  }\n  /** Destroys this program. */\n  destroy() {\n    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n  }\n}\nexports.GLProgram = GLProgram;\nexports.IGLUniformData = IGLUniformData;\n//# sourceMappingURL=GLProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/GLProgram.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Program.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Program.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), defaultProgram$1 = __webpack_require__(/*! ./defaultProgram.frag.js */ \"./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js\"), defaultProgram = __webpack_require__(/*! ./defaultProgram.vert.js */ \"./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js\");\n__webpack_require__(/*! ./utils/index.js */ \"./node_modules/@pixi/core/lib/shader/utils/index.js\");\nvar setPrecision = __webpack_require__(/*! ./utils/setPrecision.js */ \"./node_modules/@pixi/core/lib/shader/utils/setPrecision.js\"), getMaxFragmentPrecision = __webpack_require__(/*! ./utils/getMaxFragmentPrecision.js */ \"./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js\");\nlet UID = 0;\nconst nameCache = {}, _Program = class _Program2 {\n  /**\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param name - Name for shader\n   * @param extra - Extra data for shader\n   */\n  constructor(vertexSrc, fragmentSrc, name = \"pixi-shader\", extra = {}) {\n    this.extra = {}, this.id = UID++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== \"#version\" && (name = name.replace(/\\s+/g, \"-\"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}\n${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}\n${this.fragmentSrc}`, this.vertexSrc = setPrecision.setPrecision(\n      this.vertexSrc,\n      _Program2.defaultVertexPrecision,\n      constants.PRECISION.HIGH\n    ), this.fragmentSrc = setPrecision.setPrecision(\n      this.fragmentSrc,\n      _Program2.defaultFragmentPrecision,\n      getMaxFragmentPrecision.getMaxFragmentPrecision()\n    )), this.glPrograms = {}, this.syncUniforms = null;\n  }\n  /**\n   * The default vertex shader source.\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return defaultProgram.default;\n  }\n  /**\n   * The default fragment shader source.\n   * @readonly\n   */\n  static get defaultFragmentSrc() {\n    return defaultProgram$1.default;\n  }\n  /**\n   * A short hand function to create a program based of a vertex and fragment shader.\n   *\n   * This method will also check to see if there is a cached program.\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param name - Name for shader\n   * @returns A shiny new PixiJS shader program!\n   */\n  static from(vertexSrc, fragmentSrc, name) {\n    const key = vertexSrc + fragmentSrc;\n    let program = utils.ProgramCache[key];\n    return program || (utils.ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;\n  }\n};\n_Program.defaultVertexPrecision = constants.PRECISION.HIGH, /**\n* Default specify float precision in fragment shader.\n* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742\n* @static\n* @type {PIXI.PRECISION}\n* @default PIXI.PRECISION.MEDIUM\n*/\n_Program.defaultFragmentPrecision = utils.isMobile.apple.device ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;\nlet Program = _Program;\nexports.Program = Program;\n//# sourceMappingURL=Program.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/Program.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Shader.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Shader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\"), Program = __webpack_require__(/*! ./Program.js */ \"./node_modules/@pixi/core/lib/shader/Program.js\"), UniformGroup = __webpack_require__(/*! ./UniformGroup.js */ \"./node_modules/@pixi/core/lib/shader/UniformGroup.js\");\nclass Shader {\n  /**\n   * @param program - The program the shader will use.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   */\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup.UniformGroup ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup.UniformGroup(uniforms) : this.uniformGroup = new UniformGroup.UniformGroup({}), this.disposeRunner = new runner.Runner(\"disposeShader\");\n  }\n  // TODO move to shader system..\n  checkUniformExists(name, group) {\n    if (group.uniforms[name])\n      return !0;\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group === !0 && this.checkUniformExists(name, uniform))\n        return !0;\n    }\n    return !1;\n  }\n  destroy() {\n    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();\n  }\n  /**\n   * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n   * @readonly\n   */\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  /**\n   * A short hand function to create a shader based of a vertex and fragment shader.\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   * @returns A shiny new PixiJS shader!\n   */\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\nexports.Shader = Shader;\n//# sourceMappingURL=Shader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/Shader.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/ShaderSystem.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/ShaderSystem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\n__webpack_require__(/*! ./utils/index.js */ \"./node_modules/@pixi/core/lib/shader/utils/index.js\");\nvar generateProgram = __webpack_require__(/*! ./utils/generateProgram.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateProgram.js\"), generateUniformBufferSync = __webpack_require__(/*! ./utils/generateUniformBufferSync.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js\"), unsafeEvalSupported = __webpack_require__(/*! ./utils/unsafeEvalSupported.js */ \"./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js\"), generateUniformsSync = __webpack_require__(/*! ./utils/generateUniformsSync.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js\");\nlet UID = 0;\nconst defaultSyncData = { textureCount: 0, uboCount: 0 };\nclass ShaderSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.destroyed = !1, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;\n  }\n  /**\n   * Overrideable function by `@pixi/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  systemCheck() {\n    if (!unsafeEvalSupported.unsafeEvalSupported())\n      throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n  }\n  contextChange(gl) {\n    this.gl = gl, this.reset();\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param dontSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, dontSync) {\n    shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;\n    const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n    return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram;\n  }\n  /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param uniforms - the uniforms values that be applied to the current shader\n   */\n  setUniforms(uniforms) {\n    const shader = this.shader.program, glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n  }\n  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n  /**\n   * Syncs uniforms on the group\n   * @param group - the uniform group to sync\n   * @param syncData - this is data that is passed to the sync function and any nested sync functions\n   */\n  syncUniformGroup(group, syncData) {\n    const glProgram = this.getGlProgram();\n    (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) && (glProgram.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram, syncData));\n  }\n  /**\n   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param glProgram\n   * @param syncData\n   */\n  syncUniforms(group, glProgram, syncData) {\n    (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n  }\n  createSyncGroups(group) {\n    const id = this.getSignature(group, this.shader.program.uniformData, \"u\");\n    return this.cache[id] || (this.cache[id] = generateUniformsSync.generateUniformsSync(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];\n  }\n  /**\n   * Syncs uniform buffers\n   * @param group - the uniform buffer group to sync\n   * @param name - the name of the uniform buffer\n   */\n  syncUniformBufferGroup(group, name) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n      group.dirtyId = 0;\n      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n      group.buffer.update(), syncFunc(\n        glProgram.uniformData,\n        group.uniforms,\n        this.renderer,\n        defaultSyncData,\n        group.buffer\n      );\n    }\n    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n  }\n  /**\n   * Will create a function that uploads a uniform buffer using the STD140 standard.\n   * The upload function will then be cached for future calls\n   * If a group is manually managed, then a simple upload function is generated\n   * @param group - the uniform buffer group to sync\n   * @param glProgram - the gl program to attach the uniform bindings to\n   * @param name - the name of the uniform buffer (must exist on the shader)\n   */\n  createSyncBufferGroup(group, glProgram, name) {\n    const { gl } = this.renderer;\n    this.renderer.buffer.bind(group.buffer);\n    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount, gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n    const id = this.getSignature(group, this.shader.program.uniformData, \"ubo\");\n    let uboData = this._uboCache[id];\n    if (uboData || (uboData = this._uboCache[id] = generateUniformBufferSync.generateUniformBufferSync(group, this.shader.program.uniformData)), group.autoManage) {\n      const data = new Float32Array(uboData.size / 4);\n      group.buffer.update(data);\n    }\n    return glProgram.uniformGroups[group.id] = uboData.syncFunc, glProgram.uniformGroups[group.id];\n  }\n  /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */\n  getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms, strings = [`${preFix}-`];\n    for (const i in uniforms)\n      strings.push(i), uniformData[i] && strings.push(uniformData[i].type);\n    return strings.join(\"-\");\n  }\n  /**\n   * Returns the underlying GLShade rof the currently bound shader.\n   *\n   * This can be handy for when you to have a little more control over the setting of your uniforms.\n   * @returns The glProgram for the currently bound Shader for this context\n   */\n  getGlProgram() {\n    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n  }\n  /**\n   * Generates a glProgram version of the Shader provided.\n   * @param shader - The shader that the glProgram will be based on.\n   * @returns A shiny new glProgram!\n   */\n  generateProgram(shader) {\n    const gl = this.gl, program = shader.program, glProgram = generateProgram.generateProgram(gl, program);\n    return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;\n  }\n  /** Resets ShaderSystem state, does not affect WebGL state. */\n  reset() {\n    this.program = null, this.shader = null;\n  }\n  /**\n   * Disposes shader.\n   * If disposing one equals with current shader, set current as null.\n   * @param shader - Shader object\n   */\n  disposeShader(shader) {\n    this.shader === shader && (this.shader = null);\n  }\n  /** Destroys this System and removes all its textures. */\n  destroy() {\n    this.renderer = null, this.destroyed = !0;\n  }\n}\nShaderSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"shader\"\n};\nextensions.extensions.add(ShaderSystem);\nexports.ShaderSystem = ShaderSystem;\n//# sourceMappingURL=ShaderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/ShaderSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/UniformGroup.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/UniformGroup.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ \"./node_modules/@pixi/core/lib/geometry/Buffer.js\");\nlet UID = 0;\nclass UniformGroup {\n  /**\n   * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer.\n   * @param isStatic - Uniforms wont be changed after creation.\n   * @param isUbo - If true, will treat this uniform group as a uniform buffer object.\n   */\n  constructor(uniforms, isStatic, isUbo) {\n    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer.Buffer ? (this.buffer = uniforms, this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer.Buffer(new Float32Array(1)), this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));\n  }\n  update() {\n    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n  }\n  add(name, uniforms, _static) {\n    if (!this.ubo)\n      this.uniforms[name] = new UniformGroup(uniforms, _static);\n    else\n      throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n  }\n  static from(uniforms, _static, _ubo) {\n    return new UniformGroup(uniforms, _static, _ubo);\n  }\n  /**\n   * A short hand function for creating a static UBO UniformGroup.\n   * @param uniforms - the ubo item\n   * @param _static - should this be updated each time it is used? defaults to true here!\n   */\n  static uboFrom(uniforms, _static) {\n    return new UniformGroup(uniforms, _static ?? !0, !0);\n  }\n}\nexports.UniformGroup = UniformGroup;\n//# sourceMappingURL=UniformGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/UniformGroup.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultFragment = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`;\nexports[\"default\"] = defaultFragment;\n//# sourceMappingURL=defaultProgram.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: !0 }));\nvar defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`;\nexports[\"default\"] = defaultVertex;\n//# sourceMappingURL=defaultProgram.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i)\n    i > 0 && (src += `\nelse `), i < maxIfs - 1 && (src += `if(test == ${i}.0){}`);\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  for (; ; ) {\n    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n      maxIfs = maxIfs / 2 | 0;\n    else\n      break;\n  }\n  return maxIfs;\n}\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;\n//# sourceMappingURL=checkMaxIfStatementsInShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/compileShader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/compileShader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  return gl.shaderSource(shader, src), gl.compileShader(shader), shader;\n}\nexports.compileShader = compileShader;\n//# sourceMappingURL=compileShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/compileShader.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/defaultValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++)\n    array[i] = !1;\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * size);\n    case \"vec3\":\n      return new Float32Array(3 * size);\n    case \"vec4\":\n      return new Float32Array(4 * size);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * size);\n    case \"ivec3\":\n      return new Int32Array(3 * size);\n    case \"ivec4\":\n      return new Int32Array(4 * size);\n    case \"uvec2\":\n      return new Uint32Array(2 * size);\n    case \"uvec3\":\n      return new Uint32Array(3 * size);\n    case \"uvec4\":\n      return new Uint32Array(4 * size);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return booleanArray(2 * size);\n    case \"bvec3\":\n      return booleanArray(3 * size);\n    case \"bvec4\":\n      return booleanArray(4 * size);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nexports.defaultValue = defaultValue;\n//# sourceMappingURL=defaultValue.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/defaultValue.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateProgram.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar GLProgram = __webpack_require__(/*! ../GLProgram.js */ \"./node_modules/@pixi/core/lib/shader/GLProgram.js\"), compileShader = __webpack_require__(/*! ./compileShader.js */ \"./node_modules/@pixi/core/lib/shader/utils/compileShader.js\"), defaultValue = __webpack_require__(/*! ./defaultValue.js */ \"./node_modules/@pixi/core/lib/shader/utils/defaultValue.js\"), getAttributeData = __webpack_require__(/*! ./getAttributeData.js */ \"./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js\"), getUniformData = __webpack_require__(/*! ./getUniformData.js */ \"./node_modules/@pixi/core/lib/shader/utils/getUniformData.js\"), logProgramError = __webpack_require__(/*! ./logProgramError.js */ \"./node_modules/@pixi/core/lib/shader/utils/logProgramError.js\");\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader), gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;\n  if (transformFeedbackVaryings && (typeof gl.transformFeedbackVaryings != \"function\" ? console.warn(\"TransformFeedback is not supported but TransformFeedbackVaryings are given.\") : gl.transformFeedbackVaryings(\n    webGLProgram,\n    transformFeedbackVaryings.names,\n    transformFeedbackVaryings.bufferMode === \"separate\" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS\n  )), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData.getAttributeData(webGLProgram, gl), program.uniformData = getUniformData.getUniformData(webGLProgram, gl), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    const keys = Object.keys(program.attributeData);\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++)\n      program.attributeData[keys[i]].location = i, gl.bindAttribLocation(webGLProgram, i, keys[i]);\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader), gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program.uniformData) {\n    const data = program.uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue.defaultValue(data.type, data.size)\n    };\n  }\n  return new GLProgram.GLProgram(webGLProgram, uniformData);\n}\nexports.generateProgram = generateProgram;\n//# sourceMappingURL=generateProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/generateProgram.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ./index.js */ \"./node_modules/@pixi/core/lib/shader/utils/index.js\");\nvar uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ \"./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js\"), mapSize = __webpack_require__(/*! ./mapSize.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapSize.js\");\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nconst UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    dataLen: 0,\n    dirty: 0\n  }));\n  let size = 0, chunkSize = 0, offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    if (size = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size = Math.max(size, 16) * uboElement.data.size), uboElement.dataLen = size, chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue, offset += lineUpValue;\n    }\n    chunkSize + size > 16 ? (offset = Math.ceil(offset / 16) * 16, uboElement.offset = offset, offset += size, chunkSize = size) : (uboElement.offset = offset, chunkSize += size, offset += size);\n  }\n  return offset = Math.ceil(offset / 16) * 16, { uboElements, size: offset };\n}\nfunction getUBOData(uniforms, uniformData) {\n  const usedUniformDatas = [];\n  for (const i in uniforms)\n    uniformData[i] && usedUniformDatas.push(uniformData[i]);\n  return usedUniformDatas.sort((a, b) => a.index - b.index), usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  const usedUniformDatas = getUBOData(group.uniforms, uniformData), { uboElements, size } = createUBOElements(usedUniformDatas), funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i], uniform = group.uniforms[uboElement.data.name], name = uboElement.data.name;\n    let parsed = !1;\n    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {\n      const uniformParser = uniformParsers.uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(\n          `offset = ${uboElement.offset / 4};`,\n          uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform)\n        ), parsed = !0;\n        break;\n      }\n    }\n    if (!parsed)\n      if (uboElement.data.size > 1) {\n        const size2 = mapSize.mapSize(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size2 / rowSize, remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n      } else {\n        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n      }\n  }\n  return funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size,\n    // eslint-disable-next-line no-new-func\n    syncFunc: new Function(\n      \"ud\",\n      \"uv\",\n      \"renderer\",\n      \"syncData\",\n      \"buffer\",\n      funcFragments.join(`\n`)\n    )\n  };\n}\nexports.createUBOElements = createUBOElements;\nexports.generateUniformBufferSync = generateUniformBufferSync;\nexports.getUBOData = getUBOData;\n//# sourceMappingURL=generateUniformBufferSync.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ \"./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js\");\nconst GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (const i in group.uniforms) {\n    const data = uniformData[i];\n    if (!data) {\n      group.uniforms[i]?.group === !0 && (group.uniforms[i].ubo ? funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');\n                    `) : funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `));\n      continue;\n    }\n    const uniform = group.uniforms[i];\n    let parsed = !1;\n    for (let j = 0; j < uniformParsers.uniformParsers.length; j++)\n      if (uniformParsers.uniformParsers[j].test(data, uniform)) {\n        funcFragments.push(uniformParsers.uniformParsers[j].code(i, uniform)), parsed = !0;\n        break;\n      }\n    if (!parsed) {\n      const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace(\"location\", `ud[\"${i}\"].location`);\n      funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(`\n`));\n}\nexports.generateUniformsSync = generateUniformsSync;\n//# sourceMappingURL=generateUniformsSync.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar mapSize = __webpack_require__(/*! ./mapSize.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapSize.js\"), mapType = __webpack_require__(/*! ./mapType.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapType.js\");\nfunction getAttributeData(program, gl) {\n  const attributes = {}, totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith(\"gl_\"))\n      continue;\n    const type = mapType.mapType(gl, attribData.type), data = {\n      type,\n      name: attribData.name,\n      size: mapSize.mapSize(type),\n      location: gl.getAttribLocation(program, attribData.name)\n    };\n    attributes[attribData.name] = data;\n  }\n  return attributes;\n}\nexports.getAttributeData = getAttributeData;\n//# sourceMappingURL=getAttributeData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), getTestContext = __webpack_require__(/*! ./getTestContext.js */ \"./node_modules/@pixi/core/lib/shader/utils/getTestContext.js\");\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = constants.PRECISION.MEDIUM;\n    const gl = getTestContext.getTestContext();\n    if (gl && gl.getShaderPrecisionFormat) {\n      const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n      shaderFragment && (maxFragmentPrecision = shaderFragment.precision ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM);\n    }\n  }\n  return maxFragmentPrecision;\n}\nexports.getMaxFragmentPrecision = getMaxFragmentPrecision;\n//# sourceMappingURL=getMaxFragmentPrecision.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getTestContext.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nconst unknownContext = {};\nlet context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context?.isContextLost()) {\n    const canvas = settings.settings.ADAPTER.createCanvas();\n    let gl;\n    settings.settings.PREFER_ENV >= constants.ENV.WEBGL2 && (gl = canvas.getContext(\"webgl2\", {})), gl || (gl = canvas.getContext(\"webgl\", {}) || canvas.getContext(\"experimental-webgl\", {}), gl ? gl.getExtension(\"WEBGL_draw_buffers\") : gl = null), context = gl;\n  }\n  return context;\n}\nexports.getTestContext = getTestContext;\n//# sourceMappingURL=getTestContext.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/getTestContext.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getUniformData.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getUniformData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar defaultValue = __webpack_require__(/*! ./defaultValue.js */ \"./node_modules/@pixi/core/lib/shader/utils/defaultValue.js\"), mapType = __webpack_require__(/*! ./mapType.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapType.js\");\nfunction getUniformData(program, gl) {\n  const uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i), name = uniformData.name.replace(/\\[.*?\\]$/, \"\"), isArray = !!uniformData.name.match(/\\[.*?\\]$/), type = mapType.mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue.defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\nexports.getUniformData = getUniformData;\n//# sourceMappingURL=getUniformData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/getUniformData.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar checkMaxIfStatementsInShader = __webpack_require__(/*! ./checkMaxIfStatementsInShader.js */ \"./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js\"), compileShader = __webpack_require__(/*! ./compileShader.js */ \"./node_modules/@pixi/core/lib/shader/utils/compileShader.js\"), defaultValue = __webpack_require__(/*! ./defaultValue.js */ \"./node_modules/@pixi/core/lib/shader/utils/defaultValue.js\"), generateUniformsSync = __webpack_require__(/*! ./generateUniformsSync.js */ \"./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js\"), getMaxFragmentPrecision = __webpack_require__(/*! ./getMaxFragmentPrecision.js */ \"./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js\"), getTestContext = __webpack_require__(/*! ./getTestContext.js */ \"./node_modules/@pixi/core/lib/shader/utils/getTestContext.js\"), logProgramError = __webpack_require__(/*! ./logProgramError.js */ \"./node_modules/@pixi/core/lib/shader/utils/logProgramError.js\"), mapSize = __webpack_require__(/*! ./mapSize.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapSize.js\"), mapType = __webpack_require__(/*! ./mapType.js */ \"./node_modules/@pixi/core/lib/shader/utils/mapType.js\"), setPrecision = __webpack_require__(/*! ./setPrecision.js */ \"./node_modules/@pixi/core/lib/shader/utils/setPrecision.js\"), uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ \"./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js\"), unsafeEvalSupported = __webpack_require__(/*! ./unsafeEvalSupported.js */ \"./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js\");\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;\nexports.compileShader = compileShader.compileShader;\nexports.defaultValue = defaultValue.defaultValue;\nexports.generateUniformsSync = generateUniformsSync.generateUniformsSync;\nexports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;\nexports.getTestContext = getTestContext.getTestContext;\nexports.logProgramError = logProgramError.logProgramError;\nexports.mapSize = mapSize.mapSize;\nexports.mapType = mapType.mapType;\nexports.setPrecision = setPrecision.setPrecision;\nexports.uniformParsers = uniformParsers.uniformParsers;\nexports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/logProgramError.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split(`\n`).map((line, index) => `${index}: ${line}`), shaderLog = gl.getShaderInfoLog(shader), splitShader = shaderLog.split(`\n`), dedupe = {}, lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"))).filter((n) => n && !dedupe[n] ? (dedupe[n] = !0, !0) : !1), logArgs = [\"\"];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  const fragmentSourceToLog = shaderSrc.join(`\n`);\n  logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed(\"click to view full shader code\"), console.warn(...logArgs), console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  gl.getProgramParameter(program, gl.LINK_STATUS) || (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, vertexShader), gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, fragmentShader), console.error(\"PixiJS Error: Could not initialize shader.\"), gl.getProgramInfoLog(program) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", gl.getProgramInfoLog(program)));\n}\nexports.logProgramError = logProgramError;\n//# sourceMappingURL=logProgramError.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/logProgramError.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapSize.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapSize.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\nexports.mapSize = mapSize;\n//# sourceMappingURL=mapSize.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/mapSize.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapType.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapType.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\nexports.mapType = mapType;\n//# sourceMappingURL=mapType.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/mapType.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/setPrecision.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nfunction setPrecision(src, requestedPrecision, maxSupportedPrecision) {\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = requestedPrecision;\n    return requestedPrecision === constants.PRECISION.HIGH && maxSupportedPrecision !== constants.PRECISION.HIGH && (precision = constants.PRECISION.MEDIUM), `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== constants.PRECISION.HIGH && src.substring(0, 15) === \"precision highp\")\n    return src.replace(\"precision highp\", \"precision mediump\");\n  return src;\n}\nexports.setPrecision = setPrecision;\n//# sourceMappingURL=setPrecision.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/setPrecision.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst uniformParsers = [\n  // a float cache layer\n  {\n    test: (data) => data.type === \"float\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n            if(uv[\"${name}\"] !== ud[\"${name}\"].value)\n            {\n                ud[\"${name}\"].value = uv[\"${name}\"]\n                gl.uniform1f(ud[\"${name}\"].location, uv[\"${name}\"])\n            }\n            `\n  },\n  // handling samplers\n  {\n    test: (data, uniform) => (\n      // eslint-disable-next-line max-len,no-eq-null,eqeqeq\n      (data.type === \"sampler2D\" || data.type === \"samplerCube\" || data.type === \"sampler2DArray\") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)\n    ),\n    code: (name) => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"${name}\"], t);\n\n            if(ud[\"${name}\"].value !== t)\n            {\n                ud[\"${name}\"].value = t;\n                gl.uniform1i(ud[\"${name}\"].location, t);\n; // eslint-disable-line max-len\n            }`\n  },\n  // uploading pixi matrix object to mat3\n  {\n    test: (data, uniform) => data.type === \"mat3\" && data.size === 1 && !data.isArray && uniform.a !== void 0,\n    code: (name) => (\n      // TODO and some smart caching dirty ids here!\n      `\n            gl.uniformMatrix3fv(ud[\"${name}\"].location, false, uv[\"${name}\"].toArray(true));\n            `\n    ),\n    codeUbo: (name) => `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `\n  },\n  // uploading a pixi point as a vec2 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec2\" && data.size === 1 && !data.isArray && uniform.x !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"${name}\"].location, v.x, v.y);\n                }`,\n    codeUbo: (name) => `\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `\n  },\n  // caching layer for a vec2\n  {\n    test: (data) => data.type === \"vec2\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"${name}\"].location, v[0], v[1]);\n                }\n            `\n  },\n  // upload a pixi rectangle as a vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec4\" && data.size === 1 && !data.isArray && uniform.width !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"${name}\"].location, v.x, v.y, v.width, v.height)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `\n  },\n  // upload a pixi color as vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec4\" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud[\"${name}\"].location, v.red, v.green, v.blue, v.alpha)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `\n  },\n  // upload a pixi color as a vec3 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec3\" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud[\"${name}\"].location, v.red, v.green, v.blue)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `\n  },\n  // a caching layer for vec4 uploading\n  {\n    test: (data) => data.type === \"vec4\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"${name}\"].location, v[0], v[1], v[2], v[3])\n                }`\n  }\n];\nexports.uniformParsers = uniformParsers;\n//# sourceMappingURL=uniformParsers.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == \"boolean\")\n    return unsafeEval;\n  try {\n    unsafeEval = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\")({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\nexports.unsafeEvalSupported = unsafeEvalSupported;\n//# sourceMappingURL=unsafeEvalSupported.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/startup/StartupSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/startup/StartupSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nclass StartupSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  run(options) {\n    const { renderer } = this;\n    renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.4.3 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);\n  }\n  destroy() {\n  }\n}\nStartupSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.hello}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  hello: !1\n}, /** @ignore */\nStartupSystem.extension = {\n  type: [\n    extensions.ExtensionType.RendererSystem,\n    extensions.ExtensionType.CanvasRendererSystem\n  ],\n  name: \"startup\"\n};\nextensions.extensions.add(StartupSystem);\nexports.StartupSystem = StartupSystem;\n//# sourceMappingURL=StartupSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/startup/StartupSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/State.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/State.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nconst BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5;\nclass State {\n  constructor() {\n    this.data = 0, this.blendMode = constants.BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    !!(this.data & 1 << BLEND) !== value && (this.data ^= 1 << BLEND);\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    !!(this.data & 1 << OFFSET) !== value && (this.data ^= 1 << OFFSET);\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    !!(this.data & 1 << CULLING) !== value && (this.data ^= 1 << CULLING);\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    !!(this.data & 1 << DEPTH_TEST) !== value && (this.data ^= 1 << DEPTH_TEST);\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    !!(this.data & 1 << DEPTH_MASK) !== value && (this.data ^= 1 << DEPTH_MASK);\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    !!(this.data & 1 << WINDING) !== value && (this.data ^= 1 << WINDING);\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== constants.BLEND_MODES.NONE, this._blendMode = value;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value, this._polygonOffset = value;\n  }\n  static for2d() {\n    const state = new State();\n    return state.depthTest = !1, state.blend = !0, state;\n  }\n}\nState.prototype.toString = function() {\n  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n};\nexports.State = State;\n//# sourceMappingURL=State.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/state/State.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/StateSystem.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/StateSystem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), State = __webpack_require__(/*! ./State.js */ \"./node_modules/@pixi/core/lib/state/State.js\"), mapWebGLBlendModesToPixi = __webpack_require__(/*! ./utils/mapWebGLBlendModesToPixi.js */ \"./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js\");\nconst BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, _StateSystem = class _StateSystem2 {\n  constructor() {\n    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = constants.BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State.State(), this.defaultState.blend = !0;\n  }\n  contextChange(gl) {\n    this.gl = gl, this.blendModes = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi(gl), this.set(this.defaultState), this.reset();\n  }\n  /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */\n  set(state) {\n    if (state = state || this.defaultState, this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data, i = 0;\n      for (; diff; )\n        diff & 1 && this.map[i].call(this, !!(state.data & 1 << i)), diff = diff >> 1, i++;\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++)\n      this.checks[i](this, state);\n  }\n  /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++)\n      this.map[i].call(this, !!(state.data & 1 << i));\n    for (let i = 0; i < this.checks.length; i++)\n      this.checks[i](this, state);\n    this.stateId = state.data;\n  }\n  /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */\n  setBlend(value) {\n    this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }\n  /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */\n  setOffset(value) {\n    this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */\n  setDepthTest(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }\n  /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */\n  setCullFace(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }\n  /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? \"CW\" : \"CCW\"]);\n  }\n  /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */\n  setBlendMode(value) {\n    if (value === this.blendMode)\n      return;\n    this.blendMode = value;\n    const mode = this.blendModes[value], gl = this.gl;\n    mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = !0, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = !1, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD));\n  }\n  /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  // used\n  /** Resets all the logic and disables the VAOs. */\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n  }\n  /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */\n  updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    value && index === -1 ? this.checks.push(func) : !value && index !== -1 && this.checks.splice(index, 1);\n  }\n  /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.gl = null;\n  }\n};\n_StateSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"state\"\n};\nlet StateSystem = _StateSystem;\nextensions.extensions.add(StateSystem);\nexports.StateSystem = StateSystem;\n//# sourceMappingURL=StateSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/state/StateSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nfunction mapWebGLBlendModesToPixi(gl, array = []) {\n  return array[constants.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[constants.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.NONE] = [0, 0], array[constants.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[constants.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[constants.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[constants.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[constants.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[constants.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[constants.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array;\n}\nexports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;\n//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/ISystem.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/ISystem.js ***!
  \*******************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=ISystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/system/ISystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/SystemManager.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/SystemManager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\");\nclass SystemManager extends utils.EventEmitter {\n  constructor() {\n    super(...arguments), this.runners = {}, this._systemsHash = {};\n  }\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  setup(config) {\n    this.addRunners(...config.runners);\n    const priority = (config.priority ?? []).filter((key) => config.systems[key]), orderByPriority = [\n      ...priority,\n      ...Object.keys(config.systems).filter((key) => !priority.includes(key))\n    ];\n    for (const i of orderByPriority)\n      this.addSystem(config.systems[i], i);\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new runner.Runner(runnerId);\n    });\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name])\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    this[name] = system, this._systemsHash[name] = system;\n    for (const i in this.runners)\n      this.runners[i].add(system);\n    return this;\n  }\n  /**\n   * A function that will run a runner and call the runners function but pass in different options\n   * to each system based on there name.\n   *\n   * E.g. If you have two systems added called `systemA` and `systemB` you could call do the following:\n   *\n   * ```js\n   * system.emitWithCustomOptions(init, {\n   *     systemA: {...optionsForA},\n   *     systemB: {...optionsForB},\n   * });\n   * ```\n   *\n   * `init` would be called on system A passing `optionsForA` and on system B passing `optionsForB`.\n   * @param runner - the runner to target\n   * @param options - key value options for each system\n   */\n  emitWithCustomOptions(runner2, options) {\n    const systemHashKeys = Object.keys(this._systemsHash);\n    runner2.items.forEach((system) => {\n      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);\n      system[runner2.name](options[systemName]);\n    });\n  }\n  /** destroy the all runners and systems. Its apps job to */\n  destroy() {\n    Object.values(this.runners).forEach((runner2) => {\n      runner2.destroy();\n    }), this._systemsHash = {};\n  }\n  // TODO implement!\n  // removeSystem(ClassRef: ISystemConstructor, name: string): void\n  // {\n  // }\n}\nexports.SystemManager = SystemManager;\n//# sourceMappingURL=SystemManager.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/system/SystemManager.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/systems.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/core/lib/systems.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ \"./node_modules/@pixi/core/lib/background/BackgroundSystem.js\"), BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ \"./node_modules/@pixi/core/lib/batch/BatchSystem.js\"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ \"./node_modules/@pixi/core/lib/context/ContextSystem.js\"), FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ \"./node_modules/@pixi/core/lib/filters/FilterSystem.js\"), FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ \"./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js\"), GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ \"./node_modules/@pixi/core/lib/geometry/GeometrySystem.js\"), MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ \"./node_modules/@pixi/core/lib/mask/MaskSystem.js\"), ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ \"./node_modules/@pixi/core/lib/mask/ScissorSystem.js\"), StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ \"./node_modules/@pixi/core/lib/mask/StencilSystem.js\"), PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ \"./node_modules/@pixi/core/lib/plugin/PluginSystem.js\"), ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ \"./node_modules/@pixi/core/lib/projection/ProjectionSystem.js\"), GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ \"./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js\"), RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ \"./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js\"), ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ \"./node_modules/@pixi/core/lib/shader/ShaderSystem.js\"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ \"./node_modules/@pixi/core/lib/startup/StartupSystem.js\"), StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ \"./node_modules/@pixi/core/lib/state/StateSystem.js\"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ \"./node_modules/@pixi/core/lib/system/SystemManager.js\"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ \"./node_modules/@pixi/core/lib/textures/TextureGCSystem.js\"), TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ \"./node_modules/@pixi/core/lib/textures/TextureSystem.js\"), TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ \"./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js\"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ \"./node_modules/@pixi/core/lib/view/ViewSystem.js\");\nexports.BackgroundSystem = BackgroundSystem.BackgroundSystem;\nexports.BatchSystem = BatchSystem.BatchSystem;\nexports.ContextSystem = ContextSystem.ContextSystem;\nexports.FilterSystem = FilterSystem.FilterSystem;\nexports.FramebufferSystem = FramebufferSystem.FramebufferSystem;\nexports.GeometrySystem = GeometrySystem.GeometrySystem;\nexports.MaskSystem = MaskSystem.MaskSystem;\nexports.ScissorSystem = ScissorSystem.ScissorSystem;\nexports.StencilSystem = StencilSystem.StencilSystem;\nexports.PluginSystem = PluginSystem.PluginSystem;\nexports.ProjectionSystem = ProjectionSystem.ProjectionSystem;\nexports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;\nexports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;\nexports.ShaderSystem = ShaderSystem.ShaderSystem;\nexports.StartupSystem = StartupSystem.StartupSystem;\nexports.StateSystem = StateSystem.StateSystem;\nexports.SystemManager = SystemManager.SystemManager;\nexports.TextureGCSystem = TextureGCSystem.TextureGCSystem;\nexports.TextureSystem = TextureSystem.TextureSystem;\nexports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;\nexports.ViewSystem = ViewSystem.ViewSystem;\n//# sourceMappingURL=systems.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/systems.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/BaseTexture.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/BaseTexture.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), autoDetectResource = __webpack_require__(/*! ./resources/autoDetectResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js\"), BufferResource = __webpack_require__(/*! ./resources/BufferResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BufferResource.js\"), Resource = __webpack_require__(/*! ./resources/Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\");\nconst defaultBufferOptions = {\n  scaleMode: constants.SCALE_MODES.NEAREST,\n  alphaMode: constants.ALPHA_MODES.NPM\n}, _BaseTexture = class _BaseTexture2 extends utils.EventEmitter {\n  /**\n   * @param {PIXI.Resource|PIXI.ImageSource|string} [resource=null] -\n   *        The current resource to use, for things that aren't Resource objects, will be converted\n   *        into a Resource.\n   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.\n   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture\n   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture\n   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures\n   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest\n   * @param {PIXI.FORMATS} [options.format] - GL format type\n   * @param {PIXI.TYPES} [options.type] - GL data type\n   * @param {PIXI.TARGETS} [options.target] - GL texture target\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha\n   * @param {number} [options.width=0] - Width of the texture\n   * @param {number} [options.height=0] - Height of the texture\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture\n   * @param {object} [options.resourceOptions] - Optional resource options,\n   *        see {@link PIXI.autoDetectResource autoDetectResource}\n   */\n  constructor(resource = null, options = null) {\n    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);\n    const {\n      alphaMode,\n      mipmap,\n      anisotropicLevel,\n      scaleMode,\n      width,\n      height,\n      wrapMode,\n      format,\n      type,\n      target,\n      resolution,\n      resourceOptions\n    } = options;\n    resource && !(resource instanceof Resource.Resource) && (resource = autoDetectResource.autoDetectResource(resource, resourceOptions), resource.internal = !0), this.resolution = resolution || settings.settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format, this.type = type, this.target = target, this.alphaMode = alphaMode, this.uid = utils.uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);\n  }\n  /**\n   * Pixel width of the source of this texture\n   * @readonly\n   */\n  get realWidth() {\n    return Math.round(this.width * this.resolution);\n  }\n  /**\n   * Pixel height of the source of this texture\n   * @readonly\n   */\n  get realHeight() {\n    return Math.round(this.height * this.resolution);\n  }\n  /**\n   * Mipmap mode of the texture, affects downscaled images\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  get mipmap() {\n    return this._mipmap;\n  }\n  set mipmap(value) {\n    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);\n  }\n  /**\n   * The scale mode to apply when scaling this texture\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleMode(value) {\n    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * How the texture wraps\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  get wrapMode() {\n    return this._wrapMode;\n  }\n  set wrapMode(value) {\n    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * Changes style options of BaseTexture\n   * @param scaleMode - Pixi scalemode\n   * @param mipmap - enable mipmaps\n   * @returns - this\n   */\n  setStyle(scaleMode, mipmap) {\n    let dirty;\n    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this;\n  }\n  /**\n   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.\n   * @param desiredWidth - Desired visual width\n   * @param desiredHeight - Desired visual height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setSize(desiredWidth, desiredHeight, resolution) {\n    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  }\n  /**\n   * Sets real size of baseTexture, preserves current resolution.\n   * @param realWidth - Full rendered width\n   * @param realHeight - Full rendered height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setRealSize(realWidth, realHeight, resolution) {\n    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);\n  }\n  /**\n   * Changes resolution\n   * @param resolution - res\n   * @returns - this\n   */\n  setResolution(resolution) {\n    const oldResolution = this.resolution;\n    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit(\"update\", this)), this._refreshPOT(), this);\n  }\n  /**\n   * Sets the resource if it wasn't set. Throws error if resource already present\n   * @param resource - that is managing this BaseTexture\n   * @returns - this\n   */\n  setResource(resource) {\n    if (this.resource === resource)\n      return this;\n    if (this.resource)\n      throw new Error(\"Resource can be set only once\");\n    return resource.bind(this), this.resource = resource, this;\n  }\n  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */\n  update() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n  }\n  /**\n   * Handle errors with resources.\n   * @private\n   * @param event - Error event emitted.\n   */\n  onError(event) {\n    this.emit(\"error\", this, event);\n  }\n  /**\n   * Destroys this base texture.\n   * The method stops if resource doesn't want this texture to be destroyed.\n   * Removes texture from all caches.\n   * @fires PIXI.BaseTexture#destroyed\n   */\n  destroy() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete utils.BaseTextureCache[this.cacheId], delete utils.TextureCache[this.cacheId], this.cacheId = null), this.valid = !1, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit(\"destroyed\", this), this.removeAllListeners();\n  }\n  /**\n   * Frees the texture from WebGL memory without destroying this texture object.\n   * This means you can still use the texture later which will upload it to GPU\n   * memory again.\n   * @fires PIXI.BaseTexture#dispose\n   */\n  dispose() {\n    this.emit(\"dispose\", this);\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this;\n  }\n  /**\n   * Helper function that creates a base texture based on the source you provide.\n   * The source can be - image url, image element, canvas element. If the\n   * source is an image url or an image element and not in the base texture\n   * cache, it will be created and loaded.\n   * @static\n   * @param {PIXI.ImageSource|string|string[]} source - The\n   *        source to create base texture from.\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.BaseTexture} The new base texture.\n   */\n  static from(source, options, strict = settings.settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == \"string\";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source._pixiId = `${prefix}_${utils.uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let baseTexture = utils.BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture)\n      throw new Error(`The cacheId \"${cacheId}\" does not exist in BaseTextureCache.`);\n    return baseTexture || (baseTexture = new _BaseTexture2(source, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   *        Default properties are different from the constructor's defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    const resource = new BufferResource.BufferResource(buffer, { width, height, ...options?.resourceOptions });\n    let format, type;\n    return buffer instanceof Float32Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.FLOAT) : buffer instanceof Int32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.INT) : buffer instanceof Uint32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.SHORT) : buffer instanceof Uint16Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.BYTE) : (format = constants.FORMATS.RGBA, type = constants.TYPES.UNSIGNED_BYTE), resource.internal = !0, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type, format }, options));\n  }\n  /**\n   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n   * @param {string} id - The id that the BaseTexture will be stored against.\n   */\n  static addToCache(baseTexture, id) {\n    id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), utils.BaseTextureCache[id] && utils.BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), utils.BaseTextureCache[id] = baseTexture);\n  }\n  /**\n   * Remove a BaseTexture from the global BaseTextureCache.\n   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.\n   */\n  static removeFromCache(baseTexture) {\n    if (typeof baseTexture == \"string\") {\n      const baseTextureFromCache = utils.BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete utils.BaseTextureCache[baseTexture], baseTextureFromCache;\n      }\n    } else if (baseTexture?.textureCacheIds) {\n      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n        delete utils.BaseTextureCache[baseTexture.textureCacheIds[i]];\n      return baseTexture.textureCacheIds.length = 0, baseTexture;\n    }\n    return null;\n  }\n};\n_BaseTexture.defaultOptions = {\n  /**\n   * If mipmapping is enabled for texture.\n   * @type {PIXI.MIPMAP_MODES}\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  mipmap: constants.MIPMAP_MODES.POW2,\n  /** Anisotropic filtering level of texture */\n  anisotropicLevel: 0,\n  /**\n   * Default scale mode, linear, nearest.\n   * @type {PIXI.SCALE_MODES}\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  scaleMode: constants.SCALE_MODES.LINEAR,\n  /**\n   * Wrap mode for textures.\n   * @type {PIXI.WRAP_MODES}\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  wrapMode: constants.WRAP_MODES.CLAMP,\n  /**\n   * Pre multiply the image alpha\n   * @type {PIXI.ALPHA_MODES}\n   * @default PIXI.ALPHA_MODES.UNPACK\n   */\n  alphaMode: constants.ALPHA_MODES.UNPACK,\n  /**\n   * GL texture target\n   * @type {PIXI.TARGETS}\n   * @default PIXI.TARGETS.TEXTURE_2D\n   */\n  target: constants.TARGETS.TEXTURE_2D,\n  /**\n   * GL format type\n   * @type {PIXI.FORMATS}\n   * @default PIXI.FORMATS.RGBA\n   */\n  format: constants.FORMATS.RGBA,\n  /**\n   * GL data type\n   * @type {PIXI.TYPES}\n   * @default PIXI.TYPES.UNSIGNED_BYTE\n   */\n  type: constants.TYPES.UNSIGNED_BYTE\n}, /** Global number of the texture batch, used by multi-texture renderers. */\n_BaseTexture._globalBatch = 0;\nlet BaseTexture = _BaseTexture;\nexports.BaseTexture = BaseTexture;\n//# sourceMappingURL=BaseTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/BaseTexture.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/GLTexture.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/GLTexture.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nclass GLTexture {\n  constructor(texture) {\n    this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = constants.TYPES.UNSIGNED_BYTE, this.internalFormat = constants.FORMATS.RGBA, this.samplerType = 0;\n  }\n}\nexports.GLTexture = GLTexture;\n//# sourceMappingURL=GLTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/GLTexture.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/Texture.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/Texture.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), ImageResource = __webpack_require__(/*! ./resources/ImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ImageResource.js\"), TextureUvs = __webpack_require__(/*! ./TextureUvs.js */ \"./node_modules/@pixi/core/lib/textures/TextureUvs.js\");\nconst DEFAULT_UVS = new TextureUvs.TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function() {\n  }, tex.on = function() {\n  }, tex.once = function() {\n  }, tex.emit = function() {\n  };\n}\nclass Texture extends utils.EventEmitter {\n  /**\n   * @param baseTexture - The base texture source to create the texture from\n   * @param frame - The rectangle frame of the texture to show\n   * @param orig - The area of original texture\n   * @param trim - Trimmed rectangle of original texture\n   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}\n   * @param anchor - Default anchor point used for sprite placement / rotation\n   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}\n   */\n  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {\n    if (super(), this.noFrame = !1, frame || (this.noFrame = !0, frame = new math.Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.destroyed = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === !0)\n      this._rotate = 2;\n    else if (this._rotate % 2 !== 0)\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once(\"loaded\", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on(\"update\", this.onBaseTextureUpdated, this);\n  }\n  /**\n   * Updates this texture on the gpu.\n   *\n   * Calls the TextureResource update.\n   *\n   * If you adjusted `frame` manually, please call `updateUvs()` instead.\n   */\n  update() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }\n  /**\n   * Called when the base texture is updated\n   * @protected\n   * @param baseTexture - The base texture.\n   */\n  onBaseTextureUpdated(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Destroys this texture\n   * @param [destroyBase=false] - Whether to destroy the base texture as well\n   * @fires PIXI.Texture#destroyed\n   */\n  destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        const { resource } = this.baseTexture;\n        resource?.url && utils.TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit(\"destroyed\", this), this.removeAllListeners();\n  }\n  /**\n   * Creates a new texture object that acts the same as this one.\n   * @returns - The new texture\n   */\n  clone() {\n    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture(\n      this.baseTexture,\n      !this.noFrame && clonedFrame,\n      clonedOrig,\n      this.trim?.clone(),\n      this.rotate,\n      this.defaultAnchor,\n      this.defaultBorders\n    );\n    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;\n  }\n  /**\n   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n   * Call it after changing the frame\n   */\n  updateUvs() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs.TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }\n  /**\n   * Helper function that creates a new Texture based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -\n   *        Source or array of sources to create texture from\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.Texture} The newly created texture\n   */\n  static from(source, options = {}, strict = settings.settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == \"string\";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else if (source instanceof BaseTexture.BaseTexture) {\n      if (!source.cacheId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source.cacheId = `${prefix}-${utils.uid()}`, BaseTexture.BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || \"pixiid\";\n        source._pixiId = `${prefix}_${utils.uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let texture = utils.TextureCache[cacheId];\n    if (isFrame && strict && !texture)\n      throw new Error(`The cacheId \"${cacheId}\" does not exist in TextureCache.`);\n    return !texture && !(source instanceof BaseTexture.BaseTexture) ? (options.resolution || (options.resolution = utils.getResolutionOfUrl(source)), texture = new Texture(new BaseTexture.BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)) : !texture && source instanceof BaseTexture.BaseTexture && (texture = new Texture(source), Texture.addToCache(texture, cacheId)), texture;\n  }\n  /**\n   * Useful for loading textures via URLs. Use instead of `Texture.from` because\n   * it does a better job of handling failed URLs more effectively. This also ignores\n   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.\n   * @param url - The remote URL or array of URLs to load.\n   * @param options - Optional options to include\n   * @returns - A Promise that resolves to a Texture.\n   */\n  static fromURL(url, options) {\n    const resourceOptions = Object.assign({ autoLoad: !1 }, options?.resourceOptions), texture = Texture.from(url, Object.assign({ resourceOptions }, options), !1), resource = texture.baseTexture.resource;\n    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n   *        Default properties are different from the constructor's defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    return new Texture(BaseTexture.BaseTexture.fromBuffer(buffer, width, height, options));\n  }\n  /**\n   * Create a texture from a source and add to the cache.\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.\n   * @param imageUrl - File name of texture, for cache and resolving resolution.\n   * @param name - Human readable name for the texture cache. If no name is\n   *        specified, only `imageUrl` will be used as the cache ID.\n   * @param options\n   * @returns - Output texture\n   */\n  static fromLoader(source, imageUrl, name, options) {\n    const baseTexture = new BaseTexture.BaseTexture(source, Object.assign({\n      scaleMode: BaseTexture.BaseTexture.defaultOptions.scaleMode,\n      resolution: utils.getResolutionOfUrl(imageUrl)\n    }, options)), { resource } = baseTexture;\n    resource instanceof ImageResource.ImageResource && (resource.url = imageUrl);\n    const texture = new Texture(baseTexture);\n    return name || (name = imageUrl), BaseTexture.BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve) => {\n      texture.baseTexture.once(\"loaded\", () => resolve(texture));\n    });\n  }\n  /**\n   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n   * @param texture - The Texture to add to the cache.\n   * @param id - The id that the Texture will be stored against.\n   */\n  static addToCache(texture, id) {\n    id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), utils.TextureCache[id] && utils.TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), utils.TextureCache[id] = texture);\n  }\n  /**\n   * Remove a Texture from the global TextureCache.\n   * @param texture - id of a Texture to be removed, or a Texture instance itself\n   * @returns - The Texture that was removed\n   */\n  static removeFromCache(texture) {\n    if (typeof texture == \"string\") {\n      const textureFromCache = utils.TextureCache[texture];\n      if (textureFromCache) {\n        const index = textureFromCache.textureCacheIds.indexOf(texture);\n        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete utils.TextureCache[texture], textureFromCache;\n      }\n    } else if (texture?.textureCacheIds) {\n      for (let i = 0; i < texture.textureCacheIds.length; ++i)\n        utils.TextureCache[texture.textureCacheIds[i]] === texture && delete utils.TextureCache[texture.textureCacheIds[i]];\n      return texture.textureCacheIds.length = 0, texture;\n    }\n    return null;\n  }\n  /**\n   * Returns resolution of baseTexture\n   * @readonly\n   */\n  get resolution() {\n    return this.baseTexture.resolution;\n  }\n  /**\n   * The frame specifies the region of the base texture that this texture uses.\n   * Please call `updateUvs()` after you change coordinates of `frame` manually.\n   */\n  get frame() {\n    return this._frame;\n  }\n  set frame(frame) {\n    this._frame = frame, this.noFrame = !1;\n    const { x, y, width, height } = frame, xNotFit = x + width > this.baseTexture.width, yNotFit = y + height > this.baseTexture.height;\n    if (xNotFit || yNotFit) {\n      const relationship = xNotFit && yNotFit ? \"and\" : \"or\", errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`, errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);\n    }\n    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();\n  }\n  /**\n   * Indicates whether the texture is rotated inside the atlas\n   * set to 2 to compensate for texture packer rotation\n   * set to 6 to compensate for spine packer rotation\n   * can be used to rotate or mirror sprites\n   * See {@link PIXI.groupD8} for explanation\n   */\n  get rotate() {\n    return this._rotate;\n  }\n  set rotate(rotate) {\n    this._rotate = rotate, this.valid && this.updateUvs();\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this.baseTexture;\n  }\n  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */\n  static get EMPTY() {\n    return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture.BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;\n  }\n  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */\n  static get WHITE() {\n    if (!Texture._WHITE) {\n      const canvas = settings.settings.ADAPTER.createCanvas(16, 16), context = canvas.getContext(\"2d\");\n      canvas.width = 16, canvas.height = 16, context.fillStyle = \"white\", context.fillRect(0, 0, 16, 16), Texture._WHITE = new Texture(BaseTexture.BaseTexture.from(canvas)), removeAllHandlers(Texture._WHITE), removeAllHandlers(Texture._WHITE.baseTexture);\n    }\n    return Texture._WHITE;\n  }\n}\nexports.Texture = Texture;\n//# sourceMappingURL=Texture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/Texture.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureGCSystem.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nconst _TextureGCSystem = class _TextureGCSystem2 {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem2.defaultMaxIdle, this.checkCountMax = _TextureGCSystem2.defaultCheckCountMax, this.mode = _TextureGCSystem2.defaultMode;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== constants.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const tm = this.renderer.texture, managedTextures = tm.managedTextures;\n    let wasRemoved = !1;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, !0), managedTextures[i] = null, wasRemoved = !0);\n    }\n    if (wasRemoved) {\n      let j = 0;\n      for (let i = 0; i < managedTextures.length; i++)\n        managedTextures[i] !== null && (managedTextures[j++] = managedTextures[i]);\n      managedTextures.length = j;\n    }\n  }\n  /**\n   * Removes all the textures within the specified displayObject and its children from the GPU.\n   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.\n   */\n  unload(displayObject) {\n    const tm = this.renderer.texture, texture = displayObject._texture;\n    texture && !texture.framebuffer && tm.destroyTexture(texture);\n    for (let i = displayObject.children.length - 1; i >= 0; i--)\n      this.unload(displayObject.children[i]);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n};\n_TextureGCSystem.defaultMode = constants.GC_MODES.AUTO, /**\n* Default maximum idle frames before a texture is destroyed by garbage collection.\n* @static\n* @default 3600\n* @see PIXI.TextureGCSystem#maxIdle\n*/\n_TextureGCSystem.defaultMaxIdle = 60 * 60, /**\n* Default frames between two garbage collections.\n* @static\n* @default 600\n* @see PIXI.TextureGCSystem#checkCountMax\n*/\n_TextureGCSystem.defaultCheckCountMax = 60 * 10, /** @ignore */\n_TextureGCSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"textureGC\"\n};\nlet TextureGCSystem = _TextureGCSystem;\nextensions.extensions.add(TextureGCSystem);\nexports.TextureGCSystem = TextureGCSystem;\n//# sourceMappingURL=TextureGCSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/TextureGCSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureMatrix.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureMatrix.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\");\nconst tempMat = new math.Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this._texture = texture, this.mapCoord = new math.Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > \"u\" ? 0.5 : clampMargin, this.isSimple = !1;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture = value, this._textureID = -1;\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    out === void 0 && (out = uvs);\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i], y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx, out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed.\n   * @param [forceUpdate=false] - if true, matrices will be updated any case\n   * @returns - Whether or not it was updated\n   */\n  update(forceUpdate) {\n    const tex = this._texture;\n    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)\n      return !1;\n    this._textureID = tex._updateID, this._updateID++;\n    const uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig, trim = tex.trim;\n    trim && (tempMat.set(\n      orig.width / trim.width,\n      0,\n      0,\n      orig.height / trim.height,\n      -trim.x / trim.width,\n      -trim.y / trim.height\n    ), this.mapCoord.append(tempMat));\n    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;\n    return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, !0;\n  }\n}\nexports.TextureMatrix = TextureMatrix;\n//# sourceMappingURL=TextureMatrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/TextureMatrix.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureSystem.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureSystem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), GLTexture = __webpack_require__(/*! ./GLTexture.js */ \"./node_modules/@pixi/core/lib/textures/GLTexture.js\"), mapInternalFormatToSamplerType = __webpack_require__(/*! ./utils/mapInternalFormatToSamplerType.js */ \"./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js\"), mapTypeAndFormatToInternalFormat = __webpack_require__(/*! ./utils/mapTypeAndFormatToInternalFormat.js */ \"./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js\");\nclass TextureSystem {\n  /**\n   * @param renderer - The renderer this system works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture.BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType.mapInternalFormatToSamplerType(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++)\n      this.boundTextures[i] = null;\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture.GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++)\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++)\n      this.bind(null, i);\n  }\n  /**\n   * Bind a texture to a specific location\n   *\n   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n   * @param texture - Texture to bind\n   * @param [location=0] - Location to bind at\n   */\n  bind(texture, location = 0) {\n    const { gl } = this;\n    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;\n    } else\n      this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;\n  }\n  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n  reset() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++)\n      this.boundTextures[i] = this.unknownTexture;\n  }\n  /**\n   * Unbind a texture.\n   * @param texture - Texture to bind\n   */\n  unbind(texture) {\n    const { gl, boundTextures } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (let i = 0; i < boundTextures.length; i++)\n        boundTextures[i] === this.unknownTexture && this.bind(null, i);\n    }\n    for (let i = 0; i < boundTextures.length; i++)\n      boundTextures[i] === texture && (this.currentLocation !== i && (gl.activeTexture(gl.TEXTURE0 + i), this.currentLocation = i), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i] = null);\n  }\n  /**\n   * Ensures that current boundTextures all have FLOAT sampler type,\n   * see {@link PIXI.SAMPLER_TYPES} for explanation.\n   * @param maxTextures - number of locations to check\n   */\n  ensureSamplerType(maxTextures) {\n    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n    if (hasIntegerTextures)\n      for (let i = maxTextures - 1; i >= 0; --i) {\n        const tex = boundTextures[i];\n        tex && tex._glTextures[CONTEXT_UID].samplerType !== constants.SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);\n      }\n  }\n  /**\n   * Initialize a texture\n   * @private\n   * @param texture - Texture to initialize\n   */\n  initTexture(texture) {\n    const glTexture = new GLTexture.GLTexture(this.gl.createTexture());\n    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on(\"dispose\", this.destroyTexture, this), glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? constants.SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === constants.TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;\n  }\n  /**\n   * Update a texture\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to initialize\n   */\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture)\n      return;\n    const renderer = this.renderer;\n    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))\n      glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);\n    else {\n      const width = texture.realWidth, height = texture.realHeight, gl = renderer.gl;\n      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(\n        texture.target,\n        0,\n        glTexture.internalFormat,\n        width,\n        height,\n        0,\n        texture.format,\n        glTexture.type,\n        null\n      ));\n    }\n    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;\n  }\n  /**\n   * Deletes the texture from WebGL\n   * @private\n   * @param texture - the texture to destroy\n   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n   */\n  destroyTexture(texture, skipRemove) {\n    const { gl } = this;\n    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off(\"dispose\", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {\n      const i = this.managedTextures.indexOf(texture);\n      i !== -1 && utils.removeItems(this.managedTextures, i, 1);\n    }\n  }\n  /**\n   * Update texture style such as mipmap flag\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to update\n   */\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    glTexture && ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = !1 : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = constants.WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);\n  }\n  /**\n   * Set style for texture\n   * @private\n   * @param texture - Texture to update\n   * @param glTexture\n   */\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.extensions.add(TextureSystem);\nexports.TextureSystem = TextureSystem;\n//# sourceMappingURL=TextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/TextureSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureUvs.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureUvs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\");\nclass TextureUvs {\n  constructor() {\n    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n  }\n  /**\n   * Sets the texture Uvs based on the given frame information.\n   * @protected\n   * @param frame - The frame of the texture\n   * @param baseFrame - The base frame of the texture\n   * @param rotate - Rotation of frame, see {@link PIXI.groupD8}\n   */\n  set(frame, baseFrame, rotate) {\n    const tw = baseFrame.width, th = baseFrame.height;\n    if (rotate) {\n      const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th, cX = frame.x / tw + w2, cY = frame.y / th + h2;\n      rotate = math.groupD8.add(rotate, math.groupD8.NW), this.x0 = cX + w2 * math.groupD8.uX(rotate), this.y0 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x1 = cX + w2 * math.groupD8.uX(rotate), this.y1 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x2 = cX + w2 * math.groupD8.uX(rotate), this.y2 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x3 = cX + w2 * math.groupD8.uX(rotate), this.y3 = cY + h2 * math.groupD8.uY(rotate);\n    } else\n      this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th;\n    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n  }\n}\nTextureUvs.prototype.toString = function() {\n  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;\n};\nexports.TextureUvs = TextureUvs;\n//# sourceMappingURL=TextureUvs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/TextureUvs.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar BaseTexture = __webpack_require__(/*! ../BaseTexture.js */ \"./node_modules/@pixi/core/lib/textures/BaseTexture.js\"), autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js\"), Resource = __webpack_require__(/*! ./Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\");\nclass AbstractMultiResource extends Resource.Resource {\n  /**\n   * @param length\n   * @param options - Options to for Resource constructor\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(length, options) {\n    const { width, height } = options || {};\n    super(width, height), this.items = [], this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture.BaseTexture();\n      this.items.push(partTexture), this.itemDirtyIds.push(-2);\n    }\n    this.length = length, this._load = null, this.baseTexture = null;\n  }\n  /**\n   * Used from ArrayResource and CubeResource constructors.\n   * @param resources - Can be resources, image elements, canvas, etc. ,\n   *  length should be same as constructor length\n   * @param options - Detect options for resources\n   */\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++)\n      resources[i] && (resources[i].castToBaseTexture ? this.addBaseTextureAt(resources[i].castToBaseTexture(), i) : resources[i] instanceof Resource.Resource ? this.addResourceAt(resources[i], i) : this.addResourceAt(autoDetectResource.autoDetectResource(resources[i], options), i));\n  }\n  /** Destroy this BaseImageResource. */\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++)\n      this.items[i].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }\n  /**\n   * Set a resource by ID\n   * @param resource\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addResourceAt(resource, index) {\n    if (!this.items[index])\n      throw new Error(`Index ${index} is out of bounds`);\n    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;\n  }\n  /**\n   * Set the parent base texture.\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    if (this.baseTexture !== null)\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++)\n      this.items[i].parentTextureArray = baseTexture, this.items[i].on(\"update\", baseTexture.update, baseTexture);\n  }\n  /**\n   * Unset the parent base texture.\n   * @param baseTexture\n   */\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++)\n      this.items[i].parentTextureArray = null, this.items[i].off(\"update\", baseTexture.update, baseTexture);\n  }\n  /**\n   * Load all the resources simultaneously\n   * @returns - When load is resolved\n   */\n  load() {\n    if (this._load)\n      return this._load;\n    const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());\n    return this._load = Promise.all(promises).then(\n      () => {\n        const { realWidth, realHeight } = this.items[0];\n        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);\n      }\n    ), this._load;\n  }\n}\nexports.AbstractMultiResource = AbstractMultiResource;\n//# sourceMappingURL=AbstractMultiResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js\");\nclass ArrayResource extends AbstractMultiResource.AbstractMultiResource {\n  /**\n   * @param source - Number of items in array or the collection\n   *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n   * @param options - Options to apply to {@link PIXI.autoDetectResource}\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(source, options) {\n    const { width, height } = options || {};\n    let urls, length;\n    Array.isArray(source) ? (urls = source, length = source.length) : length = source, super(length, { width, height }), urls && this.initFromArray(urls, options);\n  }\n  /**\n   * Set a baseTexture by ID,\n   * ArrayResource just takes resource from it, nothing more\n   * @param baseTexture\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource)\n      this.addResourceAt(baseTexture.resource, index);\n    else\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    return this;\n  }\n  /**\n   * Add binding\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;\n  }\n  /**\n   * Upload the resources to the GPU.\n   * @param renderer\n   * @param texture\n   * @param glTexture\n   * @returns - whether texture was uploaded\n   */\n  upload(renderer, texture, glTexture) {\n    const { length, itemDirtyIds, items } = this, { gl } = renderer;\n    glTexture.dirtyId < 0 && gl.texImage3D(\n      gl.TEXTURE_2D_ARRAY,\n      0,\n      glTexture.internalFormat,\n      this._width,\n      this._height,\n      length,\n      0,\n      texture.format,\n      glTexture.type,\n      null\n    );\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && gl.texSubImage3D(\n        gl.TEXTURE_2D_ARRAY,\n        0,\n        0,\n        // xoffset\n        0,\n        // yoffset\n        i,\n        // zoffset\n        item.resource.width,\n        item.resource.height,\n        1,\n        texture.format,\n        glTexture.type,\n        item.resource.source\n      ));\n    }\n    return !0;\n  }\n}\nexports.ArrayResource = ArrayResource;\n//# sourceMappingURL=ArrayResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), Resource = __webpack_require__(/*! ./Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\");\nclass BaseImageResource extends Resource.Resource {\n  /**\n   * @param {PIXI.ImageSourcee} source\n   */\n  constructor(source) {\n    const sourceAny = source, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.displayWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.displayHeight || sourceAny.height;\n    super(width, height), this.source = source, this.noSubImage = !1;\n  }\n  /**\n   * Set cross origin based detecting the url and the crossorigin\n   * @param element - Element to apply crossOrigin\n   * @param url - URL to check\n   * @param crossorigin - Cross origin value to use\n   */\n  static crossOrigin(element, url, crossorigin) {\n    crossorigin === void 0 && !url.startsWith(\"data:\") ? element.crossOrigin = utils.determineCrossOrigin(url) : crossorigin !== !1 && (element.crossOrigin = typeof crossorigin == \"string\" ? crossorigin : \"anonymous\");\n  }\n  /**\n   * Upload the texture to the GPU.\n   * @param renderer - Upload to the renderer\n   * @param baseTexture - Reference to parent texture\n   * @param glTexture\n   * @param {PIXI.ImageSourcee} [source] - (optional)\n   * @returns - true is success\n   */\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;\n    if (source = source || this.source, typeof HTMLImageElement < \"u\" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0)\n        return !1;\n    } else if (typeof HTMLVideoElement < \"u\" && source instanceof HTMLVideoElement && source.readyState <= 1)\n      return !1;\n    return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source)), !0;\n  }\n  /**\n   * Checks if source width/height was changed, resize can cause extra baseTexture update.\n   * Triggers one update in any case.\n   */\n  update() {\n    if (this.destroyed)\n      return;\n    const source = this.source, width = source.naturalWidth || source.videoWidth || source.width, height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height), super.update();\n  }\n  /** Destroy this {@link PIXI.BaseImageResource} */\n  dispose() {\n    this.source = null;\n  }\n}\nexports.BaseImageResource = BaseImageResource;\n//# sourceMappingURL=BaseImageResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BufferResource.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), Resource = __webpack_require__(/*! ./Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\");\nclass BufferResource extends Resource.Resource {\n  /**\n   * @param source - Source buffer\n   * @param options - Options\n   * @param {number} options.width - Width of the texture\n   * @param {number} options.height - Height of the texture\n   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.\n   */\n  constructor(source, options) {\n    const { width, height } = options || {};\n    if (!width || !height)\n      throw new Error(\"BufferResource width or height invalid\");\n    super(width, height), this.data = source, this.unpackAlignment = options.unpackAlignment ?? 4;\n  }\n  /**\n   * Upload the texture to the GPU.\n   * @param renderer - Upload to the renderer\n   * @param baseTexture - Reference to parent texture\n   * @param glTexture - glTexture\n   * @returns - true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);\n    const width = baseTexture.realWidth, height = baseTexture.realHeight;\n    return glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(\n      baseTexture.target,\n      0,\n      0,\n      0,\n      width,\n      height,\n      baseTexture.format,\n      glTexture.type,\n      this.data\n    ) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(\n      baseTexture.target,\n      0,\n      glTexture.internalFormat,\n      width,\n      height,\n      0,\n      baseTexture.format,\n      glTexture.type,\n      this.data\n    )), !0;\n  }\n  /** Destroy and don't use after this. */\n  dispose() {\n    this.data = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if buffer source\n   */\n  static test(source) {\n    return source === null || source instanceof Int8Array || source instanceof Uint8Array || source instanceof Uint8ClampedArray || source instanceof Int16Array || source instanceof Uint16Array || source instanceof Int32Array || source instanceof Uint32Array || source instanceof Float32Array;\n  }\n}\nexports.BufferResource = BufferResource;\n//# sourceMappingURL=BufferResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/BufferResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nclass CanvasResource extends BaseImageResource.BaseImageResource {\n  /**\n   * @param source - Canvas element to use\n   */\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(source) {\n    super(source);\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas\n   */\n  static test(source) {\n    const { OffscreenCanvas } = globalThis;\n    return OffscreenCanvas && source instanceof OffscreenCanvas ? !0 : globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;\n  }\n}\nexports.CanvasResource = CanvasResource;\n//# sourceMappingURL=CanvasResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CubeResource.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js\");\nconst _CubeResource = class _CubeResource2 extends AbstractMultiResource.AbstractMultiResource {\n  /**\n   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n   *        to use as the sides of the cube.\n   * @param options - ImageResource options\n   * @param {number} [options.width] - Width of resource\n   * @param {number} [options.height] - Height of resource\n   * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n   *   whether to copy them or use\n   */\n  constructor(source, options) {\n    const { width, height, autoLoad, linkBaseTexture } = options || {};\n    if (source && source.length !== _CubeResource2.SIDES)\n      throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    super(6, { width, height });\n    for (let i = 0; i < _CubeResource2.SIDES; i++)\n      this.items[i].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    this.linkBaseTexture = linkBaseTexture !== !1, source && this.initFromArray(source, options), autoLoad !== !1 && this.load();\n  }\n  /**\n   * Add binding.\n   * @param baseTexture - parent base texture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])\n      throw new Error(`Index ${index} is out of bounds`);\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)\n      if (baseTexture.resource)\n        this.addResourceAt(baseTexture.resource, index);\n      else\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n    else\n      baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;\n    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;\n  }\n  /**\n   * Upload the resource\n   * @param renderer\n   * @param _baseTexture\n   * @param glTexture\n   * @returns {boolean} true is success\n   */\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource2.SIDES; i++) {\n      const side = this.items[i];\n      (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i] = side.dirtyId) : dirty[i] < -1 && (renderer.gl.texImage2D(\n        side.target,\n        0,\n        glTexture.internalFormat,\n        _baseTexture.realWidth,\n        _baseTexture.realHeight,\n        0,\n        _baseTexture.format,\n        glTexture.type,\n        null\n      ), dirty[i] = -1));\n    }\n    return !0;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is an array of 6 elements\n   */\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource2.SIDES;\n  }\n};\n_CubeResource.SIDES = 6;\nlet CubeResource = _CubeResource;\nexports.CubeResource = CubeResource;\n//# sourceMappingURL=CubeResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/CubeResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nclass ImageBitmapResource extends BaseImageResource.BaseImageResource {\n  /**\n   * @param source - ImageBitmap or URL to use.\n   * @param options - Options to use.\n   */\n  constructor(source, options) {\n    options = options || {};\n    let baseSource, url, ownsImageBitmap;\n    typeof source == \"string\" ? (baseSource = ImageBitmapResource.EMPTY, url = source, ownsImageBitmap = !0) : (baseSource = source, url = null, ownsImageBitmap = !1), super(baseSource), this.url = url, this.crossOrigin = options.crossOrigin ?? !0, this.alphaMode = typeof options.alphaMode == \"number\" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  load() {\n    return this._load ? this._load : (this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings.settings.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        if (this.destroyed)\n          return;\n        const imageBlob = await response.blob();\n        if (this.destroyed)\n          return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n        });\n        if (this.destroyed) {\n          imageBitmap.close();\n          return;\n        }\n        this.source = imageBitmap, this.update(), resolve(this);\n      } catch (e) {\n        if (this.destroyed)\n          return;\n        reject(e), this.onError.emit(e);\n      }\n    }), this._load);\n  }\n  /**\n   * Upload the image bitmap resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    return this.source instanceof ImageBitmap ? (typeof this.alphaMode == \"number\" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), !1);\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap\n   */\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && (typeof source == \"string\" || source instanceof ImageBitmap);\n  }\n  /**\n   * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.\n   * Only for internal usage.\n   * @returns The cached placeholder canvas.\n   */\n  static get EMPTY() {\n    return ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.settings.ADAPTER.createCanvas(0, 0), ImageBitmapResource._EMPTY;\n  }\n}\nexports.ImageBitmapResource = ImageBitmapResource;\n//# sourceMappingURL=ImageBitmapResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nclass ImageResource extends BaseImageResource.BaseImageResource {\n  /**\n   * @param source - image source or URL\n   * @param options\n   * @param {boolean} [options.autoLoad=true] - start loading process\n   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n   *        a bitmap before upload\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n   */\n  constructor(source, options) {\n    if (options = options || {}, typeof source == \"string\") {\n      const imageElement = new Image();\n      BaseImageResource.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;\n    }\n    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (options.createBitmap ?? settings.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == \"number\" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Returns a promise when image will be loaded and processed.\n   * @param createBitmap - whether process image into bitmap\n   */\n  load(createBitmap) {\n    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));\n      };\n      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = (event) => {\n        reject(event), this.onError.emit(event);\n      });\n    }), this._load);\n  }\n  /**\n   * Called when we need to convert image into BitmapImage.\n   * Can be called multiple times, real promise is cached inside.\n   * @returns - Cached promise to fill that bitmap\n   */\n  process() {\n    const source = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    const createImageBitmap = globalThis.createImageBitmap, cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    return this._process = fetch(\n      source.src,\n      {\n        mode: cors ? \"cors\" : \"no-cors\"\n      }\n    ).then((r) => r.blob()).then((blob) => createImageBitmap(\n      blob,\n      0,\n      0,\n      source.width,\n      source.height,\n      {\n        premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n      }\n    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;\n  }\n  /**\n   * Upload the image resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode == \"number\" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)\n      return super.upload(renderer, baseTexture, glTexture);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {\n      let flag = !0;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = !1;\n          break;\n        }\n      }\n      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n   */\n  static test(source) {\n    return typeof HTMLImageElement < \"u\" && (typeof source == \"string\" || source instanceof HTMLImageElement);\n  }\n}\nexports.ImageResource = ImageResource;\n//# sourceMappingURL=ImageResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/ImageResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/Resource.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/Resource.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\");\nclass Resource {\n  /**\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   */\n  constructor(width = 0, height = 0) {\n    this._width = width, this._height = height, this.destroyed = !1, this.internal = !1, this.onResize = new runner.Runner(\"setRealSize\"), this.onUpdate = new runner.Runner(\"update\"), this.onError = new runner.Runner(\"onError\");\n  }\n  /**\n   * Bind to a parent BaseTexture\n   * @param baseTexture - Parent texture\n   */\n  bind(baseTexture) {\n    this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n  }\n  /**\n   * Unbind to a parent BaseTexture\n   * @param baseTexture - Parent texture\n   */\n  unbind(baseTexture) {\n    this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);\n  }\n  /**\n   * Trigger a resize event\n   * @param width - X dimension\n   * @param height - Y dimension\n   */\n  resize(width, height) {\n    (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));\n  }\n  /**\n   * Has been validated\n   * @readonly\n   */\n  get valid() {\n    return !!this._width && !!this._height;\n  }\n  /** Has been updated trigger event. */\n  update() {\n    this.destroyed || this.onUpdate.emit();\n  }\n  /**\n   * This can be overridden to start preloading a resource\n   * or do any other prepare step.\n   * @protected\n   * @returns Handle the validate event\n   */\n  load() {\n    return Promise.resolve(this);\n  }\n  /**\n   * The width of the resource.\n   * @readonly\n   */\n  get width() {\n    return this._width;\n  }\n  /**\n   * The height of the resource.\n   * @readonly\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Set the style, optional to override\n   * @param _renderer - yeah, renderer!\n   * @param _baseTexture - the texture\n   * @param _glTexture - texture instance for this webgl context\n   * @returns - `true` is success\n   */\n  style(_renderer, _baseTexture, _glTexture) {\n    return !1;\n  }\n  /** Clean up anything, this happens when destroying is ready. */\n  dispose() {\n  }\n  /**\n   * Call when destroying resource, unbind any BaseTexture object\n   * before calling this method, as reference counts are maintained\n   * internally.\n   */\n  destroy() {\n    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n  }\n  /**\n   * Abstract, used to auto-detect resource type.\n   * @param {*} _source - The source object\n   * @param {string} _extension - The extension of source, if set\n   */\n  static test(_source, _extension) {\n    return !1;\n  }\n}\nexports.Resource = Resource;\n//# sourceMappingURL=Resource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/Resource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/SVGResource.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nconst _SVGResource = class _SVGResource2 extends BaseImageResource.BaseImageResource {\n  /**\n   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n   * @param {object} [options] - Options to use\n   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n   * @param {boolean} [options.autoLoad=true] - Start loading right away.\n   */\n  constructor(sourceBase64, options) {\n    options = options || {}, super(settings.settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  load() {\n    return this._load ? this._load : (this._load = new Promise((resolve) => {\n      if (this._resolve = () => {\n        this.update(), resolve(this);\n      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {\n        if (!btoa)\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    }), this._load);\n  }\n  /** Loads an SVG image from `imageUrl` or `data URL`. */\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {\n      this._resolve && (tempImage.onerror = null, this.onError.emit(event));\n    }, tempImage.onload = () => {\n      if (!this._resolve)\n        return;\n      const svgWidth = tempImage.width, svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight)\n        throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n      let width = svgWidth * this.scale, height = svgHeight * this.scale;\n      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${utils.uid()}`, canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;\n    };\n  }\n  /**\n   * Get size from an svg string using a regular expression.\n   * @param svgString - a serialized svg element\n   * @returns - image extension\n   */\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size = {};\n    return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size;\n  }\n  /** Destroys this texture. */\n  dispose() {\n    super.dispose(), this._resolve = null, this._crossorigin = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} - If the source is a SVG source or data file\n   */\n  static test(source, extension) {\n    return extension === \"svg\" || typeof source == \"string\" && source.startsWith(\"data:image/svg+xml\") || typeof source == \"string\" && _SVGResource2.SVG_XML.test(source);\n  }\n  // eslint-disable-line max-len\n};\n_SVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, /**\n* Regular expression for SVG size.\n* @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n* @readonly\n*/\n_SVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\nlet SVGResource = _SVGResource;\nexports.SVGResource = SVGResource;\n//# sourceMappingURL=SVGResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/SVGResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/VideoFrameResource.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/VideoFrameResource.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nclass VideoFrameResource extends BaseImageResource.BaseImageResource {\n  /**\n   * @param source - Image element to use\n   */\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(source) {\n    super(source);\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is an VideoFrame\n   */\n  static test(source) {\n    return !!globalThis.VideoFrame && source instanceof globalThis.VideoFrame;\n  }\n}\nexports.VideoFrameResource = VideoFrameResource;\n//# sourceMappingURL=VideoFrameResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/VideoFrameResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/VideoResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar ticker = __webpack_require__(/*! @pixi/ticker */ \"./node_modules/@pixi/ticker/lib/index.js\"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\");\nconst _VideoResource = class _VideoResource2 extends BaseImageResource.BaseImageResource {\n  /**\n   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n   * @param {object} [options] - Options to use\n   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n   * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n   * If 0, `requestVideoFrameCallback` is used to update the texture.\n   * If `requestVideoFrameCallback` is not available, the texture is updated every render.\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {boolean} [options.loop=false] - Loops the video\n   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay\n   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices\n   */\n  constructor(source, options) {\n    if (options = options || {}, !(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement(\"video\");\n      options.autoLoad !== !1 && videoElement.setAttribute(\"preload\", \"auto\"), options.playsinline !== !1 && (videoElement.setAttribute(\"webkit-playsinline\", \"\"), videoElement.setAttribute(\"playsinline\", \"\")), options.muted === !0 && (videoElement.setAttribute(\"muted\", \"\"), videoElement.muted = !0), options.loop === !0 && videoElement.setAttribute(\"loop\", \"\"), options.autoPlay !== !1 && videoElement.setAttribute(\"autoplay\", \"\"), typeof source == \"string\" && (source = [source]);\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement(\"source\");\n        let { src, mime } = source[i];\n        if (src = src || source[i], src.startsWith(\"data:\"))\n          mime = src.slice(5, src.indexOf(\";\"));\n        else if (!src.startsWith(\"blob:\")) {\n          const baseSrc = src.split(\"?\").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;\n        }\n        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== !1, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Trigger updating of the texture.\n   * @param _deltaTime - time delta since last tick\n   */\n  update(_deltaTime = 0) {\n    if (!this.destroyed) {\n      if (this._updateFPS) {\n        const elapsedMS = ticker.Ticker.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      }\n      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(\n        /* deltaTime*/\n      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }\n  _videoFrameRequestCallback() {\n    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    );\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<void>} Handle the validate event\n   */\n  load() {\n    if (this._load)\n      return this._load;\n    const source = this.source;\n    return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener(\"play\", this._onPlayStart), source.addEventListener(\"pause\", this._onPlayStop), source.addEventListener(\"seeked\", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener(\"canplay\", this._onCanPlay), source.addEventListener(\"canplaythrough\", this._onCanPlay), source.addEventListener(\"error\", this._onError, !0)), this._load = new Promise((resolve, reject) => {\n      this.valid ? resolve(this) : (this._resolve = resolve, this._reject = reject, source.load());\n    }), this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event\n   */\n  _onError(event) {\n    this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);\n  }\n  /**\n   * Returns true if the underlying source is playing.\n   * @returns - True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Returns true if the underlying source is ready for playing.\n   * @returns - True if ready.\n   */\n  _isSourceReady() {\n    return this.source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    this.valid || this._onCanPlay(), this._configureAutoUpdate();\n  }\n  /** Fired when a pause event is triggered, stops the update loop. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Fired when the video is completed seeking to the current playback position. */\n  _onSeeked() {\n    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener(\"canplay\", this._onCanPlay), source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    const valid = this.valid;\n    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();\n  }\n  /** Destroys this texture. */\n  dispose() {\n    this._configureAutoUpdate();\n    const source = this.source;\n    source && (source.removeEventListener(\"play\", this._onPlayStart), source.removeEventListener(\"pause\", this._onPlayStop), source.removeEventListener(\"seeked\", this._onSeeked), source.removeEventListener(\"canplay\", this._onCanPlay), source.removeEventListener(\"canplaythrough\", this._onCanPlay), source.removeEventListener(\"error\", this._onError, !0), source.pause(), source.src = \"\", source.load()), super.dispose();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());\n  }\n  /**\n   * How many times a second to update the texture from the video. If 0, `requestVideoFrameCallback` is used to\n   * update the texture. If `requestVideoFrameCallback` is not available, the texture is updated every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());\n  }\n  _configureAutoUpdate() {\n    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (ticker.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} `true` if video source\n   */\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);\n  }\n};\n_VideoResource.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], /**\n* Map of video MIME types that can't be directly derived from file extensions.\n* @readonly\n*/\n_VideoResource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoResource = _VideoResource;\nexports.VideoResource = VideoResource;\n//# sourceMappingURL=VideoResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/VideoResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source)\n    return null;\n  let extension = \"\";\n  if (typeof source == \"string\") {\n    const result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    result && (extension = result[1].toLowerCase());\n  }\n  for (let i = INSTALLED.length - 1; i >= 0; --i) {\n    const ResourcePlugin = INSTALLED[i];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension))\n      return new ResourcePlugin(source, options);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\nexports.INSTALLED = INSTALLED;\nexports.autoDetectResource = autoDetectResource;\n//# sourceMappingURL=autoDetectResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar ArrayResource = __webpack_require__(/*! ./ArrayResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js\"), autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js\"), BufferResource = __webpack_require__(/*! ./BufferResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BufferResource.js\"), CanvasResource = __webpack_require__(/*! ./CanvasResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js\"), CubeResource = __webpack_require__(/*! ./CubeResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/CubeResource.js\"), ImageBitmapResource = __webpack_require__(/*! ./ImageBitmapResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js\"), ImageResource = __webpack_require__(/*! ./ImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/ImageResource.js\"), SVGResource = __webpack_require__(/*! ./SVGResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/SVGResource.js\"), VideoFrameResource = __webpack_require__(/*! ./VideoFrameResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/VideoFrameResource.js\"), VideoResource = __webpack_require__(/*! ./VideoResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/VideoResource.js\"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js\"), Resource = __webpack_require__(/*! ./Resource.js */ \"./node_modules/@pixi/core/lib/textures/resources/Resource.js\"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ \"./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js\");\nautoDetectResource.INSTALLED.push(\n  ImageBitmapResource.ImageBitmapResource,\n  ImageResource.ImageResource,\n  CanvasResource.CanvasResource,\n  VideoResource.VideoResource,\n  VideoFrameResource.VideoFrameResource,\n  SVGResource.SVGResource,\n  BufferResource.BufferResource,\n  CubeResource.CubeResource,\n  ArrayResource.ArrayResource\n);\nexports.ArrayResource = ArrayResource.ArrayResource;\nexports.INSTALLED = autoDetectResource.INSTALLED;\nexports.autoDetectResource = autoDetectResource.autoDetectResource;\nexports.BufferResource = BufferResource.BufferResource;\nexports.CanvasResource = CanvasResource.CanvasResource;\nexports.CubeResource = CubeResource.CubeResource;\nexports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;\nexports.ImageResource = ImageResource.ImageResource;\nexports.SVGResource = SVGResource.SVGResource;\nexports.VideoResource = VideoResource.VideoResource;\nexports.BaseImageResource = BaseImageResource.BaseImageResource;\nexports.Resource = Resource.Resource;\nexports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/resources/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nfunction mapInternalFormatToSamplerType(gl) {\n  let table;\n  return \"WebGL2RenderingContext\" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {\n    [gl.RGB]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.ALPHA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE_ALPHA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R8_SNORM]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RG8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RG8_SNORM]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB8_SNORM]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB565]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA4]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB5_A1]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA8_SNORM]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB10_A2]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB10_A2UI]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.SRGB8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.SRGB8_ALPHA8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R16F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RG16F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB16F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA16F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R32F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RG32F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB32F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA32F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R11F_G11F_B10F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGB9_E5]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.R8I]: constants.SAMPLER_TYPES.INT,\n    [gl.R8UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.R16I]: constants.SAMPLER_TYPES.INT,\n    [gl.R16UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.R32I]: constants.SAMPLER_TYPES.INT,\n    [gl.R32UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RG8I]: constants.SAMPLER_TYPES.INT,\n    [gl.RG8UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RG16I]: constants.SAMPLER_TYPES.INT,\n    [gl.RG16UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RG32I]: constants.SAMPLER_TYPES.INT,\n    [gl.RG32UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGB8I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGB8UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGB16I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGB16UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGB32I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGB32UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGBA8I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGBA8UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGBA16I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGBA16UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.RGBA32I]: constants.SAMPLER_TYPES.INT,\n    [gl.RGBA32UI]: constants.SAMPLER_TYPES.UINT,\n    [gl.DEPTH_COMPONENT16]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_COMPONENT24]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_COMPONENT32F]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_STENCIL]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH24_STENCIL8]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH32F_STENCIL8]: constants.SAMPLER_TYPES.FLOAT\n  } : table = {\n    [gl.RGB]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.RGBA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.ALPHA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE_ALPHA]: constants.SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_STENCIL]: constants.SAMPLER_TYPES.FLOAT\n  }, table;\n}\nexports.mapInternalFormatToSamplerType = mapInternalFormatToSamplerType;\n//# sourceMappingURL=mapInternalFormatToSamplerType.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nfunction mapTypeAndFormatToInternalFormat(gl) {\n  let table;\n  return \"WebGL2RenderingContext\" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {\n    [constants.TYPES.UNSIGNED_BYTE]: {\n      [constants.FORMATS.RGBA]: gl.RGBA8,\n      [constants.FORMATS.RGB]: gl.RGB8,\n      [constants.FORMATS.RG]: gl.RG8,\n      [constants.FORMATS.RED]: gl.R8,\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8UI,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB8UI,\n      [constants.FORMATS.RG_INTEGER]: gl.RG8UI,\n      [constants.FORMATS.RED_INTEGER]: gl.R8UI,\n      [constants.FORMATS.ALPHA]: gl.ALPHA,\n      [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,\n      [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n    },\n    [constants.TYPES.BYTE]: {\n      [constants.FORMATS.RGBA]: gl.RGBA8_SNORM,\n      [constants.FORMATS.RGB]: gl.RGB8_SNORM,\n      [constants.FORMATS.RG]: gl.RG8_SNORM,\n      [constants.FORMATS.RED]: gl.R8_SNORM,\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8I,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB8I,\n      [constants.FORMATS.RG_INTEGER]: gl.RG8I,\n      [constants.FORMATS.RED_INTEGER]: gl.R8I\n    },\n    [constants.TYPES.UNSIGNED_SHORT]: {\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16UI,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB16UI,\n      [constants.FORMATS.RG_INTEGER]: gl.RG16UI,\n      [constants.FORMATS.RED_INTEGER]: gl.R16UI,\n      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16\n    },\n    [constants.TYPES.SHORT]: {\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16I,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB16I,\n      [constants.FORMATS.RG_INTEGER]: gl.RG16I,\n      [constants.FORMATS.RED_INTEGER]: gl.R16I\n    },\n    [constants.TYPES.UNSIGNED_INT]: {\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32UI,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB32UI,\n      [constants.FORMATS.RG_INTEGER]: gl.RG32UI,\n      [constants.FORMATS.RED_INTEGER]: gl.R32UI,\n      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24\n    },\n    [constants.TYPES.INT]: {\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32I,\n      [constants.FORMATS.RGB_INTEGER]: gl.RGB32I,\n      [constants.FORMATS.RG_INTEGER]: gl.RG32I,\n      [constants.FORMATS.RED_INTEGER]: gl.R32I\n    },\n    [constants.TYPES.FLOAT]: {\n      [constants.FORMATS.RGBA]: gl.RGBA32F,\n      [constants.FORMATS.RGB]: gl.RGB32F,\n      [constants.FORMATS.RG]: gl.RG32F,\n      [constants.FORMATS.RED]: gl.R32F,\n      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F\n    },\n    [constants.TYPES.HALF_FLOAT]: {\n      [constants.FORMATS.RGBA]: gl.RGBA16F,\n      [constants.FORMATS.RGB]: gl.RGB16F,\n      [constants.FORMATS.RG]: gl.RG16F,\n      [constants.FORMATS.RED]: gl.R16F\n    },\n    [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {\n      [constants.FORMATS.RGB]: gl.RGB565\n    },\n    [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {\n      [constants.FORMATS.RGBA]: gl.RGBA4\n    },\n    [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {\n      [constants.FORMATS.RGBA]: gl.RGB5_A1\n    },\n    [constants.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {\n      [constants.FORMATS.RGBA]: gl.RGB10_A2,\n      [constants.FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI\n    },\n    [constants.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {\n      [constants.FORMATS.RGB]: gl.R11F_G11F_B10F\n    },\n    [constants.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {\n      [constants.FORMATS.RGB]: gl.RGB9_E5\n    },\n    [constants.TYPES.UNSIGNED_INT_24_8]: {\n      [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8\n    },\n    [constants.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {\n      [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8\n    }\n  } : table = {\n    [constants.TYPES.UNSIGNED_BYTE]: {\n      [constants.FORMATS.RGBA]: gl.RGBA,\n      [constants.FORMATS.RGB]: gl.RGB,\n      [constants.FORMATS.ALPHA]: gl.ALPHA,\n      [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,\n      [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n    },\n    [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {\n      [constants.FORMATS.RGB]: gl.RGB\n    },\n    [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {\n      [constants.FORMATS.RGBA]: gl.RGBA\n    },\n    [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {\n      [constants.FORMATS.RGBA]: gl.RGBA\n    }\n  }, table;\n}\nexports.mapTypeAndFormatToInternalFormat = mapTypeAndFormatToInternalFormat;\n//# sourceMappingURL=mapTypeAndFormatToInternalFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar runner = __webpack_require__(/*! @pixi/runner */ \"./node_modules/@pixi/runner/lib/index.js\");\nclass TransformFeedback {\n  constructor() {\n    this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new runner.Runner(\"disposeTransformFeedback\");\n  }\n  /**\n   * Bind buffer to TransformFeedback\n   * @param index - index to bind\n   * @param buffer - buffer to bind\n   */\n  bindBuffer(index, buffer) {\n    this.buffers[index] = buffer;\n  }\n  /** Destroy WebGL resources that are connected to this TransformFeedback. */\n  destroy() {\n    this.disposeRunner.emit(this, !1);\n  }\n}\nexports.TransformFeedback = TransformFeedback;\n//# sourceMappingURL=TransformFeedback.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\");\nclass TransformFeedbackSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  /**\n   * Bind TransformFeedback and buffers\n   * @param transformFeedback - TransformFeedback to bind\n   */\n  bind(transformFeedback) {\n    const { gl, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n  }\n  /** Unbind TransformFeedback */\n  unbind() {\n    const { gl } = this;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n  }\n  /**\n   * Begin TransformFeedback\n   * @param drawMode - DrawMode for TransformFeedback\n   * @param shader - A Shader used by TransformFeedback. Current bound shader will be used if not provided.\n   */\n  beginTransformFeedback(drawMode, shader) {\n    const { gl, renderer } = this;\n    shader && renderer.shader.bind(shader), gl.beginTransformFeedback(drawMode);\n  }\n  /** End TransformFeedback */\n  endTransformFeedback() {\n    const { gl } = this;\n    gl.endTransformFeedback();\n  }\n  /**\n   * Create TransformFeedback and bind buffers\n   * @param tf - TransformFeedback\n   * @returns WebGLTransformFeedback\n   */\n  createGLTransformFeedback(tf) {\n    const { gl, renderer, CONTEXT_UID } = this, glTransformFeedback = gl.createTransformFeedback();\n    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n    for (let i = 0; i < tf.buffers.length; i++) {\n      const buffer = tf.buffers[i];\n      buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null));\n    }\n    return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;\n  }\n  /**\n   * Disposes TransfromFeedback\n   * @param {PIXI.TransformFeedback} tf - TransformFeedback\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress delete TransformFeedback\n   */\n  disposeTransformFeedback(tf, contextLost) {\n    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;\n    tf.disposeRunner.remove(this);\n    const bufferSystem = this.renderer.buffer;\n    if (bufferSystem)\n      for (let i = 0; i < tf.buffers.length; i++) {\n        const buffer = tf.buffers[i];\n        if (!buffer)\n          continue;\n        const buf = buffer._glBuffers[this.CONTEXT_UID];\n        buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer, contextLost));\n      }\n    glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTransformFeedbackSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"transformFeedback\"\n};\nextensions.extensions.add(TransformFeedbackSystem);\nexports.TransformFeedbackSystem = TransformFeedbackSystem;\n//# sourceMappingURL=TransformFeedbackSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/Quad.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/Quad.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ \"./node_modules/@pixi/core/lib/geometry/Geometry.js\");\nclass Quad extends Geometry.Geometry {\n  constructor() {\n    super(), this.addAttribute(\"aVertexPosition\", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]);\n  }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/utils/Quad.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/QuadUv.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/QuadUv.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ \"./node_modules/@pixi/core/lib/geometry/Buffer.js\"), Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ \"./node_modules/@pixi/core/lib/geometry/Geometry.js\");\nclass QuadUv extends Geometry.Geometry {\n  constructor() {\n    super(), this.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]), this.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]), this.vertexBuffer = new Buffer.Buffer(this.vertices), this.uvBuffer = new Buffer.Buffer(this.uvs), this.addAttribute(\"aVertexPosition\", this.vertexBuffer).addAttribute(\"aTextureCoord\", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);\n  }\n  /**\n   * Maps two Rectangle to the quad.\n   * @param targetTextureFrame - The first rectangle\n   * @param destinationFrame - The second rectangle\n   * @returns - Returns itself.\n   */\n  map(targetTextureFrame, destinationFrame) {\n    let x = 0, y = 0;\n    return this.uvs[0] = x, this.uvs[1] = y, this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y, this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x, this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height, x = destinationFrame.x, y = destinationFrame.y, this.vertices[0] = x, this.vertices[1] = y, this.vertices[2] = x + destinationFrame.width, this.vertices[3] = y, this.vertices[4] = x + destinationFrame.width, this.vertices[5] = y + destinationFrame.height, this.vertices[6] = x, this.vertices[7] = y + destinationFrame.height, this.invalidate(), this;\n  }\n  /**\n   * Legacy upload method, just marks buffers dirty.\n   * @returns - Returns itself.\n   */\n  invalidate() {\n    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n  }\n}\nexports.QuadUv = QuadUv;\n//# sourceMappingURL=QuadUv.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/utils/QuadUv.js?");

/***/ }),

/***/ "./node_modules/@pixi/core/lib/view/ViewSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/view/ViewSystem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), math = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.js\"), settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nclass ViewSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * initiates the view system\n   * @param {PIXI.ViewOptions} options - the options for the view\n   */\n  init(options) {\n    this.screen = new math.Rectangle(0, 0, options.width, options.height), this.element = options.view || settings.settings.ADAPTER.createCanvas(), this.resolution = options.resolution || settings.settings.RESOLUTION, this.autoDensity = !!options.autoDensity;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   */\n  resizeView(desiredScreenWidth, desiredScreenHeight) {\n    this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);\n    const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;\n    this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit(\"resize\", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.\n   */\n  destroy(removeView) {\n    removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;\n  }\n}\nViewSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.width}\n   * @default 800\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  width: 800,\n  /**\n   * {@link PIXI.IRendererOptions.height}\n   * @default 600\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  height: 600,\n  /**\n   * {@link PIXI.IRendererOptions.resolution}\n   * @type {number}\n   * @default PIXI.settings.RESOLUTION\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  resolution: void 0,\n  /**\n   * {@link PIXI.IRendererOptions.autoDensity}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  autoDensity: !1\n}, /** @ignore */\nViewSystem.extension = {\n  type: [\n    extensions.ExtensionType.RendererSystem,\n    extensions.ExtensionType.CanvasRendererSystem\n  ],\n  name: \"_view\"\n};\nextensions.extensions.add(ViewSystem);\nexports.ViewSystem = ViewSystem;\n//# sourceMappingURL=ViewSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/core/lib/view/ViewSystem.js?");

/***/ }),

/***/ "./node_modules/@pixi/extensions/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/extensions/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => (ExtensionType2.Renderer = \"renderer\", ExtensionType2.Application = \"application\", ExtensionType2.RendererSystem = \"renderer-webgl-system\", ExtensionType2.RendererPlugin = \"renderer-webgl-plugin\", ExtensionType2.CanvasRendererSystem = \"renderer-canvas-system\", ExtensionType2.CanvasRendererPlugin = \"renderer-canvas-plugin\", ExtensionType2.Asset = \"asset\", ExtensionType2.LoadParser = \"load-parser\", ExtensionType2.ResolveParser = \"resolve-parser\", ExtensionType2.CacheParser = \"cache-parser\", ExtensionType2.DetectionParser = \"detection-parser\", ExtensionType2))(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext == \"function\" || typeof ext == \"object\" && ext.extension) {\n    if (!ext.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    ext = { ...typeof ext.extension != \"object\" ? { type: ext.extension } : ext.extension, ref: ext };\n  }\n  if (typeof ext == \"object\")\n    ext = { ...ext };\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof ext.type == \"string\" && (ext.type = [ext.type]), ext;\n}, normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority, extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  remove(...extensions2) {\n    return extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    }), this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  add(...extensions2) {\n    return extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers, queue = this._queue;\n        handlers[type] ? handlers[type]?.(ext) : (queue[type] = queue[type] || [], queue[type]?.push(ext));\n      });\n    }), this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.\n   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type])\n      throw new Error(`Extension type ${type} already has a handler`);\n    addHandlers[type] = onAdd, removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    return queue[type] && (queue[type]?.forEach((ext) => onAdd(ext)), delete queue[type]), this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        extension.name && (map[extension.name] = extension.ref);\n      },\n      (extension) => {\n        extension.name && delete map[extension.name];\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        list.includes(extension.ref) || (list.push(extension.ref), list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority)));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        index !== -1 && list.splice(index, 1);\n      }\n    );\n  }\n};\nexports.ExtensionType = ExtensionType;\nexports.extensions = extensions;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/extensions/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/math-extras/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/math-extras/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar core = __webpack_require__(/*! @pixi/core */ \"./node_modules/@pixi/core/lib/index.js\");\n__webpack_require__(/*! ./pointExtras.js */ \"./node_modules/@pixi/math-extras/lib/pointExtras.js\");\n__webpack_require__(/*! ./rectangleExtras.js */ \"./node_modules/@pixi/math-extras/lib/rectangleExtras.js\");\nfunction floatEqual(a, b, epsilon = Number.EPSILON) {\n  return a === b ? !0 : Math.abs(a - b) < epsilon;\n}\nfunction genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {\n  outPoint || (outPoint = new core.Point());\n  const dxa = aEnd.x - aStart.x, dya = aEnd.y - aStart.y, dxb = bEnd.x - bStart.x, dyb = bEnd.y - bStart.y, denominator = dyb * dxa - dxb * dya;\n  if (floatEqual(denominator, 0))\n    return outPoint.x = NaN, outPoint.y = NaN, outPoint;\n  const ua = (dxb * (aStart.y - bStart.y) - dyb * (aStart.x - bStart.x)) / denominator, ub = (dxa * (aStart.y - bStart.y) - dya * (aStart.x - bStart.x)) / denominator;\n  return !isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1) ? (outPoint.x = NaN, outPoint.y = NaN, outPoint) : (outPoint.x = aStart.x + ua * dxa, outPoint.y = bStart.y + ub * dyb, outPoint);\n}\nfunction lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {\n  return genericLineIntersection(aStart, aEnd, bStart, bEnd, !0, outPoint);\n}\nfunction segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {\n  return genericLineIntersection(aStart, aEnd, bStart, bEnd, !1, outPoint);\n}\nexports.floatEqual = floatEqual;\nexports.lineIntersection = lineIntersection;\nexports.segmentIntersection = segmentIntersection;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math-extras/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/math-extras/lib/pointExtras.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/math-extras/lib/pointExtras.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar core = __webpack_require__(/*! @pixi/core */ \"./node_modules/@pixi/core/lib/index.js\");\nconst mixins = {\n  /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method add\n   * @memberof PIXI.Point#\n   * @param {IPointData} other - The point to add to `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */\n  /**\n   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method add\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} other - The point to add to `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n   */\n  add(other, outPoint) {\n    return outPoint || (outPoint = new core.Point()), outPoint.x = this.x + other.x, outPoint.y = this.y + other.y, outPoint;\n  },\n  /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method subtract\n   * @memberof PIXI.Point#\n   * @param {IPointData} other - The point to subtract to `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */\n  /**\n   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method subtract\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} other - The point to subtract to `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n   */\n  subtract(other, outPoint) {\n    return outPoint || (outPoint = new core.Point()), outPoint.x = this.x - other.x, outPoint.y = this.y - other.y, outPoint;\n  },\n  /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method multiply\n   * @memberof PIXI.Point#\n   * @param {IPointData} other - The point to multiply with `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */\n  /**\n   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method multiply\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} other - The point to multiply with `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n   */\n  multiply(other, outPoint) {\n    return outPoint || (outPoint = new core.Point()), outPoint.x = this.x * other.x, outPoint.y = this.y * other.y, outPoint;\n  },\n  /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method multiplyScalar\n   * @memberof PIXI.Point#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n   */\n  /**\n   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method multiplyScalar\n   * @memberof PIXI.ObservablePoint#\n   * @param {number} scalar - The number to multiply both components of `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n   */\n  multiplyScalar(scalar, outPoint) {\n    return outPoint || (outPoint = new core.Point()), outPoint.x = this.x * scalar, outPoint.y = this.y * scalar, outPoint;\n  },\n  /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method dot\n   * @memberof PIXI.Point#\n   * @param {IPointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */\n  /**\n   * Computes the dot product of `other` with `this` point.\n   * The dot product is the sum of the products of the corresponding components of two vectors.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method dot\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} other - The other point to calculate the dot product with `this`.\n   * @returns {number} The result of the dot product. This is an scalar value.\n   */\n  dot(other) {\n    return this.x * other.x + this.y * other.y;\n  },\n  /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method cross\n   * @memberof PIXI.Point#\n   * @param {IPointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */\n  /**\n   * Computes the cross product of `other` with `this` point.\n   * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n   * the result becomes a vector that will only have magnitude on the z axis.\n   *\n   * This function returns the z component of the cross product of the two points.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method cross\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} other - The other point to calculate the cross product with `this`.\n   * @returns {number} The z component of the result of the cross product.\n   */\n  cross(other) {\n    return this.x * other.y - this.y * other.x;\n  },\n  /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method normalize\n   * @memberof PIXI.Point#\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The normalized point.\n   */\n  /**\n   * Computes a normalized version of `this` point.\n   *\n   * A normalized vector is a vector of magnitude (length) 1\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method normalize\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The normalized point.\n   */\n  normalize(outPoint) {\n    outPoint || (outPoint = new core.Point());\n    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    return outPoint.x = this.x / magnitude, outPoint.y = this.y / magnitude, outPoint;\n  },\n  /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method magnitude\n   * @memberof PIXI.Point#\n   * @returns {number} The magnitude (length) of the vector.\n   */\n  /**\n   * Computes the magnitude of this point (Euclidean distance from 0, 0).\n   *\n   * Defined as the square root of the sum of the squares of each component.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method magnitude\n   * @memberof PIXI.ObservablePoint#\n   * @returns {number} The magnitude (length) of the vector.\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method magnitudeSquared\n   * @memberof PIXI.Point#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */\n  /**\n   * Computes the square magnitude of this point.\n   * If you are comparing the lengths of vectors, you should compare the length squared instead\n   * as it is slightly more efficient to calculate.\n   *\n   * Defined as the sum of the squares of each component.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method magnitudeSquared\n   * @memberof PIXI.ObservablePoint#\n   * @returns {number} The magnitude squared (length squared) of the vector.\n   */\n  magnitudeSquared() {\n    return this.x * this.x + this.y * this.y;\n  },\n  /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method project\n   * @memberof PIXI.Point#\n   * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `this` on `onto` projection.\n   */\n  /**\n   * Computes vector projection of `this` on `onto`.\n   *\n   * Imagine a light source, parallel to `onto`, above `this`.\n   * The light would cast rays perpendicular to `onto`.\n   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method project\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The `this` on `onto` projection.\n   */\n  project(onto, outPoint) {\n    outPoint || (outPoint = new core.Point());\n    const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);\n    return outPoint.x = onto.x * normalizedScalarProjection, outPoint.y = onto.y * normalizedScalarProjection, outPoint;\n  },\n  /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method reflect\n   * @memberof PIXI.Point#\n   * @param {IPointData} normal - The normal vector of your reflecting plane.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The reflection of `this` on your reflecting plane.\n   */\n  /**\n   * Reflects `this` vector off of a plane orthogonal to `normal`.\n   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n   *\n   * Imagine a light source bouncing onto a mirror.\n   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n   * `this.reflect(normal)` is the reflection of `this` on that mirror.\n   *\n   * _Note: Only available with **@pixi/math-extras**._\n   * @method reflect\n   * @memberof PIXI.ObservablePoint#\n   * @param {IPointData} normal - The normal vector of your reflecting plane.\n   * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n   * optional (otherwise will create a new Point).\n   * @returns {IPointData} The reflection of `this` on your reflecting plane.\n   */\n  reflect(normal, outPoint) {\n    outPoint || (outPoint = new core.Point());\n    const dotProduct = this.x * normal.x + this.y * normal.y;\n    return outPoint.x = this.x - 2 * dotProduct * normal.x, outPoint.y = this.y - 2 * dotProduct * normal.y, outPoint;\n  }\n};\nObject.assign(core.Point.prototype, mixins);\nObject.assign(core.ObservablePoint.prototype, mixins);\n//# sourceMappingURL=pointExtras.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math-extras/lib/pointExtras.js?");

/***/ }),

/***/ "./node_modules/@pixi/math-extras/lib/rectangleExtras.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/math-extras/lib/rectangleExtras.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar core = __webpack_require__(/*! @pixi/core */ \"./node_modules/@pixi/core/lib/index.js\");\ncore.Rectangle.prototype.containsRect = function(other) {\n  return other.width <= 0 || other.height <= 0 ? other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom : other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n};\ncore.Rectangle.prototype.equals = function(other) {\n  return other === this ? !0 : other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n};\ncore.Rectangle.prototype.intersection = function(other, outRect) {\n  outRect || (outRect = new core.Rectangle());\n  const x0 = this.x < other.x ? other.x : this.x, x1 = this.right > other.right ? other.right : this.right;\n  if (x1 <= x0)\n    return outRect.x = outRect.y = outRect.width = outRect.height = 0, outRect;\n  const y0 = this.y < other.y ? other.y : this.y, y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n  return y1 <= y0 ? (outRect.x = outRect.y = outRect.width = outRect.height = 0, outRect) : (outRect.x = x0, outRect.y = y0, outRect.width = x1 - x0, outRect.height = y1 - y0, outRect);\n};\ncore.Rectangle.prototype.union = function(other, outRect) {\n  outRect || (outRect = new core.Rectangle());\n  const x1 = Math.min(this.x, other.x), x2 = Math.max(this.x + this.width, other.x + other.width), y1 = Math.min(this.y, other.y), y2 = Math.max(this.y + this.height, other.y + other.height);\n  return outRect.x = x1, outRect.y = y1, outRect.width = x2 - x1, outRect.height = y2 - y1, outRect;\n};\n//# sourceMappingURL=rectangleExtras.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math-extras/lib/rectangleExtras.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPoint.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPoint.js ***!
  \***********************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=IPoint.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/IPoint.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPointData.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPointData.js ***!
  \***************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=IPointData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/IPointData.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/Matrix.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/Matrix.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/math/lib/const.js\"), Point = __webpack_require__(/*! ./Point.js */ \"./node_modules/@pixi/math/lib/Point.js\");\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    this.array = null, this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    this.array || (this.array = new Float32Array(9));\n    const array = out || this.array;\n    return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {PIXI.Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point.Point();\n    const x = pos.x, y = pos.y;\n    return newPos.x = this.a * x + this.c * y + this.tx, newPos.y = this.b * x + this.d * y + this.ty, newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point.Point();\n    const id = 1 / (this.a * this.d + this.c * -this.b), x = pos.x, y = pos.y;\n    return newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id, newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    return this.tx += x, this.ty += y, this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;\n    return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;\n    return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x - (pivotX * this.a + pivotY * this.c), this.ty = y - (pivotX * this.b + pivotY * this.d), this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a, c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a, b = this.b, c = this.c, d = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c, d), skewY = Math.atan2(b, a), delta = Math.abs(skewX + skewY);\n    return delta < 1e-5 || Math.abs(_const.PI_2 - delta) < 1e-5 ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a * a + b * b), transform.scale.y = Math.sqrt(c * c + d * d), transform.position.x = this.tx + (pivot.x * a + pivot.y * c), transform.position.y = this.ty + (pivot.x * b + pivot.y * d), transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;\n    return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param {PIXI.Matrix} matrix - The matrix to copy from.\n   * @returns {PIXI.Matrix} this\n   */\n  copyFrom(matrix) {\n    return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;\n  }\n  /**\n   * A default (identity) matrix\n   * @readonly\n   */\n  static get IDENTITY() {\n    return new Matrix();\n  }\n  /**\n   * A temp matrix\n   * @readonly\n   */\n  static get TEMP_MATRIX() {\n    return new Matrix();\n  }\n}\nMatrix.prototype.toString = function() {\n  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n};\nexports.Matrix = Matrix;\n//# sourceMappingURL=Matrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/Matrix.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/ObservablePoint.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/ObservablePoint.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param cb - callback function triggered when `x` and/or `y` are changed\n   * @param scope - owner of callback\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(cb, scope, x = 0, y = 0) {\n    this._x = x, this._y = y, this.cb = cb, this.scope = scope;\n  }\n  /**\n   * Creates a clone of this point.\n   * The callback and scope params can be overridden otherwise they will default\n   * to the clone object's values.\n   * @override\n   * @param cb - The callback function triggered when `x` and/or `y` are changed\n   * @param scope - The owner of the callback\n   * @returns a copy of this observable point\n   */\n  clone(cb = this.cb, scope = this.scope) {\n    return new ObservablePoint(cb, scope, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    return (this._x !== x || this._y !== y) && (this._x = x, this._y = y, this.cb.call(this.scope)), this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    return (this._x !== p.x || this._y !== p.y) && (this._x = p.x, this._y = p.y, this.cb.call(this.scope)), this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    return p.set(this._x, this._y), p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x !== value && (this._x = value, this.cb.call(this.scope));\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y !== value && (this._y = value, this.cb.call(this.scope));\n  }\n}\nObservablePoint.prototype.toString = function() {\n  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;\n};\nexports.ObservablePoint = ObservablePoint;\n//# sourceMappingURL=ObservablePoint.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/ObservablePoint.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/Point.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/Point.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    this.x = 0, this.y = 0, this.x = x, this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    return this.set(p.x, p.y), this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    return p.set(this.x, this.y), p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    return this.x = x, this.y = y, this;\n  }\n}\nPoint.prototype.toString = function() {\n  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;\n};\nexports.Point = Point;\n//# sourceMappingURL=Point.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/Point.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/Transform.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/math/lib/Transform.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Matrix = __webpack_require__(/*! ./Matrix.js */ \"./node_modules/@pixi/math/lib/Matrix.js\"), ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ \"./node_modules/@pixi/math/lib/ObservablePoint.js\");\nconst _Transform = class {\n  constructor() {\n    this.worldTransform = new Matrix.Matrix(), this.localTransform = new Matrix.Matrix(), this.position = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint.ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint.ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n  }\n  /** Called when a value changes. */\n  onChange() {\n    this._localID++;\n  }\n  /** Called when the skew or the rotation changes. */\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n  }\n  /** Updates the local transformation matrix. */\n  updateLocalTransform() {\n    const lt = this.localTransform;\n    this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);\n  }\n  /**\n   * Updates the local and the world transformation matrices.\n   * @param parentTransform - The parent transform\n   */\n  updateTransform(parentTransform) {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {\n      const pt = parentTransform.worldTransform, wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++;\n    }\n  }\n  /**\n   * Decomposes a matrix and sets the transforms properties based on it.\n   * @param matrix - The matrix to decompose\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this), this._localID++;\n  }\n  /** The rotation of the object in radians. */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    this._rotation !== value && (this._rotation = value, this.updateSkew());\n  }\n};\n_Transform.IDENTITY = new _Transform();\nlet Transform = _Transform;\nTransform.prototype.toString = function() {\n  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;\n};\nexports.Transform = Transform;\n//# sourceMappingURL=Transform.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/Transform.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/const.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/const.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180;\nvar SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = \"POLY\", SHAPES2[SHAPES2.RECT = 1] = \"RECT\", SHAPES2[SHAPES2.CIRC = 2] = \"CIRC\", SHAPES2[SHAPES2.ELIP = 3] = \"ELIP\", SHAPES2[SHAPES2.RREC = 4] = \"RREC\", SHAPES2))(SHAPES || {});\nexports.DEG_TO_RAD = DEG_TO_RAD;\nexports.PI_2 = PI_2;\nexports.RAD_TO_DEG = RAD_TO_DEG;\nexports.SHAPES = SHAPES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/const.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/groupD8.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/math/lib/groupD8.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Matrix = __webpack_require__(/*! ./Matrix.js */ \"./node_modules/@pixi/math/lib/Matrix.js\");\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]), _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]), _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]), _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++)\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix.Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0), rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @readonly\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @readonly\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @readonly\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @readonly\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @readonly\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @readonly\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @readonly\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @readonly\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @readonly\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @readonly\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @readonly\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @readonly\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {PIXI.GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n   * @returns {PIXI.GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @param {PIXI.GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {PIXI.GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD8.S : groupD8.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD8.E : groupD8.W : dy > 0 ? dx > 0 ? groupD8.SE : groupD8.SW : dx > 0 ? groupD8.NE : groupD8.NW,\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx, mat.ty = ty, matrix.append(mat);\n  }\n};\nexports.groupD8 = groupD8;\n//# sourceMappingURL=groupD8.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/groupD8.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Circle = __webpack_require__(/*! ./shapes/Circle.js */ \"./node_modules/@pixi/math/lib/shapes/Circle.js\"), Ellipse = __webpack_require__(/*! ./shapes/Ellipse.js */ \"./node_modules/@pixi/math/lib/shapes/Ellipse.js\"), Polygon = __webpack_require__(/*! ./shapes/Polygon.js */ \"./node_modules/@pixi/math/lib/shapes/Polygon.js\"), Rectangle = __webpack_require__(/*! ./shapes/Rectangle.js */ \"./node_modules/@pixi/math/lib/shapes/Rectangle.js\"), RoundedRectangle = __webpack_require__(/*! ./shapes/RoundedRectangle.js */ \"./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js\"), groupD8 = __webpack_require__(/*! ./groupD8.js */ \"./node_modules/@pixi/math/lib/groupD8.js\");\n__webpack_require__(/*! ./IPoint.js */ \"./node_modules/@pixi/math/lib/IPoint.js\");\n__webpack_require__(/*! ./IPointData.js */ \"./node_modules/@pixi/math/lib/IPointData.js\");\nvar Matrix = __webpack_require__(/*! ./Matrix.js */ \"./node_modules/@pixi/math/lib/Matrix.js\"), ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ \"./node_modules/@pixi/math/lib/ObservablePoint.js\"), Point = __webpack_require__(/*! ./Point.js */ \"./node_modules/@pixi/math/lib/Point.js\"), Transform = __webpack_require__(/*! ./Transform.js */ \"./node_modules/@pixi/math/lib/Transform.js\"), _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/math/lib/const.js\");\nexports.Circle = Circle.Circle;\nexports.Ellipse = Ellipse.Ellipse;\nexports.Polygon = Polygon.Polygon;\nexports.Rectangle = Rectangle.Rectangle;\nexports.RoundedRectangle = RoundedRectangle.RoundedRectangle;\nexports.groupD8 = groupD8.groupD8;\nexports.Matrix = Matrix.Matrix;\nexports.ObservablePoint = ObservablePoint.ObservablePoint;\nexports.Point = Point.Point;\nexports.Transform = Transform.Transform;\nexports.DEG_TO_RAD = _const.DEG_TO_RAD;\nexports.PI_2 = _const.PI_2;\nexports.RAD_TO_DEG = _const.RAD_TO_DEG;\nexports.SHAPES = _const.SHAPES;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Circle.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Circle.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/math/lib/const.js\"), Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/@pixi/math/lib/shapes/Rectangle.js\");\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    this.x = x, this.y = y, this.radius = radius, this.type = _const.SHAPES.CIRC;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return !1;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x, dy = this.y - y;\n    return dx *= dx, dy *= dy, dx + dy <= r2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }\n}\nCircle.prototype.toString = function() {\n  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n};\nexports.Circle = Circle;\n//# sourceMappingURL=Circle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/shapes/Circle.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Ellipse.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Ellipse.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/math/lib/const.js\"), Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/@pixi/math/lib/shapes/Rectangle.js\");\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    this.x = x, this.y = y, this.width = halfWidth, this.height = halfHeight, this.type = _const.SHAPES.ELIP;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {PIXI.Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    let normx = (x - this.x) / this.width, normy = (y - this.y) / this.height;\n    return normx *= normx, normy *= normy, normx + normy <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }\n}\nEllipse.prototype.toString = function() {\n  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n};\nexports.Ellipse = Ellipse;\n//# sourceMappingURL=Ellipse.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/shapes/Ellipse.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Polygon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Polygon.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/math/lib/const.js\");\nclass Polygon {\n  /**\n   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] != \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++)\n        p.push(flat[i].x, flat[i].y);\n      flat = p;\n    }\n    this.points = flat, this.type = _const.SHAPES.POLY, this.closeStroke = !0;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice(), polygon = new Polygon(points);\n    return polygon.closeStroke = this.closeStroke, polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = !1;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2], yi = this.points[i * 2 + 1], xj = this.points[j * 2], yj = this.points[j * 2 + 1];\n      yi > y != yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi && (inside = !inside);\n    }\n    return inside;\n  }\n}\nPolygon.prototype.toString = function() {\n  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n};\nexports.Polygon = Polygon;\n//# sourceMappingURL=Polygon.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/shapes/Polygon.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Rectangle.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Rectangle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/math/lib/const.js\"), Point = __webpack_require__(/*! ../Point.js */ \"./node_modules/@pixi/math/lib/Point.js\");\nconst tempPoints = [new Point.Point(), new Point.Point(), new Point.Point(), new Point.Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = Number(x), this.y = Number(y), this.width = Number(width), this.height = Number(height), this.type = _const.SHAPES.RECT;\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** A constant empty rectangle. */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    return this.width <= 0 || this.height <= 0 ? !1 : x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      if ((this.right > other.right ? other.right : this.right) <= x02)\n        return !1;\n      const y02 = this.y < other.y ? other.y : this.y;\n      return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;\n    }\n    const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0)\n      return !1;\n    const lt = tempPoints[0].set(other.left, other.top), lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top), rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y)\n      return !1;\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0 || (transform.apply(lt, lt), transform.apply(lb, lb), transform.apply(rt, rt), transform.apply(rb, rb), Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1))\n      return !1;\n    const nx = s * (lb.y - lt.y), ny = s * (lt.x - lb.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y)\n      return !1;\n    const mx = s * (lt.y - rt.y), my = s * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;\n    return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y);\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1, this;\n  }\n}\nRectangle.prototype.toString = function() {\n  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n};\nexports.Rectangle = Rectangle;\n//# sourceMappingURL=Rectangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/shapes/Rectangle.js?");

/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/math/lib/const.js\");\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    this.x = x, this.y = y, this.width = width, this.height = height, this.radius = radius, this.type = _const.SHAPES.RREC;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) {\n      const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n      if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius)\n        return !0;\n      let dx = x - (this.x + radius), dy = y - (this.y + radius);\n      const radius2 = radius * radius;\n      if (dx * dx + dy * dy <= radius2 || (dx = x - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x - (this.x + radius), dx * dx + dy * dy <= radius2))\n        return !0;\n    }\n    return !1;\n  }\n}\nRoundedRectangle.prototype.toString = function() {\n  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n};\nexports.RoundedRectangle = RoundedRectangle;\n//# sourceMappingURL=RoundedRectangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js?");

/***/ }),

/***/ "./node_modules/@pixi/runner/lib/Runner.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/Runner.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass Runner {\n  /**\n   * @param {string} name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [], this._name = name, this._aliasCount = 0;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    if (arguments.length > 8)\n      throw new Error(\"max arguments reached\");\n    const { name, items } = this;\n    this._aliasCount++;\n    for (let i = 0, len = items.length; i < len; i++)\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    return items === this.items && this._aliasCount--, this;\n  }\n  ensureNonAliasedItems() {\n    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * E.g. A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```js\n   * import { Runner } from '@pixi/runner';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.includes(item);\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    return this.ensureNonAliasedItems(), this.items.length = 0, this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll(), this.items.length = 0, this._name = \"\";\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @type {string}\n   */\n  get name() {\n    return this._name;\n  }\n}\nObject.defineProperties(Runner.prototype, {\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method dispatch\n   * @see PIXI.Runner#emit\n   */\n  dispatch: { value: Runner.prototype.emit },\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method run\n   * @see PIXI.Runner#emit\n   */\n  run: { value: Runner.prototype.emit }\n});\nexports.Runner = Runner;\n//# sourceMappingURL=Runner.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/runner/lib/Runner.js?");

/***/ }),

/***/ "./node_modules/@pixi/runner/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar Runner = __webpack_require__(/*! ./Runner.js */ \"./node_modules/@pixi/runner/lib/Runner.js\");\nexports.Runner = Runner.Runner;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/runner/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvas.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvas.js ***!
  \****************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=ICanvas.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/ICanvas.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js ***!
  \**********************************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=ICanvasRenderingContext2D.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/adapter.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/adapter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst BrowserAdapter = {\n  /**\n   * Creates a canvas element of the given size.\n   * This canvas is created using the browser's native canvas element.\n   * @param width - width of the canvas\n   * @param height - height of the canvas\n   */\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    return canvas.width = width, canvas.height = height, canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => new DOMParser().parseFromString(xml, \"text/xml\")\n};\nexports.BrowserAdapter = BrowserAdapter;\n//# sourceMappingURL=adapter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/adapter.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar adapter = __webpack_require__(/*! ./adapter.js */ \"./node_modules/@pixi/settings/lib/adapter.js\");\n__webpack_require__(/*! ./ICanvas.js */ \"./node_modules/@pixi/settings/lib/ICanvas.js\");\n__webpack_require__(/*! ./ICanvasRenderingContext2D.js */ \"./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js\");\nvar settings = __webpack_require__(/*! ./settings.js */ \"./node_modules/@pixi/settings/lib/settings.js\"), isMobile = __webpack_require__(/*! ./utils/isMobile.js */ \"./node_modules/@pixi/settings/lib/utils/isMobile.js\");\nexports.BrowserAdapter = adapter.BrowserAdapter;\nexports.settings = settings.settings;\nexports.isMobile = isMobile.isMobile;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/settings.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/settings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar adapter = __webpack_require__(/*! ./adapter.js */ \"./node_modules/@pixi/settings/lib/adapter.js\");\nconst settings = {\n  /**\n   * This adapter is used to call methods that are platform dependent.\n   * For example `document.createElement` only runs on the web but fails in node environments.\n   * This allows us to support more platforms by abstracting away specific implementations per platform.\n   *\n   * By default the adapter is set to work in the browser. However you can create your own\n   * by implementing the `IAdapter` interface. See `IAdapter` for more information.\n   * @name ADAPTER\n   * @memberof PIXI.settings\n   * @type {PIXI.IAdapter}\n   * @default PIXI.BrowserAdapter\n   */\n  ADAPTER: adapter.BrowserAdapter,\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @static\n   * @name RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  RESOLUTION: 1,\n  /**\n   * Enables bitmap creation before image load. This feature is experimental.\n   * @static\n   * @name CREATE_IMAGE_BITMAP\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  CREATE_IMAGE_BITMAP: !1,\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * @static\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  ROUND_PIXELS: !1\n};\nexports.settings = settings;\n//# sourceMappingURL=settings.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/settings.js?");

/***/ }),

/***/ "./node_modules/@pixi/settings/lib/utils/isMobile.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/utils/isMobile.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar isMobileJs = __webpack_require__(/*! ismobilejs */ \"./node_modules/ismobilejs/esm/index.js\");\nconst isMobileCall = isMobileJs.default ?? isMobileJs, isMobile = isMobileCall(globalThis.navigator);\nexports.isMobile = isMobile;\n//# sourceMappingURL=isMobile.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/settings/lib/utils/isMobile.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/Ticker.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/Ticker.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/ticker/lib/const.js\"), TickerListener = __webpack_require__(/*! ./TickerListener.js */ \"./node_modules/@pixi/ticker/lib/TickerListener.js\");\nconst _Ticker = class _Ticker2 {\n  constructor() {\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener.TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {\n      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority, !0));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next, previous = this._head;\n    if (!current)\n      listener.connect(previous);\n    else {\n      for (; current; ) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current, current = current.next;\n      }\n      listener.previous || listener.connect(previous);\n    }\n    return this._startIfPossible(), this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    for (; listener; )\n      listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head)\n      return 0;\n    let count = 0, current = this._head;\n    for (; current = current.next; )\n      count++;\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      for (; listener; )\n        listener = listener.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link PIXI.Ticker#elapsedMS},\n   * the current {@link PIXI.Ticker#deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link PIXI.Ticker#lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS)\n          return;\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      for (; listener; )\n        listener = listener.emit(this.deltaTime);\n      head.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.Ticker#deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This value is used to cap {@link PIXI.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0)\n      this._minElapsedMS = 0;\n    else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n   * {@link PIXI.VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the PIXI.Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker2._shared) {\n      const shared = _Ticker2._shared = new _Ticker2();\n      shared.autoStart = !0, shared._protected = !0;\n    }\n    return _Ticker2._shared;\n  }\n  /**\n   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get system() {\n    if (!_Ticker2._system) {\n      const system = _Ticker2._system = new _Ticker2();\n      system.autoStart = !0, system._protected = !0;\n    }\n    return _Ticker2._system;\n  }\n};\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\nexports.Ticker = Ticker;\n//# sourceMappingURL=Ticker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/Ticker.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerListener.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerListener.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = !1) {\n    this.next = null, this.previous = null, this._destroyed = !1, this.fn = fn, this.context = context, this.priority = priority, this.once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this.fn === fn && this.context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @private\n   * @param deltaTime - time since the last emit.\n   * @returns Next ticker\n   */\n  emit(deltaTime) {\n    this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));\n    const redirect = this.next;\n    return this.once && this.destroy(!0), this._destroyed && (this.next = null), redirect;\n  }\n  /**\n   * Connect to the list.\n   * @private\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @private\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = !1) {\n    this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n    const redirect = this.next;\n    return this.next = hard ? null : redirect, this.previous = null, redirect;\n  }\n}\nexports.TickerListener = TickerListener;\n//# sourceMappingURL=TickerListener.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/TickerListener.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerPlugin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerPlugin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar extensions = __webpack_require__(/*! @pixi/extensions */ \"./node_modules/@pixi/extensions/lib/index.js\"), _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/ticker/lib/const.js\"), Ticker = __webpack_require__(/*! ./Ticker.js */ \"./node_modules/@pixi/ticker/lib/Ticker.js\");\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: !0,\n      sharedTicker: !1\n    }, options), Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    ), this.stop = () => {\n      this._ticker.stop();\n    }, this.start = () => {\n      this._ticker.start();\n    }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker.Ticker.shared : new Ticker.Ticker(), options.autoStart && this.start();\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null, oldTicker.destroy();\n    }\n  }\n}\nTickerPlugin.extension = extensions.ExtensionType.Application;\nextensions.extensions.add(TickerPlugin);\nexports.TickerPlugin = TickerPlugin;\n//# sourceMappingURL=TickerPlugin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/TickerPlugin.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/const.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/const.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => (UPDATE_PRIORITY2[UPDATE_PRIORITY2.INTERACTION = 50] = \"INTERACTION\", UPDATE_PRIORITY2[UPDATE_PRIORITY2.HIGH = 25] = \"HIGH\", UPDATE_PRIORITY2[UPDATE_PRIORITY2.NORMAL = 0] = \"NORMAL\", UPDATE_PRIORITY2[UPDATE_PRIORITY2.LOW = -25] = \"LOW\", UPDATE_PRIORITY2[UPDATE_PRIORITY2.UTILITY = -50] = \"UTILITY\", UPDATE_PRIORITY2))(UPDATE_PRIORITY || {});\nexports.UPDATE_PRIORITY = UPDATE_PRIORITY;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/const.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ./settings.js */ \"./node_modules/@pixi/ticker/lib/settings.js\");\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/ticker/lib/const.js\"), Ticker = __webpack_require__(/*! ./Ticker.js */ \"./node_modules/@pixi/ticker/lib/Ticker.js\"), TickerPlugin = __webpack_require__(/*! ./TickerPlugin.js */ \"./node_modules/@pixi/ticker/lib/TickerPlugin.js\");\nexports.UPDATE_PRIORITY = _const.UPDATE_PRIORITY;\nexports.Ticker = Ticker.Ticker;\nexports.TickerPlugin = TickerPlugin.TickerPlugin;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/settings.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/settings.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), utils = __webpack_require__(/*! @pixi/utils */ \"./node_modules/@pixi/utils/lib/index.js\"), Ticker = __webpack_require__(/*! ./Ticker.js */ \"./node_modules/@pixi/ticker/lib/Ticker.js\");\nObject.defineProperties(settings.settings, {\n  /**\n   * Target frames per millisecond.\n   * @static\n   * @name TARGET_FPMS\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.Ticker.targetFPMS\n   */\n  TARGET_FPMS: {\n    get() {\n      return Ticker.Ticker.targetFPMS;\n    },\n    set(value) {\n      utils.deprecation(\"7.1.0\", \"settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS\"), Ticker.Ticker.targetFPMS = value;\n    }\n  }\n});\nObject.defineProperty(exports, \"settings\", ({\n  enumerable: !0,\n  get: function() {\n    return settings.settings;\n  }\n}));\n//# sourceMappingURL=settings.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/ticker/lib/settings.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\");\nlet promise;\nasync function detectVideoAlphaMode() {\n  return promise ?? (promise = (async () => {\n    const gl = document.createElement(\"canvas\").getContext(\"webgl\");\n    if (!gl)\n      return constants.ALPHA_MODES.UNPACK;\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2), video2.onerror = () => resolve(null), video2.autoplay = !1, video2.crossOrigin = \"anonymous\", video2.preload = \"auto\", video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\", video2.load();\n    });\n    if (!video)\n      return constants.ALPHA_MODES.UNPACK;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    ), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    return gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel), gl.deleteFramebuffer(framebuffer), gl.deleteTexture(texture), gl.getExtension(\"WEBGL_lose_context\")?.loseContext(), pixel[0] <= pixel[3] ? constants.ALPHA_MODES.PMA : constants.ALPHA_MODES.UNPACK;\n  })()), promise;\n}\nexports.detectVideoAlphaMode = detectVideoAlphaMode;\n//# sourceMappingURL=detectVideoAlphaMode.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/hello.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/hello.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar deprecation = __webpack_require__(/*! ../logging/deprecation.js */ \"./node_modules/@pixi/utils/lib/logging/deprecation.js\");\nfunction skipHello() {\n  deprecation.deprecation(\"7.0.0\", \"skipHello is deprecated, please use settings.RENDER_OPTIONS.hello\");\n}\nfunction sayHello() {\n  deprecation.deprecation(\"7.0.0\", `sayHello is deprecated, please use Renderer's \"hello\" option`);\n}\nexports.sayHello = sayHello;\nexports.skipHello = skipHello;\n//# sourceMappingURL=hello.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/browser/hello.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ../settings.js */ \"./node_modules/@pixi/utils/lib/settings.js\");\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nlet supported;\nfunction isWebGLSupported() {\n  return typeof supported > \"u\" && (supported = function() {\n    const contextOptions = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings.settings.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      const canvas = settings.settings.ADAPTER.createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions) || canvas.getContext(\"experimental-webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        loseContext && loseContext.loseContext();\n      }\n      return gl = null, success;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\nexports.isWebGLSupported = isWebGLSupported;\n//# sourceMappingURL=isWebGLSupported.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), deprecation = __webpack_require__(/*! ../logging/deprecation.js */ \"./node_modules/@pixi/utils/lib/logging/deprecation.js\");\nfunction hex2rgb(hex, out = []) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.hex2rgb is deprecated, use Color#toRgbArray instead\"), color.Color.shared.setValue(hex).toRgbArray(out);\n}\nfunction hex2string(hex) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.hex2string is deprecated, use Color#toHex instead\"), color.Color.shared.setValue(hex).toHex();\n}\nfunction string2hex(string) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.string2hex is deprecated, use Color#toNumber instead\"), color.Color.shared.setValue(string).toNumber();\n}\nfunction rgb2hex(rgb) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.rgb2hex is deprecated, use Color#toNumber instead\"), color.Color.shared.setValue(rgb).toNumber();\n}\nexports.hex2rgb = hex2rgb;\nexports.hex2string = hex2string;\nexports.rgb2hex = rgb2hex;\nexports.string2hex = string2hex;\n//# sourceMappingURL=hex.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/color/hex.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/premultiply.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/premultiply.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar color = __webpack_require__(/*! @pixi/color */ \"./node_modules/@pixi/color/lib/index.js\"), constants = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.js\"), deprecation = __webpack_require__(/*! ../logging/deprecation.js */ \"./node_modules/@pixi/utils/lib/logging/deprecation.js\");\nfunction mapPremultipliedBlendModes() {\n  const pm = [], npm = [];\n  for (let i = 0; i < 32; i++)\n    pm[i] = i, npm[i] = i;\n  pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL, pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD, pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN, npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM, npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM, npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;\n  const array = [];\n  return array.push(npm), array.push(pm), array;\n}\nconst premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply = !0) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.premultiplyRgba has moved to Color.premultiply\"), color.Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\nfunction premultiplyTint(tint, alpha) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.premultiplyTint has moved to Color.toPremultiplied\"), color.Color.shared.setValue(tint).toPremultiplied(alpha);\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply = !0) {\n  return deprecation.deprecation(\"7.2.0\", \"utils.premultiplyTintToRgba has moved to Color.premultiply\"), color.Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\nexports.correctBlendMode = correctBlendMode;\nexports.premultiplyBlendMode = premultiplyBlendMode;\nexports.premultiplyRgba = premultiplyRgba;\nexports.premultiplyTint = premultiplyTint;\nexports.premultiplyTintToRgba = premultiplyTintToRgba;\n//# sourceMappingURL=premultiply.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/color/premultiply.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/const.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/const.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nexports.DATA_URI = DATA_URI;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/const.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    outBuffer[i + 0] = j + 0, outBuffer[i + 1] = j + 1, outBuffer[i + 2] = j + 2, outBuffer[i + 3] = j + 0, outBuffer[i + 4] = j + 2, outBuffer[i + 5] = j + 3;\n  return outBuffer;\n}\nexports.createIndicesForQuads = createIndicesForQuads;\n//# sourceMappingURL=createIndicesForQuads.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/getBufferType.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/getBufferType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4)\n    return array instanceof Float32Array ? \"Float32Array\" : array instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nexports.getBufferType = getBufferType;\n//# sourceMappingURL=getBufferType.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/getBufferType.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar getBufferType = __webpack_require__(/*! ./getBufferType.js */ \"./node_modules/@pixi/utils/lib/data/getBufferType.js\");\nconst map = { Float32Array, Uint32Array, Int32Array, Uint8Array };\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0, stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++)\n    stride += sizes[i], outSize += arrays[i].length;\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null, littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i], array = arrays[i], type = getBufferType.getBufferType(array);\n    views[type] || (views[type] = new map[type](buffer)), out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\nexports.interleaveTypedArrays = interleaveTypedArrays;\n//# sourceMappingURL=interleaveTypedArrays.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/pow2.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/pow2.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction nextPow2(v) {\n  return v += v === 0 ? 1 : 0, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, v |= v >>> 16, v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  return v >>>= shift, r |= shift, shift = (v > 15 ? 1 : 0) << 2, v >>>= shift, r |= shift, shift = (v > 3 ? 1 : 0) << 1, v >>>= shift, r |= shift, r | v >> 1;\n}\nexports.isPow2 = isPow2;\nexports.log2 = log2;\nexports.nextPow2 = nextPow2;\n//# sourceMappingURL=pow2.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/pow2.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/removeItems.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/removeItems.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0)\n    return;\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i)\n    arr[i] = arr[i + removeCount];\n  arr.length = len;\n}\nexports.removeItems = removeItems;\n//# sourceMappingURL=removeItems.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/removeItems.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/sign.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/sign.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction sign(n) {\n  return n === 0 ? 0 : n < 0 ? -1 : 1;\n}\nexports.sign = sign;\n//# sourceMappingURL=sign.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/sign.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/uid.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/uid.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nlet nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nexports.uid = uid;\n//# sourceMappingURL=uid.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/data/uid.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ./settings.js */ \"./node_modules/@pixi/utils/lib/settings.js\");\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\"), eventemitter3 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"), earcut = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\"), url = __webpack_require__(/*! ./url.js */ \"./node_modules/@pixi/utils/lib/url.js\"), path = __webpack_require__(/*! ./path.js */ \"./node_modules/@pixi/utils/lib/path.js\"), detectVideoAlphaMode = __webpack_require__(/*! ./browser/detectVideoAlphaMode.js */ \"./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js\"), hello = __webpack_require__(/*! ./browser/hello.js */ \"./node_modules/@pixi/utils/lib/browser/hello.js\"), isWebGLSupported = __webpack_require__(/*! ./browser/isWebGLSupported.js */ \"./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js\"), hex = __webpack_require__(/*! ./color/hex.js */ \"./node_modules/@pixi/utils/lib/color/hex.js\"), premultiply = __webpack_require__(/*! ./color/premultiply.js */ \"./node_modules/@pixi/utils/lib/color/premultiply.js\"), _const = __webpack_require__(/*! ./const.js */ \"./node_modules/@pixi/utils/lib/const.js\"), createIndicesForQuads = __webpack_require__(/*! ./data/createIndicesForQuads.js */ \"./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js\"), getBufferType = __webpack_require__(/*! ./data/getBufferType.js */ \"./node_modules/@pixi/utils/lib/data/getBufferType.js\"), interleaveTypedArrays = __webpack_require__(/*! ./data/interleaveTypedArrays.js */ \"./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js\"), pow2 = __webpack_require__(/*! ./data/pow2.js */ \"./node_modules/@pixi/utils/lib/data/pow2.js\"), removeItems = __webpack_require__(/*! ./data/removeItems.js */ \"./node_modules/@pixi/utils/lib/data/removeItems.js\"), sign = __webpack_require__(/*! ./data/sign.js */ \"./node_modules/@pixi/utils/lib/data/sign.js\"), uid = __webpack_require__(/*! ./data/uid.js */ \"./node_modules/@pixi/utils/lib/data/uid.js\"), deprecation = __webpack_require__(/*! ./logging/deprecation.js */ \"./node_modules/@pixi/utils/lib/logging/deprecation.js\"), BoundingBox = __webpack_require__(/*! ./media/BoundingBox.js */ \"./node_modules/@pixi/utils/lib/media/BoundingBox.js\"), caches = __webpack_require__(/*! ./media/caches.js */ \"./node_modules/@pixi/utils/lib/media/caches.js\"), CanvasRenderTarget = __webpack_require__(/*! ./media/CanvasRenderTarget.js */ \"./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js\"), getCanvasBoundingBox = __webpack_require__(/*! ./media/getCanvasBoundingBox.js */ \"./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js\"), trimCanvas = __webpack_require__(/*! ./media/trimCanvas.js */ \"./node_modules/@pixi/utils/lib/media/trimCanvas.js\"), decomposeDataUri = __webpack_require__(/*! ./network/decomposeDataUri.js */ \"./node_modules/@pixi/utils/lib/network/decomposeDataUri.js\"), determineCrossOrigin = __webpack_require__(/*! ./network/determineCrossOrigin.js */ \"./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js\"), getResolutionOfUrl = __webpack_require__(/*! ./network/getResolutionOfUrl.js */ \"./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js\");\n__webpack_require__(/*! ./types/index.js */ \"./node_modules/@pixi/utils/lib/types/index.js\");\nObject.defineProperty(exports, \"isMobile\", ({\n  enumerable: !0,\n  get: function() {\n    return settings.isMobile;\n  }\n}));\nexports.EventEmitter = eventemitter3;\nexports.earcut = earcut;\nexports.url = url.url;\nexports.path = path.path;\nexports.detectVideoAlphaMode = detectVideoAlphaMode.detectVideoAlphaMode;\nexports.sayHello = hello.sayHello;\nexports.skipHello = hello.skipHello;\nexports.isWebGLSupported = isWebGLSupported.isWebGLSupported;\nexports.hex2rgb = hex.hex2rgb;\nexports.hex2string = hex.hex2string;\nexports.rgb2hex = hex.rgb2hex;\nexports.string2hex = hex.string2hex;\nexports.correctBlendMode = premultiply.correctBlendMode;\nexports.premultiplyBlendMode = premultiply.premultiplyBlendMode;\nexports.premultiplyRgba = premultiply.premultiplyRgba;\nexports.premultiplyTint = premultiply.premultiplyTint;\nexports.premultiplyTintToRgba = premultiply.premultiplyTintToRgba;\nexports.DATA_URI = _const.DATA_URI;\nexports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;\nexports.getBufferType = getBufferType.getBufferType;\nexports.interleaveTypedArrays = interleaveTypedArrays.interleaveTypedArrays;\nexports.isPow2 = pow2.isPow2;\nexports.log2 = pow2.log2;\nexports.nextPow2 = pow2.nextPow2;\nexports.removeItems = removeItems.removeItems;\nexports.sign = sign.sign;\nexports.uid = uid.uid;\nexports.deprecation = deprecation.deprecation;\nexports.BoundingBox = BoundingBox.BoundingBox;\nexports.BaseTextureCache = caches.BaseTextureCache;\nexports.ProgramCache = caches.ProgramCache;\nexports.TextureCache = caches.TextureCache;\nexports.clearTextureCache = caches.clearTextureCache;\nexports.destroyTextureCache = caches.destroyTextureCache;\nexports.CanvasRenderTarget = CanvasRenderTarget.CanvasRenderTarget;\nexports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;\nexports.trimCanvas = trimCanvas.trimCanvas;\nexports.decomposeDataUri = decomposeDataUri.decomposeDataUri;\nexports.determineCrossOrigin = determineCrossOrigin.determineCrossOrigin;\nexports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/logging/deprecation.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/logging/deprecation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst warnings = {};\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message])\n    return;\n  let stack = new Error().stack;\n  typeof stack > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`) : (stack = stack.split(`\n`).splice(ignoreDepth).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\n    \"%cPixiJS Deprecation Warning: %c%s\",\n    \"color:#614108;background:#fffbe6\",\n    \"font-weight:normal;color:#614108;background:#fffbe6\",\n    `${message}\nDeprecated since v${version}`\n  ), console.warn(stack), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`), console.warn(stack))), warnings[message] = !0;\n}\nexports.deprecation = deprecation;\n//# sourceMappingURL=deprecation.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/logging/deprecation.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/BoundingBox.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/BoundingBox.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst _BoundingBox = class {\n  /**\n   * @param left - The left coordinate value of the bounding box.\n   * @param top - The top coordinate value of the bounding box.\n   * @param right - The right coordinate value of the bounding box.\n   * @param bottom - The bottom coordinate value of the bounding box.\n   */\n  constructor(left, top, right, bottom) {\n    this.left = left, this.top = top, this.right = right, this.bottom = bottom;\n  }\n  /** The width of the bounding box. */\n  get width() {\n    return this.right - this.left;\n  }\n  /** The height of the bounding box. */\n  get height() {\n    return this.bottom - this.top;\n  }\n  /** Determines whether the BoundingBox is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n};\n_BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);\nlet BoundingBox = _BoundingBox;\nexports.BoundingBox = BoundingBox;\n//# sourceMappingURL=BoundingBox.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/media/BoundingBox.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nclass CanvasRenderTarget {\n  /**\n   * @param width - the width for the newly created canvas\n   * @param height - the height for the newly created canvas\n   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas\n   */\n  constructor(width, height, resolution) {\n    this._canvas = settings.settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext(\"2d\"), this.resolution = resolution || settings.settings.RESOLUTION, this.resize(width, height);\n  }\n  /**\n   * Clears the canvas that was created by the CanvasRenderTarget class.\n   * @private\n   */\n  clear() {\n    this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  }\n  /**\n   * Resizes the canvas to the specified width and height.\n   * @param desiredWidth - the desired width of the canvas\n   * @param desiredHeight - the desired height of the canvas\n   */\n  resize(desiredWidth, desiredHeight) {\n    this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);\n  }\n  /** Destroys this canvas. */\n  destroy() {\n    this._context = null, this._canvas = null;\n  }\n  /**\n   * The width of the canvas buffer in pixels.\n   * @member {number}\n   */\n  get width() {\n    return this._checkDestroyed(), this._canvas.width;\n  }\n  set width(val) {\n    this._checkDestroyed(), this._canvas.width = Math.round(val);\n  }\n  /**\n   * The height of the canvas buffer in pixels.\n   * @member {number}\n   */\n  get height() {\n    return this._checkDestroyed(), this._canvas.height;\n  }\n  set height(val) {\n    this._checkDestroyed(), this._canvas.height = Math.round(val);\n  }\n  /** The Canvas object that belongs to this CanvasRenderTarget. */\n  get canvas() {\n    return this._checkDestroyed(), this._canvas;\n  }\n  /** A CanvasRenderingContext2D object representing a two-dimensional rendering context. */\n  get context() {\n    return this._checkDestroyed(), this._context;\n  }\n  _checkDestroyed() {\n    if (this._canvas === null)\n      throw new TypeError(\"The CanvasRenderTarget has already been destroyed\");\n  }\n}\nexports.CanvasRenderTarget = CanvasRenderTarget;\n//# sourceMappingURL=CanvasRenderTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/caches.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/caches.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction destroyTextureCache() {\n  let key;\n  for (key in TextureCache)\n    TextureCache[key].destroy();\n  for (key in BaseTextureCache)\n    BaseTextureCache[key].destroy();\n}\nfunction clearTextureCache() {\n  let key;\n  for (key in TextureCache)\n    delete TextureCache[key];\n  for (key in BaseTextureCache)\n    delete BaseTextureCache[key];\n}\nexports.BaseTextureCache = BaseTextureCache;\nexports.ProgramCache = ProgramCache;\nexports.TextureCache = TextureCache;\nexports.clearTextureCache = clearTextureCache;\nexports.destroyTextureCache = destroyTextureCache;\n//# sourceMappingURL=caches.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/media/caches.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar BoundingBox = __webpack_require__(/*! ./BoundingBox.js */ \"./node_modules/@pixi/utils/lib/media/BoundingBox.js\");\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    if (data[index + 3] !== 0)\n      return !1;\n  return !0;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride)\n    if (data[index + 3] !== 0)\n      return !1;\n  return !0;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const { width, height } = canvas, context = canvas.getContext(\"2d\", {\n    willReadFrequently: !0\n  });\n  if (context === null)\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  const data = context.getImageData(0, 0, width, height).data;\n  let left = 0, top = 0, right = width - 1, bottom = height - 1;\n  for (; top < height && checkRow(data, width, top); )\n    ++top;\n  if (top === height)\n    return BoundingBox.BoundingBox.EMPTY;\n  for (; checkRow(data, width, bottom); )\n    --bottom;\n  for (; checkColumn(data, width, left, top, bottom); )\n    ++left;\n  for (; checkColumn(data, width, right, top, bottom); )\n    --right;\n  return ++right, ++bottom, new BoundingBox.BoundingBox(left, top, right, bottom);\n}\nexports.getCanvasBoundingBox = getCanvasBoundingBox;\n//# sourceMappingURL=getCanvasBoundingBox.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/trimCanvas.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/trimCanvas.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar getCanvasBoundingBox = __webpack_require__(/*! ./getCanvasBoundingBox.js */ \"./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js\");\nfunction trimCanvas(canvas) {\n  const boundingBox = getCanvasBoundingBox.getCanvasBoundingBox(canvas), { width, height } = boundingBox;\n  let data = null;\n  if (!boundingBox.isEmpty()) {\n    const context = canvas.getContext(\"2d\");\n    if (context === null)\n      throw new TypeError(\"Failed to get canvas 2D context\");\n    data = context.getImageData(\n      boundingBox.left,\n      boundingBox.top,\n      width,\n      height\n    );\n  }\n  return { width, height, data };\n}\nexports.trimCanvas = trimCanvas;\n//# sourceMappingURL=trimCanvas.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/media/trimCanvas.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/decomposeDataUri.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/decomposeDataUri.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/@pixi/utils/lib/const.js\");\nfunction decomposeDataUri(dataUri) {\n  const dataUriMatch = _const.DATA_URI.exec(dataUri);\n  if (dataUriMatch)\n    return {\n      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,\n      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,\n      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,\n      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,\n      data: dataUriMatch[5]\n    };\n}\nexports.decomposeDataUri = decomposeDataUri;\n//# sourceMappingURL=decomposeDataUri.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/network/decomposeDataUri.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\"))\n    return \"\";\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? \"anonymous\" : \"\";\n}\nexports.determineCrossOrigin = determineCrossOrigin;\n//# sourceMappingURL=determineCrossOrigin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n__webpack_require__(/*! ../settings.js */ \"./node_modules/@pixi/utils/lib/settings.js\");\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = settings.settings.RETINA_PREFIX?.exec(url);\n  return resolution ? parseFloat(resolution[1]) : defaultValue;\n}\nexports.getResolutionOfUrl = getResolutionOfUrl;\n//# sourceMappingURL=getResolutionOfUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/path.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nfunction assertPath(path2) {\n  if (typeof path2 != \"string\")\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction removeUrlParams(url) {\n  return url.split(\"?\")[0].split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length)\n      code = path2.charCodeAt(i);\n    else {\n      if (code === 47)\n        break;\n      code = 47;\n    }\n    if (code === 47) {\n      if (!(lastSlash === i - 1 || dots === 1))\n        if (lastSlash !== i - 1 && dots === 2) {\n          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n            if (res.length > 2) {\n              const lastSlashIndex = res.lastIndexOf(\"/\");\n              if (lastSlashIndex !== res.length - 1) {\n                lastSlashIndex === -1 ? (res = \"\", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\")), lastSlash = i, dots = 0;\n                continue;\n              }\n            } else if (res.length === 2 || res.length === 1) {\n              res = \"\", lastSegmentLength = 0, lastSlash = i, dots = 0;\n              continue;\n            }\n          }\n          allowAboveRoot && (res.length > 0 ? res += \"/..\" : res = \"..\", lastSegmentLength = 2);\n        } else\n          res.length > 0 ? res += `/${path2.slice(lastSlash + 1, i)}` : res = path2.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;\n      lastSlash = i, dots = 0;\n    } else\n      code === 46 && dots !== -1 ? ++dots : dots = -1;\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2), path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile)\n      return matchFile[0];\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    return matchProtocol ? matchProtocol[0] : \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    if (assertPath(url), this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.settings.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    return url = this.toPosix(url), url.startsWith(\"/\") ? path.join(rootUrl, url.slice(1)) : this.isAbsolute(url) ? url : this.join(baseUrl, url);\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    if (assertPath(path2), path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    this.hasProtocol(path2) && (protocol = this.rootname(path2), path2 = path2.slice(protocol.length));\n    const trailingSeparator = path2.endsWith(\"/\");\n    return path2 = normalizeStringPosix(path2, !1), path2.length > 0 && trailingSeparator && (path2 += \"/\"), isAbsolute ? `/${path2}` : protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    return assertPath(path2), path2 = this.toPosix(path2), this.hasProtocol(path2) ? !0 : path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0)\n      return \".\";\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      if (assertPath(arg), arg.length > 0)\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          this.joinExtensions.includes(this.extname(prevArg).toLowerCase()) ? joined += `/../${arg}` : joined += `/${arg}`;\n        }\n    }\n    return joined === void 0 ? \".\" : this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    if (assertPath(path2), path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1, matchedSlash = !0;\n    const proto = this.getProtocol(path2), origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i)\n      if (code = path2.charCodeAt(i), code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else\n        matchedSlash = !1;\n    return end === -1 ? hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto : hasRoot && end === 1 ? \"//\" : proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2), path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\") ? root = \"/\" : root = this.getProtocol(path2), this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      index !== -1 ? root = path2.slice(0, index) : root = path2, root.endsWith(\"/\") || (root += \"/\");\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2), ext && assertPath(ext), path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0, end = -1, matchedSlash = !0, i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1, firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else\n          firstNonSlashEnd === -1 && (matchedSlash = !1, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i) : (extIdx = -1, end = firstNonSlashEnd));\n      }\n      return start === end ? end = firstNonSlashEnd : end === -1 && (end = path2.length), path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i)\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else\n        end === -1 && (matchedSlash = !1, end = i + 1);\n    return end === -1 ? \"\" : path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2), path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);\n    }\n    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? \"\" : path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2), isAbsolute || this.hasProtocol(path2) ? start = 1 : start = 0;\n    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, i = path2.length - 1, preDotState = 0;\n    for (; i >= start; --i) {\n      if (code = path2.charCodeAt(i), code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);\n    }\n    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path2.slice(1, end) : ret.base = ret.name = path2.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path2.slice(1, startDot), ret.base = path2.slice(1, end)) : (ret.name = path2.slice(startPart, startDot), ret.base = path2.slice(startPart, end)), ret.ext = path2.slice(startDot, end)), ret.dir = this.dirname(path2), protocol && (ret.dir = protocol + ret.dir), ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\nexports.path = path;\n//# sourceMappingURL=path.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/path.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/settings.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/settings.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar settings = __webpack_require__(/*! @pixi/settings */ \"./node_modules/@pixi/settings/lib/index.js\");\nsettings.settings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nObject.defineProperty(exports, \"settings\", ({\n  enumerable: !0,\n  get: function() {\n    return settings.settings;\n  }\n}));\n//# sourceMappingURL=settings.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/settings.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/types/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/types/index.js ***!
  \*****************************************************/
/***/ (() => {

"use strict";
eval("\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/types/index.js?");

/***/ }),

/***/ "./node_modules/@pixi/utils/lib/url.js":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/url.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar url$1 = __webpack_require__(/*! url */ \"./node_modules/url/url.js\"), deprecation = __webpack_require__(/*! ./logging/deprecation.js */ \"./node_modules/@pixi/utils/lib/logging/deprecation.js\");\nconst url = {\n  /**\n   * @deprecated since 7.3.0\n   */\n  get parse() {\n    return deprecation.deprecation(\"7.3.0\", \"utils.url.parse is deprecated, use native URL API instead.\"), url$1.parse;\n  },\n  /**\n   * @deprecated since 7.3.0\n   */\n  get format() {\n    return deprecation.deprecation(\"7.3.0\", \"utils.url.format is deprecated, use native URL API instead.\"), url$1.format;\n  },\n  /**\n   * @deprecated since 7.3.0\n   */\n  get resolve() {\n    return deprecation.deprecation(\"7.3.0\", \"utils.url.resolve is deprecated, use native URL API instead.\"), url$1.resolve;\n  }\n};\nexports.url = url;\n//# sourceMappingURL=url.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@pixi/utils/lib/url.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/conventions.js":
/*!********************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/conventions.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/**\n * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.\n *\n * Works with anything that has a `length` property and index access properties, including NodeList.\n *\n * @template {unknown} T\n * @param {Array<T> | ({length:number, [number]: T})} list\n * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate\n * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,\n * \t\t\t\tallows injecting a custom implementation in tests\n * @returns {T | undefined}\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find\n */\nfunction find(list, predicate, ac) {\n\tif (ac === undefined) {\n\t\tac = Array.prototype;\n\t}\n\tif (list && typeof ac.find === 'function') {\n\t\treturn ac.find.call(list, predicate);\n\t}\n\tfor (var i = 0; i < list.length; i++) {\n\t\tif (Object.prototype.hasOwnProperty.call(list, i)) {\n\t\t\tvar item = list[i];\n\t\t\tif (predicate.call(undefined, item, i, list)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * \"Shallow freezes\" an object to render it immutable.\n * Uses `Object.freeze` if available,\n * otherwise the immutability is only in the type.\n *\n * Is used to create \"enum like\" objects.\n *\n * @template T\n * @param {T} object the object to freeze\n * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,\n * \t\t\t\tallows to inject custom object constructor for tests\n * @returns {Readonly<T>}\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n */\nfunction freeze(object, oc) {\n\tif (oc === undefined) {\n\t\toc = Object\n\t}\n\treturn oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object\n}\n\n/**\n * Since we can not rely on `Object.assign` we provide a simplified version\n * that is sufficient for our needs.\n *\n * @param {Object} target\n * @param {Object | null | undefined} source\n *\n * @returns {Object} target\n * @throws TypeError if target is not an object\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign\n */\nfunction assign(target, source) {\n\tif (target === null || typeof target !== 'object') {\n\t\tthrow new TypeError('target is not an object')\n\t}\n\tfor (var key in source) {\n\t\tif (Object.prototype.hasOwnProperty.call(source, key)) {\n\t\t\ttarget[key] = source[key]\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * All mime types that are allowed as input to `DOMParser.parseFromString`\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec\n * @see DOMParser.prototype.parseFromString\n */\nvar MIME_TYPE = freeze({\n\t/**\n\t * `text/html`, the only mime type that triggers treating an XML document as HTML.\n\t *\n\t * @see DOMParser.SupportedType.isHTML\n\t * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n\t * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n\t * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec\n\t */\n\tHTML: 'text/html',\n\n\t/**\n\t * Helper method to check a mime type if it indicates an HTML document\n\t *\n\t * @param {string} [value]\n\t * @returns {boolean}\n\t *\n\t * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n\t * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n\t * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring \t */\n\tisHTML: function (value) {\n\t\treturn value === MIME_TYPE.HTML\n\t},\n\n\t/**\n\t * `application/xml`, the standard mime type for XML documents.\n\t *\n\t * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration\n\t * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303\n\t * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n\t */\n\tXML_APPLICATION: 'application/xml',\n\n\t/**\n\t * `text/html`, an alias for `application/xml`.\n\t *\n\t * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303\n\t * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration\n\t * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n\t */\n\tXML_TEXT: 'text/xml',\n\n\t/**\n\t * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,\n\t * but is parsed as an XML document.\n\t *\n\t * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec\n\t * @see https://en.wikipedia.org/wiki/XHTML Wikipedia\n\t */\n\tXML_XHTML_APPLICATION: 'application/xhtml+xml',\n\n\t/**\n\t * `image/svg+xml`,\n\t *\n\t * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration\n\t * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1\n\t * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia\n\t */\n\tXML_SVG_IMAGE: 'image/svg+xml',\n})\n\n/**\n * Namespaces that are used in this code base.\n *\n * @see http://www.w3.org/TR/REC-xml-names\n */\nvar NAMESPACE = freeze({\n\t/**\n\t * The XHTML namespace.\n\t *\n\t * @see http://www.w3.org/1999/xhtml\n\t */\n\tHTML: 'http://www.w3.org/1999/xhtml',\n\n\t/**\n\t * Checks if `uri` equals `NAMESPACE.HTML`.\n\t *\n\t * @param {string} [uri]\n\t *\n\t * @see NAMESPACE.HTML\n\t */\n\tisHTML: function (uri) {\n\t\treturn uri === NAMESPACE.HTML\n\t},\n\n\t/**\n\t * The SVG namespace.\n\t *\n\t * @see http://www.w3.org/2000/svg\n\t */\n\tSVG: 'http://www.w3.org/2000/svg',\n\n\t/**\n\t * The `xml:` namespace.\n\t *\n\t * @see http://www.w3.org/XML/1998/namespace\n\t */\n\tXML: 'http://www.w3.org/XML/1998/namespace',\n\n\t/**\n\t * The `xmlns:` namespace\n\t *\n\t * @see https://www.w3.org/2000/xmlns/\n\t */\n\tXMLNS: 'http://www.w3.org/2000/xmlns/',\n})\n\nexports.assign = assign;\nexports.find = find;\nexports.freeze = freeze;\nexports.MIME_TYPE = MIME_TYPE;\nexports.NAMESPACE = NAMESPACE;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/conventions.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom-parser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var conventions = __webpack_require__(/*! ./conventions */ \"./node_modules/@xmldom/xmldom/lib/conventions.js\");\nvar dom = __webpack_require__(/*! ./dom */ \"./node_modules/@xmldom/xmldom/lib/dom.js\")\nvar entities = __webpack_require__(/*! ./entities */ \"./node_modules/@xmldom/xmldom/lib/entities.js\");\nvar sax = __webpack_require__(/*! ./sax */ \"./node_modules/@xmldom/xmldom/lib/sax.js\");\n\nvar DOMImplementation = dom.DOMImplementation;\n\nvar NAMESPACE = conventions.NAMESPACE;\n\nvar ParseError = sax.ParseError;\nvar XMLReader = sax.XMLReader;\n\n/**\n * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:\n *\n * > XML parsed entities are often stored in computer files which,\n * > for editing convenience, are organized into lines.\n * > These lines are typically separated by some combination\n * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n * >\n * > To simplify the tasks of applications, the XML processor must behave\n * > as if it normalized all line breaks in external parsed entities (including the document entity)\n * > on input, before parsing, by translating all of the following to a single #xA character:\n * >\n * > 1. the two-character sequence #xD #xA\n * > 2. the two-character sequence #xD #x85\n * > 3. the single character #x85\n * > 4. the single character #x2028\n * > 5. any #xD character that is not immediately followed by #xA or #x85.\n *\n * @param {string} input\n * @returns {string}\n */\nfunction normalizeLineEndings(input) {\n\treturn input\n\t\t.replace(/\\r[\\n\\u0085]/g, '\\n')\n\t\t.replace(/[\\r\\u0085\\u2028]/g, '\\n')\n}\n\n/**\n * @typedef Locator\n * @property {number} [columnNumber]\n * @property {number} [lineNumber]\n */\n\n/**\n * @typedef DOMParserOptions\n * @property {DOMHandler} [domBuilder]\n * @property {Function} [errorHandler]\n * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing\n * \t\t\t\t\t\tdefaults to `normalizeLineEndings`\n * @property {Locator} [locator]\n * @property {Record<string, string>} [xmlns]\n *\n * @see normalizeLineEndings\n */\n\n/**\n * The DOMParser interface provides the ability to parse XML or HTML source code\n * from a string into a DOM `Document`.\n *\n * _xmldom is different from the spec in that it allows an `options` parameter,\n * to override the default behavior._\n *\n * @param {DOMParserOptions} [options]\n * @constructor\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n */\nfunction DOMParser(options){\n\tthis.options = options ||{locator:{}};\n}\n\nDOMParser.prototype.parseFromString = function(source,mimeType){\n\tvar options = this.options;\n\tvar sax =  new XMLReader();\n\tvar domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler\n\tvar errorHandler = options.errorHandler;\n\tvar locator = options.locator;\n\tvar defaultNSMap = options.xmlns||{};\n\tvar isHTML = /\\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;\n  \tvar entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\n\tif(locator){\n\t\tdomBuilder.setDocumentLocator(locator)\n\t}\n\n\tsax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);\n\tsax.domBuilder = options.domBuilder || domBuilder;\n\tif(isHTML){\n\t\tdefaultNSMap[''] = NAMESPACE.HTML;\n\t}\n\tdefaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n\tvar normalize = options.normalizeLineEndings || normalizeLineEndings;\n\tif (source && typeof source === 'string') {\n\t\tsax.parse(\n\t\t\tnormalize(source),\n\t\t\tdefaultNSMap,\n\t\t\tentityMap\n\t\t)\n\t} else {\n\t\tsax.errorHandler.error('invalid doc source')\n\t}\n\treturn domBuilder.doc;\n}\nfunction buildErrorHandler(errorImpl,domBuilder,locator){\n\tif(!errorImpl){\n\t\tif(domBuilder instanceof DOMHandler){\n\t\t\treturn domBuilder;\n\t\t}\n\t\terrorImpl = domBuilder ;\n\t}\n\tvar errorHandler = {}\n\tvar isCallback = errorImpl instanceof Function;\n\tlocator = locator||{}\n\tfunction build(key){\n\t\tvar fn = errorImpl[key];\n\t\tif(!fn && isCallback){\n\t\t\tfn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;\n\t\t}\n\t\terrorHandler[key] = fn && function(msg){\n\t\t\tfn('[xmldom '+key+']\\t'+msg+_locator(locator));\n\t\t}||function(){};\n\t}\n\tbuild('warning');\n\tbuild('error');\n\tbuild('fatalError');\n\treturn errorHandler;\n}\n\n//console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n/**\n * +ContentHandler+ErrorHandler\n * +LexicalHandler+EntityResolver2\n * -DeclHandler-DTDHandler\n *\n * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\n * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\n * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\n */\nfunction DOMHandler() {\n    this.cdata = false;\n}\nfunction position(locator,node){\n\tnode.lineNumber = locator.lineNumber;\n\tnode.columnNumber = locator.columnNumber;\n}\n/**\n * @see org.xml.sax.ContentHandler#startDocument\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n */\nDOMHandler.prototype = {\n\tstartDocument : function() {\n    \tthis.doc = new DOMImplementation().createDocument(null, null, null);\n    \tif (this.locator) {\n        \tthis.doc.documentURI = this.locator.systemId;\n    \t}\n\t},\n\tstartElement:function(namespaceURI, localName, qName, attrs) {\n\t\tvar doc = this.doc;\n\t    var el = doc.createElementNS(namespaceURI, qName||localName);\n\t    var len = attrs.length;\n\t    appendElement(this, el);\n\t    this.currentElement = el;\n\n\t\tthis.locator && position(this.locator,el)\n\t    for (var i = 0 ; i < len; i++) {\n\t        var namespaceURI = attrs.getURI(i);\n\t        var value = attrs.getValue(i);\n\t        var qName = attrs.getQName(i);\n\t\t\tvar attr = doc.createAttributeNS(namespaceURI, qName);\n\t\t\tthis.locator &&position(attrs.getLocator(i),attr);\n\t\t\tattr.value = attr.nodeValue = value;\n\t\t\tel.setAttributeNode(attr)\n\t    }\n\t},\n\tendElement:function(namespaceURI, localName, qName) {\n\t\tvar current = this.currentElement\n\t\tvar tagName = current.tagName;\n\t\tthis.currentElement = current.parentNode;\n\t},\n\tstartPrefixMapping:function(prefix, uri) {\n\t},\n\tendPrefixMapping:function(prefix) {\n\t},\n\tprocessingInstruction:function(target, data) {\n\t    var ins = this.doc.createProcessingInstruction(target, data);\n\t    this.locator && position(this.locator,ins)\n\t    appendElement(this, ins);\n\t},\n\tignorableWhitespace:function(ch, start, length) {\n\t},\n\tcharacters:function(chars, start, length) {\n\t\tchars = _toString.apply(this,arguments)\n\t\t//console.log(chars)\n\t\tif(chars){\n\t\t\tif (this.cdata) {\n\t\t\t\tvar charNode = this.doc.createCDATASection(chars);\n\t\t\t} else {\n\t\t\t\tvar charNode = this.doc.createTextNode(chars);\n\t\t\t}\n\t\t\tif(this.currentElement){\n\t\t\t\tthis.currentElement.appendChild(charNode);\n\t\t\t}else if(/^\\s*$/.test(chars)){\n\t\t\t\tthis.doc.appendChild(charNode);\n\t\t\t\t//process xml\n\t\t\t}\n\t\t\tthis.locator && position(this.locator,charNode)\n\t\t}\n\t},\n\tskippedEntity:function(name) {\n\t},\n\tendDocument:function() {\n\t\tthis.doc.normalize();\n\t},\n\tsetDocumentLocator:function (locator) {\n\t    if(this.locator = locator){// && !('lineNumber' in locator)){\n\t    \tlocator.lineNumber = 0;\n\t    }\n\t},\n\t//LexicalHandler\n\tcomment:function(chars, start, length) {\n\t\tchars = _toString.apply(this,arguments)\n\t    var comm = this.doc.createComment(chars);\n\t    this.locator && position(this.locator,comm)\n\t    appendElement(this, comm);\n\t},\n\n\tstartCDATA:function() {\n\t    //used in characters() methods\n\t    this.cdata = true;\n\t},\n\tendCDATA:function() {\n\t    this.cdata = false;\n\t},\n\n\tstartDTD:function(name, publicId, systemId) {\n\t\tvar impl = this.doc.implementation;\n\t    if (impl && impl.createDocumentType) {\n\t        var dt = impl.createDocumentType(name, publicId, systemId);\n\t        this.locator && position(this.locator,dt)\n\t        appendElement(this, dt);\n\t\t\t\t\tthis.doc.doctype = dt;\n\t    }\n\t},\n\t/**\n\t * @see org.xml.sax.ErrorHandler\n\t * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n\t */\n\twarning:function(error) {\n\t\tconsole.warn('[xmldom warning]\\t'+error,_locator(this.locator));\n\t},\n\terror:function(error) {\n\t\tconsole.error('[xmldom error]\\t'+error,_locator(this.locator));\n\t},\n\tfatalError:function(error) {\n\t\tthrow new ParseError(error, this.locator);\n\t}\n}\nfunction _locator(l){\n\tif(l){\n\t\treturn '\\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'\n\t}\n}\nfunction _toString(chars,start,length){\n\tif(typeof chars == 'string'){\n\t\treturn chars.substr(start,length)\n\t}else{//java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n\t\tif(chars.length >= start+length || start){\n\t\t\treturn new java.lang.String(chars,start,length)+'';\n\t\t}\n\t\treturn chars;\n\t}\n}\n\n/*\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n * used method of org.xml.sax.ext.LexicalHandler:\n *  #comment(chars, start, length)\n *  #startCDATA()\n *  #endCDATA()\n *  #startDTD(name, publicId, systemId)\n *\n *\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\n *  #endDTD()\n *  #startEntity(name)\n *  #endEntity(name)\n *\n *\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n * IGNORED method of org.xml.sax.ext.DeclHandler\n * \t#attributeDecl(eName, aName, type, mode, value)\n *  #elementDecl(name, model)\n *  #externalEntityDecl(name, publicId, systemId)\n *  #internalEntityDecl(name, value)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n * IGNORED method of org.xml.sax.EntityResolver2\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n *  #resolveEntity(publicId, systemId)\n *  #getExternalSubset(name, baseURI)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n * IGNORED method of org.xml.sax.DTDHandler\n *  #notationDecl(name, publicId, systemId) {};\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n */\n\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g,function(key){\n\tDOMHandler.prototype[key] = function(){return null}\n})\n\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\nfunction appendElement (hander,node) {\n    if (!hander.currentElement) {\n        hander.doc.appendChild(node);\n    } else {\n        hander.currentElement.appendChild(node);\n    }\n}//appendChild and setAttributeNS are preformance key\n\nexports.__DOMHandler = DOMHandler;\nexports.normalizeLineEndings = normalizeLineEndings;\nexports.DOMParser = DOMParser;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/dom-parser.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var conventions = __webpack_require__(/*! ./conventions */ \"./node_modules/@xmldom/xmldom/lib/conventions.js\");\n\nvar find = conventions.find;\nvar NAMESPACE = conventions.NAMESPACE;\n\n/**\n * A prerequisite for `[].filter`, to drop elements that are empty\n * @param {string} input\n * @returns {boolean}\n */\nfunction notEmptyString (input) {\n\treturn input !== ''\n}\n/**\n * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * @param {string} input\n * @returns {string[]} (can be empty)\n */\nfunction splitOnASCIIWhitespace(input) {\n\t// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n\treturn input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : []\n}\n\n/**\n * Adds element as a key to current if it is not already present.\n *\n * @param {Record<string, boolean | undefined>} current\n * @param {string} element\n * @returns {Record<string, boolean | undefined>}\n */\nfunction orderedSetReducer (current, element) {\n\tif (!current.hasOwnProperty(element)) {\n\t\tcurrent[element] = true;\n\t}\n\treturn current;\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ordered-set\n * @param {string} input\n * @returns {string[]}\n */\nfunction toOrderedSet(input) {\n\tif (!input) return [];\n\tvar list = splitOnASCIIWhitespace(input);\n\treturn Object.keys(list.reduce(orderedSetReducer, {}))\n}\n\n/**\n * Uses `list.indexOf` to implement something like `Array.prototype.includes`,\n * which we can not rely on being available.\n *\n * @param {any[]} list\n * @returns {function(any): boolean}\n */\nfunction arrayIncludes (list) {\n\treturn function(element) {\n\t\treturn list && list.indexOf(element) !== -1;\n\t}\n}\n\nfunction copy(src,dest){\n\tfor(var p in src){\n\t\tif (Object.prototype.hasOwnProperty.call(src, p)) {\n\t\t\tdest[p] = src[p];\n\t\t}\n\t}\n}\n\n/**\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n */\nfunction _extends(Class,Super){\n\tvar pt = Class.prototype;\n\tif(!(pt instanceof Super)){\n\t\tfunction t(){};\n\t\tt.prototype = Super.prototype;\n\t\tt = new t();\n\t\tcopy(pt,t);\n\t\tClass.prototype = pt = t;\n\t}\n\tif(pt.constructor != Class){\n\t\tif(typeof Class != 'function'){\n\t\t\tconsole.error(\"unknown Class:\"+Class)\n\t\t}\n\t\tpt.constructor = Class\n\t}\n}\n\n// Node Types\nvar NodeType = {}\nvar ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;\nvar ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;\nvar TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;\nvar CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;\nvar ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;\nvar ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;\nvar PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;\nvar DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;\nvar DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;\nvar DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;\nvar NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;\n\n// ExceptionCode\nvar ExceptionCode = {}\nvar ExceptionMessage = {};\nvar INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]=\"Index size error\"),1);\nvar DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]=\"DOMString size error\"),2);\nvar HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]=\"Hierarchy request error\"),3);\nvar WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]=\"Wrong document\"),4);\nvar INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]=\"Invalid character\"),5);\nvar NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]=\"No data allowed\"),6);\nvar NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]=\"No modification allowed\"),7);\nvar NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]=\"Not found\"),8);\nvar NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]=\"Not supported\"),9);\nvar INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]=\"Attribute in use\"),10);\n//level2\nvar INVALID_STATE_ERR        \t= ExceptionCode.INVALID_STATE_ERR        \t= ((ExceptionMessage[11]=\"Invalid state\"),11);\nvar SYNTAX_ERR               \t= ExceptionCode.SYNTAX_ERR               \t= ((ExceptionMessage[12]=\"Syntax error\"),12);\nvar INVALID_MODIFICATION_ERR \t= ExceptionCode.INVALID_MODIFICATION_ERR \t= ((ExceptionMessage[13]=\"Invalid modification\"),13);\nvar NAMESPACE_ERR            \t= ExceptionCode.NAMESPACE_ERR           \t= ((ExceptionMessage[14]=\"Invalid namespace\"),14);\nvar INVALID_ACCESS_ERR       \t= ExceptionCode.INVALID_ACCESS_ERR      \t= ((ExceptionMessage[15]=\"Invalid access\"),15);\n\n/**\n * DOM Level 2\n * Object DOMException\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n */\nfunction DOMException(code, message) {\n\tif(message instanceof Error){\n\t\tvar error = message;\n\t}else{\n\t\terror = this;\n\t\tError.call(this, ExceptionMessage[code]);\n\t\tthis.message = ExceptionMessage[code];\n\t\tif(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n\t}\n\terror.code = code;\n\tif(message) this.message = this.message + \": \" + message;\n\treturn error;\n};\nDOMException.prototype = Error.prototype;\ncopy(ExceptionCode,DOMException)\n\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n */\nfunction NodeList() {\n};\nNodeList.prototype = {\n\t/**\n\t * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n\t * @standard level1\n\t */\n\tlength:0,\n\t/**\n\t * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n\t * @standard level1\n\t * @param index  unsigned long\n\t *   Index into the collection.\n\t * @return Node\n\t * \tThe node at the indexth position in the NodeList, or null if that is not a valid index.\n\t */\n\titem: function(index) {\n\t\treturn index >= 0 && index < this.length ? this[index] : null;\n\t},\n\ttoString:function(isHTML,nodeFilter){\n\t\tfor(var buf = [], i = 0;i<this.length;i++){\n\t\t\tserializeToString(this[i],buf,isHTML,nodeFilter);\n\t\t}\n\t\treturn buf.join('');\n\t},\n\t/**\n\t * @private\n\t * @param {function (Node):boolean} predicate\n\t * @returns {Node[]}\n\t */\n\tfilter: function (predicate) {\n\t\treturn Array.prototype.filter.call(this, predicate);\n\t},\n\t/**\n\t * @private\n\t * @param {Node} item\n\t * @returns {number}\n\t */\n\tindexOf: function (item) {\n\t\treturn Array.prototype.indexOf.call(this, item);\n\t},\n};\n\nfunction LiveNodeList(node,refresh){\n\tthis._node = node;\n\tthis._refresh = refresh\n\t_updateLiveList(this);\n}\nfunction _updateLiveList(list){\n\tvar inc = list._node._inc || list._node.ownerDocument._inc;\n\tif (list._inc !== inc) {\n\t\tvar ls = list._refresh(list._node);\n\t\t__set__(list,'length',ls.length);\n\t\tif (!list.$$length || ls.length < list.$$length) {\n\t\t\tfor (var i = ls.length; i in list; i++) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(list, i)) {\n\t\t\t\t\tdelete list[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcopy(ls,list);\n\t\tlist._inc = inc;\n\t}\n}\nLiveNodeList.prototype.item = function(i){\n\t_updateLiveList(this);\n\treturn this[i] || null;\n}\n\n_extends(LiveNodeList,NodeList);\n\n/**\n * Objects implementing the NamedNodeMap interface are used\n * to represent collections of nodes that can be accessed by name.\n * Note that NamedNodeMap does not inherit from NodeList;\n * NamedNodeMaps are not maintained in any particular order.\n * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,\n * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n * and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities\n */\nfunction NamedNodeMap() {\n};\n\nfunction _findNodeIndex(list,node){\n\tvar i = list.length;\n\twhile(i--){\n\t\tif(list[i] === node){return i}\n\t}\n}\n\nfunction _addNamedNode(el,list,newAttr,oldAttr){\n\tif(oldAttr){\n\t\tlist[_findNodeIndex(list,oldAttr)] = newAttr;\n\t}else{\n\t\tlist[list.length++] = newAttr;\n\t}\n\tif(el){\n\t\tnewAttr.ownerElement = el;\n\t\tvar doc = el.ownerDocument;\n\t\tif(doc){\n\t\t\toldAttr && _onRemoveAttribute(doc,el,oldAttr);\n\t\t\t_onAddAttribute(doc,el,newAttr);\n\t\t}\n\t}\n}\nfunction _removeNamedNode(el,list,attr){\n\t//console.log('remove attr:'+attr)\n\tvar i = _findNodeIndex(list,attr);\n\tif(i>=0){\n\t\tvar lastIndex = list.length-1\n\t\twhile(i<lastIndex){\n\t\t\tlist[i] = list[++i]\n\t\t}\n\t\tlist.length = lastIndex;\n\t\tif(el){\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tif(doc){\n\t\t\t\t_onRemoveAttribute(doc,el,attr);\n\t\t\t\tattr.ownerElement = null;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tthrow new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))\n\t}\n}\nNamedNodeMap.prototype = {\n\tlength:0,\n\titem:NodeList.prototype.item,\n\tgetNamedItem: function(key) {\n//\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n//\t\t\treturn null;\n//\t\t}\n\t\t//console.log()\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar attr = this[i];\n\t\t\t//console.log(attr.nodeName,key)\n\t\t\tif(attr.nodeName == key){\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t},\n\tsetNamedItem: function(attr) {\n\t\tvar el = attr.ownerElement;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\tvar oldAttr = this.getNamedItem(attr.nodeName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\t/* returns Node */\n\tsetNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n\t\tvar el = attr.ownerElement, oldAttr;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\toldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\n\t/* returns Node */\n\tremoveNamedItem: function(key) {\n\t\tvar attr = this.getNamedItem(key);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\n\n\t},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\n\t//for level2\n\tremoveNamedItemNS:function(namespaceURI,localName){\n\t\tvar attr = this.getNamedItemNS(namespaceURI,localName);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\t},\n\tgetNamedItemNS: function(namespaceURI, localName) {\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar node = this[i];\n\t\t\tif(node.localName == localName && node.namespaceURI == namespaceURI){\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n};\n\n/**\n * The DOMImplementation interface represents an object providing methods\n * which are not dependent on any particular document.\n * Such an object is returned by the `Document.implementation` property.\n *\n * __The individual methods describe the differences compared to the specs.__\n *\n * @constructor\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)\n * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n */\nfunction DOMImplementation() {\n}\n\nDOMImplementation.prototype = {\n\t/**\n\t * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.\n\t * The different implementations fairly diverged in what kind of features were reported.\n\t * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.\n\t *\n\t * @deprecated It is deprecated and modern browsers return true in all cases.\n\t *\n\t * @param {string} feature\n\t * @param {string} [version]\n\t * @returns {boolean} always true\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n\t * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n\t */\n\thasFeature: function(feature, version) {\n\t\t\treturn true;\n\t},\n\t/**\n\t * Creates an XML Document object of the specified type with its document element.\n\t *\n\t * __It behaves slightly different from the description in the living standard__:\n\t * - There is no interface/class `XMLDocument`, it returns a `Document` instance.\n\t * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n\t * - this implementation is not validating names or qualified names\n\t *   (when parsing XML strings, the SAX parser takes care of that)\n\t *\n\t * @param {string|null} namespaceURI\n\t * @param {string} qualifiedName\n\t * @param {DocumentType=null} doctype\n\t * @returns {Document}\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core\n\t *\n\t * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n\t * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n\t * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n\t */\n\tcreateDocument: function(namespaceURI,  qualifiedName, doctype){\n\t\tvar doc = new Document();\n\t\tdoc.implementation = this;\n\t\tdoc.childNodes = new NodeList();\n\t\tdoc.doctype = doctype || null;\n\t\tif (doctype){\n\t\t\tdoc.appendChild(doctype);\n\t\t}\n\t\tif (qualifiedName){\n\t\t\tvar root = doc.createElementNS(namespaceURI, qualifiedName);\n\t\t\tdoc.appendChild(root);\n\t\t}\n\t\treturn doc;\n\t},\n\t/**\n\t * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.\n\t *\n\t * __This behavior is slightly different from the in the specs__:\n\t * - this implementation is not validating names or qualified names\n\t *   (when parsing XML strings, the SAX parser takes care of that)\n\t *\n\t * @param {string} qualifiedName\n\t * @param {string} [publicId]\n\t * @param {string} [systemId]\n\t * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation\n\t * \t\t\t\t  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard\n\t *\n\t * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n\t * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n\t * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n\t */\n\tcreateDocumentType: function(qualifiedName, publicId, systemId){\n\t\tvar node = new DocumentType();\n\t\tnode.name = qualifiedName;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.publicId = publicId || '';\n\t\tnode.systemId = systemId || '';\n\n\t\treturn node;\n\t}\n};\n\n\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n */\n\nfunction Node() {\n};\n\nNode.prototype = {\n\tfirstChild : null,\n\tlastChild : null,\n\tpreviousSibling : null,\n\tnextSibling : null,\n\tattributes : null,\n\tparentNode : null,\n\tchildNodes : null,\n\townerDocument : null,\n\tnodeValue : null,\n\tnamespaceURI : null,\n\tprefix : null,\n\tlocalName : null,\n\t// Modified in DOM Level 2:\n\tinsertBefore:function(newChild, refChild){//raises\n\t\treturn _insertBefore(this,newChild,refChild);\n\t},\n\treplaceChild:function(newChild, oldChild){//raises\n\t\t_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);\n\t\tif(oldChild){\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t},\n\tremoveChild:function(oldChild){\n\t\treturn _removeChild(this,oldChild);\n\t},\n\tappendChild:function(newChild){\n\t\treturn this.insertBefore(newChild,null);\n\t},\n\thasChildNodes:function(){\n\t\treturn this.firstChild != null;\n\t},\n\tcloneNode:function(deep){\n\t\treturn cloneNode(this.ownerDocument||this,this,deep);\n\t},\n\t// Modified in DOM Level 2:\n\tnormalize:function(){\n\t\tvar child = this.firstChild;\n\t\twhile(child){\n\t\t\tvar next = child.nextSibling;\n\t\t\tif(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){\n\t\t\t\tthis.removeChild(next);\n\t\t\t\tchild.appendData(next.data);\n\t\t\t}else{\n\t\t\t\tchild.normalize();\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t}\n\t},\n  \t// Introduced in DOM Level 2:\n\tisSupported:function(feature, version){\n\t\treturn this.ownerDocument.implementation.hasFeature(feature,version);\n\t},\n    // Introduced in DOM Level 2:\n    hasAttributes:function(){\n    \treturn this.attributes.length>0;\n    },\n\t/**\n\t * Look up the prefix associated to the given namespace URI, starting from this node.\n\t * **The default namespace declarations are ignored by this method.**\n\t * See Namespace Prefix Lookup for details on the algorithm used by this method.\n\t *\n\t * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._\n\t *\n\t * @param {string | null} namespaceURI\n\t * @returns {string | null}\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n\t * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n\t * @see https://github.com/xmldom/xmldom/issues/322\n\t */\n    lookupPrefix:function(namespaceURI){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tfor(var n in map){\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    lookupNamespaceURI:function(prefix){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tif(Object.prototype.hasOwnProperty.call(map, prefix)){\n    \t\t\t\treturn map[prefix] ;\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    isDefaultNamespace:function(namespaceURI){\n    \tvar prefix = this.lookupPrefix(namespaceURI);\n    \treturn prefix == null;\n    }\n};\n\n\nfunction _xmlEncoder(c){\n\treturn c == '<' && '&lt;' ||\n         c == '>' && '&gt;' ||\n         c == '&' && '&amp;' ||\n         c == '\"' && '&quot;' ||\n         '&#'+c.charCodeAt()+';'\n}\n\n\ncopy(NodeType,Node);\ncopy(NodeType,Node.prototype);\n\n/**\n * @param callback return true for continue,false for break\n * @return boolean true: break visit;\n */\nfunction _visitNode(node,callback){\n\tif(callback(node)){\n\t\treturn true;\n\t}\n\tif(node = node.firstChild){\n\t\tdo{\n\t\t\tif(_visitNode(node,callback)){return true}\n        }while(node=node.nextSibling)\n    }\n}\n\n\n\nfunction Document(){\n\tthis.ownerDocument = this;\n}\n\nfunction _onAddAttribute(doc,el,newAttr){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns === NAMESPACE.XMLNS){\n\t\t//update namespace\n\t\tel._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value\n\t}\n}\n\nfunction _onRemoveAttribute(doc,el,newAttr,remove){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns === NAMESPACE.XMLNS){\n\t\t//update namespace\n\t\tdelete el._nsMap[newAttr.prefix?newAttr.localName:'']\n\t}\n}\n\n/**\n * Updates `el.childNodes`, updating the indexed items and it's `length`.\n * Passing `newChild` means it will be appended.\n * Otherwise it's assumed that an item has been removed,\n * and `el.firstNode` and it's `.nextSibling` are used\n * to walk the current list of child nodes.\n *\n * @param {Document} doc\n * @param {Node} el\n * @param {Node} [newChild]\n * @private\n */\nfunction _onUpdateChild (doc, el, newChild) {\n\tif(doc && doc._inc){\n\t\tdoc._inc++;\n\t\t//update childNodes\n\t\tvar cs = el.childNodes;\n\t\tif (newChild) {\n\t\t\tcs[cs.length++] = newChild;\n\t\t} else {\n\t\t\tvar child = el.firstChild;\n\t\t\tvar i = 0;\n\t\t\twhile (child) {\n\t\t\t\tcs[i++] = child;\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t\tcs.length = i;\n\t\t\tdelete cs[cs.length];\n\t\t}\n\t}\n}\n\n/**\n * Removes the connections between `parentNode` and `child`\n * and any existing `child.previousSibling` or `child.nextSibling`.\n *\n * @see https://github.com/xmldom/xmldom/issues/135\n * @see https://github.com/xmldom/xmldom/issues/145\n *\n * @param {Node} parentNode\n * @param {Node} child\n * @returns {Node} the child that was removed.\n * @private\n */\nfunction _removeChild (parentNode, child) {\n\tvar previous = child.previousSibling;\n\tvar next = child.nextSibling;\n\tif (previous) {\n\t\tprevious.nextSibling = next;\n\t} else {\n\t\tparentNode.firstChild = next;\n\t}\n\tif (next) {\n\t\tnext.previousSibling = previous;\n\t} else {\n\t\tparentNode.lastChild = previous;\n\t}\n\tchild.parentNode = null;\n\tchild.previousSibling = null;\n\tchild.nextSibling = null;\n\t_onUpdateChild(parentNode.ownerDocument, parentNode);\n\treturn child;\n}\n\n/**\n * Returns `true` if `node` can be a parent for insertion.\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasValidParentNodeType(node) {\n\treturn (\n\t\tnode &&\n\t\t(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)\n\t);\n}\n\n/**\n * Returns `true` if `node` can be inserted according to it's `nodeType`.\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasInsertableNodeType(node) {\n\treturn (\n\t\tnode &&\n\t\t(isElementNode(node) ||\n\t\t\tisTextNode(node) ||\n\t\t\tisDocTypeNode(node) ||\n\t\t\tnode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||\n\t\t\tnode.nodeType === Node.COMMENT_NODE ||\n\t\t\tnode.nodeType === Node.PROCESSING_INSTRUCTION_NODE)\n\t);\n}\n\n/**\n * Returns true if `node` is a DOCTYPE node\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isDocTypeNode(node) {\n\treturn node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n}\n\n/**\n * Returns true if the node is an element\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isElementNode(node) {\n\treturn node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Returns true if `node` is a text node\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isTextNode(node) {\n\treturn node && node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Document} doc The document node\n * @param {Node} child the node that would become the nextSibling if the element would be inserted\n * @returns {boolean} `true` if an element can be inserted before child\n * @private\n * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n */\nfunction isElementInsertionPossible(doc, child) {\n\tvar parentChildNodes = doc.childNodes || [];\n\tif (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n\t\treturn false;\n\t}\n\tvar docTypeNode = find(parentChildNodes, isDocTypeNode);\n\treturn !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Node} doc The document node\n * @param {Node} child the node that would become the nextSibling if the element would be inserted\n * @returns {boolean} `true` if an element can be inserted before child\n * @private\n * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n */\nfunction isElementReplacementPossible(doc, child) {\n\tvar parentChildNodes = doc.childNodes || [];\n\n\tfunction hasElementChildThatIsNotChild(node) {\n\t\treturn isElementNode(node) && node !== child;\n\t}\n\n\tif (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n\t\treturn false;\n\t}\n\tvar docTypeNode = find(parentChildNodes, isDocTypeNode);\n\treturn !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * @private\n * Steps 1-5 of the checks before inserting and before replacing a child are the same.\n *\n * @param {Node} parent the parent node to insert `node` into\n * @param {Node} node the node to insert\n * @param {Node=} child the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n * @throws DOMException if `child` is provided but is not a child of `parent`.\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidity1to5(parent, node, child) {\n\t// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n\tif (!hasValidParentNodeType(parent)) {\n\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n\t}\n\t// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n\t// not implemented!\n\t// 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n\tif (child && child.parentNode !== parent) {\n\t\tthrow new DOMException(NOT_FOUND_ERR, 'child not in parent');\n\t}\n\tif (\n\t\t// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n\t\t!hasInsertableNodeType(node) ||\n\t\t// 5. If either `node` is a Text node and `parent` is a document,\n\t\t// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n\t\t// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n\t\t// or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n\t\t(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)\n\t) {\n\t\tthrow new DOMException(\n\t\t\tHIERARCHY_REQUEST_ERR,\n\t\t\t'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType\n\t\t);\n\t}\n}\n\n/**\n * @private\n * Step 6 of the checks before inserting and before replacing a child are different.\n *\n * @param {Document} parent the parent node to insert `node` into\n * @param {Node} node the node to insert\n * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n * @throws DOMException if `child` is provided but is not a child of `parent`.\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidityInDocument(parent, node, child) {\n\tvar parentChildNodes = parent.childNodes || [];\n\tvar nodeChildNodes = node.childNodes || [];\n\n\t// DocumentFragment\n\tif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\tvar nodeChildElements = nodeChildNodes.filter(isElementNode);\n\t\t// If node has more than one element child or has a Text node child.\n\t\tif (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n\t\t}\n\t\t// Otherwise, if `node` has one element child and either `parent` has an element child,\n\t\t// `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n\t\tif (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n\t\t}\n\t}\n\t// Element\n\tif (isElementNode(node)) {\n\t\t// `parent` has an element child, `child` is a doctype,\n\t\t// or `child` is non-null and a doctype is following `child`.\n\t\tif (!isElementInsertionPossible(parent, child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n\t\t}\n\t}\n\t// DocumentType\n\tif (isDocTypeNode(node)) {\n\t\t// `parent` has a doctype child,\n\t\tif (find(parentChildNodes, isDocTypeNode)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n\t\t}\n\t\tvar parentElementChild = find(parentChildNodes, isElementNode);\n\t\t// `child` is non-null and an element is preceding `child`,\n\t\tif (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n\t\t}\n\t\t// or `child` is null and `parent` has an element child.\n\t\tif (!child && parentElementChild) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n\t\t}\n\t}\n}\n\n/**\n * @private\n * Step 6 of the checks before inserting and before replacing a child are different.\n *\n * @param {Document} parent the parent node to insert `node` into\n * @param {Node} node the node to insert\n * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n * @throws DOMException if `child` is provided but is not a child of `parent`.\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreReplacementValidityInDocument(parent, node, child) {\n\tvar parentChildNodes = parent.childNodes || [];\n\tvar nodeChildNodes = node.childNodes || [];\n\n\t// DocumentFragment\n\tif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\tvar nodeChildElements = nodeChildNodes.filter(isElementNode);\n\t\t// If `node` has more than one element child or has a Text node child.\n\t\tif (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n\t\t}\n\t\t// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n\t\tif (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n\t\t}\n\t}\n\t// Element\n\tif (isElementNode(node)) {\n\t\t// `parent` has an element child that is not `child` or a doctype is following `child`.\n\t\tif (!isElementReplacementPossible(parent, child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n\t\t}\n\t}\n\t// DocumentType\n\tif (isDocTypeNode(node)) {\n\t\tfunction hasDoctypeChildThatIsNotChild(node) {\n\t\t\treturn isDocTypeNode(node) && node !== child;\n\t\t}\n\n\t\t// `parent` has a doctype child that is not `child`,\n\t\tif (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n\t\t}\n\t\tvar parentElementChild = find(parentChildNodes, isElementNode);\n\t\t// or an element is preceding `child`.\n\t\tif (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n\t\t\tthrow new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n\t\t}\n\t}\n}\n\n/**\n * @private\n * @param {Node} parent the parent node to insert `node` into\n * @param {Node} node the node to insert\n * @param {Node=} child the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n * @throws DOMException if `child` is provided but is not a child of `parent`.\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n */\nfunction _insertBefore(parent, node, child, _inDocumentAssertion) {\n\t// To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n\tassertPreInsertionValidity1to5(parent, node, child);\n\n\t// If parent is a document, and any of the statements below, switched on the interface node implements,\n\t// are true, then throw a \"HierarchyRequestError\" DOMException.\n\tif (parent.nodeType === Node.DOCUMENT_NODE) {\n\t\t(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n\t}\n\n\tvar cp = node.parentNode;\n\tif(cp){\n\t\tcp.removeChild(node);//remove and update\n\t}\n\tif(node.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\tvar newFirst = node.firstChild;\n\t\tif (newFirst == null) {\n\t\t\treturn node;\n\t\t}\n\t\tvar newLast = node.lastChild;\n\t}else{\n\t\tnewFirst = newLast = node;\n\t}\n\tvar pre = child ? child.previousSibling : parent.lastChild;\n\n\tnewFirst.previousSibling = pre;\n\tnewLast.nextSibling = child;\n\n\n\tif(pre){\n\t\tpre.nextSibling = newFirst;\n\t}else{\n\t\tparent.firstChild = newFirst;\n\t}\n\tif(child == null){\n\t\tparent.lastChild = newLast;\n\t}else{\n\t\tchild.previousSibling = newLast;\n\t}\n\tdo{\n\t\tnewFirst.parentNode = parent;\n\t}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))\n\t_onUpdateChild(parent.ownerDocument||parent, parent);\n\t//console.log(parent.lastChild.nextSibling == null)\n\tif (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n\t\tnode.firstChild = node.lastChild = null;\n\t}\n\treturn node;\n}\n\n/**\n * Appends `newChild` to `parentNode`.\n * If `newChild` is already connected to a `parentNode` it is first removed from it.\n *\n * @see https://github.com/xmldom/xmldom/issues/135\n * @see https://github.com/xmldom/xmldom/issues/145\n * @param {Node} parentNode\n * @param {Node} newChild\n * @returns {Node}\n * @private\n */\nfunction _appendSingleChild (parentNode, newChild) {\n\tif (newChild.parentNode) {\n\t\tnewChild.parentNode.removeChild(newChild);\n\t}\n\tnewChild.parentNode = parentNode;\n\tnewChild.previousSibling = parentNode.lastChild;\n\tnewChild.nextSibling = null;\n\tif (newChild.previousSibling) {\n\t\tnewChild.previousSibling.nextSibling = newChild;\n\t} else {\n\t\tparentNode.firstChild = newChild;\n\t}\n\tparentNode.lastChild = newChild;\n\t_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n\treturn newChild;\n}\n\nDocument.prototype = {\n\t//implementation : null,\n\tnodeName :  '#document',\n\tnodeType :  DOCUMENT_NODE,\n\t/**\n\t * The DocumentType node of the document.\n\t *\n\t * @readonly\n\t * @type DocumentType\n\t */\n\tdoctype :  null,\n\tdocumentElement :  null,\n\t_inc : 1,\n\n\tinsertBefore :  function(newChild, refChild){//raises\n\t\tif(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){\n\t\t\tvar child = newChild.firstChild;\n\t\t\twhile(child){\n\t\t\t\tvar next = child.nextSibling;\n\t\t\t\tthis.insertBefore(child,refChild);\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t\treturn newChild;\n\t\t}\n\t\t_insertBefore(this, newChild, refChild);\n\t\tnewChild.ownerDocument = this;\n\t\tif (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\n\t\treturn newChild;\n\t},\n\tremoveChild :  function(oldChild){\n\t\tif(this.documentElement == oldChild){\n\t\t\tthis.documentElement = null;\n\t\t}\n\t\treturn _removeChild(this,oldChild);\n\t},\n\treplaceChild: function (newChild, oldChild) {\n\t\t//raises\n\t\t_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n\t\tnewChild.ownerDocument = this;\n\t\tif (oldChild) {\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t\tif (isElementNode(newChild)) {\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\t},\n\t// Introduced in DOM Level 2:\n\timportNode : function(importedNode,deep){\n\t\treturn importNode(this,importedNode,deep);\n\t},\n\t// Introduced in DOM Level 2:\n\tgetElementById :\tfunction(id){\n\t\tvar rtv = null;\n\t\t_visitNode(this.documentElement,function(node){\n\t\t\tif(node.nodeType == ELEMENT_NODE){\n\t\t\t\tif(node.getAttribute('id') == id){\n\t\t\t\t\trtv = node;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\treturn rtv;\n\t},\n\n\t/**\n\t * The `getElementsByClassName` method of `Document` interface returns an array-like object\n\t * of all child elements which have **all** of the given class name(s).\n\t *\n\t * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.\n\t *\n\t *\n\t * Warning: This is a live LiveNodeList.\n\t * Changes in the DOM will reflect in the array as the changes occur.\n\t * If an element selected by this array no longer qualifies for the selector,\n\t * it will automatically be removed. Be aware of this for iteration purposes.\n\t *\n\t * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n\t * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n\t */\n\tgetElementsByClassName: function(classNames) {\n\t\tvar classNamesSet = toOrderedSet(classNames)\n\t\treturn new LiveNodeList(this, function(base) {\n\t\t\tvar ls = [];\n\t\t\tif (classNamesSet.length > 0) {\n\t\t\t\t_visitNode(base.documentElement, function(node) {\n\t\t\t\t\tif(node !== base && node.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tvar nodeClassNames = node.getAttribute('class')\n\t\t\t\t\t\t// can be null if the attribute does not exist\n\t\t\t\t\t\tif (nodeClassNames) {\n\t\t\t\t\t\t\t// before splitting and iterating just compare them for the most common case\n\t\t\t\t\t\t\tvar matches = classNames === nodeClassNames;\n\t\t\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\t\t\tvar nodeClassNamesSet = toOrderedSet(nodeClassNames)\n\t\t\t\t\t\t\t\tmatches = classNamesSet.every(arrayIncludes(nodeClassNamesSet))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(matches) {\n\t\t\t\t\t\t\t\tls.push(node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn ls;\n\t\t});\n\t},\n\n\t//document factory method:\n\tcreateElement :\tfunction(tagName){\n\t\tvar node = new Element();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = tagName;\n\t\tnode.tagName = tagName;\n\t\tnode.localName = tagName;\n\t\tnode.childNodes = new NodeList();\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\tcreateDocumentFragment :\tfunction(){\n\t\tvar node = new DocumentFragment();\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\treturn node;\n\t},\n\tcreateTextNode :\tfunction(data){\n\t\tvar node = new Text();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateComment :\tfunction(data){\n\t\tvar node = new Comment();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateCDATASection :\tfunction(data){\n\t\tvar node = new CDATASection();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateProcessingInstruction :\tfunction(target,data){\n\t\tvar node = new ProcessingInstruction();\n\t\tnode.ownerDocument = this;\n\t\tnode.tagName = node.nodeName = node.target = target;\n\t\tnode.nodeValue = node.data = data;\n\t\treturn node;\n\t},\n\tcreateAttribute :\tfunction(name){\n\t\tvar node = new Attr();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.name = name;\n\t\tnode.nodeName\t= name;\n\t\tnode.localName = name;\n\t\tnode.specified = true;\n\t\treturn node;\n\t},\n\tcreateEntityReference :\tfunction(name){\n\t\tvar node = new EntityReference();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.nodeName\t= name;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateElementNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Element();\n\t\tvar pl = qualifiedName.split(':');\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tnode.childNodes = new NodeList();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.tagName = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateAttributeNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Attr();\n\t\tvar pl = qualifiedName.split(':');\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.name = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tnode.specified = true;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\treturn node;\n\t}\n};\n_extends(Document,Node);\n\n\nfunction Element() {\n\tthis._nsMap = {};\n};\nElement.prototype = {\n\tnodeType : ELEMENT_NODE,\n\thasAttribute : function(name){\n\t\treturn this.getAttributeNode(name)!=null;\n\t},\n\tgetAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name);\n\t\treturn attr && attr.value || '';\n\t},\n\tgetAttributeNode : function(name){\n\t\treturn this.attributes.getNamedItem(name);\n\t},\n\tsetAttribute : function(name, value){\n\t\tvar attr = this.ownerDocument.createAttribute(name);\n\t\tattr.value = attr.nodeValue = \"\" + value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tremoveAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name)\n\t\tattr && this.removeAttributeNode(attr);\n\t},\n\n\t//four real opeartion method\n\tappendChild:function(newChild){\n\t\tif(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\t\treturn this.insertBefore(newChild,null);\n\t\t}else{\n\t\t\treturn _appendSingleChild(this,newChild);\n\t\t}\n\t},\n\tsetAttributeNode : function(newAttr){\n\t\treturn this.attributes.setNamedItem(newAttr);\n\t},\n\tsetAttributeNodeNS : function(newAttr){\n\t\treturn this.attributes.setNamedItemNS(newAttr);\n\t},\n\tremoveAttributeNode : function(oldAttr){\n\t\t//console.log(this == oldAttr.ownerElement)\n\t\treturn this.attributes.removeNamedItem(oldAttr.nodeName);\n\t},\n\t//get real attribute name,and remove it by removeAttributeNode\n\tremoveAttributeNS : function(namespaceURI, localName){\n\t\tvar old = this.getAttributeNodeNS(namespaceURI, localName);\n\t\told && this.removeAttributeNode(old);\n\t},\n\n\thasAttributeNS : function(namespaceURI, localName){\n\t\treturn this.getAttributeNodeNS(namespaceURI, localName)!=null;\n\t},\n\tgetAttributeNS : function(namespaceURI, localName){\n\t\tvar attr = this.getAttributeNodeNS(namespaceURI, localName);\n\t\treturn attr && attr.value || '';\n\t},\n\tsetAttributeNS : function(namespaceURI, qualifiedName, value){\n\t\tvar attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n\t\tattr.value = attr.nodeValue = \"\" + value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tgetAttributeNodeNS : function(namespaceURI, localName){\n\t\treturn this.attributes.getNamedItemNS(namespaceURI, localName);\n\t},\n\n\tgetElementsByTagName : function(tagName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t},\n\tgetElementsByTagNameNS : function(namespaceURI, localName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\n\t\t});\n\t}\n};\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n\n\n_extends(Element,Node);\nfunction Attr() {\n};\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr,Node);\n\n\nfunction CharacterData() {\n};\nCharacterData.prototype = {\n\tdata : '',\n\tsubstringData : function(offset, count) {\n\t\treturn this.data.substring(offset, offset+count);\n\t},\n\tappendData: function(text) {\n\t\ttext = this.data+text;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t},\n\tinsertData: function(offset,text) {\n\t\tthis.replaceData(offset,0,text);\n\n\t},\n\tappendChild:function(newChild){\n\t\tthrow new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])\n\t},\n\tdeleteData: function(offset, count) {\n\t\tthis.replaceData(offset,count,\"\");\n\t},\n\treplaceData: function(offset, count, text) {\n\t\tvar start = this.data.substring(0,offset);\n\t\tvar end = this.data.substring(offset+count);\n\t\ttext = start + text + end;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t}\n}\n_extends(CharacterData,Node);\nfunction Text() {\n};\nText.prototype = {\n\tnodeName : \"#text\",\n\tnodeType : TEXT_NODE,\n\tsplitText : function(offset) {\n\t\tvar text = this.data;\n\t\tvar newText = text.substring(offset);\n\t\ttext = text.substring(0, offset);\n\t\tthis.data = this.nodeValue = text;\n\t\tthis.length = text.length;\n\t\tvar newNode = this.ownerDocument.createTextNode(newText);\n\t\tif(this.parentNode){\n\t\t\tthis.parentNode.insertBefore(newNode, this.nextSibling);\n\t\t}\n\t\treturn newNode;\n\t}\n}\n_extends(Text,CharacterData);\nfunction Comment() {\n};\nComment.prototype = {\n\tnodeName : \"#comment\",\n\tnodeType : COMMENT_NODE\n}\n_extends(Comment,CharacterData);\n\nfunction CDATASection() {\n};\nCDATASection.prototype = {\n\tnodeName : \"#cdata-section\",\n\tnodeType : CDATA_SECTION_NODE\n}\n_extends(CDATASection,CharacterData);\n\n\nfunction DocumentType() {\n};\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType,Node);\n\nfunction Notation() {\n};\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation,Node);\n\nfunction Entity() {\n};\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity,Node);\n\nfunction EntityReference() {\n};\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference,Node);\n\nfunction DocumentFragment() {\n};\nDocumentFragment.prototype.nodeName =\t\"#document-fragment\";\nDocumentFragment.prototype.nodeType =\tDOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment,Node);\n\n\nfunction ProcessingInstruction() {\n}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction,Node);\nfunction XMLSerializer(){}\nXMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){\n\treturn nodeSerializeToString.call(node,isHtml,nodeFilter);\n}\nNode.prototype.toString = nodeSerializeToString;\nfunction nodeSerializeToString(isHtml,nodeFilter){\n\tvar buf = [];\n\tvar refNode = this.nodeType == 9 && this.documentElement || this;\n\tvar prefix = refNode.prefix;\n\tvar uri = refNode.namespaceURI;\n\n\tif(uri && prefix == null){\n\t\t//console.log(prefix)\n\t\tvar prefix = refNode.lookupPrefix(uri);\n\t\tif(prefix == null){\n\t\t\t//isHTML = true;\n\t\t\tvar visibleNamespaces=[\n\t\t\t{namespace:uri,prefix:null}\n\t\t\t//{namespace:uri,prefix:''}\n\t\t\t]\n\t\t}\n\t}\n\tserializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);\n\t//console.log('###',this.nodeType,uri,prefix,buf.join(''))\n\treturn buf.join('');\n}\n\nfunction needNamespaceDefine(node, isHTML, visibleNamespaces) {\n\tvar prefix = node.prefix || '';\n\tvar uri = node.namespaceURI;\n\t// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n\t// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n\t// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n\t// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n\t// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n\t// > [...] Furthermore, the attribute value [...] must not be an empty string.\n\t// so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n\tif (!uri) {\n\t\treturn false;\n\t}\n\tif (prefix === \"xml\" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {\n\t\treturn false;\n\t}\n\n\tvar i = visibleNamespaces.length\n\twhile (i--) {\n\t\tvar ns = visibleNamespaces[i];\n\t\t// get namespace prefix\n\t\tif (ns.prefix === prefix) {\n\t\t\treturn ns.namespace !== uri;\n\t\t}\n\t}\n\treturn true;\n}\n/**\n * Well-formed constraint: No < in Attribute Values\n * > The replacement text of any entity referred to directly or indirectly\n * > in an attribute value must not contain a <.\n * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n * @see https://www.w3.org/TR/xml11/#NT-AttValue\n *\n * Literal whitespace other than space that appear in attribute values\n * are serialized as their entity references, so they will be preserved.\n * (In contrast to whitespace literals in the input which are normalized to spaces)\n * @see https://www.w3.org/TR/xml11/#AVNormalize\n * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n */\nfunction addSerializedAttribute(buf, qualifiedName, value) {\n\tbuf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"')\n}\n\nfunction serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){\n\tif (!visibleNamespaces) {\n\t\tvisibleNamespaces = [];\n\t}\n\n\tif(nodeFilter){\n\t\tnode = nodeFilter(node);\n\t\tif(node){\n\t\t\tif(typeof node == 'string'){\n\t\t\t\tbuf.push(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\t\t//buf.sort.apply(attrs, attributeSorter);\n\t}\n\n\tswitch(node.nodeType){\n\tcase ELEMENT_NODE:\n\t\tvar attrs = node.attributes;\n\t\tvar len = attrs.length;\n\t\tvar child = node.firstChild;\n\t\tvar nodeName = node.tagName;\n\n\t\tisHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML\n\n\t\tvar prefixedNodeName = nodeName\n\t\tif (!isHTML && !node.prefix && node.namespaceURI) {\n\t\t\tvar defaultNS\n\t\t\t// lookup current default ns from `xmlns` attribute\n\t\t\tfor (var ai = 0; ai < attrs.length; ai++) {\n\t\t\t\tif (attrs.item(ai).name === 'xmlns') {\n\t\t\t\t\tdefaultNS = attrs.item(ai).value\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!defaultNS) {\n\t\t\t\t// lookup current default ns in visibleNamespaces\n\t\t\t\tfor (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n\t\t\t\t\tvar namespace = visibleNamespaces[nsi]\n\t\t\t\t\tif (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n\t\t\t\t\t\tdefaultNS = namespace.namespace\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defaultNS !== node.namespaceURI) {\n\t\t\t\tfor (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n\t\t\t\t\tvar namespace = visibleNamespaces[nsi]\n\t\t\t\t\tif (namespace.namespace === node.namespaceURI) {\n\t\t\t\t\t\tif (namespace.prefix) {\n\t\t\t\t\t\t\tprefixedNodeName = namespace.prefix + ':' + nodeName\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuf.push('<', prefixedNodeName);\n\n\t\tfor(var i=0;i<len;i++){\n\t\t\t// add namespaces for attributes\n\t\t\tvar attr = attrs.item(i);\n\t\t\tif (attr.prefix == 'xmlns') {\n\t\t\t\tvisibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });\n\t\t\t}else if(attr.nodeName == 'xmlns'){\n\t\t\t\tvisibleNamespaces.push({ prefix: '', namespace: attr.value });\n\t\t\t}\n\t\t}\n\n\t\tfor(var i=0;i<len;i++){\n\t\t\tvar attr = attrs.item(i);\n\t\t\tif (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {\n\t\t\t\tvar prefix = attr.prefix||'';\n\t\t\t\tvar uri = attr.namespaceURI;\n\t\t\t\taddSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n\t\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace:uri });\n\t\t\t}\n\t\t\tserializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);\n\t\t}\n\n\t\t// add namespace for current node\n\t\tif (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n\t\t\tvar prefix = node.prefix||'';\n\t\t\tvar uri = node.namespaceURI;\n\t\t\taddSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace:uri });\n\t\t}\n\n\t\tif(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){\n\t\t\tbuf.push('>');\n\t\t\t//if is cdata child node\n\t\t\tif(isHTML && /^script$/i.test(nodeName)){\n\t\t\t\twhile(child){\n\t\t\t\t\tif(child.data){\n\t\t\t\t\t\tbuf.push(child.data);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tserializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n\t\t\t\t\t}\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\twhile(child){\n\t\t\t\t\tserializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.push('</',prefixedNodeName,'>');\n\t\t}else{\n\t\t\tbuf.push('/>');\n\t\t}\n\t\t// remove added visible namespaces\n\t\t//visibleNamespaces.length = startVisibleNamespaces;\n\t\treturn;\n\tcase DOCUMENT_NODE:\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tserializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t\treturn;\n\tcase ATTRIBUTE_NODE:\n\t\treturn addSerializedAttribute(buf, node.name, node.value);\n\tcase TEXT_NODE:\n\t\t/**\n\t\t * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n\t\t * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\n\t\t * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\n\t\t * `&amp;` and `&lt;` respectively.\n\t\t * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\n\t\t * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\n\t\t * when that string is not marking the end of a CDATA section.\n\t\t *\n\t\t * In the content of elements, character data is any string of characters\n\t\t * which does not contain the start-delimiter of any markup\n\t\t * and does not include the CDATA-section-close delimiter, `]]>`.\n\t\t *\n\t\t * @see https://www.w3.org/TR/xml/#NT-CharData\n\t\t * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n\t\t */\n\t\treturn buf.push(node.data\n\t\t\t.replace(/[<&>]/g,_xmlEncoder)\n\t\t);\n\tcase CDATA_SECTION_NODE:\n\t\treturn buf.push( '<![CDATA[',node.data,']]>');\n\tcase COMMENT_NODE:\n\t\treturn buf.push( \"<!--\",node.data,\"-->\");\n\tcase DOCUMENT_TYPE_NODE:\n\t\tvar pubid = node.publicId;\n\t\tvar sysid = node.systemId;\n\t\tbuf.push('<!DOCTYPE ',node.name);\n\t\tif(pubid){\n\t\t\tbuf.push(' PUBLIC ', pubid);\n\t\t\tif (sysid && sysid!='.') {\n\t\t\t\tbuf.push(' ', sysid);\n\t\t\t}\n\t\t\tbuf.push('>');\n\t\t}else if(sysid && sysid!='.'){\n\t\t\tbuf.push(' SYSTEM ', sysid, '>');\n\t\t}else{\n\t\t\tvar sub = node.internalSubset;\n\t\t\tif(sub){\n\t\t\t\tbuf.push(\" [\",sub,\"]\");\n\t\t\t}\n\t\t\tbuf.push(\">\");\n\t\t}\n\t\treturn;\n\tcase PROCESSING_INSTRUCTION_NODE:\n\t\treturn buf.push( \"<?\",node.target,\" \",node.data,\"?>\");\n\tcase ENTITY_REFERENCE_NODE:\n\t\treturn buf.push( '&',node.nodeName,';');\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE:\n\tdefault:\n\t\tbuf.push('??',node.nodeName);\n\t}\n}\nfunction importNode(doc,node,deep){\n\tvar node2;\n\tswitch (node.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tnode2 = node.cloneNode(false);\n\t\tnode2.ownerDocument = doc;\n\t\t//var attrs = node2.attributes;\n\t\t//var len = attrs.length;\n\t\t//for(var i=0;i<len;i++){\n\t\t\t//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n\t\t//}\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tbreak;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t\tbreak;\n\t//case ENTITY_REFERENCE_NODE:\n\t//case PROCESSING_INSTRUCTION_NODE:\n\t////case TEXT_NODE:\n\t//case CDATA_SECTION_NODE:\n\t//case COMMENT_NODE:\n\t//\tdeep = false;\n\t//\tbreak;\n\t//case DOCUMENT_NODE:\n\t//case DOCUMENT_TYPE_NODE:\n\t//cannot be imported.\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE：\n\t//can not hit in level3\n\t//default:throw e;\n\t}\n\tif(!node2){\n\t\tnode2 = node.cloneNode(false);//false\n\t}\n\tnode2.ownerDocument = doc;\n\tnode2.parentNode = null;\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(importNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n//\n//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n//\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\nfunction cloneNode(doc,node,deep){\n\tvar node2 = new node.constructor();\n\tfor (var n in node) {\n\t\tif (Object.prototype.hasOwnProperty.call(node, n)) {\n\t\t\tvar v = node[n];\n\t\t\tif (typeof v != \"object\") {\n\t\t\t\tif (v != node2[n]) {\n\t\t\t\t\tnode2[n] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(node.childNodes){\n\t\tnode2.childNodes = new NodeList();\n\t}\n\tnode2.ownerDocument = doc;\n\tswitch (node2.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tvar attrs\t= node.attributes;\n\t\tvar attrs2\t= node2.attributes = new NamedNodeMap();\n\t\tvar len = attrs.length\n\t\tattrs2._ownerElement = node2;\n\t\tfor(var i=0;i<len;i++){\n\t\t\tnode2.setAttributeNode(cloneNode(doc,attrs.item(i),true));\n\t\t}\n\t\tbreak;;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t}\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(cloneNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n\nfunction __set__(object,key,value){\n\tobject[key] = value\n}\n//do dynamic\ntry{\n\tif(Object.defineProperty){\n\t\tObject.defineProperty(LiveNodeList.prototype,'length',{\n\t\t\tget:function(){\n\t\t\t\t_updateLiveList(this);\n\t\t\t\treturn this.$$length;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(Node.prototype,'textContent',{\n\t\t\tget:function(){\n\t\t\t\treturn getTextContent(this);\n\t\t\t},\n\n\t\t\tset:function(data){\n\t\t\t\tswitch(this.nodeType){\n\t\t\t\tcase ELEMENT_NODE:\n\t\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t\twhile(this.firstChild){\n\t\t\t\t\t\tthis.removeChild(this.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tif(data || String(data)){\n\t\t\t\t\t\tthis.appendChild(this.ownerDocument.createTextNode(data));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.data = data;\n\t\t\t\t\tthis.value = data;\n\t\t\t\t\tthis.nodeValue = data;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tfunction getTextContent(node){\n\t\t\tswitch(node.nodeType){\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\tvar buf = [];\n\t\t\t\tnode = node.firstChild;\n\t\t\t\twhile(node){\n\t\t\t\t\tif(node.nodeType!==7 && node.nodeType !==8){\n\t\t\t\t\t\tbuf.push(getTextContent(node));\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t}\n\t\t\t\treturn buf.join('');\n\t\t\tdefault:\n\t\t\t\treturn node.nodeValue;\n\t\t\t}\n\t\t}\n\n\t\t__set__ = function(object,key,value){\n\t\t\t//console.log(value)\n\t\t\tobject['$$'+key] = value\n\t\t}\n\t}\n}catch(e){//ie8\n}\n\n//if(typeof require == 'function'){\n\texports.DocumentType = DocumentType;\n\texports.DOMException = DOMException;\n\texports.DOMImplementation = DOMImplementation;\n\texports.Element = Element;\n\texports.Node = Node;\n\texports.NodeList = NodeList;\n\texports.XMLSerializer = XMLSerializer;\n//}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/dom.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/entities.js":
/*!*****************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/entities.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar freeze = (__webpack_require__(/*! ./conventions */ \"./node_modules/@xmldom/xmldom/lib/conventions.js\").freeze);\n\n/**\n * The entities that are predefined in every XML document.\n *\n * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1\n * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0\n * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia\n */\nexports.XML_ENTITIES = freeze({\n\tamp: '&',\n\tapos: \"'\",\n\tgt: '>',\n\tlt: '<',\n\tquot: '\"',\n});\n\n/**\n * A map of all entities that are detected in an HTML document.\n * They contain all entries from `XML_ENTITIES`.\n *\n * @see XML_ENTITIES\n * @see DOMParser.parseFromString\n * @see DOMImplementation.prototype.createHTMLDocument\n * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec\n * @see https://html.spec.whatwg.org/entities.json JSON\n * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names\n * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML\n * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)\n * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)\n */\nexports.HTML_ENTITIES = freeze({\n\tAacute: '\\u00C1',\n\taacute: '\\u00E1',\n\tAbreve: '\\u0102',\n\tabreve: '\\u0103',\n\tac: '\\u223E',\n\tacd: '\\u223F',\n\tacE: '\\u223E\\u0333',\n\tAcirc: '\\u00C2',\n\tacirc: '\\u00E2',\n\tacute: '\\u00B4',\n\tAcy: '\\u0410',\n\tacy: '\\u0430',\n\tAElig: '\\u00C6',\n\taelig: '\\u00E6',\n\taf: '\\u2061',\n\tAfr: '\\uD835\\uDD04',\n\tafr: '\\uD835\\uDD1E',\n\tAgrave: '\\u00C0',\n\tagrave: '\\u00E0',\n\talefsym: '\\u2135',\n\taleph: '\\u2135',\n\tAlpha: '\\u0391',\n\talpha: '\\u03B1',\n\tAmacr: '\\u0100',\n\tamacr: '\\u0101',\n\tamalg: '\\u2A3F',\n\tAMP: '\\u0026',\n\tamp: '\\u0026',\n\tAnd: '\\u2A53',\n\tand: '\\u2227',\n\tandand: '\\u2A55',\n\tandd: '\\u2A5C',\n\tandslope: '\\u2A58',\n\tandv: '\\u2A5A',\n\tang: '\\u2220',\n\tange: '\\u29A4',\n\tangle: '\\u2220',\n\tangmsd: '\\u2221',\n\tangmsdaa: '\\u29A8',\n\tangmsdab: '\\u29A9',\n\tangmsdac: '\\u29AA',\n\tangmsdad: '\\u29AB',\n\tangmsdae: '\\u29AC',\n\tangmsdaf: '\\u29AD',\n\tangmsdag: '\\u29AE',\n\tangmsdah: '\\u29AF',\n\tangrt: '\\u221F',\n\tangrtvb: '\\u22BE',\n\tangrtvbd: '\\u299D',\n\tangsph: '\\u2222',\n\tangst: '\\u00C5',\n\tangzarr: '\\u237C',\n\tAogon: '\\u0104',\n\taogon: '\\u0105',\n\tAopf: '\\uD835\\uDD38',\n\taopf: '\\uD835\\uDD52',\n\tap: '\\u2248',\n\tapacir: '\\u2A6F',\n\tapE: '\\u2A70',\n\tape: '\\u224A',\n\tapid: '\\u224B',\n\tapos: '\\u0027',\n\tApplyFunction: '\\u2061',\n\tapprox: '\\u2248',\n\tapproxeq: '\\u224A',\n\tAring: '\\u00C5',\n\taring: '\\u00E5',\n\tAscr: '\\uD835\\uDC9C',\n\tascr: '\\uD835\\uDCB6',\n\tAssign: '\\u2254',\n\tast: '\\u002A',\n\tasymp: '\\u2248',\n\tasympeq: '\\u224D',\n\tAtilde: '\\u00C3',\n\tatilde: '\\u00E3',\n\tAuml: '\\u00C4',\n\tauml: '\\u00E4',\n\tawconint: '\\u2233',\n\tawint: '\\u2A11',\n\tbackcong: '\\u224C',\n\tbackepsilon: '\\u03F6',\n\tbackprime: '\\u2035',\n\tbacksim: '\\u223D',\n\tbacksimeq: '\\u22CD',\n\tBackslash: '\\u2216',\n\tBarv: '\\u2AE7',\n\tbarvee: '\\u22BD',\n\tBarwed: '\\u2306',\n\tbarwed: '\\u2305',\n\tbarwedge: '\\u2305',\n\tbbrk: '\\u23B5',\n\tbbrktbrk: '\\u23B6',\n\tbcong: '\\u224C',\n\tBcy: '\\u0411',\n\tbcy: '\\u0431',\n\tbdquo: '\\u201E',\n\tbecaus: '\\u2235',\n\tBecause: '\\u2235',\n\tbecause: '\\u2235',\n\tbemptyv: '\\u29B0',\n\tbepsi: '\\u03F6',\n\tbernou: '\\u212C',\n\tBernoullis: '\\u212C',\n\tBeta: '\\u0392',\n\tbeta: '\\u03B2',\n\tbeth: '\\u2136',\n\tbetween: '\\u226C',\n\tBfr: '\\uD835\\uDD05',\n\tbfr: '\\uD835\\uDD1F',\n\tbigcap: '\\u22C2',\n\tbigcirc: '\\u25EF',\n\tbigcup: '\\u22C3',\n\tbigodot: '\\u2A00',\n\tbigoplus: '\\u2A01',\n\tbigotimes: '\\u2A02',\n\tbigsqcup: '\\u2A06',\n\tbigstar: '\\u2605',\n\tbigtriangledown: '\\u25BD',\n\tbigtriangleup: '\\u25B3',\n\tbiguplus: '\\u2A04',\n\tbigvee: '\\u22C1',\n\tbigwedge: '\\u22C0',\n\tbkarow: '\\u290D',\n\tblacklozenge: '\\u29EB',\n\tblacksquare: '\\u25AA',\n\tblacktriangle: '\\u25B4',\n\tblacktriangledown: '\\u25BE',\n\tblacktriangleleft: '\\u25C2',\n\tblacktriangleright: '\\u25B8',\n\tblank: '\\u2423',\n\tblk12: '\\u2592',\n\tblk14: '\\u2591',\n\tblk34: '\\u2593',\n\tblock: '\\u2588',\n\tbne: '\\u003D\\u20E5',\n\tbnequiv: '\\u2261\\u20E5',\n\tbNot: '\\u2AED',\n\tbnot: '\\u2310',\n\tBopf: '\\uD835\\uDD39',\n\tbopf: '\\uD835\\uDD53',\n\tbot: '\\u22A5',\n\tbottom: '\\u22A5',\n\tbowtie: '\\u22C8',\n\tboxbox: '\\u29C9',\n\tboxDL: '\\u2557',\n\tboxDl: '\\u2556',\n\tboxdL: '\\u2555',\n\tboxdl: '\\u2510',\n\tboxDR: '\\u2554',\n\tboxDr: '\\u2553',\n\tboxdR: '\\u2552',\n\tboxdr: '\\u250C',\n\tboxH: '\\u2550',\n\tboxh: '\\u2500',\n\tboxHD: '\\u2566',\n\tboxHd: '\\u2564',\n\tboxhD: '\\u2565',\n\tboxhd: '\\u252C',\n\tboxHU: '\\u2569',\n\tboxHu: '\\u2567',\n\tboxhU: '\\u2568',\n\tboxhu: '\\u2534',\n\tboxminus: '\\u229F',\n\tboxplus: '\\u229E',\n\tboxtimes: '\\u22A0',\n\tboxUL: '\\u255D',\n\tboxUl: '\\u255C',\n\tboxuL: '\\u255B',\n\tboxul: '\\u2518',\n\tboxUR: '\\u255A',\n\tboxUr: '\\u2559',\n\tboxuR: '\\u2558',\n\tboxur: '\\u2514',\n\tboxV: '\\u2551',\n\tboxv: '\\u2502',\n\tboxVH: '\\u256C',\n\tboxVh: '\\u256B',\n\tboxvH: '\\u256A',\n\tboxvh: '\\u253C',\n\tboxVL: '\\u2563',\n\tboxVl: '\\u2562',\n\tboxvL: '\\u2561',\n\tboxvl: '\\u2524',\n\tboxVR: '\\u2560',\n\tboxVr: '\\u255F',\n\tboxvR: '\\u255E',\n\tboxvr: '\\u251C',\n\tbprime: '\\u2035',\n\tBreve: '\\u02D8',\n\tbreve: '\\u02D8',\n\tbrvbar: '\\u00A6',\n\tBscr: '\\u212C',\n\tbscr: '\\uD835\\uDCB7',\n\tbsemi: '\\u204F',\n\tbsim: '\\u223D',\n\tbsime: '\\u22CD',\n\tbsol: '\\u005C',\n\tbsolb: '\\u29C5',\n\tbsolhsub: '\\u27C8',\n\tbull: '\\u2022',\n\tbullet: '\\u2022',\n\tbump: '\\u224E',\n\tbumpE: '\\u2AAE',\n\tbumpe: '\\u224F',\n\tBumpeq: '\\u224E',\n\tbumpeq: '\\u224F',\n\tCacute: '\\u0106',\n\tcacute: '\\u0107',\n\tCap: '\\u22D2',\n\tcap: '\\u2229',\n\tcapand: '\\u2A44',\n\tcapbrcup: '\\u2A49',\n\tcapcap: '\\u2A4B',\n\tcapcup: '\\u2A47',\n\tcapdot: '\\u2A40',\n\tCapitalDifferentialD: '\\u2145',\n\tcaps: '\\u2229\\uFE00',\n\tcaret: '\\u2041',\n\tcaron: '\\u02C7',\n\tCayleys: '\\u212D',\n\tccaps: '\\u2A4D',\n\tCcaron: '\\u010C',\n\tccaron: '\\u010D',\n\tCcedil: '\\u00C7',\n\tccedil: '\\u00E7',\n\tCcirc: '\\u0108',\n\tccirc: '\\u0109',\n\tCconint: '\\u2230',\n\tccups: '\\u2A4C',\n\tccupssm: '\\u2A50',\n\tCdot: '\\u010A',\n\tcdot: '\\u010B',\n\tcedil: '\\u00B8',\n\tCedilla: '\\u00B8',\n\tcemptyv: '\\u29B2',\n\tcent: '\\u00A2',\n\tCenterDot: '\\u00B7',\n\tcenterdot: '\\u00B7',\n\tCfr: '\\u212D',\n\tcfr: '\\uD835\\uDD20',\n\tCHcy: '\\u0427',\n\tchcy: '\\u0447',\n\tcheck: '\\u2713',\n\tcheckmark: '\\u2713',\n\tChi: '\\u03A7',\n\tchi: '\\u03C7',\n\tcir: '\\u25CB',\n\tcirc: '\\u02C6',\n\tcirceq: '\\u2257',\n\tcirclearrowleft: '\\u21BA',\n\tcirclearrowright: '\\u21BB',\n\tcircledast: '\\u229B',\n\tcircledcirc: '\\u229A',\n\tcircleddash: '\\u229D',\n\tCircleDot: '\\u2299',\n\tcircledR: '\\u00AE',\n\tcircledS: '\\u24C8',\n\tCircleMinus: '\\u2296',\n\tCirclePlus: '\\u2295',\n\tCircleTimes: '\\u2297',\n\tcirE: '\\u29C3',\n\tcire: '\\u2257',\n\tcirfnint: '\\u2A10',\n\tcirmid: '\\u2AEF',\n\tcirscir: '\\u29C2',\n\tClockwiseContourIntegral: '\\u2232',\n\tCloseCurlyDoubleQuote: '\\u201D',\n\tCloseCurlyQuote: '\\u2019',\n\tclubs: '\\u2663',\n\tclubsuit: '\\u2663',\n\tColon: '\\u2237',\n\tcolon: '\\u003A',\n\tColone: '\\u2A74',\n\tcolone: '\\u2254',\n\tcoloneq: '\\u2254',\n\tcomma: '\\u002C',\n\tcommat: '\\u0040',\n\tcomp: '\\u2201',\n\tcompfn: '\\u2218',\n\tcomplement: '\\u2201',\n\tcomplexes: '\\u2102',\n\tcong: '\\u2245',\n\tcongdot: '\\u2A6D',\n\tCongruent: '\\u2261',\n\tConint: '\\u222F',\n\tconint: '\\u222E',\n\tContourIntegral: '\\u222E',\n\tCopf: '\\u2102',\n\tcopf: '\\uD835\\uDD54',\n\tcoprod: '\\u2210',\n\tCoproduct: '\\u2210',\n\tCOPY: '\\u00A9',\n\tcopy: '\\u00A9',\n\tcopysr: '\\u2117',\n\tCounterClockwiseContourIntegral: '\\u2233',\n\tcrarr: '\\u21B5',\n\tCross: '\\u2A2F',\n\tcross: '\\u2717',\n\tCscr: '\\uD835\\uDC9E',\n\tcscr: '\\uD835\\uDCB8',\n\tcsub: '\\u2ACF',\n\tcsube: '\\u2AD1',\n\tcsup: '\\u2AD0',\n\tcsupe: '\\u2AD2',\n\tctdot: '\\u22EF',\n\tcudarrl: '\\u2938',\n\tcudarrr: '\\u2935',\n\tcuepr: '\\u22DE',\n\tcuesc: '\\u22DF',\n\tcularr: '\\u21B6',\n\tcularrp: '\\u293D',\n\tCup: '\\u22D3',\n\tcup: '\\u222A',\n\tcupbrcap: '\\u2A48',\n\tCupCap: '\\u224D',\n\tcupcap: '\\u2A46',\n\tcupcup: '\\u2A4A',\n\tcupdot: '\\u228D',\n\tcupor: '\\u2A45',\n\tcups: '\\u222A\\uFE00',\n\tcurarr: '\\u21B7',\n\tcurarrm: '\\u293C',\n\tcurlyeqprec: '\\u22DE',\n\tcurlyeqsucc: '\\u22DF',\n\tcurlyvee: '\\u22CE',\n\tcurlywedge: '\\u22CF',\n\tcurren: '\\u00A4',\n\tcurvearrowleft: '\\u21B6',\n\tcurvearrowright: '\\u21B7',\n\tcuvee: '\\u22CE',\n\tcuwed: '\\u22CF',\n\tcwconint: '\\u2232',\n\tcwint: '\\u2231',\n\tcylcty: '\\u232D',\n\tDagger: '\\u2021',\n\tdagger: '\\u2020',\n\tdaleth: '\\u2138',\n\tDarr: '\\u21A1',\n\tdArr: '\\u21D3',\n\tdarr: '\\u2193',\n\tdash: '\\u2010',\n\tDashv: '\\u2AE4',\n\tdashv: '\\u22A3',\n\tdbkarow: '\\u290F',\n\tdblac: '\\u02DD',\n\tDcaron: '\\u010E',\n\tdcaron: '\\u010F',\n\tDcy: '\\u0414',\n\tdcy: '\\u0434',\n\tDD: '\\u2145',\n\tdd: '\\u2146',\n\tddagger: '\\u2021',\n\tddarr: '\\u21CA',\n\tDDotrahd: '\\u2911',\n\tddotseq: '\\u2A77',\n\tdeg: '\\u00B0',\n\tDel: '\\u2207',\n\tDelta: '\\u0394',\n\tdelta: '\\u03B4',\n\tdemptyv: '\\u29B1',\n\tdfisht: '\\u297F',\n\tDfr: '\\uD835\\uDD07',\n\tdfr: '\\uD835\\uDD21',\n\tdHar: '\\u2965',\n\tdharl: '\\u21C3',\n\tdharr: '\\u21C2',\n\tDiacriticalAcute: '\\u00B4',\n\tDiacriticalDot: '\\u02D9',\n\tDiacriticalDoubleAcute: '\\u02DD',\n\tDiacriticalGrave: '\\u0060',\n\tDiacriticalTilde: '\\u02DC',\n\tdiam: '\\u22C4',\n\tDiamond: '\\u22C4',\n\tdiamond: '\\u22C4',\n\tdiamondsuit: '\\u2666',\n\tdiams: '\\u2666',\n\tdie: '\\u00A8',\n\tDifferentialD: '\\u2146',\n\tdigamma: '\\u03DD',\n\tdisin: '\\u22F2',\n\tdiv: '\\u00F7',\n\tdivide: '\\u00F7',\n\tdivideontimes: '\\u22C7',\n\tdivonx: '\\u22C7',\n\tDJcy: '\\u0402',\n\tdjcy: '\\u0452',\n\tdlcorn: '\\u231E',\n\tdlcrop: '\\u230D',\n\tdollar: '\\u0024',\n\tDopf: '\\uD835\\uDD3B',\n\tdopf: '\\uD835\\uDD55',\n\tDot: '\\u00A8',\n\tdot: '\\u02D9',\n\tDotDot: '\\u20DC',\n\tdoteq: '\\u2250',\n\tdoteqdot: '\\u2251',\n\tDotEqual: '\\u2250',\n\tdotminus: '\\u2238',\n\tdotplus: '\\u2214',\n\tdotsquare: '\\u22A1',\n\tdoublebarwedge: '\\u2306',\n\tDoubleContourIntegral: '\\u222F',\n\tDoubleDot: '\\u00A8',\n\tDoubleDownArrow: '\\u21D3',\n\tDoubleLeftArrow: '\\u21D0',\n\tDoubleLeftRightArrow: '\\u21D4',\n\tDoubleLeftTee: '\\u2AE4',\n\tDoubleLongLeftArrow: '\\u27F8',\n\tDoubleLongLeftRightArrow: '\\u27FA',\n\tDoubleLongRightArrow: '\\u27F9',\n\tDoubleRightArrow: '\\u21D2',\n\tDoubleRightTee: '\\u22A8',\n\tDoubleUpArrow: '\\u21D1',\n\tDoubleUpDownArrow: '\\u21D5',\n\tDoubleVerticalBar: '\\u2225',\n\tDownArrow: '\\u2193',\n\tDownarrow: '\\u21D3',\n\tdownarrow: '\\u2193',\n\tDownArrowBar: '\\u2913',\n\tDownArrowUpArrow: '\\u21F5',\n\tDownBreve: '\\u0311',\n\tdowndownarrows: '\\u21CA',\n\tdownharpoonleft: '\\u21C3',\n\tdownharpoonright: '\\u21C2',\n\tDownLeftRightVector: '\\u2950',\n\tDownLeftTeeVector: '\\u295E',\n\tDownLeftVector: '\\u21BD',\n\tDownLeftVectorBar: '\\u2956',\n\tDownRightTeeVector: '\\u295F',\n\tDownRightVector: '\\u21C1',\n\tDownRightVectorBar: '\\u2957',\n\tDownTee: '\\u22A4',\n\tDownTeeArrow: '\\u21A7',\n\tdrbkarow: '\\u2910',\n\tdrcorn: '\\u231F',\n\tdrcrop: '\\u230C',\n\tDscr: '\\uD835\\uDC9F',\n\tdscr: '\\uD835\\uDCB9',\n\tDScy: '\\u0405',\n\tdscy: '\\u0455',\n\tdsol: '\\u29F6',\n\tDstrok: '\\u0110',\n\tdstrok: '\\u0111',\n\tdtdot: '\\u22F1',\n\tdtri: '\\u25BF',\n\tdtrif: '\\u25BE',\n\tduarr: '\\u21F5',\n\tduhar: '\\u296F',\n\tdwangle: '\\u29A6',\n\tDZcy: '\\u040F',\n\tdzcy: '\\u045F',\n\tdzigrarr: '\\u27FF',\n\tEacute: '\\u00C9',\n\teacute: '\\u00E9',\n\teaster: '\\u2A6E',\n\tEcaron: '\\u011A',\n\tecaron: '\\u011B',\n\tecir: '\\u2256',\n\tEcirc: '\\u00CA',\n\tecirc: '\\u00EA',\n\tecolon: '\\u2255',\n\tEcy: '\\u042D',\n\tecy: '\\u044D',\n\teDDot: '\\u2A77',\n\tEdot: '\\u0116',\n\teDot: '\\u2251',\n\tedot: '\\u0117',\n\tee: '\\u2147',\n\tefDot: '\\u2252',\n\tEfr: '\\uD835\\uDD08',\n\tefr: '\\uD835\\uDD22',\n\teg: '\\u2A9A',\n\tEgrave: '\\u00C8',\n\tegrave: '\\u00E8',\n\tegs: '\\u2A96',\n\tegsdot: '\\u2A98',\n\tel: '\\u2A99',\n\tElement: '\\u2208',\n\telinters: '\\u23E7',\n\tell: '\\u2113',\n\tels: '\\u2A95',\n\telsdot: '\\u2A97',\n\tEmacr: '\\u0112',\n\temacr: '\\u0113',\n\tempty: '\\u2205',\n\temptyset: '\\u2205',\n\tEmptySmallSquare: '\\u25FB',\n\temptyv: '\\u2205',\n\tEmptyVerySmallSquare: '\\u25AB',\n\temsp: '\\u2003',\n\temsp13: '\\u2004',\n\temsp14: '\\u2005',\n\tENG: '\\u014A',\n\teng: '\\u014B',\n\tensp: '\\u2002',\n\tEogon: '\\u0118',\n\teogon: '\\u0119',\n\tEopf: '\\uD835\\uDD3C',\n\teopf: '\\uD835\\uDD56',\n\tepar: '\\u22D5',\n\teparsl: '\\u29E3',\n\teplus: '\\u2A71',\n\tepsi: '\\u03B5',\n\tEpsilon: '\\u0395',\n\tepsilon: '\\u03B5',\n\tepsiv: '\\u03F5',\n\teqcirc: '\\u2256',\n\teqcolon: '\\u2255',\n\teqsim: '\\u2242',\n\teqslantgtr: '\\u2A96',\n\teqslantless: '\\u2A95',\n\tEqual: '\\u2A75',\n\tequals: '\\u003D',\n\tEqualTilde: '\\u2242',\n\tequest: '\\u225F',\n\tEquilibrium: '\\u21CC',\n\tequiv: '\\u2261',\n\tequivDD: '\\u2A78',\n\teqvparsl: '\\u29E5',\n\terarr: '\\u2971',\n\terDot: '\\u2253',\n\tEscr: '\\u2130',\n\tescr: '\\u212F',\n\tesdot: '\\u2250',\n\tEsim: '\\u2A73',\n\tesim: '\\u2242',\n\tEta: '\\u0397',\n\teta: '\\u03B7',\n\tETH: '\\u00D0',\n\teth: '\\u00F0',\n\tEuml: '\\u00CB',\n\teuml: '\\u00EB',\n\teuro: '\\u20AC',\n\texcl: '\\u0021',\n\texist: '\\u2203',\n\tExists: '\\u2203',\n\texpectation: '\\u2130',\n\tExponentialE: '\\u2147',\n\texponentiale: '\\u2147',\n\tfallingdotseq: '\\u2252',\n\tFcy: '\\u0424',\n\tfcy: '\\u0444',\n\tfemale: '\\u2640',\n\tffilig: '\\uFB03',\n\tfflig: '\\uFB00',\n\tffllig: '\\uFB04',\n\tFfr: '\\uD835\\uDD09',\n\tffr: '\\uD835\\uDD23',\n\tfilig: '\\uFB01',\n\tFilledSmallSquare: '\\u25FC',\n\tFilledVerySmallSquare: '\\u25AA',\n\tfjlig: '\\u0066\\u006A',\n\tflat: '\\u266D',\n\tfllig: '\\uFB02',\n\tfltns: '\\u25B1',\n\tfnof: '\\u0192',\n\tFopf: '\\uD835\\uDD3D',\n\tfopf: '\\uD835\\uDD57',\n\tForAll: '\\u2200',\n\tforall: '\\u2200',\n\tfork: '\\u22D4',\n\tforkv: '\\u2AD9',\n\tFouriertrf: '\\u2131',\n\tfpartint: '\\u2A0D',\n\tfrac12: '\\u00BD',\n\tfrac13: '\\u2153',\n\tfrac14: '\\u00BC',\n\tfrac15: '\\u2155',\n\tfrac16: '\\u2159',\n\tfrac18: '\\u215B',\n\tfrac23: '\\u2154',\n\tfrac25: '\\u2156',\n\tfrac34: '\\u00BE',\n\tfrac35: '\\u2157',\n\tfrac38: '\\u215C',\n\tfrac45: '\\u2158',\n\tfrac56: '\\u215A',\n\tfrac58: '\\u215D',\n\tfrac78: '\\u215E',\n\tfrasl: '\\u2044',\n\tfrown: '\\u2322',\n\tFscr: '\\u2131',\n\tfscr: '\\uD835\\uDCBB',\n\tgacute: '\\u01F5',\n\tGamma: '\\u0393',\n\tgamma: '\\u03B3',\n\tGammad: '\\u03DC',\n\tgammad: '\\u03DD',\n\tgap: '\\u2A86',\n\tGbreve: '\\u011E',\n\tgbreve: '\\u011F',\n\tGcedil: '\\u0122',\n\tGcirc: '\\u011C',\n\tgcirc: '\\u011D',\n\tGcy: '\\u0413',\n\tgcy: '\\u0433',\n\tGdot: '\\u0120',\n\tgdot: '\\u0121',\n\tgE: '\\u2267',\n\tge: '\\u2265',\n\tgEl: '\\u2A8C',\n\tgel: '\\u22DB',\n\tgeq: '\\u2265',\n\tgeqq: '\\u2267',\n\tgeqslant: '\\u2A7E',\n\tges: '\\u2A7E',\n\tgescc: '\\u2AA9',\n\tgesdot: '\\u2A80',\n\tgesdoto: '\\u2A82',\n\tgesdotol: '\\u2A84',\n\tgesl: '\\u22DB\\uFE00',\n\tgesles: '\\u2A94',\n\tGfr: '\\uD835\\uDD0A',\n\tgfr: '\\uD835\\uDD24',\n\tGg: '\\u22D9',\n\tgg: '\\u226B',\n\tggg: '\\u22D9',\n\tgimel: '\\u2137',\n\tGJcy: '\\u0403',\n\tgjcy: '\\u0453',\n\tgl: '\\u2277',\n\tgla: '\\u2AA5',\n\tglE: '\\u2A92',\n\tglj: '\\u2AA4',\n\tgnap: '\\u2A8A',\n\tgnapprox: '\\u2A8A',\n\tgnE: '\\u2269',\n\tgne: '\\u2A88',\n\tgneq: '\\u2A88',\n\tgneqq: '\\u2269',\n\tgnsim: '\\u22E7',\n\tGopf: '\\uD835\\uDD3E',\n\tgopf: '\\uD835\\uDD58',\n\tgrave: '\\u0060',\n\tGreaterEqual: '\\u2265',\n\tGreaterEqualLess: '\\u22DB',\n\tGreaterFullEqual: '\\u2267',\n\tGreaterGreater: '\\u2AA2',\n\tGreaterLess: '\\u2277',\n\tGreaterSlantEqual: '\\u2A7E',\n\tGreaterTilde: '\\u2273',\n\tGscr: '\\uD835\\uDCA2',\n\tgscr: '\\u210A',\n\tgsim: '\\u2273',\n\tgsime: '\\u2A8E',\n\tgsiml: '\\u2A90',\n\tGt: '\\u226B',\n\tGT: '\\u003E',\n\tgt: '\\u003E',\n\tgtcc: '\\u2AA7',\n\tgtcir: '\\u2A7A',\n\tgtdot: '\\u22D7',\n\tgtlPar: '\\u2995',\n\tgtquest: '\\u2A7C',\n\tgtrapprox: '\\u2A86',\n\tgtrarr: '\\u2978',\n\tgtrdot: '\\u22D7',\n\tgtreqless: '\\u22DB',\n\tgtreqqless: '\\u2A8C',\n\tgtrless: '\\u2277',\n\tgtrsim: '\\u2273',\n\tgvertneqq: '\\u2269\\uFE00',\n\tgvnE: '\\u2269\\uFE00',\n\tHacek: '\\u02C7',\n\thairsp: '\\u200A',\n\thalf: '\\u00BD',\n\thamilt: '\\u210B',\n\tHARDcy: '\\u042A',\n\thardcy: '\\u044A',\n\thArr: '\\u21D4',\n\tharr: '\\u2194',\n\tharrcir: '\\u2948',\n\tharrw: '\\u21AD',\n\tHat: '\\u005E',\n\thbar: '\\u210F',\n\tHcirc: '\\u0124',\n\thcirc: '\\u0125',\n\thearts: '\\u2665',\n\theartsuit: '\\u2665',\n\thellip: '\\u2026',\n\thercon: '\\u22B9',\n\tHfr: '\\u210C',\n\thfr: '\\uD835\\uDD25',\n\tHilbertSpace: '\\u210B',\n\thksearow: '\\u2925',\n\thkswarow: '\\u2926',\n\thoarr: '\\u21FF',\n\thomtht: '\\u223B',\n\thookleftarrow: '\\u21A9',\n\thookrightarrow: '\\u21AA',\n\tHopf: '\\u210D',\n\thopf: '\\uD835\\uDD59',\n\thorbar: '\\u2015',\n\tHorizontalLine: '\\u2500',\n\tHscr: '\\u210B',\n\thscr: '\\uD835\\uDCBD',\n\thslash: '\\u210F',\n\tHstrok: '\\u0126',\n\thstrok: '\\u0127',\n\tHumpDownHump: '\\u224E',\n\tHumpEqual: '\\u224F',\n\thybull: '\\u2043',\n\thyphen: '\\u2010',\n\tIacute: '\\u00CD',\n\tiacute: '\\u00ED',\n\tic: '\\u2063',\n\tIcirc: '\\u00CE',\n\ticirc: '\\u00EE',\n\tIcy: '\\u0418',\n\ticy: '\\u0438',\n\tIdot: '\\u0130',\n\tIEcy: '\\u0415',\n\tiecy: '\\u0435',\n\tiexcl: '\\u00A1',\n\tiff: '\\u21D4',\n\tIfr: '\\u2111',\n\tifr: '\\uD835\\uDD26',\n\tIgrave: '\\u00CC',\n\tigrave: '\\u00EC',\n\tii: '\\u2148',\n\tiiiint: '\\u2A0C',\n\tiiint: '\\u222D',\n\tiinfin: '\\u29DC',\n\tiiota: '\\u2129',\n\tIJlig: '\\u0132',\n\tijlig: '\\u0133',\n\tIm: '\\u2111',\n\tImacr: '\\u012A',\n\timacr: '\\u012B',\n\timage: '\\u2111',\n\tImaginaryI: '\\u2148',\n\timagline: '\\u2110',\n\timagpart: '\\u2111',\n\timath: '\\u0131',\n\timof: '\\u22B7',\n\timped: '\\u01B5',\n\tImplies: '\\u21D2',\n\tin: '\\u2208',\n\tincare: '\\u2105',\n\tinfin: '\\u221E',\n\tinfintie: '\\u29DD',\n\tinodot: '\\u0131',\n\tInt: '\\u222C',\n\tint: '\\u222B',\n\tintcal: '\\u22BA',\n\tintegers: '\\u2124',\n\tIntegral: '\\u222B',\n\tintercal: '\\u22BA',\n\tIntersection: '\\u22C2',\n\tintlarhk: '\\u2A17',\n\tintprod: '\\u2A3C',\n\tInvisibleComma: '\\u2063',\n\tInvisibleTimes: '\\u2062',\n\tIOcy: '\\u0401',\n\tiocy: '\\u0451',\n\tIogon: '\\u012E',\n\tiogon: '\\u012F',\n\tIopf: '\\uD835\\uDD40',\n\tiopf: '\\uD835\\uDD5A',\n\tIota: '\\u0399',\n\tiota: '\\u03B9',\n\tiprod: '\\u2A3C',\n\tiquest: '\\u00BF',\n\tIscr: '\\u2110',\n\tiscr: '\\uD835\\uDCBE',\n\tisin: '\\u2208',\n\tisindot: '\\u22F5',\n\tisinE: '\\u22F9',\n\tisins: '\\u22F4',\n\tisinsv: '\\u22F3',\n\tisinv: '\\u2208',\n\tit: '\\u2062',\n\tItilde: '\\u0128',\n\titilde: '\\u0129',\n\tIukcy: '\\u0406',\n\tiukcy: '\\u0456',\n\tIuml: '\\u00CF',\n\tiuml: '\\u00EF',\n\tJcirc: '\\u0134',\n\tjcirc: '\\u0135',\n\tJcy: '\\u0419',\n\tjcy: '\\u0439',\n\tJfr: '\\uD835\\uDD0D',\n\tjfr: '\\uD835\\uDD27',\n\tjmath: '\\u0237',\n\tJopf: '\\uD835\\uDD41',\n\tjopf: '\\uD835\\uDD5B',\n\tJscr: '\\uD835\\uDCA5',\n\tjscr: '\\uD835\\uDCBF',\n\tJsercy: '\\u0408',\n\tjsercy: '\\u0458',\n\tJukcy: '\\u0404',\n\tjukcy: '\\u0454',\n\tKappa: '\\u039A',\n\tkappa: '\\u03BA',\n\tkappav: '\\u03F0',\n\tKcedil: '\\u0136',\n\tkcedil: '\\u0137',\n\tKcy: '\\u041A',\n\tkcy: '\\u043A',\n\tKfr: '\\uD835\\uDD0E',\n\tkfr: '\\uD835\\uDD28',\n\tkgreen: '\\u0138',\n\tKHcy: '\\u0425',\n\tkhcy: '\\u0445',\n\tKJcy: '\\u040C',\n\tkjcy: '\\u045C',\n\tKopf: '\\uD835\\uDD42',\n\tkopf: '\\uD835\\uDD5C',\n\tKscr: '\\uD835\\uDCA6',\n\tkscr: '\\uD835\\uDCC0',\n\tlAarr: '\\u21DA',\n\tLacute: '\\u0139',\n\tlacute: '\\u013A',\n\tlaemptyv: '\\u29B4',\n\tlagran: '\\u2112',\n\tLambda: '\\u039B',\n\tlambda: '\\u03BB',\n\tLang: '\\u27EA',\n\tlang: '\\u27E8',\n\tlangd: '\\u2991',\n\tlangle: '\\u27E8',\n\tlap: '\\u2A85',\n\tLaplacetrf: '\\u2112',\n\tlaquo: '\\u00AB',\n\tLarr: '\\u219E',\n\tlArr: '\\u21D0',\n\tlarr: '\\u2190',\n\tlarrb: '\\u21E4',\n\tlarrbfs: '\\u291F',\n\tlarrfs: '\\u291D',\n\tlarrhk: '\\u21A9',\n\tlarrlp: '\\u21AB',\n\tlarrpl: '\\u2939',\n\tlarrsim: '\\u2973',\n\tlarrtl: '\\u21A2',\n\tlat: '\\u2AAB',\n\tlAtail: '\\u291B',\n\tlatail: '\\u2919',\n\tlate: '\\u2AAD',\n\tlates: '\\u2AAD\\uFE00',\n\tlBarr: '\\u290E',\n\tlbarr: '\\u290C',\n\tlbbrk: '\\u2772',\n\tlbrace: '\\u007B',\n\tlbrack: '\\u005B',\n\tlbrke: '\\u298B',\n\tlbrksld: '\\u298F',\n\tlbrkslu: '\\u298D',\n\tLcaron: '\\u013D',\n\tlcaron: '\\u013E',\n\tLcedil: '\\u013B',\n\tlcedil: '\\u013C',\n\tlceil: '\\u2308',\n\tlcub: '\\u007B',\n\tLcy: '\\u041B',\n\tlcy: '\\u043B',\n\tldca: '\\u2936',\n\tldquo: '\\u201C',\n\tldquor: '\\u201E',\n\tldrdhar: '\\u2967',\n\tldrushar: '\\u294B',\n\tldsh: '\\u21B2',\n\tlE: '\\u2266',\n\tle: '\\u2264',\n\tLeftAngleBracket: '\\u27E8',\n\tLeftArrow: '\\u2190',\n\tLeftarrow: '\\u21D0',\n\tleftarrow: '\\u2190',\n\tLeftArrowBar: '\\u21E4',\n\tLeftArrowRightArrow: '\\u21C6',\n\tleftarrowtail: '\\u21A2',\n\tLeftCeiling: '\\u2308',\n\tLeftDoubleBracket: '\\u27E6',\n\tLeftDownTeeVector: '\\u2961',\n\tLeftDownVector: '\\u21C3',\n\tLeftDownVectorBar: '\\u2959',\n\tLeftFloor: '\\u230A',\n\tleftharpoondown: '\\u21BD',\n\tleftharpoonup: '\\u21BC',\n\tleftleftarrows: '\\u21C7',\n\tLeftRightArrow: '\\u2194',\n\tLeftrightarrow: '\\u21D4',\n\tleftrightarrow: '\\u2194',\n\tleftrightarrows: '\\u21C6',\n\tleftrightharpoons: '\\u21CB',\n\tleftrightsquigarrow: '\\u21AD',\n\tLeftRightVector: '\\u294E',\n\tLeftTee: '\\u22A3',\n\tLeftTeeArrow: '\\u21A4',\n\tLeftTeeVector: '\\u295A',\n\tleftthreetimes: '\\u22CB',\n\tLeftTriangle: '\\u22B2',\n\tLeftTriangleBar: '\\u29CF',\n\tLeftTriangleEqual: '\\u22B4',\n\tLeftUpDownVector: '\\u2951',\n\tLeftUpTeeVector: '\\u2960',\n\tLeftUpVector: '\\u21BF',\n\tLeftUpVectorBar: '\\u2958',\n\tLeftVector: '\\u21BC',\n\tLeftVectorBar: '\\u2952',\n\tlEg: '\\u2A8B',\n\tleg: '\\u22DA',\n\tleq: '\\u2264',\n\tleqq: '\\u2266',\n\tleqslant: '\\u2A7D',\n\tles: '\\u2A7D',\n\tlescc: '\\u2AA8',\n\tlesdot: '\\u2A7F',\n\tlesdoto: '\\u2A81',\n\tlesdotor: '\\u2A83',\n\tlesg: '\\u22DA\\uFE00',\n\tlesges: '\\u2A93',\n\tlessapprox: '\\u2A85',\n\tlessdot: '\\u22D6',\n\tlesseqgtr: '\\u22DA',\n\tlesseqqgtr: '\\u2A8B',\n\tLessEqualGreater: '\\u22DA',\n\tLessFullEqual: '\\u2266',\n\tLessGreater: '\\u2276',\n\tlessgtr: '\\u2276',\n\tLessLess: '\\u2AA1',\n\tlesssim: '\\u2272',\n\tLessSlantEqual: '\\u2A7D',\n\tLessTilde: '\\u2272',\n\tlfisht: '\\u297C',\n\tlfloor: '\\u230A',\n\tLfr: '\\uD835\\uDD0F',\n\tlfr: '\\uD835\\uDD29',\n\tlg: '\\u2276',\n\tlgE: '\\u2A91',\n\tlHar: '\\u2962',\n\tlhard: '\\u21BD',\n\tlharu: '\\u21BC',\n\tlharul: '\\u296A',\n\tlhblk: '\\u2584',\n\tLJcy: '\\u0409',\n\tljcy: '\\u0459',\n\tLl: '\\u22D8',\n\tll: '\\u226A',\n\tllarr: '\\u21C7',\n\tllcorner: '\\u231E',\n\tLleftarrow: '\\u21DA',\n\tllhard: '\\u296B',\n\tlltri: '\\u25FA',\n\tLmidot: '\\u013F',\n\tlmidot: '\\u0140',\n\tlmoust: '\\u23B0',\n\tlmoustache: '\\u23B0',\n\tlnap: '\\u2A89',\n\tlnapprox: '\\u2A89',\n\tlnE: '\\u2268',\n\tlne: '\\u2A87',\n\tlneq: '\\u2A87',\n\tlneqq: '\\u2268',\n\tlnsim: '\\u22E6',\n\tloang: '\\u27EC',\n\tloarr: '\\u21FD',\n\tlobrk: '\\u27E6',\n\tLongLeftArrow: '\\u27F5',\n\tLongleftarrow: '\\u27F8',\n\tlongleftarrow: '\\u27F5',\n\tLongLeftRightArrow: '\\u27F7',\n\tLongleftrightarrow: '\\u27FA',\n\tlongleftrightarrow: '\\u27F7',\n\tlongmapsto: '\\u27FC',\n\tLongRightArrow: '\\u27F6',\n\tLongrightarrow: '\\u27F9',\n\tlongrightarrow: '\\u27F6',\n\tlooparrowleft: '\\u21AB',\n\tlooparrowright: '\\u21AC',\n\tlopar: '\\u2985',\n\tLopf: '\\uD835\\uDD43',\n\tlopf: '\\uD835\\uDD5D',\n\tloplus: '\\u2A2D',\n\tlotimes: '\\u2A34',\n\tlowast: '\\u2217',\n\tlowbar: '\\u005F',\n\tLowerLeftArrow: '\\u2199',\n\tLowerRightArrow: '\\u2198',\n\tloz: '\\u25CA',\n\tlozenge: '\\u25CA',\n\tlozf: '\\u29EB',\n\tlpar: '\\u0028',\n\tlparlt: '\\u2993',\n\tlrarr: '\\u21C6',\n\tlrcorner: '\\u231F',\n\tlrhar: '\\u21CB',\n\tlrhard: '\\u296D',\n\tlrm: '\\u200E',\n\tlrtri: '\\u22BF',\n\tlsaquo: '\\u2039',\n\tLscr: '\\u2112',\n\tlscr: '\\uD835\\uDCC1',\n\tLsh: '\\u21B0',\n\tlsh: '\\u21B0',\n\tlsim: '\\u2272',\n\tlsime: '\\u2A8D',\n\tlsimg: '\\u2A8F',\n\tlsqb: '\\u005B',\n\tlsquo: '\\u2018',\n\tlsquor: '\\u201A',\n\tLstrok: '\\u0141',\n\tlstrok: '\\u0142',\n\tLt: '\\u226A',\n\tLT: '\\u003C',\n\tlt: '\\u003C',\n\tltcc: '\\u2AA6',\n\tltcir: '\\u2A79',\n\tltdot: '\\u22D6',\n\tlthree: '\\u22CB',\n\tltimes: '\\u22C9',\n\tltlarr: '\\u2976',\n\tltquest: '\\u2A7B',\n\tltri: '\\u25C3',\n\tltrie: '\\u22B4',\n\tltrif: '\\u25C2',\n\tltrPar: '\\u2996',\n\tlurdshar: '\\u294A',\n\tluruhar: '\\u2966',\n\tlvertneqq: '\\u2268\\uFE00',\n\tlvnE: '\\u2268\\uFE00',\n\tmacr: '\\u00AF',\n\tmale: '\\u2642',\n\tmalt: '\\u2720',\n\tmaltese: '\\u2720',\n\tMap: '\\u2905',\n\tmap: '\\u21A6',\n\tmapsto: '\\u21A6',\n\tmapstodown: '\\u21A7',\n\tmapstoleft: '\\u21A4',\n\tmapstoup: '\\u21A5',\n\tmarker: '\\u25AE',\n\tmcomma: '\\u2A29',\n\tMcy: '\\u041C',\n\tmcy: '\\u043C',\n\tmdash: '\\u2014',\n\tmDDot: '\\u223A',\n\tmeasuredangle: '\\u2221',\n\tMediumSpace: '\\u205F',\n\tMellintrf: '\\u2133',\n\tMfr: '\\uD835\\uDD10',\n\tmfr: '\\uD835\\uDD2A',\n\tmho: '\\u2127',\n\tmicro: '\\u00B5',\n\tmid: '\\u2223',\n\tmidast: '\\u002A',\n\tmidcir: '\\u2AF0',\n\tmiddot: '\\u00B7',\n\tminus: '\\u2212',\n\tminusb: '\\u229F',\n\tminusd: '\\u2238',\n\tminusdu: '\\u2A2A',\n\tMinusPlus: '\\u2213',\n\tmlcp: '\\u2ADB',\n\tmldr: '\\u2026',\n\tmnplus: '\\u2213',\n\tmodels: '\\u22A7',\n\tMopf: '\\uD835\\uDD44',\n\tmopf: '\\uD835\\uDD5E',\n\tmp: '\\u2213',\n\tMscr: '\\u2133',\n\tmscr: '\\uD835\\uDCC2',\n\tmstpos: '\\u223E',\n\tMu: '\\u039C',\n\tmu: '\\u03BC',\n\tmultimap: '\\u22B8',\n\tmumap: '\\u22B8',\n\tnabla: '\\u2207',\n\tNacute: '\\u0143',\n\tnacute: '\\u0144',\n\tnang: '\\u2220\\u20D2',\n\tnap: '\\u2249',\n\tnapE: '\\u2A70\\u0338',\n\tnapid: '\\u224B\\u0338',\n\tnapos: '\\u0149',\n\tnapprox: '\\u2249',\n\tnatur: '\\u266E',\n\tnatural: '\\u266E',\n\tnaturals: '\\u2115',\n\tnbsp: '\\u00A0',\n\tnbump: '\\u224E\\u0338',\n\tnbumpe: '\\u224F\\u0338',\n\tncap: '\\u2A43',\n\tNcaron: '\\u0147',\n\tncaron: '\\u0148',\n\tNcedil: '\\u0145',\n\tncedil: '\\u0146',\n\tncong: '\\u2247',\n\tncongdot: '\\u2A6D\\u0338',\n\tncup: '\\u2A42',\n\tNcy: '\\u041D',\n\tncy: '\\u043D',\n\tndash: '\\u2013',\n\tne: '\\u2260',\n\tnearhk: '\\u2924',\n\tneArr: '\\u21D7',\n\tnearr: '\\u2197',\n\tnearrow: '\\u2197',\n\tnedot: '\\u2250\\u0338',\n\tNegativeMediumSpace: '\\u200B',\n\tNegativeThickSpace: '\\u200B',\n\tNegativeThinSpace: '\\u200B',\n\tNegativeVeryThinSpace: '\\u200B',\n\tnequiv: '\\u2262',\n\tnesear: '\\u2928',\n\tnesim: '\\u2242\\u0338',\n\tNestedGreaterGreater: '\\u226B',\n\tNestedLessLess: '\\u226A',\n\tNewLine: '\\u000A',\n\tnexist: '\\u2204',\n\tnexists: '\\u2204',\n\tNfr: '\\uD835\\uDD11',\n\tnfr: '\\uD835\\uDD2B',\n\tngE: '\\u2267\\u0338',\n\tnge: '\\u2271',\n\tngeq: '\\u2271',\n\tngeqq: '\\u2267\\u0338',\n\tngeqslant: '\\u2A7E\\u0338',\n\tnges: '\\u2A7E\\u0338',\n\tnGg: '\\u22D9\\u0338',\n\tngsim: '\\u2275',\n\tnGt: '\\u226B\\u20D2',\n\tngt: '\\u226F',\n\tngtr: '\\u226F',\n\tnGtv: '\\u226B\\u0338',\n\tnhArr: '\\u21CE',\n\tnharr: '\\u21AE',\n\tnhpar: '\\u2AF2',\n\tni: '\\u220B',\n\tnis: '\\u22FC',\n\tnisd: '\\u22FA',\n\tniv: '\\u220B',\n\tNJcy: '\\u040A',\n\tnjcy: '\\u045A',\n\tnlArr: '\\u21CD',\n\tnlarr: '\\u219A',\n\tnldr: '\\u2025',\n\tnlE: '\\u2266\\u0338',\n\tnle: '\\u2270',\n\tnLeftarrow: '\\u21CD',\n\tnleftarrow: '\\u219A',\n\tnLeftrightarrow: '\\u21CE',\n\tnleftrightarrow: '\\u21AE',\n\tnleq: '\\u2270',\n\tnleqq: '\\u2266\\u0338',\n\tnleqslant: '\\u2A7D\\u0338',\n\tnles: '\\u2A7D\\u0338',\n\tnless: '\\u226E',\n\tnLl: '\\u22D8\\u0338',\n\tnlsim: '\\u2274',\n\tnLt: '\\u226A\\u20D2',\n\tnlt: '\\u226E',\n\tnltri: '\\u22EA',\n\tnltrie: '\\u22EC',\n\tnLtv: '\\u226A\\u0338',\n\tnmid: '\\u2224',\n\tNoBreak: '\\u2060',\n\tNonBreakingSpace: '\\u00A0',\n\tNopf: '\\u2115',\n\tnopf: '\\uD835\\uDD5F',\n\tNot: '\\u2AEC',\n\tnot: '\\u00AC',\n\tNotCongruent: '\\u2262',\n\tNotCupCap: '\\u226D',\n\tNotDoubleVerticalBar: '\\u2226',\n\tNotElement: '\\u2209',\n\tNotEqual: '\\u2260',\n\tNotEqualTilde: '\\u2242\\u0338',\n\tNotExists: '\\u2204',\n\tNotGreater: '\\u226F',\n\tNotGreaterEqual: '\\u2271',\n\tNotGreaterFullEqual: '\\u2267\\u0338',\n\tNotGreaterGreater: '\\u226B\\u0338',\n\tNotGreaterLess: '\\u2279',\n\tNotGreaterSlantEqual: '\\u2A7E\\u0338',\n\tNotGreaterTilde: '\\u2275',\n\tNotHumpDownHump: '\\u224E\\u0338',\n\tNotHumpEqual: '\\u224F\\u0338',\n\tnotin: '\\u2209',\n\tnotindot: '\\u22F5\\u0338',\n\tnotinE: '\\u22F9\\u0338',\n\tnotinva: '\\u2209',\n\tnotinvb: '\\u22F7',\n\tnotinvc: '\\u22F6',\n\tNotLeftTriangle: '\\u22EA',\n\tNotLeftTriangleBar: '\\u29CF\\u0338',\n\tNotLeftTriangleEqual: '\\u22EC',\n\tNotLess: '\\u226E',\n\tNotLessEqual: '\\u2270',\n\tNotLessGreater: '\\u2278',\n\tNotLessLess: '\\u226A\\u0338',\n\tNotLessSlantEqual: '\\u2A7D\\u0338',\n\tNotLessTilde: '\\u2274',\n\tNotNestedGreaterGreater: '\\u2AA2\\u0338',\n\tNotNestedLessLess: '\\u2AA1\\u0338',\n\tnotni: '\\u220C',\n\tnotniva: '\\u220C',\n\tnotnivb: '\\u22FE',\n\tnotnivc: '\\u22FD',\n\tNotPrecedes: '\\u2280',\n\tNotPrecedesEqual: '\\u2AAF\\u0338',\n\tNotPrecedesSlantEqual: '\\u22E0',\n\tNotReverseElement: '\\u220C',\n\tNotRightTriangle: '\\u22EB',\n\tNotRightTriangleBar: '\\u29D0\\u0338',\n\tNotRightTriangleEqual: '\\u22ED',\n\tNotSquareSubset: '\\u228F\\u0338',\n\tNotSquareSubsetEqual: '\\u22E2',\n\tNotSquareSuperset: '\\u2290\\u0338',\n\tNotSquareSupersetEqual: '\\u22E3',\n\tNotSubset: '\\u2282\\u20D2',\n\tNotSubsetEqual: '\\u2288',\n\tNotSucceeds: '\\u2281',\n\tNotSucceedsEqual: '\\u2AB0\\u0338',\n\tNotSucceedsSlantEqual: '\\u22E1',\n\tNotSucceedsTilde: '\\u227F\\u0338',\n\tNotSuperset: '\\u2283\\u20D2',\n\tNotSupersetEqual: '\\u2289',\n\tNotTilde: '\\u2241',\n\tNotTildeEqual: '\\u2244',\n\tNotTildeFullEqual: '\\u2247',\n\tNotTildeTilde: '\\u2249',\n\tNotVerticalBar: '\\u2224',\n\tnpar: '\\u2226',\n\tnparallel: '\\u2226',\n\tnparsl: '\\u2AFD\\u20E5',\n\tnpart: '\\u2202\\u0338',\n\tnpolint: '\\u2A14',\n\tnpr: '\\u2280',\n\tnprcue: '\\u22E0',\n\tnpre: '\\u2AAF\\u0338',\n\tnprec: '\\u2280',\n\tnpreceq: '\\u2AAF\\u0338',\n\tnrArr: '\\u21CF',\n\tnrarr: '\\u219B',\n\tnrarrc: '\\u2933\\u0338',\n\tnrarrw: '\\u219D\\u0338',\n\tnRightarrow: '\\u21CF',\n\tnrightarrow: '\\u219B',\n\tnrtri: '\\u22EB',\n\tnrtrie: '\\u22ED',\n\tnsc: '\\u2281',\n\tnsccue: '\\u22E1',\n\tnsce: '\\u2AB0\\u0338',\n\tNscr: '\\uD835\\uDCA9',\n\tnscr: '\\uD835\\uDCC3',\n\tnshortmid: '\\u2224',\n\tnshortparallel: '\\u2226',\n\tnsim: '\\u2241',\n\tnsime: '\\u2244',\n\tnsimeq: '\\u2244',\n\tnsmid: '\\u2224',\n\tnspar: '\\u2226',\n\tnsqsube: '\\u22E2',\n\tnsqsupe: '\\u22E3',\n\tnsub: '\\u2284',\n\tnsubE: '\\u2AC5\\u0338',\n\tnsube: '\\u2288',\n\tnsubset: '\\u2282\\u20D2',\n\tnsubseteq: '\\u2288',\n\tnsubseteqq: '\\u2AC5\\u0338',\n\tnsucc: '\\u2281',\n\tnsucceq: '\\u2AB0\\u0338',\n\tnsup: '\\u2285',\n\tnsupE: '\\u2AC6\\u0338',\n\tnsupe: '\\u2289',\n\tnsupset: '\\u2283\\u20D2',\n\tnsupseteq: '\\u2289',\n\tnsupseteqq: '\\u2AC6\\u0338',\n\tntgl: '\\u2279',\n\tNtilde: '\\u00D1',\n\tntilde: '\\u00F1',\n\tntlg: '\\u2278',\n\tntriangleleft: '\\u22EA',\n\tntrianglelefteq: '\\u22EC',\n\tntriangleright: '\\u22EB',\n\tntrianglerighteq: '\\u22ED',\n\tNu: '\\u039D',\n\tnu: '\\u03BD',\n\tnum: '\\u0023',\n\tnumero: '\\u2116',\n\tnumsp: '\\u2007',\n\tnvap: '\\u224D\\u20D2',\n\tnVDash: '\\u22AF',\n\tnVdash: '\\u22AE',\n\tnvDash: '\\u22AD',\n\tnvdash: '\\u22AC',\n\tnvge: '\\u2265\\u20D2',\n\tnvgt: '\\u003E\\u20D2',\n\tnvHarr: '\\u2904',\n\tnvinfin: '\\u29DE',\n\tnvlArr: '\\u2902',\n\tnvle: '\\u2264\\u20D2',\n\tnvlt: '\\u003C\\u20D2',\n\tnvltrie: '\\u22B4\\u20D2',\n\tnvrArr: '\\u2903',\n\tnvrtrie: '\\u22B5\\u20D2',\n\tnvsim: '\\u223C\\u20D2',\n\tnwarhk: '\\u2923',\n\tnwArr: '\\u21D6',\n\tnwarr: '\\u2196',\n\tnwarrow: '\\u2196',\n\tnwnear: '\\u2927',\n\tOacute: '\\u00D3',\n\toacute: '\\u00F3',\n\toast: '\\u229B',\n\tocir: '\\u229A',\n\tOcirc: '\\u00D4',\n\tocirc: '\\u00F4',\n\tOcy: '\\u041E',\n\tocy: '\\u043E',\n\todash: '\\u229D',\n\tOdblac: '\\u0150',\n\todblac: '\\u0151',\n\todiv: '\\u2A38',\n\todot: '\\u2299',\n\todsold: '\\u29BC',\n\tOElig: '\\u0152',\n\toelig: '\\u0153',\n\tofcir: '\\u29BF',\n\tOfr: '\\uD835\\uDD12',\n\tofr: '\\uD835\\uDD2C',\n\togon: '\\u02DB',\n\tOgrave: '\\u00D2',\n\tograve: '\\u00F2',\n\togt: '\\u29C1',\n\tohbar: '\\u29B5',\n\tohm: '\\u03A9',\n\toint: '\\u222E',\n\tolarr: '\\u21BA',\n\tolcir: '\\u29BE',\n\tolcross: '\\u29BB',\n\toline: '\\u203E',\n\tolt: '\\u29C0',\n\tOmacr: '\\u014C',\n\tomacr: '\\u014D',\n\tOmega: '\\u03A9',\n\tomega: '\\u03C9',\n\tOmicron: '\\u039F',\n\tomicron: '\\u03BF',\n\tomid: '\\u29B6',\n\tominus: '\\u2296',\n\tOopf: '\\uD835\\uDD46',\n\toopf: '\\uD835\\uDD60',\n\topar: '\\u29B7',\n\tOpenCurlyDoubleQuote: '\\u201C',\n\tOpenCurlyQuote: '\\u2018',\n\toperp: '\\u29B9',\n\toplus: '\\u2295',\n\tOr: '\\u2A54',\n\tor: '\\u2228',\n\torarr: '\\u21BB',\n\tord: '\\u2A5D',\n\torder: '\\u2134',\n\torderof: '\\u2134',\n\tordf: '\\u00AA',\n\tordm: '\\u00BA',\n\torigof: '\\u22B6',\n\toror: '\\u2A56',\n\torslope: '\\u2A57',\n\torv: '\\u2A5B',\n\toS: '\\u24C8',\n\tOscr: '\\uD835\\uDCAA',\n\toscr: '\\u2134',\n\tOslash: '\\u00D8',\n\toslash: '\\u00F8',\n\tosol: '\\u2298',\n\tOtilde: '\\u00D5',\n\totilde: '\\u00F5',\n\tOtimes: '\\u2A37',\n\totimes: '\\u2297',\n\totimesas: '\\u2A36',\n\tOuml: '\\u00D6',\n\touml: '\\u00F6',\n\tovbar: '\\u233D',\n\tOverBar: '\\u203E',\n\tOverBrace: '\\u23DE',\n\tOverBracket: '\\u23B4',\n\tOverParenthesis: '\\u23DC',\n\tpar: '\\u2225',\n\tpara: '\\u00B6',\n\tparallel: '\\u2225',\n\tparsim: '\\u2AF3',\n\tparsl: '\\u2AFD',\n\tpart: '\\u2202',\n\tPartialD: '\\u2202',\n\tPcy: '\\u041F',\n\tpcy: '\\u043F',\n\tpercnt: '\\u0025',\n\tperiod: '\\u002E',\n\tpermil: '\\u2030',\n\tperp: '\\u22A5',\n\tpertenk: '\\u2031',\n\tPfr: '\\uD835\\uDD13',\n\tpfr: '\\uD835\\uDD2D',\n\tPhi: '\\u03A6',\n\tphi: '\\u03C6',\n\tphiv: '\\u03D5',\n\tphmmat: '\\u2133',\n\tphone: '\\u260E',\n\tPi: '\\u03A0',\n\tpi: '\\u03C0',\n\tpitchfork: '\\u22D4',\n\tpiv: '\\u03D6',\n\tplanck: '\\u210F',\n\tplanckh: '\\u210E',\n\tplankv: '\\u210F',\n\tplus: '\\u002B',\n\tplusacir: '\\u2A23',\n\tplusb: '\\u229E',\n\tpluscir: '\\u2A22',\n\tplusdo: '\\u2214',\n\tplusdu: '\\u2A25',\n\tpluse: '\\u2A72',\n\tPlusMinus: '\\u00B1',\n\tplusmn: '\\u00B1',\n\tplussim: '\\u2A26',\n\tplustwo: '\\u2A27',\n\tpm: '\\u00B1',\n\tPoincareplane: '\\u210C',\n\tpointint: '\\u2A15',\n\tPopf: '\\u2119',\n\tpopf: '\\uD835\\uDD61',\n\tpound: '\\u00A3',\n\tPr: '\\u2ABB',\n\tpr: '\\u227A',\n\tprap: '\\u2AB7',\n\tprcue: '\\u227C',\n\tprE: '\\u2AB3',\n\tpre: '\\u2AAF',\n\tprec: '\\u227A',\n\tprecapprox: '\\u2AB7',\n\tpreccurlyeq: '\\u227C',\n\tPrecedes: '\\u227A',\n\tPrecedesEqual: '\\u2AAF',\n\tPrecedesSlantEqual: '\\u227C',\n\tPrecedesTilde: '\\u227E',\n\tpreceq: '\\u2AAF',\n\tprecnapprox: '\\u2AB9',\n\tprecneqq: '\\u2AB5',\n\tprecnsim: '\\u22E8',\n\tprecsim: '\\u227E',\n\tPrime: '\\u2033',\n\tprime: '\\u2032',\n\tprimes: '\\u2119',\n\tprnap: '\\u2AB9',\n\tprnE: '\\u2AB5',\n\tprnsim: '\\u22E8',\n\tprod: '\\u220F',\n\tProduct: '\\u220F',\n\tprofalar: '\\u232E',\n\tprofline: '\\u2312',\n\tprofsurf: '\\u2313',\n\tprop: '\\u221D',\n\tProportion: '\\u2237',\n\tProportional: '\\u221D',\n\tpropto: '\\u221D',\n\tprsim: '\\u227E',\n\tprurel: '\\u22B0',\n\tPscr: '\\uD835\\uDCAB',\n\tpscr: '\\uD835\\uDCC5',\n\tPsi: '\\u03A8',\n\tpsi: '\\u03C8',\n\tpuncsp: '\\u2008',\n\tQfr: '\\uD835\\uDD14',\n\tqfr: '\\uD835\\uDD2E',\n\tqint: '\\u2A0C',\n\tQopf: '\\u211A',\n\tqopf: '\\uD835\\uDD62',\n\tqprime: '\\u2057',\n\tQscr: '\\uD835\\uDCAC',\n\tqscr: '\\uD835\\uDCC6',\n\tquaternions: '\\u210D',\n\tquatint: '\\u2A16',\n\tquest: '\\u003F',\n\tquesteq: '\\u225F',\n\tQUOT: '\\u0022',\n\tquot: '\\u0022',\n\trAarr: '\\u21DB',\n\trace: '\\u223D\\u0331',\n\tRacute: '\\u0154',\n\tracute: '\\u0155',\n\tradic: '\\u221A',\n\traemptyv: '\\u29B3',\n\tRang: '\\u27EB',\n\trang: '\\u27E9',\n\trangd: '\\u2992',\n\trange: '\\u29A5',\n\trangle: '\\u27E9',\n\traquo: '\\u00BB',\n\tRarr: '\\u21A0',\n\trArr: '\\u21D2',\n\trarr: '\\u2192',\n\trarrap: '\\u2975',\n\trarrb: '\\u21E5',\n\trarrbfs: '\\u2920',\n\trarrc: '\\u2933',\n\trarrfs: '\\u291E',\n\trarrhk: '\\u21AA',\n\trarrlp: '\\u21AC',\n\trarrpl: '\\u2945',\n\trarrsim: '\\u2974',\n\tRarrtl: '\\u2916',\n\trarrtl: '\\u21A3',\n\trarrw: '\\u219D',\n\trAtail: '\\u291C',\n\tratail: '\\u291A',\n\tratio: '\\u2236',\n\trationals: '\\u211A',\n\tRBarr: '\\u2910',\n\trBarr: '\\u290F',\n\trbarr: '\\u290D',\n\trbbrk: '\\u2773',\n\trbrace: '\\u007D',\n\trbrack: '\\u005D',\n\trbrke: '\\u298C',\n\trbrksld: '\\u298E',\n\trbrkslu: '\\u2990',\n\tRcaron: '\\u0158',\n\trcaron: '\\u0159',\n\tRcedil: '\\u0156',\n\trcedil: '\\u0157',\n\trceil: '\\u2309',\n\trcub: '\\u007D',\n\tRcy: '\\u0420',\n\trcy: '\\u0440',\n\trdca: '\\u2937',\n\trdldhar: '\\u2969',\n\trdquo: '\\u201D',\n\trdquor: '\\u201D',\n\trdsh: '\\u21B3',\n\tRe: '\\u211C',\n\treal: '\\u211C',\n\trealine: '\\u211B',\n\trealpart: '\\u211C',\n\treals: '\\u211D',\n\trect: '\\u25AD',\n\tREG: '\\u00AE',\n\treg: '\\u00AE',\n\tReverseElement: '\\u220B',\n\tReverseEquilibrium: '\\u21CB',\n\tReverseUpEquilibrium: '\\u296F',\n\trfisht: '\\u297D',\n\trfloor: '\\u230B',\n\tRfr: '\\u211C',\n\trfr: '\\uD835\\uDD2F',\n\trHar: '\\u2964',\n\trhard: '\\u21C1',\n\trharu: '\\u21C0',\n\trharul: '\\u296C',\n\tRho: '\\u03A1',\n\trho: '\\u03C1',\n\trhov: '\\u03F1',\n\tRightAngleBracket: '\\u27E9',\n\tRightArrow: '\\u2192',\n\tRightarrow: '\\u21D2',\n\trightarrow: '\\u2192',\n\tRightArrowBar: '\\u21E5',\n\tRightArrowLeftArrow: '\\u21C4',\n\trightarrowtail: '\\u21A3',\n\tRightCeiling: '\\u2309',\n\tRightDoubleBracket: '\\u27E7',\n\tRightDownTeeVector: '\\u295D',\n\tRightDownVector: '\\u21C2',\n\tRightDownVectorBar: '\\u2955',\n\tRightFloor: '\\u230B',\n\trightharpoondown: '\\u21C1',\n\trightharpoonup: '\\u21C0',\n\trightleftarrows: '\\u21C4',\n\trightleftharpoons: '\\u21CC',\n\trightrightarrows: '\\u21C9',\n\trightsquigarrow: '\\u219D',\n\tRightTee: '\\u22A2',\n\tRightTeeArrow: '\\u21A6',\n\tRightTeeVector: '\\u295B',\n\trightthreetimes: '\\u22CC',\n\tRightTriangle: '\\u22B3',\n\tRightTriangleBar: '\\u29D0',\n\tRightTriangleEqual: '\\u22B5',\n\tRightUpDownVector: '\\u294F',\n\tRightUpTeeVector: '\\u295C',\n\tRightUpVector: '\\u21BE',\n\tRightUpVectorBar: '\\u2954',\n\tRightVector: '\\u21C0',\n\tRightVectorBar: '\\u2953',\n\tring: '\\u02DA',\n\trisingdotseq: '\\u2253',\n\trlarr: '\\u21C4',\n\trlhar: '\\u21CC',\n\trlm: '\\u200F',\n\trmoust: '\\u23B1',\n\trmoustache: '\\u23B1',\n\trnmid: '\\u2AEE',\n\troang: '\\u27ED',\n\troarr: '\\u21FE',\n\trobrk: '\\u27E7',\n\tropar: '\\u2986',\n\tRopf: '\\u211D',\n\tropf: '\\uD835\\uDD63',\n\troplus: '\\u2A2E',\n\trotimes: '\\u2A35',\n\tRoundImplies: '\\u2970',\n\trpar: '\\u0029',\n\trpargt: '\\u2994',\n\trppolint: '\\u2A12',\n\trrarr: '\\u21C9',\n\tRrightarrow: '\\u21DB',\n\trsaquo: '\\u203A',\n\tRscr: '\\u211B',\n\trscr: '\\uD835\\uDCC7',\n\tRsh: '\\u21B1',\n\trsh: '\\u21B1',\n\trsqb: '\\u005D',\n\trsquo: '\\u2019',\n\trsquor: '\\u2019',\n\trthree: '\\u22CC',\n\trtimes: '\\u22CA',\n\trtri: '\\u25B9',\n\trtrie: '\\u22B5',\n\trtrif: '\\u25B8',\n\trtriltri: '\\u29CE',\n\tRuleDelayed: '\\u29F4',\n\truluhar: '\\u2968',\n\trx: '\\u211E',\n\tSacute: '\\u015A',\n\tsacute: '\\u015B',\n\tsbquo: '\\u201A',\n\tSc: '\\u2ABC',\n\tsc: '\\u227B',\n\tscap: '\\u2AB8',\n\tScaron: '\\u0160',\n\tscaron: '\\u0161',\n\tsccue: '\\u227D',\n\tscE: '\\u2AB4',\n\tsce: '\\u2AB0',\n\tScedil: '\\u015E',\n\tscedil: '\\u015F',\n\tScirc: '\\u015C',\n\tscirc: '\\u015D',\n\tscnap: '\\u2ABA',\n\tscnE: '\\u2AB6',\n\tscnsim: '\\u22E9',\n\tscpolint: '\\u2A13',\n\tscsim: '\\u227F',\n\tScy: '\\u0421',\n\tscy: '\\u0441',\n\tsdot: '\\u22C5',\n\tsdotb: '\\u22A1',\n\tsdote: '\\u2A66',\n\tsearhk: '\\u2925',\n\tseArr: '\\u21D8',\n\tsearr: '\\u2198',\n\tsearrow: '\\u2198',\n\tsect: '\\u00A7',\n\tsemi: '\\u003B',\n\tseswar: '\\u2929',\n\tsetminus: '\\u2216',\n\tsetmn: '\\u2216',\n\tsext: '\\u2736',\n\tSfr: '\\uD835\\uDD16',\n\tsfr: '\\uD835\\uDD30',\n\tsfrown: '\\u2322',\n\tsharp: '\\u266F',\n\tSHCHcy: '\\u0429',\n\tshchcy: '\\u0449',\n\tSHcy: '\\u0428',\n\tshcy: '\\u0448',\n\tShortDownArrow: '\\u2193',\n\tShortLeftArrow: '\\u2190',\n\tshortmid: '\\u2223',\n\tshortparallel: '\\u2225',\n\tShortRightArrow: '\\u2192',\n\tShortUpArrow: '\\u2191',\n\tshy: '\\u00AD',\n\tSigma: '\\u03A3',\n\tsigma: '\\u03C3',\n\tsigmaf: '\\u03C2',\n\tsigmav: '\\u03C2',\n\tsim: '\\u223C',\n\tsimdot: '\\u2A6A',\n\tsime: '\\u2243',\n\tsimeq: '\\u2243',\n\tsimg: '\\u2A9E',\n\tsimgE: '\\u2AA0',\n\tsiml: '\\u2A9D',\n\tsimlE: '\\u2A9F',\n\tsimne: '\\u2246',\n\tsimplus: '\\u2A24',\n\tsimrarr: '\\u2972',\n\tslarr: '\\u2190',\n\tSmallCircle: '\\u2218',\n\tsmallsetminus: '\\u2216',\n\tsmashp: '\\u2A33',\n\tsmeparsl: '\\u29E4',\n\tsmid: '\\u2223',\n\tsmile: '\\u2323',\n\tsmt: '\\u2AAA',\n\tsmte: '\\u2AAC',\n\tsmtes: '\\u2AAC\\uFE00',\n\tSOFTcy: '\\u042C',\n\tsoftcy: '\\u044C',\n\tsol: '\\u002F',\n\tsolb: '\\u29C4',\n\tsolbar: '\\u233F',\n\tSopf: '\\uD835\\uDD4A',\n\tsopf: '\\uD835\\uDD64',\n\tspades: '\\u2660',\n\tspadesuit: '\\u2660',\n\tspar: '\\u2225',\n\tsqcap: '\\u2293',\n\tsqcaps: '\\u2293\\uFE00',\n\tsqcup: '\\u2294',\n\tsqcups: '\\u2294\\uFE00',\n\tSqrt: '\\u221A',\n\tsqsub: '\\u228F',\n\tsqsube: '\\u2291',\n\tsqsubset: '\\u228F',\n\tsqsubseteq: '\\u2291',\n\tsqsup: '\\u2290',\n\tsqsupe: '\\u2292',\n\tsqsupset: '\\u2290',\n\tsqsupseteq: '\\u2292',\n\tsqu: '\\u25A1',\n\tSquare: '\\u25A1',\n\tsquare: '\\u25A1',\n\tSquareIntersection: '\\u2293',\n\tSquareSubset: '\\u228F',\n\tSquareSubsetEqual: '\\u2291',\n\tSquareSuperset: '\\u2290',\n\tSquareSupersetEqual: '\\u2292',\n\tSquareUnion: '\\u2294',\n\tsquarf: '\\u25AA',\n\tsquf: '\\u25AA',\n\tsrarr: '\\u2192',\n\tSscr: '\\uD835\\uDCAE',\n\tsscr: '\\uD835\\uDCC8',\n\tssetmn: '\\u2216',\n\tssmile: '\\u2323',\n\tsstarf: '\\u22C6',\n\tStar: '\\u22C6',\n\tstar: '\\u2606',\n\tstarf: '\\u2605',\n\tstraightepsilon: '\\u03F5',\n\tstraightphi: '\\u03D5',\n\tstrns: '\\u00AF',\n\tSub: '\\u22D0',\n\tsub: '\\u2282',\n\tsubdot: '\\u2ABD',\n\tsubE: '\\u2AC5',\n\tsube: '\\u2286',\n\tsubedot: '\\u2AC3',\n\tsubmult: '\\u2AC1',\n\tsubnE: '\\u2ACB',\n\tsubne: '\\u228A',\n\tsubplus: '\\u2ABF',\n\tsubrarr: '\\u2979',\n\tSubset: '\\u22D0',\n\tsubset: '\\u2282',\n\tsubseteq: '\\u2286',\n\tsubseteqq: '\\u2AC5',\n\tSubsetEqual: '\\u2286',\n\tsubsetneq: '\\u228A',\n\tsubsetneqq: '\\u2ACB',\n\tsubsim: '\\u2AC7',\n\tsubsub: '\\u2AD5',\n\tsubsup: '\\u2AD3',\n\tsucc: '\\u227B',\n\tsuccapprox: '\\u2AB8',\n\tsucccurlyeq: '\\u227D',\n\tSucceeds: '\\u227B',\n\tSucceedsEqual: '\\u2AB0',\n\tSucceedsSlantEqual: '\\u227D',\n\tSucceedsTilde: '\\u227F',\n\tsucceq: '\\u2AB0',\n\tsuccnapprox: '\\u2ABA',\n\tsuccneqq: '\\u2AB6',\n\tsuccnsim: '\\u22E9',\n\tsuccsim: '\\u227F',\n\tSuchThat: '\\u220B',\n\tSum: '\\u2211',\n\tsum: '\\u2211',\n\tsung: '\\u266A',\n\tSup: '\\u22D1',\n\tsup: '\\u2283',\n\tsup1: '\\u00B9',\n\tsup2: '\\u00B2',\n\tsup3: '\\u00B3',\n\tsupdot: '\\u2ABE',\n\tsupdsub: '\\u2AD8',\n\tsupE: '\\u2AC6',\n\tsupe: '\\u2287',\n\tsupedot: '\\u2AC4',\n\tSuperset: '\\u2283',\n\tSupersetEqual: '\\u2287',\n\tsuphsol: '\\u27C9',\n\tsuphsub: '\\u2AD7',\n\tsuplarr: '\\u297B',\n\tsupmult: '\\u2AC2',\n\tsupnE: '\\u2ACC',\n\tsupne: '\\u228B',\n\tsupplus: '\\u2AC0',\n\tSupset: '\\u22D1',\n\tsupset: '\\u2283',\n\tsupseteq: '\\u2287',\n\tsupseteqq: '\\u2AC6',\n\tsupsetneq: '\\u228B',\n\tsupsetneqq: '\\u2ACC',\n\tsupsim: '\\u2AC8',\n\tsupsub: '\\u2AD4',\n\tsupsup: '\\u2AD6',\n\tswarhk: '\\u2926',\n\tswArr: '\\u21D9',\n\tswarr: '\\u2199',\n\tswarrow: '\\u2199',\n\tswnwar: '\\u292A',\n\tszlig: '\\u00DF',\n\tTab: '\\u0009',\n\ttarget: '\\u2316',\n\tTau: '\\u03A4',\n\ttau: '\\u03C4',\n\ttbrk: '\\u23B4',\n\tTcaron: '\\u0164',\n\ttcaron: '\\u0165',\n\tTcedil: '\\u0162',\n\ttcedil: '\\u0163',\n\tTcy: '\\u0422',\n\ttcy: '\\u0442',\n\ttdot: '\\u20DB',\n\ttelrec: '\\u2315',\n\tTfr: '\\uD835\\uDD17',\n\ttfr: '\\uD835\\uDD31',\n\tthere4: '\\u2234',\n\tTherefore: '\\u2234',\n\ttherefore: '\\u2234',\n\tTheta: '\\u0398',\n\ttheta: '\\u03B8',\n\tthetasym: '\\u03D1',\n\tthetav: '\\u03D1',\n\tthickapprox: '\\u2248',\n\tthicksim: '\\u223C',\n\tThickSpace: '\\u205F\\u200A',\n\tthinsp: '\\u2009',\n\tThinSpace: '\\u2009',\n\tthkap: '\\u2248',\n\tthksim: '\\u223C',\n\tTHORN: '\\u00DE',\n\tthorn: '\\u00FE',\n\tTilde: '\\u223C',\n\ttilde: '\\u02DC',\n\tTildeEqual: '\\u2243',\n\tTildeFullEqual: '\\u2245',\n\tTildeTilde: '\\u2248',\n\ttimes: '\\u00D7',\n\ttimesb: '\\u22A0',\n\ttimesbar: '\\u2A31',\n\ttimesd: '\\u2A30',\n\ttint: '\\u222D',\n\ttoea: '\\u2928',\n\ttop: '\\u22A4',\n\ttopbot: '\\u2336',\n\ttopcir: '\\u2AF1',\n\tTopf: '\\uD835\\uDD4B',\n\ttopf: '\\uD835\\uDD65',\n\ttopfork: '\\u2ADA',\n\ttosa: '\\u2929',\n\ttprime: '\\u2034',\n\tTRADE: '\\u2122',\n\ttrade: '\\u2122',\n\ttriangle: '\\u25B5',\n\ttriangledown: '\\u25BF',\n\ttriangleleft: '\\u25C3',\n\ttrianglelefteq: '\\u22B4',\n\ttriangleq: '\\u225C',\n\ttriangleright: '\\u25B9',\n\ttrianglerighteq: '\\u22B5',\n\ttridot: '\\u25EC',\n\ttrie: '\\u225C',\n\ttriminus: '\\u2A3A',\n\tTripleDot: '\\u20DB',\n\ttriplus: '\\u2A39',\n\ttrisb: '\\u29CD',\n\ttritime: '\\u2A3B',\n\ttrpezium: '\\u23E2',\n\tTscr: '\\uD835\\uDCAF',\n\ttscr: '\\uD835\\uDCC9',\n\tTScy: '\\u0426',\n\ttscy: '\\u0446',\n\tTSHcy: '\\u040B',\n\ttshcy: '\\u045B',\n\tTstrok: '\\u0166',\n\ttstrok: '\\u0167',\n\ttwixt: '\\u226C',\n\ttwoheadleftarrow: '\\u219E',\n\ttwoheadrightarrow: '\\u21A0',\n\tUacute: '\\u00DA',\n\tuacute: '\\u00FA',\n\tUarr: '\\u219F',\n\tuArr: '\\u21D1',\n\tuarr: '\\u2191',\n\tUarrocir: '\\u2949',\n\tUbrcy: '\\u040E',\n\tubrcy: '\\u045E',\n\tUbreve: '\\u016C',\n\tubreve: '\\u016D',\n\tUcirc: '\\u00DB',\n\tucirc: '\\u00FB',\n\tUcy: '\\u0423',\n\tucy: '\\u0443',\n\tudarr: '\\u21C5',\n\tUdblac: '\\u0170',\n\tudblac: '\\u0171',\n\tudhar: '\\u296E',\n\tufisht: '\\u297E',\n\tUfr: '\\uD835\\uDD18',\n\tufr: '\\uD835\\uDD32',\n\tUgrave: '\\u00D9',\n\tugrave: '\\u00F9',\n\tuHar: '\\u2963',\n\tuharl: '\\u21BF',\n\tuharr: '\\u21BE',\n\tuhblk: '\\u2580',\n\tulcorn: '\\u231C',\n\tulcorner: '\\u231C',\n\tulcrop: '\\u230F',\n\tultri: '\\u25F8',\n\tUmacr: '\\u016A',\n\tumacr: '\\u016B',\n\tuml: '\\u00A8',\n\tUnderBar: '\\u005F',\n\tUnderBrace: '\\u23DF',\n\tUnderBracket: '\\u23B5',\n\tUnderParenthesis: '\\u23DD',\n\tUnion: '\\u22C3',\n\tUnionPlus: '\\u228E',\n\tUogon: '\\u0172',\n\tuogon: '\\u0173',\n\tUopf: '\\uD835\\uDD4C',\n\tuopf: '\\uD835\\uDD66',\n\tUpArrow: '\\u2191',\n\tUparrow: '\\u21D1',\n\tuparrow: '\\u2191',\n\tUpArrowBar: '\\u2912',\n\tUpArrowDownArrow: '\\u21C5',\n\tUpDownArrow: '\\u2195',\n\tUpdownarrow: '\\u21D5',\n\tupdownarrow: '\\u2195',\n\tUpEquilibrium: '\\u296E',\n\tupharpoonleft: '\\u21BF',\n\tupharpoonright: '\\u21BE',\n\tuplus: '\\u228E',\n\tUpperLeftArrow: '\\u2196',\n\tUpperRightArrow: '\\u2197',\n\tUpsi: '\\u03D2',\n\tupsi: '\\u03C5',\n\tupsih: '\\u03D2',\n\tUpsilon: '\\u03A5',\n\tupsilon: '\\u03C5',\n\tUpTee: '\\u22A5',\n\tUpTeeArrow: '\\u21A5',\n\tupuparrows: '\\u21C8',\n\turcorn: '\\u231D',\n\turcorner: '\\u231D',\n\turcrop: '\\u230E',\n\tUring: '\\u016E',\n\turing: '\\u016F',\n\turtri: '\\u25F9',\n\tUscr: '\\uD835\\uDCB0',\n\tuscr: '\\uD835\\uDCCA',\n\tutdot: '\\u22F0',\n\tUtilde: '\\u0168',\n\tutilde: '\\u0169',\n\tutri: '\\u25B5',\n\tutrif: '\\u25B4',\n\tuuarr: '\\u21C8',\n\tUuml: '\\u00DC',\n\tuuml: '\\u00FC',\n\tuwangle: '\\u29A7',\n\tvangrt: '\\u299C',\n\tvarepsilon: '\\u03F5',\n\tvarkappa: '\\u03F0',\n\tvarnothing: '\\u2205',\n\tvarphi: '\\u03D5',\n\tvarpi: '\\u03D6',\n\tvarpropto: '\\u221D',\n\tvArr: '\\u21D5',\n\tvarr: '\\u2195',\n\tvarrho: '\\u03F1',\n\tvarsigma: '\\u03C2',\n\tvarsubsetneq: '\\u228A\\uFE00',\n\tvarsubsetneqq: '\\u2ACB\\uFE00',\n\tvarsupsetneq: '\\u228B\\uFE00',\n\tvarsupsetneqq: '\\u2ACC\\uFE00',\n\tvartheta: '\\u03D1',\n\tvartriangleleft: '\\u22B2',\n\tvartriangleright: '\\u22B3',\n\tVbar: '\\u2AEB',\n\tvBar: '\\u2AE8',\n\tvBarv: '\\u2AE9',\n\tVcy: '\\u0412',\n\tvcy: '\\u0432',\n\tVDash: '\\u22AB',\n\tVdash: '\\u22A9',\n\tvDash: '\\u22A8',\n\tvdash: '\\u22A2',\n\tVdashl: '\\u2AE6',\n\tVee: '\\u22C1',\n\tvee: '\\u2228',\n\tveebar: '\\u22BB',\n\tveeeq: '\\u225A',\n\tvellip: '\\u22EE',\n\tVerbar: '\\u2016',\n\tverbar: '\\u007C',\n\tVert: '\\u2016',\n\tvert: '\\u007C',\n\tVerticalBar: '\\u2223',\n\tVerticalLine: '\\u007C',\n\tVerticalSeparator: '\\u2758',\n\tVerticalTilde: '\\u2240',\n\tVeryThinSpace: '\\u200A',\n\tVfr: '\\uD835\\uDD19',\n\tvfr: '\\uD835\\uDD33',\n\tvltri: '\\u22B2',\n\tvnsub: '\\u2282\\u20D2',\n\tvnsup: '\\u2283\\u20D2',\n\tVopf: '\\uD835\\uDD4D',\n\tvopf: '\\uD835\\uDD67',\n\tvprop: '\\u221D',\n\tvrtri: '\\u22B3',\n\tVscr: '\\uD835\\uDCB1',\n\tvscr: '\\uD835\\uDCCB',\n\tvsubnE: '\\u2ACB\\uFE00',\n\tvsubne: '\\u228A\\uFE00',\n\tvsupnE: '\\u2ACC\\uFE00',\n\tvsupne: '\\u228B\\uFE00',\n\tVvdash: '\\u22AA',\n\tvzigzag: '\\u299A',\n\tWcirc: '\\u0174',\n\twcirc: '\\u0175',\n\twedbar: '\\u2A5F',\n\tWedge: '\\u22C0',\n\twedge: '\\u2227',\n\twedgeq: '\\u2259',\n\tweierp: '\\u2118',\n\tWfr: '\\uD835\\uDD1A',\n\twfr: '\\uD835\\uDD34',\n\tWopf: '\\uD835\\uDD4E',\n\twopf: '\\uD835\\uDD68',\n\twp: '\\u2118',\n\twr: '\\u2240',\n\twreath: '\\u2240',\n\tWscr: '\\uD835\\uDCB2',\n\twscr: '\\uD835\\uDCCC',\n\txcap: '\\u22C2',\n\txcirc: '\\u25EF',\n\txcup: '\\u22C3',\n\txdtri: '\\u25BD',\n\tXfr: '\\uD835\\uDD1B',\n\txfr: '\\uD835\\uDD35',\n\txhArr: '\\u27FA',\n\txharr: '\\u27F7',\n\tXi: '\\u039E',\n\txi: '\\u03BE',\n\txlArr: '\\u27F8',\n\txlarr: '\\u27F5',\n\txmap: '\\u27FC',\n\txnis: '\\u22FB',\n\txodot: '\\u2A00',\n\tXopf: '\\uD835\\uDD4F',\n\txopf: '\\uD835\\uDD69',\n\txoplus: '\\u2A01',\n\txotime: '\\u2A02',\n\txrArr: '\\u27F9',\n\txrarr: '\\u27F6',\n\tXscr: '\\uD835\\uDCB3',\n\txscr: '\\uD835\\uDCCD',\n\txsqcup: '\\u2A06',\n\txuplus: '\\u2A04',\n\txutri: '\\u25B3',\n\txvee: '\\u22C1',\n\txwedge: '\\u22C0',\n\tYacute: '\\u00DD',\n\tyacute: '\\u00FD',\n\tYAcy: '\\u042F',\n\tyacy: '\\u044F',\n\tYcirc: '\\u0176',\n\tycirc: '\\u0177',\n\tYcy: '\\u042B',\n\tycy: '\\u044B',\n\tyen: '\\u00A5',\n\tYfr: '\\uD835\\uDD1C',\n\tyfr: '\\uD835\\uDD36',\n\tYIcy: '\\u0407',\n\tyicy: '\\u0457',\n\tYopf: '\\uD835\\uDD50',\n\tyopf: '\\uD835\\uDD6A',\n\tYscr: '\\uD835\\uDCB4',\n\tyscr: '\\uD835\\uDCCE',\n\tYUcy: '\\u042E',\n\tyucy: '\\u044E',\n\tYuml: '\\u0178',\n\tyuml: '\\u00FF',\n\tZacute: '\\u0179',\n\tzacute: '\\u017A',\n\tZcaron: '\\u017D',\n\tzcaron: '\\u017E',\n\tZcy: '\\u0417',\n\tzcy: '\\u0437',\n\tZdot: '\\u017B',\n\tzdot: '\\u017C',\n\tzeetrf: '\\u2128',\n\tZeroWidthSpace: '\\u200B',\n\tZeta: '\\u0396',\n\tzeta: '\\u03B6',\n\tZfr: '\\u2128',\n\tzfr: '\\uD835\\uDD37',\n\tZHcy: '\\u0416',\n\tzhcy: '\\u0436',\n\tzigrarr: '\\u21DD',\n\tZopf: '\\u2124',\n\tzopf: '\\uD835\\uDD6B',\n\tZscr: '\\uD835\\uDCB5',\n\tzscr: '\\uD835\\uDCCF',\n\tzwj: '\\u200D',\n\tzwnj: '\\u200C',\n});\n\n/**\n * @deprecated use `HTML_ENTITIES` instead\n * @see HTML_ENTITIES\n */\nexports.entityMap = exports.HTML_ENTITIES;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/entities.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var dom = __webpack_require__(/*! ./dom */ \"./node_modules/@xmldom/xmldom/lib/dom.js\")\nexports.DOMImplementation = dom.DOMImplementation\nexports.XMLSerializer = dom.XMLSerializer\nexports.DOMParser = __webpack_require__(/*! ./dom-parser */ \"./node_modules/@xmldom/xmldom/lib/dom-parser.js\").DOMParser\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/index.js?");

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/sax.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/sax.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var NAMESPACE = (__webpack_require__(/*! ./conventions */ \"./node_modules/@xmldom/xmldom/lib/conventions.js\").NAMESPACE);\n\n//[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]///\\u10000-\\uEFFFF\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\"+nameStartChar.source.slice(1,-1)+\"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\nvar tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\\:'+nameStartChar.source+nameChar.source+'*)?$');\n//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\nvar S_TAG = 0;//tag name offerring\nvar S_ATTR = 1;//attr name offerring\nvar S_ATTR_SPACE=2;//attr name end and space offer\nvar S_EQ = 3;//=space?\nvar S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)\nvar S_ATTR_END = 5;//attr value end and no space(quot end)\nvar S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)\nvar S_TAG_CLOSE = 7;//closed el<el />\n\n/**\n * Creates an error that will not be caught by XMLReader aka the SAX parser.\n *\n * @param {string} message\n * @param {any?} locator Optional, can provide details about the location in the source\n * @constructor\n */\nfunction ParseError(message, locator) {\n\tthis.message = message\n\tthis.locator = locator\n\tif(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);\n}\nParseError.prototype = new Error();\nParseError.prototype.name = ParseError.name\n\nfunction XMLReader(){\n\n}\n\nXMLReader.prototype = {\n\tparse:function(source,defaultNSMap,entityMap){\n\t\tvar domBuilder = this.domBuilder;\n\t\tdomBuilder.startDocument();\n\t\t_copy(defaultNSMap ,defaultNSMap = {})\n\t\tparse(source,defaultNSMap,entityMap,\n\t\t\t\tdomBuilder,this.errorHandler);\n\t\tdomBuilder.endDocument();\n\t}\n}\nfunction parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){\n\tfunction fixedFromCharCode(code) {\n\t\t// String.prototype.fromCharCode does not supports\n\t\t// > 2 bytes unicode chars directly\n\t\tif (code > 0xffff) {\n\t\t\tcode -= 0x10000;\n\t\t\tvar surrogate1 = 0xd800 + (code >> 10)\n\t\t\t\t, surrogate2 = 0xdc00 + (code & 0x3ff);\n\n\t\t\treturn String.fromCharCode(surrogate1, surrogate2);\n\t\t} else {\n\t\t\treturn String.fromCharCode(code);\n\t\t}\n\t}\n\tfunction entityReplacer(a){\n\t\tvar k = a.slice(1,-1);\n\t\tif (Object.hasOwnProperty.call(entityMap, k)) {\n\t\t\treturn entityMap[k];\n\t\t}else if(k.charAt(0) === '#'){\n\t\t\treturn fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))\n\t\t}else{\n\t\t\terrorHandler.error('entity not found:'+a);\n\t\t\treturn a;\n\t\t}\n\t}\n\tfunction appendText(end){//has some bugs\n\t\tif(end>start){\n\t\t\tvar xt = source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);\n\t\t\tlocator&&position(start);\n\t\t\tdomBuilder.characters(xt,0,end-start);\n\t\t\tstart = end\n\t\t}\n\t}\n\tfunction position(p,m){\n\t\twhile(p>=lineEnd && (m = linePattern.exec(source))){\n\t\t\tlineStart = m.index;\n\t\t\tlineEnd = lineStart + m[0].length;\n\t\t\tlocator.lineNumber++;\n\t\t\t//console.log('line++:',locator,startPos,endPos)\n\t\t}\n\t\tlocator.columnNumber = p-lineStart+1;\n\t}\n\tvar lineStart = 0;\n\tvar lineEnd = 0;\n\tvar linePattern = /.*(?:\\r\\n?|\\n)|.*$/g\n\tvar locator = domBuilder.locator;\n\n\tvar parseStack = [{currentNSMap:defaultNSMapCopy}]\n\tvar closeMap = {};\n\tvar start = 0;\n\twhile(true){\n\t\ttry{\n\t\t\tvar tagStart = source.indexOf('<',start);\n\t\t\tif(tagStart<0){\n\t\t\t\tif(!source.substr(start).match(/^\\s*$/)){\n\t\t\t\t\tvar doc = domBuilder.doc;\n\t    \t\t\tvar text = doc.createTextNode(source.substr(start));\n\t    \t\t\tdoc.appendChild(text);\n\t    \t\t\tdomBuilder.currentElement = text;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tagStart>start){\n\t\t\t\tappendText(tagStart);\n\t\t\t}\n\t\t\tswitch(source.charAt(tagStart+1)){\n\t\t\tcase '/':\n\t\t\t\tvar end = source.indexOf('>',tagStart+3);\n\t\t\t\tvar tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n\t\t\t\tvar config = parseStack.pop();\n\t\t\t\tif(end<0){\n\n\t        \t\ttagName = source.substring(tagStart+2).replace(/[\\s<].*/,'');\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' is not complete:'+config.tagName);\n\t        \t\tend = tagStart+1+tagName.length;\n\t        \t}else if(tagName.match(/\\s</)){\n\t        \t\ttagName = tagName.replace(/[\\s<].*/,'');\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' maybe not complete');\n\t        \t\tend = tagStart+1+tagName.length;\n\t\t\t\t}\n\t\t\t\tvar localNSMap = config.localNSMap;\n\t\t\t\tvar endMatch = config.tagName == tagName;\n\t\t\t\tvar endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()\n\t\t        if(endIgnoreCaseMach){\n\t\t        \tdomBuilder.endElement(config.uri,config.localName,tagName);\n\t\t\t\t\tif(localNSMap){\n\t\t\t\t\t\tfor (var prefix in localNSMap) {\n\t\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n\t\t\t\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!endMatch){\n\t\t            \terrorHandler.fatalError(\"end tag name: \"+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case\n\t\t\t\t\t}\n\t\t        }else{\n\t\t        \tparseStack.push(config)\n\t\t        }\n\n\t\t\t\tend++;\n\t\t\t\tbreak;\n\t\t\t\t// end elment\n\t\t\tcase '?':// <?...?>\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tend = parseInstruction(source,tagStart,domBuilder);\n\t\t\t\tbreak;\n\t\t\tcase '!':// <!doctype,<![CDATA,<!--\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tend = parseDCC(source,tagStart,domBuilder,errorHandler);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tvar el = new ElementAttributes();\n\t\t\t\tvar currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n\t\t\t\t//elStartEnd\n\t\t\t\tvar end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);\n\t\t\t\tvar len = el.length;\n\n\n\t\t\t\tif(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){\n\t\t\t\t\tel.closed = true;\n\t\t\t\t\tif(!entityMap.nbsp){\n\t\t\t\t\t\terrorHandler.warning('unclosed xml attribute');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(locator && len){\n\t\t\t\t\tvar locator2 = copyLocator(locator,{});\n\t\t\t\t\t//try{//attribute position fixed\n\t\t\t\t\tfor(var i = 0;i<len;i++){\n\t\t\t\t\t\tvar a = el[i];\n\t\t\t\t\t\tposition(a.offset);\n\t\t\t\t\t\ta.locator = copyLocator(locator,{});\n\t\t\t\t\t}\n\t\t\t\t\tdomBuilder.locator = locator2\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\n\t\t\t\t\t\tparseStack.push(el)\n\t\t\t\t\t}\n\t\t\t\t\tdomBuilder.locator = locator;\n\t\t\t\t}else{\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\n\t\t\t\t\t\tparseStack.push(el)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (NAMESPACE.isHTML(el.uri) && !el.closed) {\n\t\t\t\t\tend = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)\n\t\t\t\t} else {\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tif (e instanceof ParseError) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\terrorHandler.error('element parse error: '+e)\n\t\t\tend = -1;\n\t\t}\n\t\tif(end>start){\n\t\t\tstart = end;\n\t\t}else{\n\t\t\t//TODO: 这里有可能sax回退，有位置错误风险\n\t\t\tappendText(Math.max(tagStart,start)+1);\n\t\t}\n\t}\n}\nfunction copyLocator(f,t){\n\tt.lineNumber = f.lineNumber;\n\tt.columnNumber = f.columnNumber;\n\treturn t;\n}\n\n/**\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n */\nfunction parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){\n\n\t/**\n\t * @param {string} qname\n\t * @param {string} value\n\t * @param {number} startIndex\n\t */\n\tfunction addAttribute(qname, value, startIndex) {\n\t\tif (el.attributeNames.hasOwnProperty(qname)) {\n\t\t\terrorHandler.fatalError('Attribute ' + qname + ' redefined')\n\t\t}\n\t\tel.addValue(\n\t\t\tqname,\n\t\t\t// @see https://www.w3.org/TR/xml/#AVNormalize\n\t\t\t// since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n\t\t\t// - recursive replacement of (DTD) entity references\n\t\t\t// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n\t\t\tvalue.replace(/[\\t\\n\\r]/g, ' ').replace(/&#?\\w+;/g, entityReplacer),\n\t\t\tstartIndex\n\t\t)\n\t}\n\tvar attrName;\n\tvar value;\n\tvar p = ++start;\n\tvar s = S_TAG;//status\n\twhile(true){\n\t\tvar c = source.charAt(p);\n\t\tswitch(c){\n\t\tcase '=':\n\t\t\tif(s === S_ATTR){//attrName\n\t\t\t\tattrName = source.slice(start,p);\n\t\t\t\ts = S_EQ;\n\t\t\t}else if(s === S_ATTR_SPACE){\n\t\t\t\ts = S_EQ;\n\t\t\t}else{\n\t\t\t\t//fatalError: equal must after attrName or space after attrName\n\t\t\t\tthrow new Error('attribute equal must after attrName'); // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tif(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n\t\t\t\t){//equal\n\t\t\t\tif(s === S_ATTR){\n\t\t\t\t\terrorHandler.warning('attribute value must after \"=\"')\n\t\t\t\t\tattrName = source.slice(start,p)\n\t\t\t\t}\n\t\t\t\tstart = p+1;\n\t\t\t\tp = source.indexOf(c,start)\n\t\t\t\tif(p>0){\n\t\t\t\t\tvalue = source.slice(start, p);\n\t\t\t\t\taddAttribute(attrName, value, start-1);\n\t\t\t\t\ts = S_ATTR_END;\n\t\t\t\t}else{\n\t\t\t\t\t//fatalError: no end quot match\n\t\t\t\t\tthrow new Error('attribute value no end \\''+c+'\\' match');\n\t\t\t\t}\n\t\t\t}else if(s == S_ATTR_NOQUOT_VALUE){\n\t\t\t\tvalue = source.slice(start, p);\n\t\t\t\taddAttribute(attrName, value, start);\n\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed start quot('+c+')!!');\n\t\t\t\tstart = p+1;\n\t\t\t\ts = S_ATTR_END\n\t\t\t}else{\n\t\t\t\t//fatalError: no equal before\n\t\t\t\tthrow new Error('attribute value must after \"=\"'); // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tswitch(s){\n\t\t\tcase S_TAG:\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\tcase S_ATTR_END:\n\t\t\tcase S_TAG_SPACE:\n\t\t\tcase S_TAG_CLOSE:\n\t\t\t\ts =S_TAG_CLOSE;\n\t\t\t\tel.closed = true;\n\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\tcase S_ATTR:\n\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\tel.closed = true;\n\t\t\t\tbreak;\n\t\t\t//case S_EQ:\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"attribute invalid close char('/')\") // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ''://end document\n\t\t\terrorHandler.error('unexpected end of input');\n\t\t\tif(s == S_TAG){\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\t}\n\t\t\treturn p;\n\t\tcase '>':\n\t\t\tswitch(s){\n\t\t\tcase S_TAG:\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\tcase S_ATTR_END:\n\t\t\tcase S_TAG_SPACE:\n\t\t\tcase S_TAG_CLOSE:\n\t\t\t\tbreak;//normal\n\t\t\tcase S_ATTR_NOQUOT_VALUE://Compatible state\n\t\t\tcase S_ATTR:\n\t\t\t\tvalue = source.slice(start,p);\n\t\t\t\tif(value.slice(-1) === '/'){\n\t\t\t\t\tel.closed  = true;\n\t\t\t\t\tvalue = value.slice(0,-1)\n\t\t\t\t}\n\t\t\tcase S_ATTR_SPACE:\n\t\t\t\tif(s === S_ATTR_SPACE){\n\t\t\t\t\tvalue = attrName;\n\t\t\t\t}\n\t\t\t\tif(s == S_ATTR_NOQUOT_VALUE){\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!');\n\t\t\t\t\taddAttribute(attrName, value, start)\n\t\t\t\t}else{\n\t\t\t\t\tif(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed value!! \"'+value+'\" instead!!')\n\t\t\t\t\t}\n\t\t\t\t\taddAttribute(value, value, start)\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase S_EQ:\n\t\t\t\tthrow new Error('attribute value missed!!');\n\t\t\t}\n//\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n\t\t\treturn p;\n\t\t/*xml space '\\x20' | #x9 | #xD | #xA; */\n\t\tcase '\\u0080':\n\t\t\tc = ' ';\n\t\tdefault:\n\t\t\tif(c<= ' '){//space\n\t\t\t\tswitch(s){\n\t\t\t\tcase S_TAG:\n\t\t\t\t\tel.setTagName(source.slice(start,p));//tagName\n\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR:\n\t\t\t\t\tattrName = source.slice(start,p)\n\t\t\t\t\ts = S_ATTR_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\t\t\tvar value = source.slice(start, p);\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\n\t\t\t\t\taddAttribute(attrName, value, start)\n\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\t//case S_TAG_SPACE:\n\t\t\t\t//case S_EQ:\n\t\t\t\t//case S_ATTR_SPACE:\n\t\t\t\t//\tvoid();break;\n\t\t\t\t//case S_TAG_CLOSE:\n\t\t\t\t\t//ignore warning\n\t\t\t\t}\n\t\t\t}else{//not space\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n\t\t\t\tswitch(s){\n\t\t\t\t//case S_TAG:void();break;\n\t\t\t\t//case S_ATTR:void();break;\n\t\t\t\t//case S_ATTR_NOQUOT_VALUE:void();break;\n\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\tvar tagName =  el.tagName;\n\t\t\t\t\tif (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed value!! \"'+attrName+'\" instead2!!')\n\t\t\t\t\t}\n\t\t\t\t\taddAttribute(attrName, attrName, start);\n\t\t\t\t\tstart = p;\n\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\terrorHandler.warning('attribute space is required\"'+attrName+'\"!!')\n\t\t\t\tcase S_TAG_SPACE:\n\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\tstart = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_EQ:\n\t\t\t\t\ts = S_ATTR_NOQUOT_VALUE;\n\t\t\t\t\tstart = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_TAG_CLOSE:\n\t\t\t\t\tthrow new Error(\"elements closed character '/' and '>' must be connected to\");\n\t\t\t\t}\n\t\t\t}\n\t\t}//end outer switch\n\t\t//console.log('p++',p)\n\t\tp++;\n\t}\n}\n/**\n * @return true if has new namespace define\n */\nfunction appendElement(el,domBuilder,currentNSMap){\n\tvar tagName = el.tagName;\n\tvar localNSMap = null;\n\t//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n\tvar i = el.length;\n\twhile(i--){\n\t\tvar a = el[i];\n\t\tvar qName = a.qName;\n\t\tvar value = a.value;\n\t\tvar nsp = qName.indexOf(':');\n\t\tif(nsp>0){\n\t\t\tvar prefix = a.prefix = qName.slice(0,nsp);\n\t\t\tvar localName = qName.slice(nsp+1);\n\t\t\tvar nsPrefix = prefix === 'xmlns' && localName\n\t\t}else{\n\t\t\tlocalName = qName;\n\t\t\tprefix = null\n\t\t\tnsPrefix = qName === 'xmlns' && ''\n\t\t}\n\t\t//can not set prefix,because prefix !== ''\n\t\ta.localName = localName ;\n\t\t//prefix == null for no ns prefix attribute\n\t\tif(nsPrefix !== false){//hack!!\n\t\t\tif(localNSMap == null){\n\t\t\t\tlocalNSMap = {}\n\t\t\t\t//console.log(currentNSMap,0)\n\t\t\t\t_copy(currentNSMap,currentNSMap={})\n\t\t\t\t//console.log(currentNSMap,1)\n\t\t\t}\n\t\t\tcurrentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n\t\t\ta.uri = NAMESPACE.XMLNS\n\t\t\tdomBuilder.startPrefixMapping(nsPrefix, value)\n\t\t}\n\t}\n\tvar i = el.length;\n\twhile(i--){\n\t\ta = el[i];\n\t\tvar prefix = a.prefix;\n\t\tif(prefix){//no prefix attribute has no namespace\n\t\t\tif(prefix === 'xml'){\n\t\t\t\ta.uri = NAMESPACE.XML;\n\t\t\t}if(prefix !== 'xmlns'){\n\t\t\t\ta.uri = currentNSMap[prefix || '']\n\n\t\t\t\t//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n\t\t\t}\n\t\t}\n\t}\n\tvar nsp = tagName.indexOf(':');\n\tif(nsp>0){\n\t\tprefix = el.prefix = tagName.slice(0,nsp);\n\t\tlocalName = el.localName = tagName.slice(nsp+1);\n\t}else{\n\t\tprefix = null;//important!!\n\t\tlocalName = el.localName = tagName;\n\t}\n\t//no prefix element has default namespace\n\tvar ns = el.uri = currentNSMap[prefix || ''];\n\tdomBuilder.startElement(ns,localName,tagName,el);\n\t//endPrefixMapping and startPrefixMapping have not any help for dom builder\n\t//localNSMap = null\n\tif(el.closed){\n\t\tdomBuilder.endElement(ns,localName,tagName);\n\t\tif(localNSMap){\n\t\t\tfor (prefix in localNSMap) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tel.currentNSMap = currentNSMap;\n\t\tel.localNSMap = localNSMap;\n\t\t//parseStack.push(el);\n\t\treturn true;\n\t}\n}\nfunction parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){\n\tif(/^(?:script|textarea)$/i.test(tagName)){\n\t\tvar elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);\n\t\tvar text = source.substring(elStartEnd+1,elEndStart);\n\t\tif(/[&<]/.test(text)){\n\t\t\tif(/^script$/i.test(tagName)){\n\t\t\t\t//if(!/\\]\\]>/.test(text)){\n\t\t\t\t\t//lexHandler.startCDATA();\n\t\t\t\t\tdomBuilder.characters(text,0,text.length);\n\t\t\t\t\t//lexHandler.endCDATA();\n\t\t\t\t\treturn elEndStart;\n\t\t\t\t//}\n\t\t\t}//}else{//text area\n\t\t\t\ttext = text.replace(/&#?\\w+;/g,entityReplacer);\n\t\t\t\tdomBuilder.characters(text,0,text.length);\n\t\t\t\treturn elEndStart;\n\t\t\t//}\n\n\t\t}\n\t}\n\treturn elStartEnd+1;\n}\nfunction fixSelfClosed(source,elStartEnd,tagName,closeMap){\n\t//if(tagName in closeMap){\n\tvar pos = closeMap[tagName];\n\tif(pos == null){\n\t\t//console.log(tagName)\n\t\tpos =  source.lastIndexOf('</'+tagName+'>')\n\t\tif(pos<elStartEnd){//忘记闭合\n\t\t\tpos = source.lastIndexOf('</'+tagName)\n\t\t}\n\t\tcloseMap[tagName] =pos\n\t}\n\treturn pos<elStartEnd;\n\t//}\n}\n\nfunction _copy (source, target) {\n\tfor (var n in source) {\n\t\tif (Object.prototype.hasOwnProperty.call(source, n)) {\n\t\t\ttarget[n] = source[n];\n\t\t}\n\t}\n}\n\nfunction parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'\n\tvar next= source.charAt(start+2)\n\tswitch(next){\n\tcase '-':\n\t\tif(source.charAt(start + 3) === '-'){\n\t\t\tvar end = source.indexOf('-->',start+4);\n\t\t\t//append comment source.substring(4,end)//<!--\n\t\t\tif(end>start){\n\t\t\t\tdomBuilder.comment(source,start+4,end-start-4);\n\t\t\t\treturn end+3;\n\t\t\t}else{\n\t\t\t\terrorHandler.error(\"Unclosed comment\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}else{\n\t\t\t//error\n\t\t\treturn -1;\n\t\t}\n\tdefault:\n\t\tif(source.substr(start+3,6) == 'CDATA['){\n\t\t\tvar end = source.indexOf(']]>',start+9);\n\t\t\tdomBuilder.startCDATA();\n\t\t\tdomBuilder.characters(source,start+9,end-start-9);\n\t\t\tdomBuilder.endCDATA()\n\t\t\treturn end+3;\n\t\t}\n\t\t//<!DOCTYPE\n\t\t//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)\n\t\tvar matchs = split(source,start);\n\t\tvar len = matchs.length;\n\t\tif(len>1 && /!doctype/i.test(matchs[0][0])){\n\t\t\tvar name = matchs[1][0];\n\t\t\tvar pubid = false;\n\t\t\tvar sysid = false;\n\t\t\tif(len>3){\n\t\t\t\tif(/^public$/i.test(matchs[2][0])){\n\t\t\t\t\tpubid = matchs[3][0];\n\t\t\t\t\tsysid = len>4 && matchs[4][0];\n\t\t\t\t}else if(/^system$/i.test(matchs[2][0])){\n\t\t\t\t\tsysid = matchs[3][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lastMatch = matchs[len-1]\n\t\t\tdomBuilder.startDTD(name, pubid, sysid);\n\t\t\tdomBuilder.endDTD();\n\n\t\t\treturn lastMatch.index+lastMatch[0].length\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\nfunction parseInstruction(source,start,domBuilder){\n\tvar end = source.indexOf('?>',start);\n\tif(end){\n\t\tvar match = source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n\t\tif(match){\n\t\t\tvar len = match[0].length;\n\t\t\tdomBuilder.processingInstruction(match[1], match[2]) ;\n\t\t\treturn end+2;\n\t\t}else{//error\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction ElementAttributes(){\n\tthis.attributeNames = {}\n}\nElementAttributes.prototype = {\n\tsetTagName:function(tagName){\n\t\tif(!tagNamePattern.test(tagName)){\n\t\t\tthrow new Error('invalid tagName:'+tagName)\n\t\t}\n\t\tthis.tagName = tagName\n\t},\n\taddValue:function(qName, value, offset) {\n\t\tif(!tagNamePattern.test(qName)){\n\t\t\tthrow new Error('invalid attribute:'+qName)\n\t\t}\n\t\tthis.attributeNames[qName] = this.length;\n\t\tthis[this.length++] = {qName:qName,value:value,offset:offset}\n\t},\n\tlength:0,\n\tgetLocalName:function(i){return this[i].localName},\n\tgetLocator:function(i){return this[i].locator},\n\tgetQName:function(i){return this[i].qName},\n\tgetURI:function(i){return this[i].uri},\n\tgetValue:function(i){return this[i].value}\n//\t,getIndex:function(uri, localName)){\n//\t\tif(localName){\n//\n//\t\t}else{\n//\t\t\tvar qName = uri\n//\t\t}\n//\t},\n//\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n//\tgetType:function(uri,localName){}\n//\tgetType:function(i){},\n}\n\n\n\nfunction split(source,start){\n\tvar match;\n\tvar buf = [];\n\tvar reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n\treg.lastIndex = start;\n\treg.exec(source);//skip <\n\twhile(match = reg.exec(source)){\n\t\tbuf.push(match);\n\t\tif(match[1])return buf;\n\t}\n}\n\nexports.XMLReader = XMLReader;\nexports.ParseError = ParseError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/@xmldom/xmldom/lib/sax.js?");

/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/actualApply.js":
/*!*************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/actualApply.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nvar $apply = __webpack_require__(/*! ./functionApply */ \"./node_modules/call-bind-apply-helpers/functionApply.js\");\nvar $call = __webpack_require__(/*! ./functionCall */ \"./node_modules/call-bind-apply-helpers/functionCall.js\");\nvar $reflectApply = __webpack_require__(/*! ./reflectApply */ \"./node_modules/call-bind-apply-helpers/reflectApply.js\");\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bind-apply-helpers/actualApply.js?");

/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionApply.js":
/*!***************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionApply.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bind-apply-helpers/functionApply.js?");

/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionCall.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionCall.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bind-apply-helpers/functionCall.js?");

/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\n\nvar $call = __webpack_require__(/*! ./functionCall */ \"./node_modules/call-bind-apply-helpers/functionCall.js\");\nvar $actualApply = __webpack_require__(/*! ./actualApply */ \"./node_modules/call-bind-apply-helpers/actualApply.js\");\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bind-apply-helpers/index.js?");

/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/reflectApply.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bind-apply-helpers/reflectApply.js?");

/***/ }),

/***/ "./node_modules/call-bound/index.js":
/*!******************************************!*\
  !*** ./node_modules/call-bound/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBindBasic = __webpack_require__(/*! call-bind-apply-helpers */ \"./node_modules/call-bind-apply-helpers/index.js\");\n\n/** @type {(thisArg: string, searchString: string, position?: number) => number} */\nvar $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);\n\n/** @type {import('.')} */\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\t/* eslint no-extra-parens: 0 */\n\n\tvar intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBindBasic(/** @type {const} */ ([intrinsic]));\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/call-bound/index.js?");

/***/ }),

/***/ "./node_modules/dunder-proto/get.js":
/*!******************************************!*\
  !*** ./node_modules/dunder-proto/get.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar callBind = __webpack_require__(/*! call-bind-apply-helpers */ \"./node_modules/call-bind-apply-helpers/index.js\");\nvar gOPD = __webpack_require__(/*! gopd */ \"./node_modules/gopd/index.js\");\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/dunder-proto/get.js?");

/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-define-property/index.js?");

/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/eval.js?");

/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('.')} */\nmodule.exports = Error;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/index.js?");

/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/range.js?");

/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/ref.js?");

/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/syntax.js?");

/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/type.js?");

/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-errors/uri.js?");

/***/ }),

/***/ "./node_modules/es-object-atoms/index.js":
/*!***********************************************!*\
  !*** ./node_modules/es-object-atoms/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('.')} */\nmodule.exports = Object;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/es-object-atoms/index.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $Object = __webpack_require__(/*! es-object-atoms */ \"./node_modules/es-object-atoms/index.js\");\n\nvar $Error = __webpack_require__(/*! es-errors */ \"./node_modules/es-errors/index.js\");\nvar $EvalError = __webpack_require__(/*! es-errors/eval */ \"./node_modules/es-errors/eval.js\");\nvar $RangeError = __webpack_require__(/*! es-errors/range */ \"./node_modules/es-errors/range.js\");\nvar $ReferenceError = __webpack_require__(/*! es-errors/ref */ \"./node_modules/es-errors/ref.js\");\nvar $SyntaxError = __webpack_require__(/*! es-errors/syntax */ \"./node_modules/es-errors/syntax.js\");\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\nvar $URIError = __webpack_require__(/*! es-errors/uri */ \"./node_modules/es-errors/uri.js\");\n\nvar abs = __webpack_require__(/*! math-intrinsics/abs */ \"./node_modules/math-intrinsics/abs.js\");\nvar floor = __webpack_require__(/*! math-intrinsics/floor */ \"./node_modules/math-intrinsics/floor.js\");\nvar max = __webpack_require__(/*! math-intrinsics/max */ \"./node_modules/math-intrinsics/max.js\");\nvar min = __webpack_require__(/*! math-intrinsics/min */ \"./node_modules/math-intrinsics/min.js\");\nvar pow = __webpack_require__(/*! math-intrinsics/pow */ \"./node_modules/math-intrinsics/pow.js\");\nvar round = __webpack_require__(/*! math-intrinsics/round */ \"./node_modules/math-intrinsics/round.js\");\nvar sign = __webpack_require__(/*! math-intrinsics/sign */ \"./node_modules/math-intrinsics/sign.js\");\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = __webpack_require__(/*! gopd */ \"./node_modules/gopd/index.js\");\nvar $defineProperty = __webpack_require__(/*! es-define-property */ \"./node_modules/es-define-property/index.js\");\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = __webpack_require__(/*! get-proto */ \"./node_modules/get-proto/index.js\");\nvar $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ \"./node_modules/get-proto/Object.getPrototypeOf.js\");\nvar $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ \"./node_modules/get-proto/Reflect.getPrototypeOf.js\");\n\nvar $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ \"./node_modules/call-bind-apply-helpers/functionApply.js\");\nvar $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ \"./node_modules/call-bind-apply-helpers/functionCall.js\");\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! hasown */ \"./node_modules/hasown/index.js\");\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/get-proto/Object.getPrototypeOf.js":
/*!*********************************************************!*\
  !*** ./node_modules/get-proto/Object.getPrototypeOf.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar $Object = __webpack_require__(/*! es-object-atoms */ \"./node_modules/es-object-atoms/index.js\");\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/get-proto/Object.getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/get-proto/Reflect.getPrototypeOf.js":
/*!**********************************************************!*\
  !*** ./node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/get-proto/Reflect.getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/get-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/get-proto/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ \"./node_modules/get-proto/Reflect.getPrototypeOf.js\");\nvar originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ \"./node_modules/get-proto/Object.getPrototypeOf.js\");\n\nvar getDunderProto = __webpack_require__(/*! dunder-proto/get */ \"./node_modules/dunder-proto/get.js\");\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/get-proto/index.js?");

/***/ }),

/***/ "./node_modules/gopd/gOPD.js":
/*!***********************************!*\
  !*** ./node_modules/gopd/gOPD.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/gopd/gOPD.js?");

/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/** @type {import('.')} */\nvar $gOPD = __webpack_require__(/*! ./gOPD */ \"./node_modules/gopd/gOPD.js\");\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/gopd/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/hasown/index.js?");

/***/ }),

/***/ "./node_modules/ismobilejs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ismobilejs/esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _isMobile__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _isMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isMobile */ \"./node_modules/ismobilejs/esm/isMobile.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pixi-playground/./node_modules/ismobilejs/esm/index.js?");

/***/ }),

/***/ "./node_modules/ismobilejs/esm/isMobile.js":
/*!*************************************************!*\
  !*** ./node_modules/ismobilejs/esm/isMobile.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isMobile)\n/* harmony export */ });\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== 'undefined' &&\n        navigator.platform === 'MacIntel' &&\n        typeof navigator.maxTouchPoints === 'number' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === 'undefined');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === 'string') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n//# sourceMappingURL=isMobile.js.map\n\n//# sourceURL=webpack://pixi-playground/./node_modules/ismobilejs/esm/isMobile.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/abs.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/abs.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/abs.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/floor.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/floor.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/floor.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/isNaN.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/isNaN.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/isNaN.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/max.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/max.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/max.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/min.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/min.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/min.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/pow.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/pow.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/pow.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/round.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/round.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/round.js?");

/***/ }),

/***/ "./node_modules/math-intrinsics/sign.js":
/*!**********************************************!*\
  !*** ./node_modules/math-intrinsics/sign.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar $isNaN = __webpack_require__(/*! ./isNaN */ \"./node_modules/math-intrinsics/isNaN.js\");\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/math-intrinsics/sign.js?");

/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = __webpack_require__(/*! ./util.inspect */ \"?4f7e\");\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nvar quotes = {\n    __proto__: null,\n    'double': '\"',\n    single: \"'\"\n};\nvar quoteREs = {\n    __proto__: null,\n    'double': /([\"\\\\])/g,\n    single: /(['\\\\])/g\n};\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (\n        (typeof globalThis !== 'undefined' && obj === globalThis)\n        || (typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g)\n    ) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var style = opts.quoteStyle || defaultStyle;\n    var quoteChar = quotes[style];\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction canTrustToString(obj) {\n    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));\n}\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    var quoteRE = quoteREs[opts.quoteStyle || 'single'];\n    quoteRE.lastIndex = 0;\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, quoteRE, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/object-inspect/index.js?");

/***/ }),

/***/ "./node_modules/parse-svg-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/parse-svg-path/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/parse-svg-path/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/basis.worker.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/basis.worker.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\\n      const images = basisTexture.getNumImages();\\n      const levels = basisTexture.getNumLevels(0);\\n      const success = basisTexture.startTranscoding();\\n      if (!success) {\\n        throw new Error(\\\"startTranscoding failed\\\");\\n      }\\n      const levelBuffers = [];\\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\\n          const levelBuffer = new Uint8Array(transcodeSize);\\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\\n          if (!success2) {\\n            throw new Error(\\\"transcodeImage failed\\\");\\n          }\\n          levelBuffers.push(levelBuffer);\\n        }\\n      }\\n      return levelBuffers;\\n    }\\n\\n    const gpuFormatToBasisTranscoderFormatMap = {\\n      \\\"bc3-rgba-unorm\\\": 3,\\n      // cTFBC3_RGBA\\n      \\\"bc7-rgba-unorm\\\": 6,\\n      // cTFBC7_RGBA,\\n      \\\"etc2-rgba8unorm\\\": 1,\\n      // cTFETC2_RGBA,\\n      \\\"astc-4x4-unorm\\\": 10,\\n      // cTFASTC_4x4_RGBA,\\n      // Uncompressed\\n      rgba8unorm: 13,\\n      // cTFRGBA32,\\n      rgba4unorm: 16\\n      // cTFRGBA4444,\\n    };\\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\\n    }\\n\\n    const settings = {\\n      jsUrl: \\\"basis/basis_transcoder.js\\\",\\n      wasmUrl: \\\"basis/basis_transcoder.wasm\\\"\\n    };\\n    let basisTranscoderFormat;\\n    let basisTranscodedTextureFormat;\\n    let basisPromise;\\n    async function getBasis() {\\n      if (!basisPromise) {\\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\\n        importScripts(absoluteJsUrl);\\n        basisPromise = new Promise((resolve) => {\\n          BASIS({\\n            locateFile: (_file) => absoluteWasmUrl\\n          }).then((module) => {\\n            module.initializeBasis();\\n            resolve(module.BasisFile);\\n          });\\n        });\\n      }\\n      return basisPromise;\\n    }\\n    async function fetchBasisTexture(url, BasisTexture) {\\n      const basisResponse = await fetch(url);\\n      if (basisResponse.ok) {\\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\\n      }\\n      throw new Error(`Failed to load Basis texture: ${url}`);\\n    }\\n    const preferredTranscodedFormat = [\\n      \\\"bc7-rgba-unorm\\\",\\n      \\\"astc-4x4-unorm\\\",\\n      \\\"etc2-rgba8unorm\\\",\\n      \\\"bc3-rgba-unorm\\\",\\n      \\\"rgba8unorm\\\"\\n    ];\\n    async function load(url) {\\n      const BasisTexture = await getBasis();\\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\\n      return {\\n        width: basisTexture.getImageWidth(0, 0),\\n        height: basisTexture.getImageHeight(0, 0),\\n        format: basisTranscodedTextureFormat,\\n        resource: levelBuffers,\\n        alphaMode: \\\"no-premultiply-alpha\\\"\\n      };\\n    }\\n    async function init(jsUrl, wasmUrl, supportedTextures) {\\n      if (jsUrl)\\n        settings.jsUrl = jsUrl;\\n      if (wasmUrl)\\n        settings.wasmUrl = wasmUrl;\\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\\n      await getBasis();\\n    }\\n    const messageHandlers = {\\n      init: async (data) => {\\n        const { jsUrl, wasmUrl, supportedTextures } = data;\\n        await init(jsUrl, wasmUrl, supportedTextures);\\n      },\\n      load: async (data) => {\\n        try {\\n          const textureOptions = await load(data.url);\\n          return {\\n            type: \\\"load\\\",\\n            url: data.url,\\n            success: true,\\n            textureOptions,\\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\\n          };\\n        } catch (e) {\\n          throw e;\\n        }\\n      }\\n    };\\n    self.onmessage = async (messageEvent) => {\\n      const message = messageEvent.data;\\n      const response = await messageHandlers[message.type](message);\\n      if (response) {\\n        self.postMessage(response, response.transferables);\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexports[\"default\"] = WorkerInstance;\n//# sourceMappingURL=basis.worker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/_virtual/basis.worker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexports[\"default\"] = WorkerInstance;\n//# sourceMappingURL=checkImageBitmap.worker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/ktx.worker.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/ktx.worker.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const converters = {\\n      rgb8unorm: {\\n        convertedFormat: \\\"rgba8unorm\\\",\\n        convertFunction: convertRGBtoRGBA\\n      },\\n      \\\"rgb8unorm-srgb\\\": {\\n        convertedFormat: \\\"rgba8unorm-srgb\\\",\\n        convertFunction: convertRGBtoRGBA\\n      }\\n    };\\n    function convertFormatIfRequired(textureOptions) {\\n      const format = textureOptions.format;\\n      if (converters[format]) {\\n        const convertFunction = converters[format].convertFunction;\\n        const levelBuffers = textureOptions.resource;\\n        for (let i = 0; i < levelBuffers.length; i++) {\\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\\n        }\\n        textureOptions.format = converters[format].convertedFormat;\\n      }\\n    }\\n    function convertRGBtoRGBA(levelBuffer) {\\n      const pixelCount = levelBuffer.byteLength / 3;\\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\\n      for (let i = 0; i < pixelCount; ++i) {\\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\\n      }\\n      return new Uint8Array(levelBufferWithAlpha.buffer);\\n    }\\n\\n    function createLevelBuffersFromKTX(ktxTexture) {\\n      const levelBuffers = [];\\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\\n        const imageData = ktxTexture.getImageData(i, 0, 0);\\n        const levelBuffer = new Uint8Array(imageData.byteLength);\\n        levelBuffer.set(imageData);\\n        levelBuffers.push(levelBuffer);\\n      }\\n      return levelBuffers;\\n    }\\n\\n    const glFormatToGPUFormatMap = {\\n      6408: \\\"rgba8unorm\\\",\\n      32856: \\\"bgra8unorm\\\",\\n      //\\n      32857: \\\"rgb10a2unorm\\\",\\n      33189: \\\"depth16unorm\\\",\\n      33190: \\\"depth24plus\\\",\\n      33321: \\\"r8unorm\\\",\\n      33323: \\\"rg8unorm\\\",\\n      33325: \\\"r16float\\\",\\n      33326: \\\"r32float\\\",\\n      33327: \\\"rg16float\\\",\\n      33328: \\\"rg32float\\\",\\n      33329: \\\"r8sint\\\",\\n      33330: \\\"r8uint\\\",\\n      33331: \\\"r16sint\\\",\\n      33332: \\\"r16uint\\\",\\n      33333: \\\"r32sint\\\",\\n      33334: \\\"r32uint\\\",\\n      33335: \\\"rg8sint\\\",\\n      33336: \\\"rg8uint\\\",\\n      33337: \\\"rg16sint\\\",\\n      33338: \\\"rg16uint\\\",\\n      33339: \\\"rg32sint\\\",\\n      33340: \\\"rg32uint\\\",\\n      33778: \\\"bc2-rgba-unorm\\\",\\n      33779: \\\"bc3-rgba-unorm\\\",\\n      34836: \\\"rgba32float\\\",\\n      34842: \\\"rgba16float\\\",\\n      35056: \\\"depth24plus-stencil8\\\",\\n      35898: \\\"rg11b10ufloat\\\",\\n      35901: \\\"rgb9e5ufloat\\\",\\n      35907: \\\"rgba8unorm-srgb\\\",\\n      // bgra8unorm-srgb\\n      36012: \\\"depth32float\\\",\\n      36013: \\\"depth32float-stencil8\\\",\\n      36168: \\\"stencil8\\\",\\n      36208: \\\"rgba32uint\\\",\\n      36214: \\\"rgba16uint\\\",\\n      36220: \\\"rgba8uint\\\",\\n      36226: \\\"rgba32sint\\\",\\n      36232: \\\"rgba16sint\\\",\\n      36238: \\\"rgba8sint\\\",\\n      36492: \\\"bc7-rgba-unorm\\\",\\n      36756: \\\"r8snorm\\\",\\n      36757: \\\"rg8snorm\\\",\\n      36759: \\\"rgba8snorm\\\",\\n      37496: \\\"etc2-rgba8unorm\\\",\\n      37808: \\\"astc-4x4-unorm\\\"\\n    };\\n    function glFormatToGPUFormat(glInternalFormat) {\\n      const format = glFormatToGPUFormatMap[glInternalFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\\n    }\\n\\n    const vkFormatToGPUFormatMap = {\\n      23: \\\"rgb8unorm\\\",\\n      // VK_FORMAT_R8G8B8_UNORM\\n      37: \\\"rgba8unorm\\\",\\n      // VK_FORMAT_R8G8B8A8_UNORM\\n      43: \\\"rgba8unorm-srgb\\\"\\n      // VK_FORMAT_R8G8B8A8_SRGB\\n      // TODO add more!\\n    };\\n    function vkFormatToGPUFormat(vkFormat) {\\n      const format = vkFormatToGPUFormatMap[vkFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\\n    }\\n\\n    function getTextureFormatFromKTXTexture(ktxTexture) {\\n      if (ktxTexture.classId === 2) {\\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\\n      }\\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\\n    }\\n\\n    const gpuFormatToBasisTranscoderFormatMap = {\\n      \\\"bc3-rgba-unorm\\\": \\\"BC3_RGBA\\\",\\n      \\\"bc7-rgba-unorm\\\": \\\"BC7_M5_RGBA\\\",\\n      \\\"etc2-rgba8unorm\\\": \\\"ETC2_RGBA\\\",\\n      \\\"astc-4x4-unorm\\\": \\\"ASTC_4x4_RGBA\\\",\\n      // Uncompressed\\n      rgba8unorm: \\\"RGBA32\\\",\\n      rg11b10ufloat: \\\"R11F_G11F_B10F\\\"\\n    };\\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\\n    }\\n\\n    const settings = {\\n      jsUrl: \\\"\\\",\\n      wasmUrl: \\\"\\\"\\n    };\\n    let basisTranscoderFormat;\\n    let basisTranscodedTextureFormat;\\n    let ktxPromise;\\n    async function getKTX() {\\n      if (!ktxPromise) {\\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\\n        importScripts(absoluteJsUrl);\\n        ktxPromise = new Promise((resolve) => {\\n          LIBKTX({\\n            locateFile: (_file) => absoluteWasmUrl\\n          }).then((libktx) => {\\n            resolve(libktx);\\n          });\\n        });\\n      }\\n      return ktxPromise;\\n    }\\n    async function fetchKTXTexture(url, ktx) {\\n      const ktx2Response = await fetch(url);\\n      if (ktx2Response.ok) {\\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\\n      }\\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\\n    }\\n    const preferredTranscodedFormat = [\\n      \\\"bc7-rgba-unorm\\\",\\n      \\\"astc-4x4-unorm\\\",\\n      \\\"etc2-rgba8unorm\\\",\\n      \\\"bc3-rgba-unorm\\\",\\n      \\\"rgba8unorm\\\"\\n    ];\\n    async function load(url) {\\n      const ktx = await getKTX();\\n      const ktxTexture = await fetchKTXTexture(url, ktx);\\n      let format;\\n      if (ktxTexture.needsTranscoding) {\\n        format = basisTranscodedTextureFormat;\\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\\n        if (result !== ktx.ErrorCode.SUCCESS) {\\n          throw new Error(\\\"Unable to transcode basis texture.\\\");\\n        }\\n      } else {\\n        format = getTextureFormatFromKTXTexture(ktxTexture);\\n      }\\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\\n      const textureOptions = {\\n        width: ktxTexture.baseWidth,\\n        height: ktxTexture.baseHeight,\\n        format,\\n        mipLevelCount: ktxTexture.numLevels,\\n        resource: levelBuffers,\\n        alphaMode: \\\"no-premultiply-alpha\\\"\\n      };\\n      convertFormatIfRequired(textureOptions);\\n      return textureOptions;\\n    }\\n    async function init(jsUrl, wasmUrl, supportedTextures) {\\n      if (jsUrl)\\n        settings.jsUrl = jsUrl;\\n      if (wasmUrl)\\n        settings.wasmUrl = wasmUrl;\\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\\n      await getKTX();\\n    }\\n    const messageHandlers = {\\n      init: async (data) => {\\n        const { jsUrl, wasmUrl, supportedTextures } = data;\\n        await init(jsUrl, wasmUrl, supportedTextures);\\n      },\\n      load: async (data) => {\\n        try {\\n          const textureOptions = await load(data.url);\\n          return {\\n            type: \\\"load\\\",\\n            url: data.url,\\n            success: true,\\n            textureOptions,\\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\\n          };\\n        } catch (e) {\\n          throw e;\\n        }\\n      }\\n    };\\n    self.onmessage = async (messageEvent) => {\\n      const message = messageEvent.data;\\n      const response = await messageHandlers[message.type]?.(message);\\n      if (response) {\\n        self.postMessage(response, response.transferables);\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexports[\"default\"] = WorkerInstance;\n//# sourceMappingURL=ktx.worker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/_virtual/ktx.worker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexports[\"default\"] = WorkerInstance;\n//# sourceMappingURL=loadImageBitmap.worker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FederatedEvent = __webpack_require__(/*! ../events/FederatedEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedEvent.js\");\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar isMobile = __webpack_require__(/*! ../utils/browser/isMobile.js */ \"./node_modules/pixi.js/lib/utils/browser/isMobile.js\");\nvar removeItems = __webpack_require__(/*! ../utils/data/removeItems.js */ \"./node_modules/pixi.js/lib/utils/data/removeItems.js\");\n\n\"use strict\";\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nconst _AccessibilitySystem = class _AccessibilitySystem {\n  // 2fps\n  // eslint-disable-next-line jsdoc/require-param\n  /**\n   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer, _mobileInfo = isMobile.isMobile) {\n    this._mobileInfo = _mobileInfo;\n    /** Whether accessibility divs are visible for debugging */\n    this.debug = false;\n    /** Whether to activate on tab key press */\n    this._activateOnTab = true;\n    /** Whether to deactivate accessibility when mouse moves */\n    this._deactivateOnMouseMove = true;\n    /** Internal variable, see isActive getter. */\n    this._isActive = false;\n    /** Internal variable, see isMobileAccessibility getter. */\n    this._isMobileAccessibility = false;\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    this._div = null;\n    /** A simple pool for storing divs. */\n    this._pool = [];\n    /** This is a tick used to check if an object is no longer being rendered. */\n    this._renderId = 0;\n    /** The array of currently active accessible items. */\n    this._children = [];\n    /** Count to throttle div updates on android devices. */\n    this._androidUpdateCount = 0;\n    /**  The frequency to update the div elements. */\n    this._androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (_mobileInfo.tablet || _mobileInfo.phone) {\n      this._createTouchHook();\n    }\n    this._renderer = renderer;\n  }\n  /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @type {boolean}\n   * @readonly\n   */\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @type {boolean}\n   * @readonly\n   */\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  /**\n   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n   * @readonly\n   */\n  get hookDiv() {\n    return this._hookDiv;\n  }\n  /**\n   * Creates the touch hooks.\n   * @private\n   */\n  _createTouchHook() {\n    const hookDiv = document.createElement(\"button\");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = \"absolute\";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = \"#FF0000\";\n    hookDiv.title = \"select to enable accessibility for this content\";\n    hookDiv.addEventListener(\"focus\", () => {\n      this._isMobileAccessibility = true;\n      this._activate();\n      this._destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  /**\n   * Destroys the touch hooks.\n   * @private\n   */\n  _destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */\n  _activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    if (!this._div) {\n      this._div = document.createElement(\"div\");\n      this._div.style.width = `${DIV_TOUCH_SIZE}px`;\n      this._div.style.height = `${DIV_TOUCH_SIZE}px`;\n      this._div.style.position = \"absolute\";\n      this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      this._div.style.pointerEvents = \"none\";\n    }\n    if (this._activateOnTab) {\n      this._onKeyDown = this._onKeyDown.bind(this);\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    if (this._deactivateOnMouseMove) {\n      this._onMouseMove = this._onMouseMove.bind(this);\n      globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, true);\n    }\n    const canvas = this._renderer.view.canvas;\n    if (!canvas.parentNode) {\n      const observer = new MutationObserver(() => {\n        if (canvas.parentNode) {\n          canvas.parentNode.appendChild(this._div);\n          observer.disconnect();\n          this._initAccessibilitySetup();\n        }\n      });\n      observer.observe(document.body, { childList: true, subtree: true });\n    } else {\n      canvas.parentNode.appendChild(this._div);\n      this._initAccessibilitySetup();\n    }\n  }\n  // New method to handle initialization after div is ready\n  _initAccessibilitySetup() {\n    this._renderer.runners.postrender.add(this);\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n    }\n  }\n  /**\n   * Deactivates the accessibility system. Removes listeners and accessibility elements.\n   * @private\n   */\n  _deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\n    if (this._activateOnTab) {\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    this._renderer.runners.postrender.remove(this);\n    for (const child of this._children) {\n      if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n        child._accessibleDiv = null;\n      }\n      child._accessibleActive = false;\n    }\n    this._pool.forEach((div) => {\n      if (div.parentNode) {\n        div.parentNode.removeChild(div);\n      }\n    });\n    if (this._div && this._div.parentNode) {\n      this._div.parentNode.removeChild(this._div);\n    }\n    this._pool = [];\n    this._children = [];\n  }\n  /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {Container} container - The Container to check.\n   */\n  _updateAccessibleObjects(container) {\n    if (!container.visible || !container.accessibleChildren) {\n      return;\n    }\n    if (container.accessible) {\n      if (!container._accessibleActive) {\n        this._addChild(container);\n      }\n      container._renderId = this._renderId;\n    }\n    const children = container.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this._updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const defaultOpts = _AccessibilitySystem.defaultOptions;\n    const mergedOptions = {\n      accessibilityOptions: {\n        ...defaultOpts,\n        ...options?.accessibilityOptions || {}\n      }\n    };\n    this.debug = mergedOptions.accessibilityOptions.debug;\n    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n    if (mergedOptions.accessibilityOptions.enabledByDefault) {\n      this._activate();\n    } else if (this._activateOnTab) {\n      this._onKeyDown = this._onKeyDown.bind(this);\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    this._renderer.runners.postrender.remove(this);\n  }\n  /**\n   * Updates the accessibility layer during rendering.\n   * - Removes divs for containers no longer in the scene\n   * - Updates the position and dimensions of the root div\n   * - Updates positions of active accessibility divs\n   * Only fires while the accessibility system is active.\n   * @ignore\n   */\n  postrender() {\n    const now = performance.now();\n    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {\n      return;\n    }\n    this._androidUpdateCount = now + this._androidUpdateFrequency;\n    if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {\n      return;\n    }\n    const activeIds = /* @__PURE__ */ new Set();\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n      for (const child of this._children) {\n        if (child._renderId === this._renderId) {\n          activeIds.add(this._children.indexOf(child));\n        }\n      }\n    }\n    for (let i = this._children.length - 1; i >= 0; i--) {\n      const child = this._children[i];\n      if (!activeIds.has(i)) {\n        if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n          this._pool.push(child._accessibleDiv);\n          child._accessibleDiv = null;\n        }\n        child._accessibleActive = false;\n        removeItems.removeItems(this._children, i, 1);\n      }\n    }\n    if (this._renderer.renderingToScreen) {\n      const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n      const div = this._div;\n      div.style.left = `${x}px`;\n      div.style.top = `${y}px`;\n      div.style.width = `${viewWidth}px`;\n      div.style.height = `${viewHeight}px`;\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      if (!child._accessibleActive || !child._accessibleDiv) {\n        continue;\n      }\n      const div = child._accessibleDiv;\n      const hitArea = child.hitArea || child.getBounds().rectangle;\n      if (child.hitArea) {\n        const wt = child.worldTransform;\n        const sx = this._renderer.resolution;\n        const sy = this._renderer.resolution;\n        div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n        div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n        div.style.width = `${hitArea.width * wt.a * sx}px`;\n        div.style.height = `${hitArea.height * wt.d * sy}px`;\n      } else {\n        this._capHitArea(hitArea);\n        const sx = this._renderer.resolution;\n        const sy = this._renderer.resolution;\n        div.style.left = `${hitArea.x * sx}px`;\n        div.style.top = `${hitArea.y * sy}px`;\n        div.style.width = `${hitArea.width * sx}px`;\n        div.style.height = `${hitArea.height * sy}px`;\n      }\n    }\n    this._renderId++;\n  }\n  /**\n   * private function that will visually add the information to the\n   * accessibility div\n   * @param {HTMLElement} div -\n   */\n  _updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {Rectangle} hitArea - Bounds of the child\n   */\n  _capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this._renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  /**\n   * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n   * @private\n   * @param {Container} container - The child to make accessible.\n   */\n  _addChild(container) {\n    let div = this._pool.pop();\n    if (!div) {\n      if (container.accessibleType === \"button\") {\n        div = document.createElement(\"button\");\n      } else {\n        div = document.createElement(container.accessibleType);\n        div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n        if (container.accessibleText) {\n          div.innerText = container.accessibleText;\n        }\n      }\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\";\n      div.style.position = \"absolute\";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = \"none\";\n      if (navigator.userAgent.toLowerCase().includes(\"chrome\")) {\n        div.setAttribute(\"aria-live\", \"off\");\n      } else {\n        div.setAttribute(\"aria-live\", \"polite\");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute(\"aria-relevant\", \"additions\");\n      } else {\n        div.setAttribute(\"aria-relevant\", \"text\");\n      }\n      div.addEventListener(\"click\", this._onClick.bind(this));\n      div.addEventListener(\"focus\", this._onFocus.bind(this));\n      div.addEventListener(\"focusout\", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = container.accessiblePointerEvents;\n    div.type = container.accessibleType;\n    if (container.accessibleTitle && container.accessibleTitle !== null) {\n      div.title = container.accessibleTitle;\n    } else if (!container.accessibleHint || container.accessibleHint === null) {\n      div.title = `container ${container.tabIndex}`;\n    }\n    if (container.accessibleHint && container.accessibleHint !== null) {\n      div.setAttribute(\"aria-label\", container.accessibleHint);\n    }\n    if (this.debug) {\n      this._updateDebugHTML(div);\n    }\n    container._accessibleActive = true;\n    container._accessibleDiv = div;\n    div.container = container;\n    this._children.push(container);\n    this._div.appendChild(container._accessibleDiv);\n    if (container.interactive) {\n      container._accessibleDiv.tabIndex = container.tabIndex;\n    }\n  }\n  /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */\n  _dispatchEvent(e, type) {\n    const { container: target } = e.target;\n    const boundary = this._renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent.FederatedEvent(boundary), { target });\n    boundary.rootTarget = this._renderer.lastObjectRendered;\n    type.forEach((type2) => boundary.dispatchEvent(event, type2));\n  }\n  /**\n   * Maps the div button press to pixi's EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */\n  _onClick(e) {\n    this._dispatchEvent(e, [\"click\", \"pointertap\", \"tap\"]);\n  }\n  /**\n   * Maps the div focus events to pixi's EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */\n  _onFocus(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"assertive\");\n    }\n    this._dispatchEvent(e, [\"mouseover\"]);\n  }\n  /**\n   * Maps the div focus events to pixi's EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */\n  _onFocusOut(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"polite\");\n    }\n    this._dispatchEvent(e, [\"mouseout\"]);\n  }\n  /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {\n      return;\n    }\n    this._activate();\n  }\n  /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this._deactivate();\n  }\n  /**\n   * Destroys the accessibility system. Removes all elements and listeners.\n   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n   * > A typically user should not need to call this method directly.\n   */\n  destroy() {\n    this._deactivate();\n    this._destroyTouchHook();\n    this._div = null;\n    this._pool = null;\n    this._children = null;\n    this._renderer = null;\n    if (this._activateOnTab) {\n      globalThis.removeEventListener(\"keydown\", this._onKeyDown);\n    }\n  }\n  /**\n   * Enables or disables the accessibility system.\n   * @param enabled - Whether to enable or disable accessibility.\n   * @example\n   * ```js\n   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n   * ```\n   */\n  setAccessibilityEnabled(enabled) {\n    if (enabled) {\n      this._activate();\n    } else {\n      this._deactivate();\n    }\n  }\n};\n/** @ignore */\n_AccessibilitySystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"accessibility\"\n};\n/**\n * The default options used by the system.\n * You can set these before initializing the {@link Application} to change the default behavior.\n * @example\n * ```js\n * import { AccessibilitySystem } from 'pixi.js';\n *\n * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n *\n * const app = new Application()\n * app.init()\n * ```\n */\n_AccessibilitySystem.defaultOptions = {\n  /**\n   * Whether to enable accessibility features on initialization\n   * @default false\n   */\n  enabledByDefault: false,\n  /**\n   * Whether to visually show the accessibility divs for debugging\n   * @default false\n   */\n  debug: false,\n  /**\n   * Whether to activate accessibility when tab key is pressed\n   * @default true\n   */\n  activateOnTab: true,\n  /**\n   * Whether to deactivate accessibility when mouse moves\n   * @default true\n   */\n  deactivateOnMouseMove: true\n};\nlet AccessibilitySystem = _AccessibilitySystem;\n\nexports.AccessibilitySystem = AccessibilitySystem;\n//# sourceMappingURL=AccessibilitySystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst accessibilityTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  accessibleType: \"button\",\n  accessibleText: null,\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: true,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  _renderId: -1\n};\n\nexports.accessibilityTarget = accessibilityTarget;\n//# sourceMappingURL=accessibilityTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar AccessibilitySystem = __webpack_require__(/*! ./AccessibilitySystem.js */ \"./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js\");\nvar accessibilityTarget = __webpack_require__(/*! ./accessibilityTarget.js */ \"./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js\");\n\n\"use strict\";\n\nexports.AccessibilitySystem = AccessibilitySystem.AccessibilitySystem;\nexports.accessibilityTarget = accessibilityTarget.accessibilityTarget;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/accessibility/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/init.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/init.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Container = __webpack_require__(/*! ../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar AccessibilitySystem = __webpack_require__(/*! ./AccessibilitySystem.js */ \"./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js\");\nvar accessibilityTarget = __webpack_require__(/*! ./accessibilityTarget.js */ \"./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js\");\n\n\"use strict\";\nExtensions.extensions.add(AccessibilitySystem.AccessibilitySystem);\nExtensions.extensions.mixin(Container.Container, accessibilityTarget.accessibilityTarget);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/accessibility/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\nvar GLhls = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js\");\nvar GPUhls = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js\");\n\n\"use strict\";\nclass ColorBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                ${GLhls.hslgl}\n\n                vec3 blendColor(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                ${GPUhls.hslgpu}\n\n                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nColorBlend.extension = {\n  name: \"color\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.ColorBlend = ColorBlend;\n//# sourceMappingURL=ColorBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass ColorBurnBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0 - ((1.0 - base) / blend)), 0.0);\n                }\n\n                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nColorBurnBlend.extension = {\n  name: \"color-burn\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.ColorBurnBlend = ColorBurnBlend;\n//# sourceMappingURL=ColorBurnBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass ColorDodgeBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float colorDodge(float base, float blend)\n                {\n                    return base / (1.0 - blend);\n                }\n\n                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return base / (1.0 - blend);\n                }\n\n                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nColorDodgeBlend.extension = {\n  name: \"color-dodge\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.ColorDodgeBlend = ColorDodgeBlend;\n//# sourceMappingURL=ColorDodgeBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass DarkenBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                vec3 blendDarken(vec3 base, vec3 blend, float opacity)\n                {\n                    return (min(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (min(blend,base) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nDarkenBlend.extension = {\n  name: \"darken\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.DarkenBlend = DarkenBlend;\n//# sourceMappingURL=DarkenBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass DifferenceBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nDifferenceBlend.extension = {\n  name: \"difference\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.DifferenceBlend = DifferenceBlend;\n//# sourceMappingURL=DifferenceBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass DivideBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float divide(float base, float blend)\n                {\n                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;\n                }\n\n                vec3 blendDivide(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn divide(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);\n                }\n\n                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nDivideBlend.extension = {\n  name: \"divide\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.DivideBlend = DivideBlend;\n//# sourceMappingURL=DivideBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass ExclusionBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                vec3 exclusion(vec3 base, vec3 blend)\n                {\n                    return base + blend - 2.0 * base * blend;\n                }\n\n                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return base+blend-2.0*base*blend;\n                }\n\n                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nExclusionBlend.extension = {\n  name: \"exclusion\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.ExclusionBlend = ExclusionBlend;\n//# sourceMappingURL=ExclusionBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass HardLightBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float hardLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);\n                }\n\n                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                fn hardLight(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);\n                }\n\n                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nHardLightBlend.extension = {\n  name: \"hard-light\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.HardLightBlend = HardLightBlend;\n//# sourceMappingURL=HardLightBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass HardMixBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float hardMix(float base, float blend)\n                {\n                    return (base + blend >= 1.0) ? 1.0 : 0.0;\n                }\n\n                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                fn hardMix(base: f32, blend: f32) -> f32\n                {\n                    return select(0.0, 1.0, base + blend >= 1.0);\n                }\n\n                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nHardMixBlend.extension = {\n  name: \"hard-mix\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.HardMixBlend = HardMixBlend;\n//# sourceMappingURL=HardMixBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass LightenBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                vec3 blendLighten(vec3 base, vec3 blend, float opacity)\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nLightenBlend.extension = {\n  name: \"lighten\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.LightenBlend = LightenBlend;\n//# sourceMappingURL=LightenBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass LinearBurnBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float linearBurn(float base, float blend)\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nLinearBurnBlend.extension = {\n  name: \"linear-burn\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.LinearBurnBlend = LinearBurnBlend;\n//# sourceMappingURL=LinearBurnBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass LinearDodgeBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1, base + blend);\n                }\n\n                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nLinearDodgeBlend.extension = {\n  name: \"linear-dodge\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.LinearDodgeBlend = LinearDodgeBlend;\n//# sourceMappingURL=LinearDodgeBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass LinearLightBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float linearBurn(float base, float blend) {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                float linearLight(float base, float blend) {\n                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));\n                }\n\n                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base + blend);\n                }\n\n                fn linearLight(base: f32, blend: f32) -> f32\n                {\n                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nLinearLightBlend.extension = {\n  name: \"linear-light\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.LinearLightBlend = LinearLightBlend;\n//# sourceMappingURL=LinearLightBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\nvar GLhls = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js\");\nvar GPUhls = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js\");\n\n\"use strict\";\nclass LuminosityBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                ${GLhls.hslgl}\n\n                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                ${GPUhls.hslgpu}\n\n                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nLuminosityBlend.extension = {\n  name: \"luminosity\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.LuminosityBlend = LuminosityBlend;\n//# sourceMappingURL=LuminosityBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass NegationBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                vec3 negation(vec3 base, vec3 blend)\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                vec3 blendNegation(vec3 base, vec3 blend, float opacity)\n                {\n                    return (negation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nNegationBlend.extension = {\n  name: \"negation\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.NegationBlend = NegationBlend;\n//# sourceMappingURL=NegationBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass OverlayBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float overlay(float base, float blend)\n                {\n                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));\n                }\n\n                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn overlay(base: f32, blend: f32) -> f32\n                {\n                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);\n                }\n\n                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nOverlayBlend.extension = {\n  name: \"overlay\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.OverlayBlend = OverlayBlend;\n//# sourceMappingURL=OverlayBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass PinLightBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float pinLight(float base, float blend)\n                {\n                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));\n                }\n\n                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn pinLight(base: f32, blend: f32) -> f32\n                {\n                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nPinLightBlend.extension = {\n  name: \"pin-light\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.PinLightBlend = PinLightBlend;\n//# sourceMappingURL=PinLightBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\nvar GLhls = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js\");\nvar GPUhls = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js\");\n\n\"use strict\";\nclass SaturationBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                ${GLhls.hslgl}\n\n                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                ${GPUhls.hslgpu}\n\n                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nSaturationBlend.extension = {\n  name: \"saturation\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.SaturationBlend = SaturationBlend;\n//# sourceMappingURL=SaturationBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass SoftLightBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float softLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));\n                }\n\n                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn softLight(base: f32, blend: f32) -> f32\n                {\n                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);\n                }\n\n                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nSoftLightBlend.extension = {\n  name: \"soft-light\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.SoftLightBlend = SoftLightBlend;\n//# sourceMappingURL=SoftLightBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass SubtractBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float subtract(float base, float blend)\n                {\n                    return max(0.0, base - blend);\n                }\n\n                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n      },\n      gpu: {\n        functions: `\n                fn subtract(base: f32, blend: f32) -> f32\n                {\n                    return max(0, base - blend);\n                }\n\n                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nSubtractBlend.extension = {\n  name: \"subtract\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.SubtractBlend = SubtractBlend;\n//# sourceMappingURL=SubtractBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BlendModeFilter = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\n\n\"use strict\";\nclass VividLightBlend extends BlendModeFilter.BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                float colorDodge(float base, float blend)\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                float vividLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));\n                }\n\n                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n      },\n      gpu: {\n        functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                fn vividLight(base: f32, blend: f32) -> f32\n                {\n                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);\n                }\n\n                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n        main: `\n                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n      }\n    });\n  }\n}\n/** @ignore */\nVividLightBlend.extension = {\n  name: \"vivid-light\",\n  type: Extensions.ExtensionType.BlendMode\n};\n\nexports.VividLightBlend = VividLightBlend;\n//# sourceMappingURL=VividLightBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ColorBlend = __webpack_require__(/*! ./ColorBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.js\");\nvar ColorBurnBlend = __webpack_require__(/*! ./ColorBurnBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.js\");\nvar ColorDodgeBlend = __webpack_require__(/*! ./ColorDodgeBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.js\");\nvar DarkenBlend = __webpack_require__(/*! ./DarkenBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.js\");\nvar DifferenceBlend = __webpack_require__(/*! ./DifferenceBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.js\");\nvar DivideBlend = __webpack_require__(/*! ./DivideBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.js\");\nvar ExclusionBlend = __webpack_require__(/*! ./ExclusionBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.js\");\nvar HardLightBlend = __webpack_require__(/*! ./HardLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.js\");\nvar HardMixBlend = __webpack_require__(/*! ./HardMixBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.js\");\nvar LightenBlend = __webpack_require__(/*! ./LightenBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.js\");\nvar LinearBurnBlend = __webpack_require__(/*! ./LinearBurnBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.js\");\nvar LinearDodgeBlend = __webpack_require__(/*! ./LinearDodgeBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.js\");\nvar LinearLightBlend = __webpack_require__(/*! ./LinearLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.js\");\nvar LuminosityBlend = __webpack_require__(/*! ./LuminosityBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.js\");\nvar NegationBlend = __webpack_require__(/*! ./NegationBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.js\");\nvar OverlayBlend = __webpack_require__(/*! ./OverlayBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.js\");\nvar PinLightBlend = __webpack_require__(/*! ./PinLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.js\");\nvar SaturationBlend = __webpack_require__(/*! ./SaturationBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.js\");\nvar SoftLightBlend = __webpack_require__(/*! ./SoftLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.js\");\nvar SubtractBlend = __webpack_require__(/*! ./SubtractBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.js\");\nvar VividLightBlend = __webpack_require__(/*! ./VividLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.js\");\n\n\"use strict\";\n\nexports.ColorBlend = ColorBlend.ColorBlend;\nexports.ColorBurnBlend = ColorBurnBlend.ColorBurnBlend;\nexports.ColorDodgeBlend = ColorDodgeBlend.ColorDodgeBlend;\nexports.DarkenBlend = DarkenBlend.DarkenBlend;\nexports.DifferenceBlend = DifferenceBlend.DifferenceBlend;\nexports.DivideBlend = DivideBlend.DivideBlend;\nexports.ExclusionBlend = ExclusionBlend.ExclusionBlend;\nexports.HardLightBlend = HardLightBlend.HardLightBlend;\nexports.HardMixBlend = HardMixBlend.HardMixBlend;\nexports.LightenBlend = LightenBlend.LightenBlend;\nexports.LinearBurnBlend = LinearBurnBlend.LinearBurnBlend;\nexports.LinearDodgeBlend = LinearDodgeBlend.LinearDodgeBlend;\nexports.LinearLightBlend = LinearLightBlend.LinearLightBlend;\nexports.LuminosityBlend = LuminosityBlend.LuminosityBlend;\nexports.NegationBlend = NegationBlend.NegationBlend;\nexports.OverlayBlend = OverlayBlend.OverlayBlend;\nexports.PinLightBlend = PinLightBlend.PinLightBlend;\nexports.SaturationBlend = SaturationBlend.SaturationBlend;\nexports.SoftLightBlend = SoftLightBlend.SoftLightBlend;\nexports.SubtractBlend = SubtractBlend.SubtractBlend;\nexports.VividLightBlend = VividLightBlend.VividLightBlend;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/advanced-blend-modes/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/app/Application.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/Application.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar autoDetectRenderer = __webpack_require__(/*! ../rendering/renderers/autoDetectRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js\");\nvar Container = __webpack_require__(/*! ../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar globalHooks = __webpack_require__(/*! ../utils/global/globalHooks.js */ \"./node_modules/pixi.js/lib/utils/global/globalHooks.js\");\nvar deprecation = __webpack_require__(/*! ../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /**\n     * The root display container for your application.\n     * All visual elements should be added to this container or its children.\n     * @example\n     * ```js\n     * // Create a sprite and add it to the stage\n     * const sprite = Sprite.from('image.png');\n     * app.stage.addChild(sprite);\n     *\n     * // Create a container for grouping objects\n     * const container = new Container();\n     * app.stage.addChild(container);\n     * ```\n     */\n    this.stage = new Container.Container();\n    if (args[0] !== void 0) {\n      deprecation.deprecation(deprecation.v8_0_0, \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n  }\n  /**\n   * Initializes the PixiJS application with the specified options.\n   *\n   * This method must be called after creating a new Application instance.\n   * @param options - Configuration options for the application and renderer\n   * @returns A promise that resolves when initialization is complete\n   * @example\n   * ```js\n   * const app = new Application();\n   *\n   * // Initialize with custom options\n   * await app.init({\n   *     width: 800,\n   *     height: 600,\n   *     backgroundColor: 0x1099bb,\n   *     preference: 'webgl', // or 'webgpu'\n   * });\n   * ```\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer.autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /**\n   * Renders the current stage to the screen.\n   *\n   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call\n   * this method directly as rendering is handled automatically.\n   *\n   * Only use this method if you've disabled the {@link TickerPlugin} or need custom\n   * render timing control.\n   * @example\n   * ```js\n   * // Example 1: Default setup (TickerPlugin handles rendering)\n   * const app = new Application();\n   * await app.init();\n   * // No need to call render() - TickerPlugin handles it\n   *\n   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)\n   * const app = new Application();\n   * await app.init({ autoStart: false }); // Disable automatic rendering\n   *\n   * function animate() {\n   *     app.render();\n   *     requestAnimationFrame(animate);\n   * }\n   * animate();\n   * ```\n   */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer's canvas element. This is the HTML element\n   * that displays your application's graphics.\n   * @readonly\n   * @type {HTMLCanvasElement}\n   * @example\n   * ```js\n   * // Create a new application\n   * const app = new Application();\n   * // Initialize the application\n   * await app.init({...});\n   * // Add canvas to the page\n   * document.body.appendChild(app.canvas);\n   *\n   * // Access the canvas directly\n   * console.log(app.canvas); // HTMLCanvasElement\n   * ```\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @type {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   * @see {@link Application#canvas}\n   */\n  get view() {\n    deprecation.deprecation(deprecation.v8_0_0, \"Application.view is deprecated, please use Application.canvas instead.\");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's screen rectangle. This represents the visible area of your application.\n   *\n   * It's commonly used for:\n   * - Setting filter areas for full-screen effects\n   * - Defining hit areas for screen-wide interaction\n   * - Determining the visible bounds of your application\n   * @readonly\n   * @example\n   * ```js\n   * // Use as filter area for a full-screen effect\n   * const blurFilter = new BlurFilter();\n   * sprite.filterArea = app.screen;\n   *\n   * // Use as hit area for screen-wide interaction\n   * const screenSprite = new Sprite();\n   * screenSprite.hitArea = app.screen;\n   *\n   * // Get screen dimensions\n   * console.log(app.screen.width, app.screen.height);\n   * ```\n   * @see {@link Rectangle} For all available properties and methods\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   *\n   * This method should be called when you want to completely\n   * clean up the application and free all associated memory.\n   * @param rendererDestroyOptions - Options for destroying the renderer:\n   *  - `false` or `undefined`: Preserves the canvas element (default)\n   *  - `true`: Removes the canvas element\n   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal\n   * @param options - Options for destroying the application:\n   *  - `false` or `undefined`: Basic cleanup (default)\n   *  - `true`: Complete cleanup including children\n   *  - Detailed options object:\n   *    - `children`: Remove children\n   *    - `texture`: Destroy textures\n   *    - `textureSource`: Destroy texture sources\n   *    - `context`: Destroy WebGL context\n   * @example\n   * ```js\n   * // Basic cleanup\n   * app.destroy();\n   *\n   * // Remove canvas and do complete cleanup\n   * app.destroy(true, true);\n   *\n   * // Remove canvas with explicit options\n   * app.destroy({ removeView: true }, true);\n   *\n   * // Detailed cleanup with specific options\n   * app.destroy(\n   *     { removeView: true },\n   *     {\n   *         children: true,\n   *         texture: true,\n   *         textureSource: true,\n   *         context: true\n   *     }\n   * );\n   * ```\n   * > [!WARNING] After calling destroy, the application instance should no longer be used.\n   * > All properties will be null and further operations will throw errors.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @internal\n */\n_Application._plugins = [];\nlet Application = _Application;\nExtensions.extensions.handleByList(Extensions.ExtensionType.Application, Application._plugins);\nExtensions.extensions.add(globalHooks.ApplicationInitHook);\n\nexports.Application = Application;\n//# sourceMappingURL=Application.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/app/Application.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/app/ResizePlugin.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/ResizePlugin.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions.ExtensionType.Application;\n\nexports.ResizePlugin = ResizePlugin;\n//# sourceMappingURL=ResizePlugin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/app/ResizePlugin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/app/TickerPlugin.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/TickerPlugin.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar _const = __webpack_require__(/*! ../ticker/const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.Ticker.shared : new Ticker.Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions.ExtensionType.Application;\n\nexports.TickerPlugin = TickerPlugin;\n//# sourceMappingURL=TickerPlugin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/app/TickerPlugin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/app/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pixi.js/lib/app/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Application = __webpack_require__(/*! ./Application.js */ \"./node_modules/pixi.js/lib/app/Application.js\");\nvar ResizePlugin = __webpack_require__(/*! ./ResizePlugin.js */ \"./node_modules/pixi.js/lib/app/ResizePlugin.js\");\nvar TickerPlugin = __webpack_require__(/*! ./TickerPlugin.js */ \"./node_modules/pixi.js/lib/app/TickerPlugin.js\");\n\n\"use strict\";\n\nexports.Application = Application.Application;\nexports.ResizePlugin = ResizePlugin.ResizePlugin;\nexports.TickerPlugin = TickerPlugin.TickerPlugin;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/app/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/app/init.js":
/*!**********************************************!*\
  !*** ./node_modules/pixi.js/lib/app/init.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar ResizePlugin = __webpack_require__(/*! ./ResizePlugin.js */ \"./node_modules/pixi.js/lib/app/ResizePlugin.js\");\nvar TickerPlugin = __webpack_require__(/*! ./TickerPlugin.js */ \"./node_modules/pixi.js/lib/app/TickerPlugin.js\");\n\n\"use strict\";\nExtensions.extensions.add(ResizePlugin.ResizePlugin);\nExtensions.extensions.add(TickerPlugin.TickerPlugin);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/app/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/AssetExtension.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/AssetExtension.js ***!
  \***********************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=AssetExtension.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/AssetExtension.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/Assets.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/Assets.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar loadBitmapFont = __webpack_require__(/*! ../scene/text-bitmap/asset/loadBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js\");\nvar warn = __webpack_require__(/*! ../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar BackgroundLoader = __webpack_require__(/*! ./BackgroundLoader.js */ \"./node_modules/pixi.js/lib/assets/BackgroundLoader.js\");\nvar Cache = __webpack_require__(/*! ./cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar cacheTextureArray = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.js */ \"./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js\");\nvar detectAvif = __webpack_require__(/*! ./detections/parsers/detectAvif.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js\");\nvar detectDefaults = __webpack_require__(/*! ./detections/parsers/detectDefaults.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js\");\nvar detectMp4 = __webpack_require__(/*! ./detections/parsers/detectMp4.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js\");\nvar detectOgv = __webpack_require__(/*! ./detections/parsers/detectOgv.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js\");\nvar detectWebm = __webpack_require__(/*! ./detections/parsers/detectWebm.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js\");\nvar detectWebp = __webpack_require__(/*! ./detections/parsers/detectWebp.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js\");\nvar Loader = __webpack_require__(/*! ./loader/Loader.js */ \"./node_modules/pixi.js/lib/assets/loader/Loader.js\");\nvar loadJson = __webpack_require__(/*! ./loader/parsers/loadJson.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js\");\nvar loadTxt = __webpack_require__(/*! ./loader/parsers/loadTxt.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js\");\nvar loadWebFont = __webpack_require__(/*! ./loader/parsers/loadWebFont.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js\");\nvar loadSVG = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js\");\nvar loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js\");\nvar loadVideoTextures = __webpack_require__(/*! ./loader/parsers/textures/loadVideoTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js\");\nvar resolveJsonUrl = __webpack_require__(/*! ./resolver/parsers/resolveJsonUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js\");\nvar resolveTextureUrl = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js\");\nvar Resolver = __webpack_require__(/*! ./resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\nvar convertToList = __webpack_require__(/*! ./utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\nvar isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ \"./node_modules/pixi.js/lib/assets/utils/isSingleItem.js\");\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver.Resolver();\n    this.loader = new Loader.Loader();\n    this.cache = Cache.Cache;\n    this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Initializes the Assets class with configuration options. While not required,\n   * calling this before loading assets is recommended to set up default behaviors.\n   * @param options - Configuration options for the Assets system\n   * @example\n   * ```ts\n   * // Basic initialization (optional as Assets.load will call this automatically)\n   * await Assets.init();\n   *\n   * // With CDN configuration\n   * await Assets.init({\n   *     basePath: 'https://my-cdn.com/assets/',\n   *     defaultSearchParams: { version: '1.0.0' }\n   * });\n   *\n   * // With manifest and preferences\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [{\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'hero',\n   *                     src: 'hero.{png,webp}',\n   *                     data: { scaleMode: SCALE_MODES.NEAREST }\n   *                 },\n   *                 {\n   *                     alias: 'map',\n   *                     src: 'map.json'\n   *                 }\n   *             ]\n   *         }]\n   *     },\n   *     // Optimize for device capabilities\n   *     texturePreference: {\n   *         resolution: window.devicePixelRatio,\n   *         format: ['webp', 'png']\n   *     },\n   *     // Set global preferences\n   *     preferences: {\n   *         crossOrigin: 'anonymous',\n   *     }\n   * });\n   *\n   * // Load assets after initialization\n   * const heroTexture = await Assets.load('hero');\n   * ```\n   * @remarks\n   * - Can be called only once; subsequent calls will be ignored with a warning\n   * - Format detection runs automatically unless `skipDetections` is true\n   * - The manifest can be a URL to a JSON file or an inline object\n   * @see {@link AssetInitOptions} For all available initialization options\n   * @see {@link AssetsManifest} For manifest format details\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn.warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n   * allowing you to load assets using friendly names instead of direct URLs.\n   * @param assets - The unresolved assets to add to the resolver\n   * @example\n   * ```ts\n   * // Basic usage - single asset\n   * Assets.add({\n   *     alias: 'myTexture',\n   *     src: 'assets/texture.png'\n   * });\n   * const texture = await Assets.load('myTexture');\n   *\n   * // Multiple aliases for the same asset\n   * Assets.add({\n   *     alias: ['hero', 'player'],\n   *     src: 'hero.png'\n   * });\n   * const hero1 = await Assets.load('hero');\n   * const hero2 = await Assets.load('player'); // Same texture\n   *\n   * // Multiple format support\n   * Assets.add({\n   *     alias: 'character',\n   *     src: 'character.{webp,png}' // Will choose best format\n   * });\n   * Assets.add({\n   *     alias: 'character',\n   *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n   * });\n   *\n   * // With texture options\n   * Assets.add({\n   *     alias: 'sprite',\n   *     src: 'sprite.png',\n   *     data: { scaleMode: 'nearest' }\n   * });\n   *\n   * // Multiple assets at once\n   * Assets.add([\n   *     { alias: 'bg', src: 'background.png' },\n   *     { alias: 'music', src: 'music.mp3' },\n   *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n   * ]);\n   * ```\n   * @remarks\n   * - Assets are resolved when loaded, not when added\n   * - Multiple formats use the best available format for the browser\n   * - Adding with same alias overwrites previous definition\n   * - The `data` property is passed to the asset loader\n   * @see {@link Resolver} For details on asset resolution\n   * @see {@link LoaderParser} For asset-specific data options\n   * @advanced\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem.isSingleItem(urls);\n    const urlArray = convertToList.convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n   * assets into logical groups, such as game levels or UI screens.\n   * @param bundleId - Unique identifier for the bundle\n   * @param assets - Assets to include in the bundle\n   * @example\n   * ```ts\n   * // Add a bundle using array format\n   * Assets.addBundle('animals', [\n   *     { alias: 'bunny', src: 'bunny.png' },\n   *     { alias: 'chicken', src: 'chicken.png' },\n   *     { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   *\n   * // Add a bundle using object format\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * // Add a bundle with advanced options\n   * Assets.addBundle('ui', [\n   *     {\n   *         alias: 'button',\n   *         src: 'button.{webp,png}',\n   *         data: { scaleMode: 'nearest' }\n   *     },\n   *     {\n   *         alias: ['logo', 'brand'],  // Multiple aliases\n   *         src: 'logo.svg',\n   *         data: { resolution: 2 }\n   *     }\n   * ]);\n   *\n   * // Load the bundle\n   * await Assets.loadBundle('animals');\n   *\n   * // Use the loaded assets\n   * const bunny = Sprite.from('bunny');\n   * const chicken = Sprite.from('chicken');\n   * ```\n   * @remarks\n   * - Bundle IDs must be unique\n   * - Assets in bundles are not loaded until `loadBundle` is called\n   * - Bundles can be background loaded using `backgroundLoadBundle`\n   * - Assets in bundles can be loaded individually using their aliases\n   * @see {@link Assets.loadBundle} For loading bundles\n   * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n   * @see {@link Assets.unloadBundle} For unloading bundles\n   * @see {@link AssetsManifest} For manifest format details\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n   * that can be loaded together.\n   * @param bundleIds - Single bundle ID or array of bundle IDs to load\n   * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n   * @returns Promise that resolves with the loaded bundle assets\n   * @example\n   * ```ts\n   * // Define bundles in your manifest\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * // Initialize with manifest\n   * await Assets.init({ manifest });\n   *\n   * // Or add bundles programmatically\n   * Assets.addBundle('load-screen', [...]);\n   * Assets.loadBundle('load-screen');\n   *\n   * // Load a single bundle\n   * await Assets.loadBundle('load-screen');\n   * const bg = Sprite.from('background'); // Uses alias from bundle\n   *\n   * // Load multiple bundles\n   * await Assets.loadBundle([\n   *     'load-screen',\n   *     'game-screen'\n   * ]);\n   *\n   * // Load with progress tracking\n   * await Assets.loadBundle('game-screen', (progress) => {\n   *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n   * });\n   * ```\n   * @remarks\n   * - Bundle assets are cached automatically\n   * - Bundles can be pre-loaded using `backgroundLoadBundle`\n   * - Assets in bundles can be accessed by their aliases\n   * - Progress callback receives values from 0.0 to 1.0\n   * @throws {Error} If the bundle ID doesn't exist in the manifest\n   * @see {@link Assets.addBundle} For adding bundles programmatically\n   * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n   * @see {@link Assets.unloadBundle} For unloading bundles\n   * @see {@link AssetsManifest} For manifest format details\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n   * continue, making them instantly available when needed later.\n   *\n   * Background loading is useful for:\n   * - Preloading game levels while in a menu\n   * - Loading non-critical assets during gameplay\n   * - Reducing visible loading screens\n   * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n   * @example\n   * ```ts\n   * // Basic background loading\n   * Assets.backgroundLoad('images/level2-assets.png');\n   *\n   * // Background load multiple assets\n   * Assets.backgroundLoad([\n   *     'images/sprite1.png',\n   *     'images/sprite2.png',\n   *     'images/background.png'\n   * ]);\n   *\n   * // Later, when you need the assets\n   * const textures = await Assets.load([\n   *     'images/sprite1.png',\n   *     'images/sprite2.png'\n   * ]); // Resolves immediately if background loading completed\n   * ```\n   * @remarks\n   * - Background loading happens one asset at a time to avoid blocking the main thread\n   * - Loading can be interrupted safely by calling `Assets.load()`\n   * - Assets are cached as they complete loading\n   * - No progress tracking is available for background loading\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n   * predefined bundles of assets.\n   *\n   * Perfect for:\n   * - Preloading level bundles during gameplay\n   * - Loading UI assets during splash screens\n   * - Preparing assets for upcoming game states\n   * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n   * @example\n   * ```ts\n   * // Define bundles in your manifest\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *               name: 'home',\n   *               assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'images/home-bg.png',\n   *                 },\n   *                 {\n   *                     alias: 'logo',\n   *                     src: 'images/logo.png',\n   *                 }\n   *              ]\n   *            },\n   *            {\n   *             name: 'level-1',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'images/level1/bg.png',\n   *                 },\n   *                 {\n   *                     alias: 'sprites',\n   *                     src: 'images/level1/sprites.json'\n   *                 }\n   *             ]\n   *         }]\n   *     }\n   * });\n   *\n   * // Load the home screen assets right away\n   * await Assets.loadBundle('home');\n   * showHomeScreen();\n   *\n   * // Start background loading while showing home screen\n   * Assets.backgroundLoadBundle('level-1');\n   *\n   * // When player starts level, load completes faster\n   * await Assets.loadBundle('level-1');\n   * hideHomeScreen();\n   * startLevel();\n   * ```\n   * @remarks\n   * - Bundle assets are loaded one at a time\n   * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n   * - Assets are cached as they complete loading\n   * - Requires bundles to be registered via manifest or `addBundle`\n   * @see {@link Assets.addBundle} For adding bundles programmatically\n   * @see {@link Assets.loadBundle} For immediate bundle loading\n   * @see {@link AssetsManifest} For manifest format details\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   * @internal\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unloads assets and releases them from memory. This method ensures proper cleanup of\n   * loaded assets when they're no longer needed.\n   * @param urls - Single URL/alias or array of URLs/aliases to unload\n   * @example\n   * ```ts\n   * // Unload a single asset\n   * await Assets.unload('images/sprite.png');\n   *\n   * // Unload using an alias\n   * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n   *\n   * // Unload multiple assets\n   * await Assets.unload([\n   *     'images/background.png',\n   *     'images/character.png',\n   *     'hero'\n   * ]);\n   *\n   * // Unload and handle creation of new instances\n   * await Assets.unload('hero');\n   * const newHero = await Assets.load('hero'); // Will load fresh from source\n   * ```\n   * @remarks\n   * > [!WARNING]\n   * > Make sure assets aren't being used before unloading:\n   * > - Remove sprites using the texture\n   * > - Clear any references to the asset\n   * > - Textures will be destroyed and can't be used after unloading\n   * @throws {Error} If the asset is not found in cache\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList.convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n   * are no longer needed, such as when switching game levels.\n   * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n   * @example\n   * ```ts\n   * // Define and load a bundle\n   * Assets.addBundle('level-1', {\n   *     background: 'level1/bg.png',\n   *     sprites: 'level1/sprites.json',\n   *     music: 'level1/music.mp3'\n   * });\n   *\n   * // Load the bundle\n   * const level1 = await Assets.loadBundle('level-1');\n   *\n   * // Use the assets\n   * const background = Sprite.from(level1.background);\n   *\n   * // When done with the level, unload everything\n   * await Assets.unloadBundle('level-1');\n   * // background sprite is now invalid!\n   *\n   * // Unload multiple bundles\n   * await Assets.unloadBundle([\n   *     'level-1',\n   *     'level-2',\n   *     'ui-elements'\n   * ]);\n   * ```\n   * @remarks\n   * > [!WARNING]\n   * > - All assets in the bundle will be destroyed\n   * > - Bundle needs to be reloaded to use assets again\n   * > - Make sure no sprites or other objects are using the assets\n   * @throws {Error} If the bundle is not found\n   * @see {@link Assets.addBundle} For adding bundles\n   * @see {@link Assets.loadBundle} For loading bundles\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList.convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /**\n   * All the detection parsers currently added to the Assets class.\n   * @advanced\n   */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * Sets global preferences for asset loading behavior. This method configures how assets\n   * are loaded and processed across all parsers.\n   * @param preferences - Asset loading preferences\n   * @example\n   * ```ts\n   * // Basic preferences\n   * Assets.setPreferences({\n   *     crossOrigin: 'anonymous',\n   *     parseAsGraphicsContext: false\n   * });\n   * ```\n   * @remarks\n   * Preferences are applied to all compatible parsers and affect future asset loading.\n   * Common preferences include:\n   * - `crossOrigin`: CORS setting for loaded assets\n   * - `preferWorkers`: Whether to use web workers for loading textures\n   * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n   * @see {@link AssetsPreferences} For all available preferences\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nExtensions.extensions.handleByList(Extensions.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(Extensions.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(Extensions.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(Extensions.ExtensionType.DetectionParser, Assets.detections);\nExtensions.extensions.add(\n  cacheTextureArray.cacheTextureArray,\n  detectDefaults.detectDefaults,\n  detectAvif.detectAvif,\n  detectWebp.detectWebp,\n  detectMp4.detectMp4,\n  detectOgv.detectOgv,\n  detectWebm.detectWebm,\n  loadJson.loadJson,\n  loadTxt.loadTxt,\n  loadWebFont.loadWebFont,\n  loadSVG.loadSvg,\n  loadTextures.loadTextures,\n  loadVideoTextures.loadVideoTextures,\n  loadBitmapFont.loadBitmapFont,\n  loadBitmapFont.bitmapFontCachePlugin,\n  resolveTextureUrl.resolveTextureUrl,\n  resolveJsonUrl.resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: Extensions.ExtensionType.LoadParser,\n  resolver: Extensions.ExtensionType.ResolveParser,\n  cache: Extensions.ExtensionType.CacheParser,\n  detection: Extensions.ExtensionType.DetectionParser\n};\nExtensions.extensions.handle(Extensions.ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => Extensions.extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => Extensions.extensions.remove(ref[key]));\n});\n\nexports.Assets = Assets;\nexports.AssetsClass = AssetsClass;\n//# sourceMappingURL=Assets.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/Assets.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/BackgroundLoader.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/BackgroundLoader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds assets to the background loading queue. Assets are loaded one at a time to minimize\n   * performance impact.\n   * @param assetUrls - Array of resolved assets to load in the background\n   * @example\n   * ```ts\n   * // Add assets to background load queue\n   * backgroundLoader.add([\n   *     { src: 'images/level1/bg.png' },\n   *     { src: 'images/level1/characters.json' }\n   * ]);\n   *\n   * // Assets will load sequentially in the background\n   * // The loader automatically pauses when high-priority loads occur\n   * // e.g. Assets.load() is called\n   * ```\n   * @remarks\n   * - Assets are loaded one at a time to minimize performance impact\n   * - Loading automatically pauses when Assets.load() is called\n   * - No progress tracking is available for background loading\n   * - Assets are cached as they complete loading\n   * @internal\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log(\"[BackgroundLoader] assets: \", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Controls the active state of the background loader. When active, the loader will\n   * continue processing its queue. When inactive, loading is paused.\n   * @returns Whether the background loader is currently active\n   * @example\n   * ```ts\n   * // Pause background loading\n   * backgroundLoader.active = false;\n   *\n   * // Resume background loading\n   * backgroundLoader.active = true;\n   *\n   * // Check current state\n   * console.log(backgroundLoader.active); // true/false\n   *\n   * // Common use case: Pause during intensive operations\n   * backgroundLoader.active = false;  // Pause background loading\n   * ... // Perform high-priority tasks\n   * backgroundLoader.active = true;   // Resume background loading\n   * ```\n   * @remarks\n   * - Setting to true resumes loading immediately\n   * - Setting to false pauses after current asset completes\n   * - Background loading is automatically paused during `Assets.load()`\n   * - Assets already being loaded will complete even when set to false\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\nexports.BackgroundLoader = BackgroundLoader;\n//# sourceMappingURL=BackgroundLoader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/BackgroundLoader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/cache/Cache.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/cache/Cache.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar convertToList = __webpack_require__(/*! ../utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList.convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn.warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /**\n   * All loader parsers registered\n   * @advanced\n   */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexports.Cache = Cache;\n//# sourceMappingURL=Cache.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/cache/Cache.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/cache/CacheParser.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/cache/CacheParser.js ***!
  \**************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=CacheParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/cache/CacheParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst cacheTextureArray = {\n  extension: {\n    type: Extensions.ExtensionType.CacheParser,\n    name: \"cacheTextureArray\"\n  },\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture.Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? \"\" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\nexports.cacheTextureArray = cacheTextureArray;\n//# sourceMappingURL=cacheTextureArray.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar testImageFormat = __webpack_require__(/*! ../utils/testImageFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js\");\n\n\"use strict\";\nconst detectAvif = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat.testImageFormat(\n    // eslint-disable-next-line max-len\n    \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"\n  ),\n  add: async (formats) => [...formats, \"avif\"],\n  remove: async (formats) => formats.filter((f) => f !== \"avif\")\n};\n\nexports.detectAvif = detectAvif;\n//# sourceMappingURL=detectAvif.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\"];\nconst detectDefaults = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\nexports.detectDefaults = detectDefaults;\n//# sourceMappingURL=detectDefaults.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js\");\n\n\"use strict\";\nconst detectMp4 = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat.testVideoFormat(\"video/mp4\"),\n  add: async (formats) => [...formats, \"mp4\", \"m4v\"],\n  remove: async (formats) => formats.filter((f) => f !== \"mp4\" && f !== \"m4v\")\n};\n\nexports.detectMp4 = detectMp4;\n//# sourceMappingURL=detectMp4.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js\");\n\n\"use strict\";\nconst detectOgv = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat.testVideoFormat(\"video/ogg\"),\n  add: async (formats) => [...formats, \"ogv\"],\n  remove: async (formats) => formats.filter((f) => f !== \"ogv\")\n};\n\nexports.detectOgv = detectOgv;\n//# sourceMappingURL=detectOgv.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js\");\n\n\"use strict\";\nconst detectWebm = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat.testVideoFormat(\"video/webm\"),\n  add: async (formats) => [...formats, \"webm\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webm\")\n};\n\nexports.detectWebm = detectWebm;\n//# sourceMappingURL=detectWebm.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar testImageFormat = __webpack_require__(/*! ../utils/testImageFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js\");\n\n\"use strict\";\nconst detectWebp = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat.testImageFormat(\n    \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"\n  ),\n  add: async (formats) => [...formats, \"webp\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webp\")\n};\n\nexports.detectWebp = detectWebp;\n//# sourceMappingURL=detectWebp.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/types.js ***!
  \*************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nasync function testImageFormat(imageData) {\n  if (\"Image\" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (_e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexports.testImageFormat = testImageFormat;\n//# sourceMappingURL=testImageFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement(\"video\");\n  return video.canPlayType(mimeType) !== \"\";\n}\n\nexports.testVideoFormat = testVideoFormat;\n//# sourceMappingURL=testVideoFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/index.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! ./AssetExtension.js */ \"./node_modules/pixi.js/lib/assets/AssetExtension.js\");\nvar Assets = __webpack_require__(/*! ./Assets.js */ \"./node_modules/pixi.js/lib/assets/Assets.js\");\nvar BackgroundLoader = __webpack_require__(/*! ./BackgroundLoader.js */ \"./node_modules/pixi.js/lib/assets/BackgroundLoader.js\");\nvar Cache = __webpack_require__(/*! ./cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\n__webpack_require__(/*! ./cache/CacheParser.js */ \"./node_modules/pixi.js/lib/assets/cache/CacheParser.js\");\nvar cacheTextureArray = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.js */ \"./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js\");\nvar detectAvif = __webpack_require__(/*! ./detections/parsers/detectAvif.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js\");\nvar detectDefaults = __webpack_require__(/*! ./detections/parsers/detectDefaults.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js\");\nvar detectMp4 = __webpack_require__(/*! ./detections/parsers/detectMp4.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js\");\nvar detectOgv = __webpack_require__(/*! ./detections/parsers/detectOgv.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js\");\nvar detectWebm = __webpack_require__(/*! ./detections/parsers/detectWebm.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js\");\nvar detectWebp = __webpack_require__(/*! ./detections/parsers/detectWebp.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js\");\n__webpack_require__(/*! ./detections/types.js */ \"./node_modules/pixi.js/lib/assets/detections/types.js\");\nvar testImageFormat = __webpack_require__(/*! ./detections/utils/testImageFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js\");\nvar testVideoFormat = __webpack_require__(/*! ./detections/utils/testVideoFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js\");\nvar Loader = __webpack_require__(/*! ./loader/Loader.js */ \"./node_modules/pixi.js/lib/assets/loader/Loader.js\");\nvar LoaderParser = __webpack_require__(/*! ./loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar loadJson = __webpack_require__(/*! ./loader/parsers/loadJson.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js\");\nvar loadTxt = __webpack_require__(/*! ./loader/parsers/loadTxt.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js\");\nvar loadWebFont = __webpack_require__(/*! ./loader/parsers/loadWebFont.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js\");\nvar loadSVG = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js\");\nvar loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js\");\nvar loadVideoTextures = __webpack_require__(/*! ./loader/parsers/textures/loadVideoTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js\");\nvar createTexture = __webpack_require__(/*! ./loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\n__webpack_require__(/*! ./loader/types.js */ \"./node_modules/pixi.js/lib/assets/loader/types.js\");\nvar WorkerManager = __webpack_require__(/*! ./loader/workers/WorkerManager.js */ \"./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js\");\nvar resolveJsonUrl = __webpack_require__(/*! ./resolver/parsers/resolveJsonUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js\");\nvar resolveTextureUrl = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js\");\nvar Resolver = __webpack_require__(/*! ./resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\n__webpack_require__(/*! ./resolver/types.js */ \"./node_modules/pixi.js/lib/assets/resolver/types.js\");\n__webpack_require__(/*! ./types.js */ \"./node_modules/pixi.js/lib/assets/types.js\");\nvar checkDataUrl = __webpack_require__(/*! ./utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ./utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar convertToList = __webpack_require__(/*! ./utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\nvar copySearchParams = __webpack_require__(/*! ./utils/copySearchParams.js */ \"./node_modules/pixi.js/lib/assets/utils/copySearchParams.js\");\nvar createStringVariations = __webpack_require__(/*! ./utils/createStringVariations.js */ \"./node_modules/pixi.js/lib/assets/utils/createStringVariations.js\");\nvar isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ \"./node_modules/pixi.js/lib/assets/utils/isSingleItem.js\");\n\n\"use strict\";\n\nexports.Assets = Assets.Assets;\nexports.AssetsClass = Assets.AssetsClass;\nexports.BackgroundLoader = BackgroundLoader.BackgroundLoader;\nexports.Cache = Cache.Cache;\nexports.cacheTextureArray = cacheTextureArray.cacheTextureArray;\nexports.detectAvif = detectAvif.detectAvif;\nexports.detectDefaults = detectDefaults.detectDefaults;\nexports.detectMp4 = detectMp4.detectMp4;\nexports.detectOgv = detectOgv.detectOgv;\nexports.detectWebm = detectWebm.detectWebm;\nexports.detectWebp = detectWebp.detectWebp;\nexports.testImageFormat = testImageFormat.testImageFormat;\nexports.testVideoFormat = testVideoFormat.testVideoFormat;\nexports.Loader = Loader.Loader;\nexports.LoaderParserPriority = LoaderParser.LoaderParserPriority;\nexports.loadJson = loadJson.loadJson;\nexports.loadTxt = loadTxt.loadTxt;\nexports.getFontFamilyName = loadWebFont.getFontFamilyName;\nexports.loadWebFont = loadWebFont.loadWebFont;\nexports.loadSvg = loadSVG.loadSvg;\nexports.loadImageBitmap = loadTextures.loadImageBitmap;\nexports.loadTextures = loadTextures.loadTextures;\nexports.crossOrigin = loadVideoTextures.crossOrigin;\nexports.determineCrossOrigin = loadVideoTextures.determineCrossOrigin;\nexports.loadVideoTextures = loadVideoTextures.loadVideoTextures;\nexports.preloadVideo = loadVideoTextures.preloadVideo;\nexports.createTexture = createTexture.createTexture;\nexports.WorkerManager = WorkerManager.WorkerManager;\nexports.resolveJsonUrl = resolveJsonUrl.resolveJsonUrl;\nexports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;\nexports.Resolver = Resolver.Resolver;\nexports.getUrlExtension = Resolver.getUrlExtension;\nexports.checkDataUrl = checkDataUrl.checkDataUrl;\nexports.checkExtension = checkExtension.checkExtension;\nexports.convertToList = convertToList.convertToList;\nexports.copySearchParams = copySearchParams.copySearchParams;\nexports.createStringVariations = createStringVariations.createStringVariations;\nexports.isSingleItem = isSingleItem.isSingleItem;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/Loader.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/Loader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar path = __webpack_require__(/*! ../../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar convertToList = __webpack_require__(/*! ../utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\nvar isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ \"./node_modules/pixi.js/lib/assets/utils/isSingleItem.js\");\n\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn.warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem.isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList.convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item,\n      data: {}\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path.path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList.convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path.path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn.warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn.warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\nexports.Loader = Loader;\n//# sourceMappingURL=Loader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/Loader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexports.LoaderParserPriority = LoaderParserPriority;\n//# sourceMappingURL=LoaderParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\n\n\"use strict\";\nconst validJSONExtension = \".json\";\nconst validJSONMIME = \"application/json\";\nconst loadJson = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.Low\n  },\n  name: \"loadJson\",\n  test(url) {\n    return checkDataUrl.checkDataUrl(url, validJSONMIME) || checkExtension.checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await adapter.DOMAdapter.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\nexports.loadJson = loadJson;\n//# sourceMappingURL=loadJson.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\n\n\"use strict\";\nconst validTXTExtension = \".txt\";\nconst validTXTMIME = \"text/plain\";\nconst loadTxt = {\n  name: \"loadTxt\",\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.Low,\n    name: \"loadTxt\"\n  },\n  test(url) {\n    return checkDataUrl.checkDataUrl(url, validTXTMIME) || checkExtension.checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await adapter.DOMAdapter.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\nexports.loadTxt = loadTxt;\n//# sourceMappingURL=loadTxt.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar warn = __webpack_require__(/*! ../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar path = __webpack_require__(/*! ../../../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar Cache = __webpack_require__(/*! ../../cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\n\n\"use strict\";\nconst validWeights = [\n  \"normal\",\n  \"bold\",\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\"\n];\nconst validFontExtensions = [\".ttf\", \".otf\", \".woff\", \".woff2\"];\nconst validFontMIMEs = [\n  \"font/ttf\",\n  \"font/otf\",\n  \"font/woff\",\n  \"font/woff2\"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path.path.extname(url);\n  const name = path.path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n  const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(\" \");\n  if (!valid) {\n    fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.Low\n  },\n  name: \"loadWebFont\",\n  test(url) {\n    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = adapter.DOMAdapter.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? [\"normal\"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache.Cache.set(`${name}-and-url`, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    warn.warn(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache.Cache.remove(`${t.family}-and-url`);\n      adapter.DOMAdapter.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\nexports.getFontFamilyName = getFontFamilyName;\nexports.loadWebFont = loadWebFont;\n//# sourceMappingURL=loadWebFont.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar ImageSource = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar GraphicsContext = __webpack_require__(/*! ../../../../scene/graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar getResolutionOfUrl = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.js */ \"./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ./utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\n\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.Low,\n    name: \"loadSVG\"\n  },\n  name: \"loadSVG\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl.checkDataUrl(url, validSVGMIME) || checkExtension.checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await adapter.DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const resolution = asset.data?.resolution || getResolutionOfUrl.getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n  const base = new ImageSource.ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture.createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await adapter.DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext.GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\n\nexports.loadSvg = loadSvg;\n//# sourceMappingURL=loadSVG.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar ImageSource = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar getResolutionOfUrl = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.js */ \"./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar WorkerManager = __webpack_require__(/*! ../../workers/WorkerManager.js */ \"./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js\");\nvar LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ./utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\n\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/avif\"\n];\nasync function loadImageBitmap(url, asset) {\n  const response = await adapter.DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  return asset?.data?.alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.High,\n    name: \"loadTextures\"\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl.checkDataUrl(url, validImageMIMEs) || checkExtension.checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.WorkerManager.loadImageBitmap(url, asset);\n      } else {\n        src = await loadImageBitmap(url, asset);\n      }\n    } else {\n      src = await new Promise((resolve, reject) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n          src.onerror = reject;\n        }\n      });\n    }\n    const base = new ImageSource.ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl.getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture.createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexports.loadImageBitmap = loadImageBitmap;\nexports.loadTextures = loadTextures;\n//# sourceMappingURL=loadTextures.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar VideoSource = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/VideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js\");\nvar detectVideoAlphaMode = __webpack_require__(/*! ../../../../utils/browser/detectVideoAlphaMode.js */ \"./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js\");\nvar getResolutionOfUrl = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.js */ \"./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js\");\nvar checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar createTexture = __webpack_require__(/*! ./utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\n\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc || (loc = globalThis.location);\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    name: \"loadVideo\"\n  },\n  test(url) {\n    const isValidDataUrl = checkDataUrl.checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension.checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl.getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode.detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource.VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture.createTexture(base, loader, url));\n      };\n      if (options.preload && !options.autoPlay) {\n        videoElement.load();\n      }\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexports.crossOrigin = crossOrigin;\nexports.determineCrossOrigin = determineCrossOrigin;\nexports.loadVideoTextures = loadVideoTextures;\nexports.preloadVideo = preloadVideo;\n//# sourceMappingURL=loadVideoTextures.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Texture = __webpack_require__(/*! ../../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar warn = __webpack_require__(/*! ../../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar Cache = __webpack_require__(/*! ../../../../cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\n\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture.Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.Cache.has(url)) {\n      Cache.Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn.warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn.warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\n\nexports.createTexture = createTexture;\n//# sourceMappingURL=createTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/types.js ***!
  \*********************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar checkImageBitmap_worker = __webpack_require__(/*! ../../../_virtual/checkImageBitmap.worker.js */ \"./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.js\");\nvar loadImageBitmap_worker = __webpack_require__(/*! ../../../_virtual/loadImageBitmap.worker.js */ \"./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.js\");\n\n\"use strict\";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new checkImageBitmap_worker.default();\n      worker.addEventListener(\"message\", (event) => {\n        worker.terminate();\n        checkImageBitmap_worker.default.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src, asset) {\n    return this._run(\"loadImageBitmap\", [src, asset?.data?.alphaMode]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new loadImageBitmap_worker.default().worker;\n      worker.addEventListener(\"message\", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\nexports.WorkerManager = WorkerManager;\n//# sourceMappingURL=WorkerManager.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/Resolver.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/Resolver.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar path = __webpack_require__(/*! ../../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar convertToList = __webpack_require__(/*! ../utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\nvar createStringVariations = __webpack_require__(/*! ../utils/createStringVariations.js */ \"./node_modules/pixi.js/lib/assets/utils/createStringVariations.js\");\nvar isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ \"./node_modules/pixi.js/lib/assets/utils/isSingleItem.js\");\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList.convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn.warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn.warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList.convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList.convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations.createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem.isSingleItem(bundleIds);\n    bundleIds = convertToList.convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem.isSingleItem(keys);\n    keys = convertToList.convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[i];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexports.Resolver = Resolver;\nexports.getUrlExtension = getUrlExtension;\n//# sourceMappingURL=Resolver.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/resolver/Resolver.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Resolver = __webpack_require__(/*! ../Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\nvar resolveTextureUrl = __webpack_require__(/*! ./resolveTextureUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js\");\n\n\"use strict\";\nconst resolveJsonUrl = {\n  extension: {\n    type: Extensions.ExtensionType.ResolveParser,\n    priority: -2,\n    name: \"resolveJson\"\n  },\n  test: (value) => Resolver.Resolver.RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n  parse: resolveTextureUrl.resolveTextureUrl.parse\n};\n\nexports.resolveJsonUrl = resolveJsonUrl;\n//# sourceMappingURL=resolveJsonUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar loadTextures = __webpack_require__(/*! ../../loader/parsers/textures/loadTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js\");\nvar Resolver = __webpack_require__(/*! ../Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\n\n\"use strict\";\nconst resolveTextureUrl = {\n  extension: {\n    type: Extensions.ExtensionType.ResolveParser,\n    name: \"resolveTexture\"\n  },\n  test: loadTextures.loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n    format: value.split(\".\").pop(),\n    src: value\n  })\n};\n\nexports.resolveTextureUrl = resolveTextureUrl;\n//# sourceMappingURL=resolveTextureUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/types.js ***!
  \***********************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/resolver/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/types.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/types.js ***!
  \**************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\nexports.checkDataUrl = checkDataUrl;\n//# sourceMappingURL=checkDataUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/checkExtension.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/checkExtension.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar path = __webpack_require__(/*! ../../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\n\n\"use strict\";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split(\"?\")[0];\n  const ext = path.path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\nexports.checkExtension = checkExtension;\n//# sourceMappingURL=checkExtension.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/checkExtension.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/convertToList.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/convertToList.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexports.convertToList = convertToList;\n//# sourceMappingURL=convertToList.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/convertToList.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/copySearchParams.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/copySearchParams.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexports.copySearchParams = copySearchParams;\n//# sourceMappingURL=copySearchParams.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/copySearchParams.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/createStringVariations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/createStringVariations.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexports.createStringVariations = createStringVariations;\n//# sourceMappingURL=createStringVariations.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/createStringVariations.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/isSingleItem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexports.isSingleItem = isSingleItem;\n//# sourceMappingURL=isSingleItem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/assets/utils/isSingleItem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/color/Color.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/color/Color.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar colord = __webpack_require__(/*! @pixi/colord */ \"./node_modules/@pixi/colord/index.js\");\nvar namesPlugin = __webpack_require__(/*! @pixi/colord/plugins/names */ \"./node_modules/@pixi/colord/plugins/names.js\");\n\n\"use strict\";\ncolord.extend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /**\n   * Get the red component of the color, normalized between 0 and 1.\n   * @example\n   * ```ts\n   * const color = new Color('red');\n   * console.log(color.red); // 1\n   *\n   * const green = new Color('#00ff00');\n   * console.log(green.red); // 0\n   * ```\n   */\n  get red() {\n    return this._components[0];\n  }\n  /**\n   * Get the green component of the color, normalized between 0 and 1.\n   * @example\n   * ```ts\n   * const color = new Color('lime');\n   * console.log(color.green); // 1\n   *\n   * const red = new Color('#ff0000');\n   * console.log(red.green); // 0\n   * ```\n   */\n  get green() {\n    return this._components[1];\n  }\n  /**\n   * Get the blue component of the color, normalized between 0 and 1.\n   * @example\n   * ```ts\n   * const color = new Color('blue');\n   * console.log(color.blue); // 1\n   *\n   * const yellow = new Color('#ffff00');\n   * console.log(yellow.blue); // 0\n   * ```\n   */\n  get blue() {\n    return this._components[2];\n  }\n  /**\n   * Get the alpha component of the color, normalized between 0 and 1.\n   * @example\n   * ```ts\n   * const color = new Color('red');\n   * console.log(color.alpha); // 1 (fully opaque)\n   *\n   * const transparent = new Color('rgba(255, 0, 0, 0.5)');\n   * console.log(transparent.alpha); // 0.5 (semi-transparent)\n   * ```\n   */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Sets the color value and returns the instance for chaining.\n   *\n   * This is a chainable version of setting the `value` property.\n   * @param value - The color to set. Accepts various formats:\n   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n   * - RGB/RGBA values (arrays, objects)\n   * - CSS color names\n   * - HSL/HSLA values\n   * - HSV/HSVA values\n   * @returns The Color instance for chaining\n   * @example\n   * ```ts\n   * // Basic usage\n   * const color = new Color();\n   * color.setValue('#ff0000')\n   *     .setAlpha(0.5)\n   *     .premultiply(0.8);\n   *\n   * // Different formats\n   * color.setValue(0xff0000);          // Hex number\n   * color.setValue('#ff0000');         // Hex string\n   * color.setValue([1, 0, 0]);         // RGB array\n   * color.setValue([1, 0, 0, 0.5]);    // RGBA array\n   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object\n   *\n   * // Copy from another color\n   * const red = new Color('red');\n   * color.setValue(red);\n   * ```\n   * @throws {Error} If the color value is invalid or null\n   * @see {@link Color.value} For the underlying value property\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source. This property allows getting and setting the color value\n   * while preserving the original format where possible.\n   * @remarks\n   * When setting:\n   * - Setting to a `Color` instance copies its source and components\n   * - Setting to other valid sources normalizes and stores the value\n   * - Setting to `null` throws an Error\n   * - The color remains unchanged if normalization fails\n   *\n   * When getting:\n   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}\n   * - Otherwise returns the original color source\n   * @example\n   * ```ts\n   * // Setting different color formats\n   * const color = new Color();\n   *\n   * color.value = 0xff0000;         // Hex number\n   * color.value = '#ff0000';        // Hex string\n   * color.value = [1, 0, 0];        // RGB array\n   * color.value = [1, 0, 0, 0.5];   // RGBA array\n   * color.value = { r: 1, g: 0, b: 0 }; // RGB object\n   *\n   * // Copying from another color\n   * const red = new Color('red');\n   * color.value = red;  // Copies red's components\n   *\n   * // Getting the value\n   * console.log(color.value);  // Returns original format\n   *\n   * // After modifications\n   * color.multiply([0.5, 0.5, 0.5]);\n   * console.log(color.value);  // Returns null\n   * ```\n   * @throws {Error} When attempting to set `null`\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._value = this._cloneSource(value);\n      this._normalize(this._value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object with normalized components (0-1).\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Convert colors to RGBA objects\n   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }\n   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }\n   *\n   * // With transparency\n   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }\n   * ```\n   * @returns An RGBA object with normalized components\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object with normalized components (0-1).\n   *\n   * Alpha component is omitted in the output.\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Convert colors to RGB objects\n   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }\n   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }\n   *\n   * // Alpha is ignored\n   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }\n   * ```\n   * @returns An RGB object with normalized components\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /**\n   * Convert to a CSS-style rgba string representation.\n   *\n   * RGB components are scaled to 0-255 range, alpha remains 0-1.\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Convert colors to RGBA strings\n   * new Color('white').toRgbaString();     // returns \"rgba(255,255,255,1)\"\n   * new Color('#ff0000').toRgbaString();   // returns \"rgba(255,0,0,1)\"\n   *\n   * // With transparency\n   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns \"rgba(255,0,0,0.5)\"\n   * ```\n   * @returns A CSS-compatible rgba string\n   */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  /**\n   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,\n   * a cached array will be used and returned.\n   * @returns Array containing RGB components as integers between 0-255\n   * @example\n   * ```ts\n   * // Basic usage\n   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]\n   *\n   * // Using custom output array\n   * const rgb = new Uint8Array(3);\n   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]\n   *\n   * // Using different array types\n   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]\n   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]\n   * ```\n   * @remarks\n   * - Output values are always clamped between 0-255\n   * - Alpha component is not included in output\n   * - Reuses internal cache array if no output array provided\n   */\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  /**\n   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n   * a cached array will be used and returned.\n   * @returns Array containing RGBA components as floats between 0-1\n   * @example\n   * ```ts\n   * // Basic usage\n   * new Color('white').toArray();  // returns [1, 1, 1, 1]\n   * new Color('red').toArray();    // returns [1, 0, 0, 1]\n   *\n   * // With alpha\n   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]\n   *\n   * // Using custom output array\n   * const rgba = new Float32Array(4);\n   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]\n   * ```\n   * @remarks\n   * - Output values are normalized between 0-1\n   * - Includes alpha component as the fourth value\n   * - Reuses internal cache array if no output array provided\n   */\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out || (out = this._arrayRgba);\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  /**\n   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n   * a cached array will be used and returned.\n   * @returns Array containing RGB components as floats between 0-1\n   * @example\n   * ```ts\n   * // Basic usage\n   * new Color('white').toRgbArray(); // returns [1, 1, 1]\n   * new Color('red').toRgbArray();   // returns [1, 0, 0]\n   *\n   * // Using custom output array\n   * const rgb = new Float32Array(3);\n   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]\n   * ```\n   * @remarks\n   * - Output values are normalized between 0-1\n   * - Alpha component is omitted from output\n   * - Reuses internal cache array if no output array provided\n   */\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @returns The color as a 24-bit RGB integer\n   * @example\n   * ```ts\n   * // Basic usage\n   * new Color('white').toNumber(); // returns 0xffffff\n   * new Color('red').toNumber();   // returns 0xff0000\n   *\n   * // Store as hex\n   * const color = new Color('blue');\n   * const hex = color.toNumber(); // 0x0000ff\n   * ```\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number.\n   *\n   * Useful for platforms that expect colors in BGR format.\n   * @returns The color as a 24-bit BGR integer\n   * @example\n   * ```ts\n   * // Convert RGB to BGR\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   *\n   * // Common use case: platform-specific color format\n   * const color = new Color('orange');\n   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels\n   * ```\n   * @remarks\n   * This swaps the red and blue channels compared to the normal RGB format:\n   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   *\n   * Useful for platforms that expect colors in little endian byte order.\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Convert RGB color to little endian format\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   *\n   * // Common use cases:\n   * const color = new Color('orange');\n   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems\n   *\n   * // Multiple conversions\n   * const colors = {\n   *     normal: 0xffcc99,\n   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff\n   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99\n   * };\n   * ```\n   * @remarks\n   * - Swaps R and B channels in the color value\n   * - RGB 0xRRGGBB becomes 0xBBGGRR\n   * - Useful for systems that use little endian byte order\n   * - Can be used to convert back and forth between formats\n   * @returns The color as a number in little endian format (BBGGRR)\n   * @see {@link Color.toBgrNumber} For BGR format without byte swapping\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color.\n   *\n   * This action is destructive and modifies the original color.\n   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:\n   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])\n   * - Color objects ({ r: 1, g: 0, b: 0 })\n   * - CSS color names ('red', 'blue')\n   * @returns this - The Color instance for chaining\n   * @example\n   * ```ts\n   * // Basic multiplication\n   * const color = new Color('#ff0000');\n   * color.multiply(0x808080); // 50% darker red\n   *\n   * // With transparency\n   * color.multiply([1, 1, 1, 0.5]); // 50% transparent\n   *\n   * // Chain operations\n   * color\n   *     .multiply('#808080')\n   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });\n   * ```\n   * @remarks\n   * - Multiplies each RGB component and alpha separately\n   * - Values are clamped between 0-1\n   * - Original color format is lost (value becomes null)\n   * - Operation cannot be undone\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format.\n   *\n   * This action is destructive and modifies the original color.\n   * @param alpha - The alpha value to multiply by (0-1)\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n   * @returns {Color} The Color instance for chaining\n   * @example\n   * ```ts\n   * // Basic premultiplication\n   * const color = new Color('red');\n   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB\n   *\n   * // Alpha only (RGB unchanged)\n   * color.premultiply(0.5, false); // 50% transparent, original RGB\n   *\n   * // Chain with other operations\n   * color\n   *     .multiply(0x808080)\n   *     .premultiply(0.5)\n   *     .toNumber();\n   * ```\n   * @remarks\n   * - RGB channels are multiplied by alpha when applyToRGB is true\n   * - Alpha is always set to the provided value\n   * - Values are clamped between 0-1\n   * - Original color format is lost (value becomes null)\n   * - Operation cannot be undone\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Returns the color as a 32-bit premultiplied alpha integer.\n   *\n   * Format: 0xAARRGGBB\n   * @param {number} alpha - The alpha value to multiply by (0-1)\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n   * @returns {number} The premultiplied color as a 32-bit integer\n   * @example\n   * ```ts\n   * // Convert to premultiplied format\n   * const color = new Color('red');\n   *\n   * // Full opacity (0xFFRRGGBB)\n   * color.toPremultiplied(1.0); // 0xFFFF0000\n   *\n   * // 50% transparency with premultiplied RGB\n   * color.toPremultiplied(0.5); // 0x7F7F0000\n   *\n   * // 50% transparency without RGB premultiplication\n   * color.toPremultiplied(0.5, false); // 0x7FFF0000\n   * ```\n   * @remarks\n   * - Returns full opacity (0xFF000000) when alpha is 1.0\n   * - Returns 0 when alpha is 0.0 and applyToRGB is true\n   * - RGB values are rounded during premultiplication\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string (6 characters).\n   * @returns A CSS-compatible hex color string (e.g., \"#ff0000\")\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Basic colors\n   * new Color('red').toHex();    // returns \"#ff0000\"\n   * new Color('white').toHex();  // returns \"#ffffff\"\n   * new Color('black').toHex();  // returns \"#000000\"\n   *\n   * // From different formats\n   * new Color(0xff0000).toHex(); // returns \"#ff0000\"\n   * new Color([1, 0, 0]).toHex(); // returns \"#ff0000\"\n   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns \"#ff0000\"\n   * ```\n   * @remarks\n   * - Always returns a 6-character hex string\n   * - Includes leading \"#\" character\n   * - Alpha channel is ignored\n   * - Values are rounded to nearest hex value\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha (8 characters).\n   * @returns A CSS-compatible hex color string with alpha (e.g., \"#ff0000ff\")\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // Fully opaque colors\n   * new Color('red').toHexa();   // returns \"#ff0000ff\"\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   *\n   * // With transparency\n   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns \"#ff00007f\"\n   * new Color([1, 0, 0, 0]).toHexa(); // returns \"#ff000000\"\n   * ```\n   * @remarks\n   * - Returns an 8-character hex string\n   * - Includes leading \"#\" character\n   * - Alpha is encoded in last two characters\n   * - Values are rounded to nearest hex value\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha (transparency) value while preserving color components.\n   *\n   * Provides a chainable interface for setting alpha.\n   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)\n   * @returns The Color instance for chaining\n   * @example\n   * ```ts\n   * // Basic alpha setting\n   * const color = new Color('red');\n   * color.setAlpha(0.5);  // 50% transparent red\n   *\n   * // Chain with other operations\n   * color\n   *     .setValue('#ff0000')\n   *     .setAlpha(0.8)    // 80% opaque\n   *     .premultiply(0.5); // Further modify alpha\n   *\n   * // Reset to fully opaque\n   * color.setAlpha(1);\n   * ```\n   * @remarks\n   * - Alpha value is clamped between 0-1\n   * - Can be chained with other color operations\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord.colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if a value can be interpreted as a valid color format.\n   * Supports all color formats that can be used with the Color class.\n   * @param value - Value to check\n   * @returns True if the value can be used as a color\n   * @example\n   * ```ts\n   * import { Color } from 'pixi.js';\n   *\n   * // CSS colors and hex values\n   * Color.isColorLike('red');          // true\n   * Color.isColorLike('#ff0000');      // true\n   * Color.isColorLike(0xff0000);       // true\n   *\n   * // Arrays (RGB/RGBA)\n   * Color.isColorLike([1, 0, 0]);      // true\n   * Color.isColorLike([1, 0, 0, 0.5]); // true\n   *\n   * // TypedArrays\n   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true\n   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true\n   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true\n   *\n   * // Object formats\n   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)\n   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)\n   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)\n   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)\n   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)\n   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)\n   *\n   * // Color instances\n   * Color.isColorLike(new Color('red')); // true\n   *\n   * // Invalid values\n   * Color.isColorLike(null);           // false\n   * Color.isColorLike(undefined);      // false\n   * Color.isColorLike({});             // false\n   * Color.isColorLike([]);             // false\n   * Color.isColorLike('not-a-color');  // false\n   * ```\n   * @remarks\n   * Checks for the following formats:\n   * - Numbers (0x000000 to 0xffffff)\n   * - CSS color strings\n   * - RGB/RGBA arrays and objects\n   * - HSL/HSLA objects\n   * - HSV/HSVA objects\n   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)\n   * - Color instances\n   * @see {@link ColorSource} For supported color format types\n   * @see {@link Color.setValue} For setting color values\n   * @category utility\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Static shared Color instance used for utility operations. This is a singleton color object\n * that can be reused to avoid creating unnecessary Color instances.\n * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be\n * > changed by any code that uses it.\n * >\n * > It is best used for one-off color operations or temporary transformations.\n * > For persistent colors, create your own Color instance instead.\n * @example\n * ```ts\n * import { Color } from 'pixi.js';\n *\n * // Use shared instance for one-off color operations\n * Color.shared.setValue(0xff0000);\n * const redHex = Color.shared.toHex();     // \"#ff0000\"\n * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]\n *\n * // Temporary color transformations\n * const colorNumber = Color.shared\n *     .setValue('#ff0000')     // Set to red\n *     .setAlpha(0.5)          // Make semi-transparent\n *     .premultiply(0.8)       // Apply premultiplication\n *     .toNumber();            // Convert to number\n *\n * // Chain multiple operations\n * const result = Color.shared\n *     .setValue(someColor)\n *     .multiply(tintColor)\n *     .toPremultiplied(alpha);\n * ```\n * @remarks\n * - This is a shared instance - be careful about multiple code paths using it simultaneously\n * - Use for temporary color operations to avoid allocating new Color instances\n * - The value is preserved between operations, so reset if needed\n * - For persistent colors, create your own Color instance instead\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexports.Color = Color;\n//# sourceMappingURL=Color.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/color/Color.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/color/index.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/color/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ./Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\n\n\"use strict\";\n\nexports.Color = Color.Color;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/color/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar isWebGLSupported = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\n\n\"use strict\";\nconst detectBasis = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 3\n  },\n  test: async () => {\n    if (await isWebGPUSupported.isWebGPUSupported())\n      return true;\n    if (isWebGLSupported.isWebGLSupported())\n      return true;\n    return false;\n  },\n  add: async (formats) => [...formats, \"basis\"],\n  remove: async (formats) => formats.filter((f) => f !== \"basis\")\n};\n\nexports.detectBasis = detectBasis;\n//# sourceMappingURL=detectBasis.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\nvar checkExtension = __webpack_require__(/*! ../../assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CompressedSource = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar loadBasisOnWorker = __webpack_require__(/*! ./worker/loadBasisOnWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js\");\n\n\"use strict\";\nconst loadBasis = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.High,\n    name: \"loadBasis\"\n  },\n  name: \"loadBasis\",\n  test(url) {\n    return checkExtension.checkExtension(url, [\".basis\"]);\n  },\n  async load(url, _asset, loader) {\n    const supportedTextures = await getSupportedTextureFormats.getSupportedTextureFormats();\n    const textureOptions = await loadBasisOnWorker.loadBasisOnWorker(url, supportedTextures);\n    const compressedTextureSource = new CompressedSource.CompressedSource(textureOptions);\n    return createTexture.createTexture(compressedTextureSource, loader, url);\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\n\nexports.loadBasis = loadBasis;\n//# sourceMappingURL=loadBasis.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/types.js ***!
  \*********************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction createLevelBuffers(basisTexture, basisTranscoderFormat) {\n  const images = basisTexture.getNumImages();\n  const levels = basisTexture.getNumLevels(0);\n  const success = basisTexture.startTranscoding();\n  if (!success) {\n    throw new Error(\"startTranscoding failed\");\n  }\n  const levelBuffers = [];\n  for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n    for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n      const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n      const levelBuffer = new Uint8Array(transcodeSize);\n      const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n      if (!success2) {\n        throw new Error(\"transcodeImage failed\");\n      }\n      levelBuffers.push(levelBuffer);\n    }\n  }\n  return levelBuffers;\n}\n\nexports.createLevelBuffers = createLevelBuffers;\n//# sourceMappingURL=createLevelBuffers.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst gpuFormatToBasisTranscoderFormatMap = {\n  \"bc3-rgba-unorm\": 3,\n  // cTFBC3_RGBA\n  \"bc7-rgba-unorm\": 6,\n  // cTFBC7_RGBA,\n  \"etc2-rgba8unorm\": 1,\n  // cTFETC2_RGBA,\n  \"astc-4x4-unorm\": 10,\n  // cTFASTC_4x4_RGBA,\n  // Uncompressed\n  rgba8unorm: 13,\n  // cTFRGBA32,\n  rgba4unorm: 16\n  // cTFRGBA4444,\n};\nfunction gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n  const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n  if (format) {\n    return format;\n  }\n  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n}\n\nexports.gpuFormatToBasisTranscoderFormat = gpuFormatToBasisTranscoderFormat;\n//# sourceMappingURL=gpuFormatToBasisTranscoderFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst basisTranscoderUrls = {\n  jsUrl: \"https://files.pixijs.download/transcoders/basis/basis_transcoder.js\",\n  wasmUrl: \"https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm\"\n};\nfunction setBasisTranscoderPath(config) {\n  Object.assign(basisTranscoderUrls, config);\n}\n\nexports.basisTranscoderUrls = basisTranscoderUrls;\nexports.setBasisTranscoderPath = setBasisTranscoderPath;\n//# sourceMappingURL=setBasisTranscoderPath.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar basis_worker = __webpack_require__(/*! ../../../_virtual/basis.worker.js */ \"./node_modules/pixi.js/lib/_virtual/basis.worker.js\");\nvar setBasisTranscoderPath = __webpack_require__(/*! ../utils/setBasisTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js\");\n\n\"use strict\";\nlet basisWorker;\nconst urlHash = {};\nfunction getBasisWorker(supportedTextures) {\n  if (!basisWorker) {\n    basisWorker = new basis_worker.default().worker;\n    basisWorker.onmessage = (messageEvent) => {\n      const { success, url, textureOptions } = messageEvent.data;\n      if (!success) {\n        console.warn(\"Failed to load Basis texture\", url);\n      }\n      urlHash[url](textureOptions);\n    };\n    basisWorker.postMessage({\n      type: \"init\",\n      jsUrl: setBasisTranscoderPath.basisTranscoderUrls.jsUrl,\n      wasmUrl: setBasisTranscoderPath.basisTranscoderUrls.wasmUrl,\n      supportedTextures\n    });\n  }\n  return basisWorker;\n}\nfunction loadBasisOnWorker(url, supportedTextures) {\n  const ktxWorker = getBasisWorker(supportedTextures);\n  return new Promise((resolve) => {\n    urlHash[url] = resolve;\n    ktxWorker.postMessage({ type: \"load\", url });\n  });\n}\n\nexports.loadBasisOnWorker = loadBasisOnWorker;\n//# sourceMappingURL=loadBasisOnWorker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/const.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/const.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst DDS_HEADER_FIELDS = {\n  MAGIC: 0,\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19,\n  PF_FLAGS: 20,\n  FOURCC: 21,\n  RGB_BITCOUNT: 22,\n  R_BIT_MASK: 23,\n  G_BIT_MASK: 24,\n  B_BIT_MASK: 25,\n  A_BIT_MASK: 26\n};\nconst DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n};\nvar DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_UNKNOWN\"] = 0] = \"DXGI_FORMAT_UNKNOWN\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_TYPELESS\"] = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_FLOAT\"] = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_UINT\"] = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_SINT\"] = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_TYPELESS\"] = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_FLOAT\"] = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_UINT\"] = 7] = \"DXGI_FORMAT_R32G32B32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_SINT\"] = 8] = \"DXGI_FORMAT_R32G32B32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_TYPELESS\"] = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_FLOAT\"] = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_UNORM\"] = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_UINT\"] = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_SNORM\"] = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_SINT\"] = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_TYPELESS\"] = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_FLOAT\"] = 16] = \"DXGI_FORMAT_R32G32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_UINT\"] = 17] = \"DXGI_FORMAT_R32G32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_SINT\"] = 18] = \"DXGI_FORMAT_R32G32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G8X24_TYPELESS\"] = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\"] = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\"] = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\"] = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_TYPELESS\"] = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_UNORM\"] = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_UINT\"] = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R11G11B10_FLOAT\"] = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_TYPELESS\"] = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UNORM\"] = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\"] = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UINT\"] = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_SNORM\"] = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_SINT\"] = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_TYPELESS\"] = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_FLOAT\"] = 34] = \"DXGI_FORMAT_R16G16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_UNORM\"] = 35] = \"DXGI_FORMAT_R16G16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_UINT\"] = 36] = \"DXGI_FORMAT_R16G16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_SNORM\"] = 37] = \"DXGI_FORMAT_R16G16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_SINT\"] = 38] = \"DXGI_FORMAT_R16G16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_TYPELESS\"] = 39] = \"DXGI_FORMAT_R32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D32_FLOAT\"] = 40] = \"DXGI_FORMAT_D32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_FLOAT\"] = 41] = \"DXGI_FORMAT_R32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_UINT\"] = 42] = \"DXGI_FORMAT_R32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_SINT\"] = 43] = \"DXGI_FORMAT_R32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R24G8_TYPELESS\"] = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D24_UNORM_S8_UINT\"] = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\"] = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_X24_TYPELESS_G8_UINT\"] = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_TYPELESS\"] = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_UNORM\"] = 49] = \"DXGI_FORMAT_R8G8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_UINT\"] = 50] = \"DXGI_FORMAT_R8G8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_SNORM\"] = 51] = \"DXGI_FORMAT_R8G8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_SINT\"] = 52] = \"DXGI_FORMAT_R8G8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_TYPELESS\"] = 53] = \"DXGI_FORMAT_R16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_FLOAT\"] = 54] = \"DXGI_FORMAT_R16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D16_UNORM\"] = 55] = \"DXGI_FORMAT_D16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_UNORM\"] = 56] = \"DXGI_FORMAT_R16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_UINT\"] = 57] = \"DXGI_FORMAT_R16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_SNORM\"] = 58] = \"DXGI_FORMAT_R16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_SINT\"] = 59] = \"DXGI_FORMAT_R16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_TYPELESS\"] = 60] = \"DXGI_FORMAT_R8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_UNORM\"] = 61] = \"DXGI_FORMAT_R8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_UINT\"] = 62] = \"DXGI_FORMAT_R8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_SNORM\"] = 63] = \"DXGI_FORMAT_R8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_SINT\"] = 64] = \"DXGI_FORMAT_R8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_A8_UNORM\"] = 65] = \"DXGI_FORMAT_A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R1_UNORM\"] = 66] = \"DXGI_FORMAT_R1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\"] = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_B8G8_UNORM\"] = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_G8R8_G8B8_UNORM\"] = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_TYPELESS\"] = 70] = \"DXGI_FORMAT_BC1_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_UNORM\"] = 71] = \"DXGI_FORMAT_BC1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_UNORM_SRGB\"] = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_TYPELESS\"] = 73] = \"DXGI_FORMAT_BC2_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_UNORM\"] = 74] = \"DXGI_FORMAT_BC2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_UNORM_SRGB\"] = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_TYPELESS\"] = 76] = \"DXGI_FORMAT_BC3_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_UNORM\"] = 77] = \"DXGI_FORMAT_BC3_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_UNORM_SRGB\"] = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_TYPELESS\"] = 79] = \"DXGI_FORMAT_BC4_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_UNORM\"] = 80] = \"DXGI_FORMAT_BC4_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_SNORM\"] = 81] = \"DXGI_FORMAT_BC4_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_TYPELESS\"] = 82] = \"DXGI_FORMAT_BC5_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_UNORM\"] = 83] = \"DXGI_FORMAT_BC5_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_SNORM\"] = 84] = \"DXGI_FORMAT_BC5_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B5G6R5_UNORM\"] = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B5G5R5A1_UNORM\"] = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_UNORM\"] = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_UNORM\"] = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\"] = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_TYPELESS\"] = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\"] = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_TYPELESS\"] = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\"] = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_TYPELESS\"] = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_UF16\"] = 95] = \"DXGI_FORMAT_BC6H_UF16\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_SF16\"] = 96] = \"DXGI_FORMAT_BC6H_SF16\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_TYPELESS\"] = 97] = \"DXGI_FORMAT_BC7_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_UNORM\"] = 98] = \"DXGI_FORMAT_BC7_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_UNORM_SRGB\"] = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_AYUV\"] = 100] = \"DXGI_FORMAT_AYUV\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y410\"] = 101] = \"DXGI_FORMAT_Y410\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y416\"] = 102] = \"DXGI_FORMAT_Y416\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_NV12\"] = 103] = \"DXGI_FORMAT_NV12\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P010\"] = 104] = \"DXGI_FORMAT_P010\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P016\"] = 105] = \"DXGI_FORMAT_P016\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_420_OPAQUE\"] = 106] = \"DXGI_FORMAT_420_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_YUY2\"] = 107] = \"DXGI_FORMAT_YUY2\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y210\"] = 108] = \"DXGI_FORMAT_Y210\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y216\"] = 109] = \"DXGI_FORMAT_Y216\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_NV11\"] = 110] = \"DXGI_FORMAT_NV11\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_AI44\"] = 111] = \"DXGI_FORMAT_AI44\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_IA44\"] = 112] = \"DXGI_FORMAT_IA44\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P8\"] = 113] = \"DXGI_FORMAT_P8\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_A8P8\"] = 114] = \"DXGI_FORMAT_A8P8\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B4G4R4A4_UNORM\"] = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P208\"] = 116] = \"DXGI_FORMAT_P208\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_V208\"] = 117] = \"DXGI_FORMAT_V208\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_V408\"] = 118] = \"DXGI_FORMAT_V408\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\"] = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\"] = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_FORCE_UINT\"] = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n  return DXGI_FORMAT2;\n})(DXGI_FORMAT || {});\nvar D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE1D\"] = 2] = \"DDS_DIMENSION_TEXTURE1D\";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE2D\"] = 3] = \"DDS_DIMENSION_TEXTURE2D\";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE3D\"] = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n  return D3D10_RESOURCE_DIMENSION2;\n})(D3D10_RESOURCE_DIMENSION || {});\nfunction fourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nvar D3DFMT = ((D3DFMT2) => {\n  D3DFMT2[D3DFMT2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  D3DFMT2[D3DFMT2[\"R8G8B8\"] = 20] = \"R8G8B8\";\n  D3DFMT2[D3DFMT2[\"A8R8G8B8\"] = 21] = \"A8R8G8B8\";\n  D3DFMT2[D3DFMT2[\"X8R8G8B8\"] = 22] = \"X8R8G8B8\";\n  D3DFMT2[D3DFMT2[\"R5G6B5\"] = 23] = \"R5G6B5\";\n  D3DFMT2[D3DFMT2[\"X1R5G5B5\"] = 24] = \"X1R5G5B5\";\n  D3DFMT2[D3DFMT2[\"A1R5G5B5\"] = 25] = \"A1R5G5B5\";\n  D3DFMT2[D3DFMT2[\"A4R4G4B4\"] = 26] = \"A4R4G4B4\";\n  D3DFMT2[D3DFMT2[\"R3G3B2\"] = 27] = \"R3G3B2\";\n  D3DFMT2[D3DFMT2[\"A8\"] = 28] = \"A8\";\n  D3DFMT2[D3DFMT2[\"A8R3G3B2\"] = 29] = \"A8R3G3B2\";\n  D3DFMT2[D3DFMT2[\"X4R4G4B4\"] = 30] = \"X4R4G4B4\";\n  D3DFMT2[D3DFMT2[\"A2B10G10R10\"] = 31] = \"A2B10G10R10\";\n  D3DFMT2[D3DFMT2[\"A8B8G8R8\"] = 32] = \"A8B8G8R8\";\n  D3DFMT2[D3DFMT2[\"X8B8G8R8\"] = 33] = \"X8B8G8R8\";\n  D3DFMT2[D3DFMT2[\"G16R16\"] = 34] = \"G16R16\";\n  D3DFMT2[D3DFMT2[\"A2R10G10B10\"] = 35] = \"A2R10G10B10\";\n  D3DFMT2[D3DFMT2[\"A16B16G16R16\"] = 36] = \"A16B16G16R16\";\n  D3DFMT2[D3DFMT2[\"A8P8\"] = 40] = \"A8P8\";\n  D3DFMT2[D3DFMT2[\"P8\"] = 41] = \"P8\";\n  D3DFMT2[D3DFMT2[\"L8\"] = 50] = \"L8\";\n  D3DFMT2[D3DFMT2[\"A8L8\"] = 51] = \"A8L8\";\n  D3DFMT2[D3DFMT2[\"A4L4\"] = 52] = \"A4L4\";\n  D3DFMT2[D3DFMT2[\"V8U8\"] = 60] = \"V8U8\";\n  D3DFMT2[D3DFMT2[\"L6V5U5\"] = 61] = \"L6V5U5\";\n  D3DFMT2[D3DFMT2[\"X8L8V8U8\"] = 62] = \"X8L8V8U8\";\n  D3DFMT2[D3DFMT2[\"Q8W8V8U8\"] = 63] = \"Q8W8V8U8\";\n  D3DFMT2[D3DFMT2[\"V16U16\"] = 64] = \"V16U16\";\n  D3DFMT2[D3DFMT2[\"A2W10V10U10\"] = 67] = \"A2W10V10U10\";\n  D3DFMT2[D3DFMT2[\"Q16W16V16U16\"] = 110] = \"Q16W16V16U16\";\n  D3DFMT2[D3DFMT2[\"R16F\"] = 111] = \"R16F\";\n  D3DFMT2[D3DFMT2[\"G16R16F\"] = 112] = \"G16R16F\";\n  D3DFMT2[D3DFMT2[\"A16B16G16R16F\"] = 113] = \"A16B16G16R16F\";\n  D3DFMT2[D3DFMT2[\"R32F\"] = 114] = \"R32F\";\n  D3DFMT2[D3DFMT2[\"G32R32F\"] = 115] = \"G32R32F\";\n  D3DFMT2[D3DFMT2[\"A32B32G32R32F\"] = 116] = \"A32B32G32R32F\";\n  D3DFMT2[D3DFMT2[\"UYVY\"] = fourCCToInt32(\"UYVY\")] = \"UYVY\";\n  D3DFMT2[D3DFMT2[\"R8G8_B8G8\"] = fourCCToInt32(\"RGBG\")] = \"R8G8_B8G8\";\n  D3DFMT2[D3DFMT2[\"YUY2\"] = fourCCToInt32(\"YUY2\")] = \"YUY2\";\n  D3DFMT2[D3DFMT2[\"D3DFMT_G8R8_G8B8\"] = fourCCToInt32(\"GRGB\")] = \"D3DFMT_G8R8_G8B8\";\n  D3DFMT2[D3DFMT2[\"DXT1\"] = fourCCToInt32(\"DXT1\")] = \"DXT1\";\n  D3DFMT2[D3DFMT2[\"DXT2\"] = fourCCToInt32(\"DXT2\")] = \"DXT2\";\n  D3DFMT2[D3DFMT2[\"DXT3\"] = fourCCToInt32(\"DXT3\")] = \"DXT3\";\n  D3DFMT2[D3DFMT2[\"DXT4\"] = fourCCToInt32(\"DXT4\")] = \"DXT4\";\n  D3DFMT2[D3DFMT2[\"DXT5\"] = fourCCToInt32(\"DXT5\")] = \"DXT5\";\n  D3DFMT2[D3DFMT2[\"ATI1\"] = fourCCToInt32(\"ATI1\")] = \"ATI1\";\n  D3DFMT2[D3DFMT2[\"AT1N\"] = fourCCToInt32(\"AT1N\")] = \"AT1N\";\n  D3DFMT2[D3DFMT2[\"ATI2\"] = fourCCToInt32(\"ATI2\")] = \"ATI2\";\n  D3DFMT2[D3DFMT2[\"AT2N\"] = fourCCToInt32(\"AT2N\")] = \"AT2N\";\n  D3DFMT2[D3DFMT2[\"BC4U\"] = fourCCToInt32(\"BC4U\")] = \"BC4U\";\n  D3DFMT2[D3DFMT2[\"BC4S\"] = fourCCToInt32(\"BC4S\")] = \"BC4S\";\n  D3DFMT2[D3DFMT2[\"BC5U\"] = fourCCToInt32(\"BC5U\")] = \"BC5U\";\n  D3DFMT2[D3DFMT2[\"BC5S\"] = fourCCToInt32(\"BC5S\")] = \"BC5S\";\n  D3DFMT2[D3DFMT2[\"DX10\"] = fourCCToInt32(\"DX10\")] = \"DX10\";\n  return D3DFMT2;\n})(D3DFMT || {});\nconst FOURCC_TO_TEXTURE_FORMAT = {\n  [D3DFMT.DXT1]: \"bc1-rgba-unorm\",\n  [D3DFMT.DXT2]: \"bc2-rgba-unorm\",\n  [D3DFMT.DXT3]: \"bc2-rgba-unorm\",\n  [D3DFMT.DXT4]: \"bc3-rgba-unorm\",\n  [D3DFMT.DXT5]: \"bc3-rgba-unorm\",\n  [D3DFMT.ATI1]: \"bc4-r-unorm\",\n  [D3DFMT.BC4U]: \"bc4-r-unorm\",\n  [D3DFMT.BC4S]: \"bc4-r-snorm\",\n  [D3DFMT.ATI2]: \"bc5-rg-unorm\",\n  [D3DFMT.BC5U]: \"bc5-rg-unorm\",\n  [D3DFMT.BC5S]: \"bc5-rg-snorm\",\n  [36 /* A16B16G16R16 */]: \"rgba16uint\",\n  [110 /* Q16W16V16U16 */]: \"rgba16sint\",\n  [111 /* R16F */]: \"r16float\",\n  [112 /* G16R16F */]: \"rg16float\",\n  [113 /* A16B16G16R16F */]: \"rgba16float\",\n  [114 /* R32F */]: \"r32float\",\n  [115 /* G32R32F */]: \"rg32float\",\n  [116 /* A32B32G32R32F */]: \"rgba32float\"\n};\nconst DXGI_TO_TEXTURE_FORMAT = {\n  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: \"bc1-rgba-unorm\",\n  [71 /* DXGI_FORMAT_BC1_UNORM */]: \"bc1-rgba-unorm\",\n  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: \"bc1-rgba-unorm-srgb\",\n  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: \"bc2-rgba-unorm\",\n  [74 /* DXGI_FORMAT_BC2_UNORM */]: \"bc2-rgba-unorm\",\n  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: \"bc2-rgba-unorm-srgb\",\n  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: \"bc3-rgba-unorm\",\n  [77 /* DXGI_FORMAT_BC3_UNORM */]: \"bc3-rgba-unorm\",\n  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: \"bc3-rgba-unorm-srgb\",\n  [79 /* DXGI_FORMAT_BC4_TYPELESS */]: \"bc4-r-unorm\",\n  [80 /* DXGI_FORMAT_BC4_UNORM */]: \"bc4-r-unorm\",\n  [81 /* DXGI_FORMAT_BC4_SNORM */]: \"bc4-r-snorm\",\n  [82 /* DXGI_FORMAT_BC5_TYPELESS */]: \"bc5-rg-unorm\",\n  [83 /* DXGI_FORMAT_BC5_UNORM */]: \"bc5-rg-unorm\",\n  [84 /* DXGI_FORMAT_BC5_SNORM */]: \"bc5-rg-snorm\",\n  [94 /* DXGI_FORMAT_BC6H_TYPELESS */]: \"bc6h-rgb-ufloat\",\n  [95 /* DXGI_FORMAT_BC6H_UF16 */]: \"bc6h-rgb-ufloat\",\n  [96 /* DXGI_FORMAT_BC6H_SF16 */]: \"bc6h-rgb-float\",\n  [97 /* DXGI_FORMAT_BC7_TYPELESS */]: \"bc7-rgba-unorm\",\n  [98 /* DXGI_FORMAT_BC7_UNORM */]: \"bc7-rgba-unorm\",\n  [99 /* DXGI_FORMAT_BC7_UNORM_SRGB */]: \"bc7-rgba-unorm-srgb\",\n  [28 /* DXGI_FORMAT_R8G8B8A8_UNORM */]: \"rgba8unorm\",\n  [29 /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */]: \"rgba8unorm-srgb\",\n  [87 /* DXGI_FORMAT_B8G8R8A8_UNORM */]: \"bgra8unorm\",\n  [91 /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */]: \"bgra8unorm-srgb\",\n  [41 /* DXGI_FORMAT_R32_FLOAT */]: \"r32float\",\n  [49 /* DXGI_FORMAT_R8G8_UNORM */]: \"rg8unorm\",\n  [56 /* DXGI_FORMAT_R16_UNORM */]: \"r16uint\",\n  [61 /* DXGI_FORMAT_R8_UNORM */]: \"r8unorm\",\n  [24 /* DXGI_FORMAT_R10G10B10A2_UNORM */]: \"rgb10a2unorm\",\n  [11 /* DXGI_FORMAT_R16G16B16A16_UNORM */]: \"rgba16uint\",\n  [13 /* DXGI_FORMAT_R16G16B16A16_SNORM */]: \"rgba16sint\",\n  [10 /* DXGI_FORMAT_R16G16B16A16_FLOAT */]: \"rgba16float\",\n  [54 /* DXGI_FORMAT_R16_FLOAT */]: \"r16float\",\n  [34 /* DXGI_FORMAT_R16G16_FLOAT */]: \"rg16float\",\n  [16 /* DXGI_FORMAT_R32G32_FLOAT */]: \"rg32float\",\n  [2 /* DXGI_FORMAT_R32G32B32A32_FLOAT */]: \"rgba32float\"\n};\nconst DDS = {\n  MAGIC_VALUE: 542327876,\n  MAGIC_SIZE: 4,\n  HEADER_SIZE: 124,\n  HEADER_DX10_SIZE: 20,\n  PIXEL_FORMAT_FLAGS: {\n    // PIXEL_FORMAT flags\n    // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h\n    // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat\n    ALPHAPIXELS: 1,\n    ALPHA: 2,\n    FOURCC: 4,\n    RGB: 64,\n    RGBA: 65,\n    YUV: 512,\n    LUMINANCE: 131072,\n    LUMINANCEA: 131073\n  },\n  RESOURCE_MISC_TEXTURECUBE: 4,\n  HEADER_FIELDS: DDS_HEADER_FIELDS,\n  HEADER_DX10_FIELDS: DDS_DX10_FIELDS,\n  DXGI_FORMAT,\n  D3D10_RESOURCE_DIMENSION,\n  D3DFMT\n};\nconst TEXTURE_FORMAT_BLOCK_SIZE = {\n  \"bc1-rgba-unorm\": 8,\n  \"bc1-rgba-unorm-srgb\": 8,\n  \"bc2-rgba-unorm\": 16,\n  \"bc2-rgba-unorm-srgb\": 16,\n  \"bc3-rgba-unorm\": 16,\n  \"bc3-rgba-unorm-srgb\": 16,\n  \"bc4-r-unorm\": 8,\n  \"bc4-r-snorm\": 8,\n  \"bc5-rg-unorm\": 16,\n  \"bc5-rg-snorm\": 16,\n  \"bc6h-rgb-ufloat\": 16,\n  \"bc6h-rgb-float\": 16,\n  \"bc7-rgba-unorm\": 16,\n  \"bc7-rgba-unorm-srgb\": 16\n};\n\nexports.D3D10_RESOURCE_DIMENSION = D3D10_RESOURCE_DIMENSION;\nexports.D3DFMT = D3DFMT;\nexports.DDS = DDS;\nexports.DXGI_FORMAT = DXGI_FORMAT;\nexports.DXGI_TO_TEXTURE_FORMAT = DXGI_TO_TEXTURE_FORMAT;\nexports.FOURCC_TO_TEXTURE_FORMAT = FOURCC_TO_TEXTURE_FORMAT;\nexports.TEXTURE_FORMAT_BLOCK_SIZE = TEXTURE_FORMAT_BLOCK_SIZE;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/dds/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\nvar checkExtension = __webpack_require__(/*! ../../assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CompressedSource = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar parseDDS = __webpack_require__(/*! ./parseDDS.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js\");\n\n\"use strict\";\nconst loadDDS = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.High,\n    name: \"loadDDS\"\n  },\n  name: \"loadDDS\",\n  test(url) {\n    return checkExtension.checkExtension(url, [\".dds\"]);\n  },\n  async load(url, _asset, loader) {\n    const supportedTextures = await getSupportedTextureFormats.getSupportedTextureFormats();\n    const ddsResponse = await fetch(url);\n    const ddsArrayBuffer = await ddsResponse.arrayBuffer();\n    const textureOptions = parseDDS.parseDDS(ddsArrayBuffer, supportedTextures);\n    const compressedTextureSource = new CompressedSource.CompressedSource(textureOptions);\n    return createTexture.createTexture(compressedTextureSource, loader, url);\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\n\nexports.loadDDS = loadDDS;\n//# sourceMappingURL=loadDDS.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/const.js\");\n\n\"use strict\";\nfunction parseDDS(arrayBuffer, supportedFormats) {\n  const {\n    format,\n    fourCC,\n    width,\n    height,\n    dataOffset,\n    mipmapCount\n  } = parseDDSHeader(arrayBuffer);\n  if (!supportedFormats.includes(format)) {\n    throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);\n  }\n  if (mipmapCount <= 1) {\n    return {\n      format,\n      width,\n      height,\n      resource: [new Uint8Array(arrayBuffer, dataOffset)],\n      alphaMode: \"no-premultiply-alpha\"\n    };\n  }\n  const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);\n  const textureOptions = {\n    format,\n    width,\n    height,\n    resource: levelBuffers,\n    alphaMode: \"no-premultiply-alpha\"\n  };\n  return textureOptions;\n}\nfunction getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {\n  const levelBuffers = [];\n  const blockBytes = _const.TEXTURE_FORMAT_BLOCK_SIZE[format];\n  let mipWidth = width;\n  let mipHeight = height;\n  let offset = dataOffset;\n  for (let level = 0; level < mipmapCount; ++level) {\n    const alignedWidth = Math.ceil(Math.max(4, mipWidth) / 4) * 4;\n    const alignedHeight = Math.ceil(Math.max(4, mipHeight) / 4) * 4;\n    const byteLength = blockBytes ? alignedWidth / 4 * alignedHeight / 4 * blockBytes : mipWidth * mipHeight * 4;\n    const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);\n    levelBuffers.push(levelBuffer);\n    offset += byteLength;\n    mipWidth = Math.max(mipWidth >> 1, 1);\n    mipHeight = Math.max(mipHeight >> 1, 1);\n  }\n  return levelBuffers;\n}\nfunction parseDDSHeader(buffer) {\n  const header = new Uint32Array(buffer, 0, _const.DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n  if (header[_const.DDS.HEADER_FIELDS.MAGIC] !== _const.DDS.MAGIC_VALUE) {\n    throw new Error(\"Invalid magic number in DDS header\");\n  }\n  const height = header[_const.DDS.HEADER_FIELDS.HEIGHT];\n  const width = header[_const.DDS.HEADER_FIELDS.WIDTH];\n  const mipmapCount = Math.max(1, header[_const.DDS.HEADER_FIELDS.MIPMAP_COUNT]);\n  const flags = header[_const.DDS.HEADER_FIELDS.PF_FLAGS];\n  const fourCC = header[_const.DDS.HEADER_FIELDS.FOURCC];\n  const format = getTextureFormat(header, flags, fourCC, buffer);\n  const dataOffset = _const.DDS.MAGIC_SIZE + _const.DDS.HEADER_SIZE + (fourCC === _const.DDS.D3DFMT.DX10 ? _const.DDS.HEADER_DX10_SIZE : 0);\n  return {\n    format,\n    fourCC,\n    width,\n    height,\n    dataOffset,\n    mipmapCount\n  };\n}\nfunction getTextureFormat(header, flags, fourCC, buffer) {\n  if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.FOURCC) {\n    if (fourCC === _const.DDS.D3DFMT.DX10) {\n      const dx10Header = new Uint32Array(\n        buffer,\n        _const.DDS.MAGIC_SIZE + _const.DDS.HEADER_SIZE,\n        // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER\n        _const.DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT\n      );\n      const miscFlag = dx10Header[_const.DDS.HEADER_DX10_FIELDS.MISC_FLAG];\n      if (miscFlag === _const.DDS.RESOURCE_MISC_TEXTURECUBE) {\n        throw new Error(\"DDSParser does not support cubemap textures\");\n      }\n      const resourceDimension = dx10Header[_const.DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];\n      if (resourceDimension === _const.DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {\n        throw new Error(\"DDSParser does not supported 3D texture data\");\n      }\n      const dxgiFormat = dx10Header[_const.DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];\n      if (dxgiFormat in _const.DXGI_TO_TEXTURE_FORMAT) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[dxgiFormat];\n      }\n      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n    }\n    if (fourCC in _const.FOURCC_TO_TEXTURE_FORMAT) {\n      return _const.FOURCC_TO_TEXTURE_FORMAT[fourCC];\n    }\n    throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);\n  }\n  if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.RGB || flags & _const.DDS.PIXEL_FORMAT_FLAGS.RGBA) {\n    return getUncompressedTextureFormat(header);\n  }\n  if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.YUV) {\n    throw new Error(\"DDSParser does not supported YUV uncompressed texture data.\");\n  }\n  if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & _const.DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {\n    throw new Error(\"DDSParser does not support single-channel (lumninance) texture data!\");\n  }\n  if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & _const.DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {\n    throw new Error(\"DDSParser does not support single-channel (alpha) texture data!\");\n  }\n  throw new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nfunction getUncompressedTextureFormat(header) {\n  const bitCount = header[_const.DDS.HEADER_FIELDS.RGB_BITCOUNT];\n  const rBitMask = header[_const.DDS.HEADER_FIELDS.R_BIT_MASK];\n  const gBitMask = header[_const.DDS.HEADER_FIELDS.G_BIT_MASK];\n  const bBitMask = header[_const.DDS.HEADER_FIELDS.B_BIT_MASK];\n  const aBitMask = header[_const.DDS.HEADER_FIELDS.A_BIT_MASK];\n  switch (bitCount) {\n    case 32:\n      if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];\n      }\n      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];\n      }\n      if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];\n      }\n      if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];\n      }\n      if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];\n      }\n      break;\n    case 24:\n      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {\n      }\n      break;\n    case 16:\n      if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];\n      }\n      if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];\n      }\n      if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];\n      }\n      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];\n      }\n      if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];\n      }\n      break;\n    case 8:\n      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {\n        return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];\n      }\n      break;\n  }\n  throw new Error(`DDSParser does not support uncompressed texture with configuration:\n                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);\n}\n\nexports.parseDDS = parseDDS;\n//# sourceMappingURL=parseDDS.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar detectBasis = __webpack_require__(/*! ./basis/detectBasis.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.js\");\nvar loadBasis = __webpack_require__(/*! ./basis/loadBasis.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.js\");\n__webpack_require__(/*! ./basis/types.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/types.js\");\nvar createLevelBuffers = __webpack_require__(/*! ./basis/utils/createLevelBuffers.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.js\");\nvar gpuFormatToBasisTranscoderFormat = __webpack_require__(/*! ./basis/utils/gpuFormatToBasisTranscoderFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js\");\nvar setBasisTranscoderPath = __webpack_require__(/*! ./basis/utils/setBasisTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js\");\nvar loadBasisOnWorker = __webpack_require__(/*! ./basis/worker/loadBasisOnWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js\");\nvar _const = __webpack_require__(/*! ./dds/const.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/const.js\");\nvar loadDDS = __webpack_require__(/*! ./dds/loadDDS.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.js\");\nvar parseDDS = __webpack_require__(/*! ./dds/parseDDS.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js\");\nvar loadKTX = __webpack_require__(/*! ./ktx/loadKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.js\");\nvar parseKTX = __webpack_require__(/*! ./ktx/parseKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js\");\nvar _const$1 = __webpack_require__(/*! ./ktx2/const.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js\");\nvar loadKTX2 = __webpack_require__(/*! ./ktx2/loadKTX2.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.js\");\n__webpack_require__(/*! ./ktx2/types.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/types.js\");\nvar convertFormatIfRequired = __webpack_require__(/*! ./ktx2/utils/convertFormatIfRequired.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.js\");\nvar createLevelBuffersFromKTX = __webpack_require__(/*! ./ktx2/utils/createLevelBuffersFromKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js\");\nvar getTextureFormatFromKTXTexture = __webpack_require__(/*! ./ktx2/utils/getTextureFormatFromKTXTexture.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js\");\nvar glFormatToGPUFormat = __webpack_require__(/*! ./ktx2/utils/glFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js\");\nvar gpuFormatToKTXBasisTranscoderFormat = __webpack_require__(/*! ./ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js\");\nvar setKTXTranscoderPath = __webpack_require__(/*! ./ktx2/utils/setKTXTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js\");\nvar vkFormatToGPUFormat = __webpack_require__(/*! ./ktx2/utils/vkFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js\");\nvar loadKTX2onWorker = __webpack_require__(/*! ./ktx2/worker/loadKTX2onWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js\");\nvar detectCompressed = __webpack_require__(/*! ./shared/detectCompressed.js */ \"./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.js\");\nvar resolveCompressedTextureUrl = __webpack_require__(/*! ./shared/resolveCompressedTextureUrl.js */ \"./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js\");\n\n\"use strict\";\n\nexports.detectBasis = detectBasis.detectBasis;\nexports.loadBasis = loadBasis.loadBasis;\nexports.createLevelBuffers = createLevelBuffers.createLevelBuffers;\nexports.gpuFormatToBasisTranscoderFormat = gpuFormatToBasisTranscoderFormat.gpuFormatToBasisTranscoderFormat;\nexports.basisTranscoderUrls = setBasisTranscoderPath.basisTranscoderUrls;\nexports.setBasisTranscoderPath = setBasisTranscoderPath.setBasisTranscoderPath;\nexports.loadBasisOnWorker = loadBasisOnWorker.loadBasisOnWorker;\nexports.D3D10_RESOURCE_DIMENSION = _const.D3D10_RESOURCE_DIMENSION;\nexports.D3DFMT = _const.D3DFMT;\nexports.DDS = _const.DDS;\nexports.DXGI_FORMAT = _const.DXGI_FORMAT;\nexports.DXGI_TO_TEXTURE_FORMAT = _const.DXGI_TO_TEXTURE_FORMAT;\nexports.FOURCC_TO_TEXTURE_FORMAT = _const.FOURCC_TO_TEXTURE_FORMAT;\nexports.TEXTURE_FORMAT_BLOCK_SIZE = _const.TEXTURE_FORMAT_BLOCK_SIZE;\nexports.loadDDS = loadDDS.loadDDS;\nexports.parseDDS = parseDDS.parseDDS;\nexports.loadKTX = loadKTX.loadKTX;\nexports.parseKTX = parseKTX.parseKTX;\nexports.GL_INTERNAL_FORMAT = _const$1.GL_INTERNAL_FORMAT;\nexports.KTX = _const$1.KTX;\nexports.loadKTX2 = loadKTX2.loadKTX2;\nexports.convertFormatIfRequired = convertFormatIfRequired.convertFormatIfRequired;\nexports.createLevelBuffersFromKTX = createLevelBuffersFromKTX.createLevelBuffersFromKTX;\nexports.getTextureFormatFromKTXTexture = getTextureFormatFromKTXTexture.getTextureFormatFromKTXTexture;\nexports.glFormatToGPUFormat = glFormatToGPUFormat.glFormatToGPUFormat;\nexports.gpuFormatToKTXBasisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat.gpuFormatToKTXBasisTranscoderFormat;\nexports.ktxTranscoderUrls = setKTXTranscoderPath.ktxTranscoderUrls;\nexports.setKTXTranscoderPath = setKTXTranscoderPath.setKTXTranscoderPath;\nexports.vkFormatToGPUFormat = vkFormatToGPUFormat.vkFormatToGPUFormat;\nexports.loadKTX2onWorker = loadKTX2onWorker.loadKTX2onWorker;\nexports.detectCompressed = detectCompressed.detectCompressed;\nexports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;\nexports.validFormats = resolveCompressedTextureUrl.validFormats;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\nvar checkExtension = __webpack_require__(/*! ../../assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CompressedSource = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar parseKTX = __webpack_require__(/*! ./parseKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js\");\n\n\"use strict\";\nconst loadKTX = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.High,\n    name: \"loadKTX\"\n  },\n  name: \"loadKTX\",\n  test(url) {\n    return checkExtension.checkExtension(url, \".ktx\");\n  },\n  async load(url, _asset, loader) {\n    const supportedTextures = await getSupportedTextureFormats.getSupportedTextureFormats();\n    const ktxResponse = await fetch(url);\n    const ktxArrayBuffer = await ktxResponse.arrayBuffer();\n    const textureOptions = parseKTX.parseKTX(ktxArrayBuffer, supportedTextures);\n    const compressedTextureSource = new CompressedSource.CompressedSource(textureOptions);\n    return createTexture.createTexture(compressedTextureSource, loader, url);\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\n\nexports.loadKTX = loadKTX;\n//# sourceMappingURL=loadKTX.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../ktx2/const.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js\");\n\n\"use strict\";\nfunction parseKTX(arrayBuffer, supportedFormats) {\n  const dataView = new DataView(arrayBuffer);\n  if (!validate(dataView)) {\n    throw new Error(\"Invalid KTX identifier in header\");\n  }\n  const {\n    littleEndian,\n    glType,\n    glFormat,\n    glInternalFormat,\n    pixelWidth,\n    pixelHeight,\n    numberOfMipmapLevels,\n    offset\n  } = parseKTXHeader(dataView);\n  const textureFormat = _const.KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];\n  if (!textureFormat) {\n    throw new Error(`Unknown texture format ${glInternalFormat}`);\n  }\n  if (!supportedFormats.includes(textureFormat)) {\n    throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);\n  }\n  const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);\n  const imageBuffers = getImageBuffers(\n    dataView,\n    glType,\n    imagePixelByteSize,\n    pixelWidth,\n    pixelHeight,\n    offset,\n    numberOfMipmapLevels,\n    littleEndian\n  );\n  return {\n    format: textureFormat,\n    width: pixelWidth,\n    height: pixelHeight,\n    resource: imageBuffers,\n    alphaMode: \"no-premultiply-alpha\"\n  };\n}\nfunction getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {\n  const alignedWidth = pixelWidth + 3 & ~3;\n  const alignedHeight = pixelHeight + 3 & ~3;\n  let imagePixels = pixelWidth * pixelHeight;\n  if (glType === 0) {\n    imagePixels = alignedWidth * alignedHeight;\n  }\n  let mipByteSize = imagePixels * imagePixelByteSize;\n  let mipWidth = pixelWidth;\n  let mipHeight = pixelHeight;\n  let alignedMipWidth = alignedWidth;\n  let alignedMipHeight = alignedHeight;\n  let imageOffset = offset;\n  const imageBuffers = new Array(numberOfMipmapLevels);\n  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n    const imageSize = dataView.getUint32(imageOffset, littleEndian);\n    let elementOffset = imageOffset + 4;\n    imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);\n    elementOffset += mipByteSize;\n    imageOffset += imageSize + 4;\n    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;\n    mipWidth = mipWidth >> 1 || 1;\n    mipHeight = mipHeight >> 1 || 1;\n    alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);\n    alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);\n    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n  }\n  return imageBuffers;\n}\nfunction getImagePixelByteSize(glType, glFormat, glInternalFormat) {\n  let imagePixelByteSize = _const.KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n  if (glType !== 0) {\n    if (_const.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {\n      imagePixelByteSize = _const.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * _const.KTX.FORMATS_TO_COMPONENTS[glFormat];\n    } else {\n      imagePixelByteSize = _const.KTX.TYPES_TO_BYTES_PER_PIXEL[glType];\n    }\n  }\n  if (imagePixelByteSize === void 0) {\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  }\n  return imagePixelByteSize;\n}\nfunction parseKTXHeader(dataView) {\n  const littleEndian = dataView.getUint32(_const.KTX.FIELDS.ENDIANNESS, true) === _const.KTX.ENDIANNESS;\n  const glType = dataView.getUint32(_const.KTX.FIELDS.GL_TYPE, littleEndian);\n  const glFormat = dataView.getUint32(_const.KTX.FIELDS.GL_FORMAT, littleEndian);\n  const glInternalFormat = dataView.getUint32(_const.KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n  const pixelWidth = dataView.getUint32(_const.KTX.FIELDS.PIXEL_WIDTH, littleEndian);\n  const pixelHeight = dataView.getUint32(_const.KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;\n  const pixelDepth = dataView.getUint32(_const.KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;\n  const numberOfArrayElements = dataView.getUint32(_const.KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;\n  const numberOfFaces = dataView.getUint32(_const.KTX.FIELDS.NUMBER_OF_FACES, littleEndian);\n  const numberOfMipmapLevels = dataView.getUint32(_const.KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n  const bytesOfKeyValueData = dataView.getUint32(_const.KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n  if (pixelHeight === 0 || pixelDepth !== 1) {\n    throw new Error(\"Only 2D textures are supported\");\n  }\n  if (numberOfFaces !== 1) {\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  }\n  if (numberOfArrayElements !== 1) {\n    throw new Error(\"WebGL does not support array textures\");\n  }\n  return {\n    littleEndian,\n    glType,\n    glFormat,\n    glInternalFormat,\n    pixelWidth,\n    pixelHeight,\n    numberOfMipmapLevels,\n    offset: _const.KTX.FILE_HEADER_SIZE + bytesOfKeyValueData\n  };\n}\nfunction validate(dataView) {\n  for (let i = 0; i < _const.KTX.FILE_IDENTIFIER.length; i++) {\n    if (dataView.getUint8(i) !== _const.KTX.FILE_IDENTIFIER[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.parseKTX = parseKTX;\n//# sourceMappingURL=parseKTX.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2) => {\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"RGBA8_SNORM\"] = 36759] = \"RGBA8_SNORM\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"RGBA\"] = 6408] = \"RGBA\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"RGBA8UI\"] = 36220] = \"RGBA8UI\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"SRGB8_ALPHA8\"] = 35907] = \"SRGB8_ALPHA8\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"RGBA8I\"] = 36238] = \"RGBA8I\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"RGBA8\"] = 32856] = \"RGBA8\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGB_S3TC_DXT1_EXT\"] = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_S3TC_DXT1_EXT\"] = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_S3TC_DXT3_EXT\"] = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_S3TC_DXT5_EXT\"] = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\"] = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\"] = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\"] = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB_S3TC_DXT1_EXT\"] = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RED_RGTC1_EXT\"] = 36283] = \"COMPRESSED_RED_RGTC1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SIGNED_RED_RGTC1_EXT\"] = 36284] = \"COMPRESSED_SIGNED_RED_RGTC1_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RED_GREEN_RGTC2_EXT\"] = 36285] = \"COMPRESSED_RED_GREEN_RGTC2_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\"] = 36286] = \"COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_R11_EAC\"] = 37488] = \"COMPRESSED_R11_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SIGNED_R11_EAC\"] = 37489] = \"COMPRESSED_SIGNED_R11_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RG11_EAC\"] = 37490] = \"COMPRESSED_RG11_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SIGNED_RG11_EAC\"] = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGB8_ETC2\"] = 37492] = \"COMPRESSED_RGB8_ETC2\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA8_ETC2_EAC\"] = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ETC2\"] = 37493] = \"COMPRESSED_SRGB8_ETC2\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\"] = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_4x4_KHR\"] = 37808] = \"COMPRESSED_RGBA_ASTC_4x4_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_5x4_KHR\"] = 37809] = \"COMPRESSED_RGBA_ASTC_5x4_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_5x5_KHR\"] = 37810] = \"COMPRESSED_RGBA_ASTC_5x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_6x5_KHR\"] = 37811] = \"COMPRESSED_RGBA_ASTC_6x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_6x6_KHR\"] = 37812] = \"COMPRESSED_RGBA_ASTC_6x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_8x5_KHR\"] = 37813] = \"COMPRESSED_RGBA_ASTC_8x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_8x6_KHR\"] = 37814] = \"COMPRESSED_RGBA_ASTC_8x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_8x8_KHR\"] = 37815] = \"COMPRESSED_RGBA_ASTC_8x8_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_10x5_KHR\"] = 37816] = \"COMPRESSED_RGBA_ASTC_10x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_10x6_KHR\"] = 37817] = \"COMPRESSED_RGBA_ASTC_10x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_10x8_KHR\"] = 37818] = \"COMPRESSED_RGBA_ASTC_10x8_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_10x10_KHR\"] = 37819] = \"COMPRESSED_RGBA_ASTC_10x10_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_12x10_KHR\"] = 37820] = \"COMPRESSED_RGBA_ASTC_12x10_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_ASTC_12x12_KHR\"] = 37821] = \"COMPRESSED_RGBA_ASTC_12x12_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR\"] = 37840] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR\"] = 37841] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR\"] = 37842] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR\"] = 37843] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR\"] = 37844] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR\"] = 37845] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR\"] = 37846] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR\"] = 37847] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR\"] = 37848] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR\"] = 37849] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR\"] = 37850] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR\"] = 37851] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR\"] = 37852] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\"] = 37853] = \"COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGBA_BPTC_UNORM_EXT\"] = 36492] = \"COMPRESSED_RGBA_BPTC_UNORM_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\"] = 36493] = \"COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT\"] = 36494] = \"COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT\";\n  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2[\"COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT\"] = 36495] = \"COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT\";\n  return GL_INTERNAL_FORMAT2;\n})(GL_INTERNAL_FORMAT || {});\nvar GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {\n  GL_FORMATS2[GL_FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  GL_FORMATS2[GL_FORMATS2[\"RG\"] = 33319] = \"RG\";\n  GL_FORMATS2[GL_FORMATS2[\"RED\"] = 6403] = \"RED\";\n  GL_FORMATS2[GL_FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n  return GL_FORMATS2;\n})(GL_FORMATS || {});\nvar GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  GL_TYPES2[GL_TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  GL_TYPES2[GL_TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  GL_TYPES2[GL_TYPES2[\"INT\"] = 5124] = \"INT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  GL_TYPES2[GL_TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n  return GL_TYPES2;\n})(GL_TYPES || {});\nconst INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {\n  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: \"bc1-rgba-unorm\",\n  // TODO: ???\n  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: \"bc1-rgba-unorm\",\n  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: \"bc2-rgba-unorm\",\n  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: \"bc3-rgba-unorm\",\n  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: \"bc1-rgba-unorm-srgb\",\n  // TODO: ???\n  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: \"bc1-rgba-unorm-srgb\",\n  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: \"bc2-rgba-unorm-srgb\",\n  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: \"bc3-rgba-unorm-srgb\",\n  [36283 /* COMPRESSED_RED_RGTC1_EXT */]: \"bc4-r-unorm\",\n  [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */]: \"bc4-r-snorm\",\n  [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */]: \"bc5-rg-unorm\",\n  [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */]: \"bc5-rg-snorm\",\n  [37488 /* COMPRESSED_R11_EAC */]: \"eac-r11unorm\",\n  // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',\n  [37490 /* COMPRESSED_RG11_EAC */]: \"eac-rg11snorm\",\n  // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',\n  [37492 /* COMPRESSED_RGB8_ETC2 */]: \"etc2-rgb8unorm\",\n  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: \"etc2-rgba8unorm\",\n  [37493 /* COMPRESSED_SRGB8_ETC2 */]: \"etc2-rgb8unorm-srgb\",\n  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: \"etc2-rgba8unorm-srgb\",\n  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: \"etc2-rgb8a1unorm\",\n  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: \"etc2-rgb8a1unorm-srgb\",\n  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: \"astc-4x4-unorm\",\n  [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */]: \"astc-4x4-unorm-srgb\",\n  [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */]: \"astc-5x4-unorm\",\n  [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */]: \"astc-5x4-unorm-srgb\",\n  [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */]: \"astc-5x5-unorm\",\n  [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */]: \"astc-5x5-unorm-srgb\",\n  [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */]: \"astc-6x5-unorm\",\n  [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */]: \"astc-6x5-unorm-srgb\",\n  [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */]: \"astc-6x6-unorm\",\n  [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */]: \"astc-6x6-unorm-srgb\",\n  [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */]: \"astc-8x5-unorm\",\n  [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */]: \"astc-8x5-unorm-srgb\",\n  [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */]: \"astc-8x6-unorm\",\n  [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */]: \"astc-8x6-unorm-srgb\",\n  [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */]: \"astc-8x8-unorm\",\n  [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */]: \"astc-8x8-unorm-srgb\",\n  [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */]: \"astc-10x5-unorm\",\n  [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */]: \"astc-10x5-unorm-srgb\",\n  [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */]: \"astc-10x6-unorm\",\n  [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */]: \"astc-10x6-unorm-srgb\",\n  [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */]: \"astc-10x8-unorm\",\n  [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */]: \"astc-10x8-unorm-srgb\",\n  [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */]: \"astc-10x10-unorm\",\n  [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */]: \"astc-10x10-unorm-srgb\",\n  [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */]: \"astc-12x10-unorm\",\n  [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */]: \"astc-12x10-unorm-srgb\",\n  [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */]: \"astc-12x12-unorm\",\n  [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */]: \"astc-12x12-unorm-srgb\",\n  [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */]: \"bc7-rgba-unorm\",\n  [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */]: \"bc7-rgba-unorm-srgb\",\n  [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */]: \"bc6h-rgb-float\",\n  [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */]: \"bc6h-rgb-ufloat\",\n  [35907 /* SRGB8_ALPHA8 */]: \"rgba8unorm-srgb\",\n  [36759 /* RGBA8_SNORM */]: \"rgba8snorm\",\n  [36220 /* RGBA8UI */]: \"rgba8uint\",\n  [36238 /* RGBA8I */]: \"rgba8sint\",\n  [6408 /* RGBA */]: \"rgba8unorm\"\n  // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'\n};\nconst FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];\nconst FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n};\nconst FILE_HEADER_SIZE = 64;\nconst ENDIANNESS = 67305985;\nconst TYPES_TO_BYTES_PER_COMPONENT = {\n  [5121 /* UNSIGNED_BYTE */]: 1,\n  [5123 /* UNSIGNED_SHORT */]: 2,\n  [5124 /* INT */]: 4,\n  [5125 /* UNSIGNED_INT */]: 4,\n  [5126 /* FLOAT */]: 4,\n  [36193 /* HALF_FLOAT */]: 8\n};\nconst FORMATS_TO_COMPONENTS = {\n  [6408 /* RGBA */]: 4,\n  [6407 /* RGB */]: 3,\n  [33319 /* RG */]: 2,\n  [6403 /* RED */]: 1,\n  [6409 /* LUMINANCE */]: 1,\n  [6410 /* LUMINANCE_ALPHA */]: 2,\n  [6406 /* ALPHA */]: 1\n};\nconst TYPES_TO_BYTES_PER_PIXEL = {\n  [32819 /* UNSIGNED_SHORT_4_4_4_4 */]: 2,\n  [32820 /* UNSIGNED_SHORT_5_5_5_1 */]: 2,\n  [33635 /* UNSIGNED_SHORT_5_6_5 */]: 2\n};\nconst INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {\n  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,\n  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,\n  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,\n  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,\n  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,\n  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,\n  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,\n  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,\n  [36283 /* COMPRESSED_RED_RGTC1_EXT */]: 0.5,\n  [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */]: 0.5,\n  [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */]: 1,\n  [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */]: 1,\n  [37488 /* COMPRESSED_R11_EAC */]: 0.5,\n  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,\n  [37490 /* COMPRESSED_RG11_EAC */]: 1,\n  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,\n  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,\n  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,\n  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,\n  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,\n  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1,\n  [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */]: 1,\n  [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */]: 0.8,\n  [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */]: 0.8,\n  [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */]: 0.64,\n  [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */]: 0.64,\n  [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */]: 0.53375,\n  [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */]: 0.53375,\n  [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */]: 0.445,\n  [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */]: 0.445,\n  [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */]: 0.4,\n  [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */]: 0.4,\n  [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */]: 0.33375,\n  [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */]: 0.33375,\n  [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */]: 0.25,\n  [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */]: 0.25,\n  [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */]: 0.32,\n  [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */]: 0.32,\n  [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */]: 0.26625,\n  [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */]: 0.26625,\n  [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */]: 0.2,\n  [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */]: 0.2,\n  [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */]: 0.16,\n  [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */]: 0.16,\n  [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */]: 0.13375,\n  [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */]: 0.13375,\n  [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */]: 0.11125,\n  [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */]: 0.11125,\n  [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */]: 1,\n  [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */]: 1,\n  [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */]: 1,\n  [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */]: 1\n};\nconst KTX = {\n  FILE_HEADER_SIZE,\n  FILE_IDENTIFIER,\n  FORMATS_TO_COMPONENTS,\n  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,\n  INTERNAL_FORMAT_TO_TEXTURE_FORMATS,\n  FIELDS,\n  TYPES_TO_BYTES_PER_COMPONENT,\n  TYPES_TO_BYTES_PER_PIXEL,\n  ENDIANNESS\n};\n\nexports.GL_INTERNAL_FORMAT = GL_INTERNAL_FORMAT;\nexports.KTX = KTX;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar createTexture = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\nvar checkExtension = __webpack_require__(/*! ../../assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CompressedSource = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar loadKTX2onWorker = __webpack_require__(/*! ./worker/loadKTX2onWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js\");\n\n\"use strict\";\nconst loadKTX2 = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.High,\n    name: \"loadKTX2\"\n  },\n  name: \"loadKTX2\",\n  test(url) {\n    return checkExtension.checkExtension(url, \".ktx2\");\n  },\n  async load(url, _asset, loader) {\n    const supportedTextures = await getSupportedTextureFormats.getSupportedTextureFormats();\n    const textureOptions = await loadKTX2onWorker.loadKTX2onWorker(url, supportedTextures);\n    const compressedTextureSource = new CompressedSource.CompressedSource(textureOptions);\n    return createTexture.createTexture(compressedTextureSource, loader, url);\n  },\n  async unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\n\nexports.loadKTX2 = loadKTX2;\n//# sourceMappingURL=loadKTX2.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/types.js ***!
  \********************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst converters = {\n  rgb8unorm: {\n    convertedFormat: \"rgba8unorm\",\n    convertFunction: convertRGBtoRGBA\n  },\n  \"rgb8unorm-srgb\": {\n    convertedFormat: \"rgba8unorm-srgb\",\n    convertFunction: convertRGBtoRGBA\n  }\n};\nfunction convertFormatIfRequired(textureOptions) {\n  const format = textureOptions.format;\n  if (converters[format]) {\n    const convertFunction = converters[format].convertFunction;\n    const levelBuffers = textureOptions.resource;\n    for (let i = 0; i < levelBuffers.length; i++) {\n      levelBuffers[i] = convertFunction(levelBuffers[i]);\n    }\n    textureOptions.format = converters[format].convertedFormat;\n  }\n}\nfunction convertRGBtoRGBA(levelBuffer) {\n  const pixelCount = levelBuffer.byteLength / 3;\n  const levelBufferWithAlpha = new Uint32Array(pixelCount);\n  for (let i = 0; i < pixelCount; ++i) {\n    levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n  }\n  return new Uint8Array(levelBufferWithAlpha.buffer);\n}\n\nexports.convertFormatIfRequired = convertFormatIfRequired;\n//# sourceMappingURL=convertFormatIfRequired.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction createLevelBuffersFromKTX(ktxTexture) {\n  const levelBuffers = [];\n  for (let i = 0; i < ktxTexture.numLevels; i++) {\n    const imageData = ktxTexture.getImageData(i, 0, 0);\n    const levelBuffer = new Uint8Array(imageData.byteLength);\n    levelBuffer.set(imageData);\n    levelBuffers.push(levelBuffer);\n  }\n  return levelBuffers;\n}\n\nexports.createLevelBuffersFromKTX = createLevelBuffersFromKTX;\n//# sourceMappingURL=createLevelBuffersFromKTX.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar glFormatToGPUFormat = __webpack_require__(/*! ./glFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js\");\nvar vkFormatToGPUFormat = __webpack_require__(/*! ./vkFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js\");\n\n\"use strict\";\nfunction getTextureFormatFromKTXTexture(ktxTexture) {\n  if (ktxTexture.classId === 2) {\n    return vkFormatToGPUFormat.vkFormatToGPUFormat(ktxTexture.vkFormat);\n  }\n  return glFormatToGPUFormat.glFormatToGPUFormat(ktxTexture.glInternalformat);\n}\n\nexports.getTextureFormatFromKTXTexture = getTextureFormatFromKTXTexture;\n//# sourceMappingURL=getTextureFormatFromKTXTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst glFormatToGPUFormatMap = {\n  6408: \"rgba8unorm\",\n  32856: \"bgra8unorm\",\n  //\n  32857: \"rgb10a2unorm\",\n  33189: \"depth16unorm\",\n  33190: \"depth24plus\",\n  33321: \"r8unorm\",\n  33323: \"rg8unorm\",\n  33325: \"r16float\",\n  33326: \"r32float\",\n  33327: \"rg16float\",\n  33328: \"rg32float\",\n  33329: \"r8sint\",\n  33330: \"r8uint\",\n  33331: \"r16sint\",\n  33332: \"r16uint\",\n  33333: \"r32sint\",\n  33334: \"r32uint\",\n  33335: \"rg8sint\",\n  33336: \"rg8uint\",\n  33337: \"rg16sint\",\n  33338: \"rg16uint\",\n  33339: \"rg32sint\",\n  33340: \"rg32uint\",\n  33778: \"bc2-rgba-unorm\",\n  33779: \"bc3-rgba-unorm\",\n  34836: \"rgba32float\",\n  34842: \"rgba16float\",\n  35056: \"depth24plus-stencil8\",\n  35898: \"rg11b10ufloat\",\n  35901: \"rgb9e5ufloat\",\n  35907: \"rgba8unorm-srgb\",\n  // bgra8unorm-srgb\n  36012: \"depth32float\",\n  36013: \"depth32float-stencil8\",\n  36168: \"stencil8\",\n  36208: \"rgba32uint\",\n  36214: \"rgba16uint\",\n  36220: \"rgba8uint\",\n  36226: \"rgba32sint\",\n  36232: \"rgba16sint\",\n  36238: \"rgba8sint\",\n  36492: \"bc7-rgba-unorm\",\n  36756: \"r8snorm\",\n  36757: \"rg8snorm\",\n  36759: \"rgba8snorm\",\n  37496: \"etc2-rgba8unorm\",\n  37808: \"astc-4x4-unorm\"\n};\nfunction glFormatToGPUFormat(glInternalFormat) {\n  const format = glFormatToGPUFormatMap[glInternalFormat];\n  if (format) {\n    return format;\n  }\n  throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n}\n\nexports.glFormatToGPUFormat = glFormatToGPUFormat;\n//# sourceMappingURL=glFormatToGPUFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst gpuFormatToBasisTranscoderFormatMap = {\n  \"bc3-rgba-unorm\": \"BC3_RGBA\",\n  \"bc7-rgba-unorm\": \"BC7_M5_RGBA\",\n  \"etc2-rgba8unorm\": \"ETC2_RGBA\",\n  \"astc-4x4-unorm\": \"ASTC_4x4_RGBA\",\n  // Uncompressed\n  rgba8unorm: \"RGBA32\",\n  rg11b10ufloat: \"R11F_G11F_B10F\"\n};\nfunction gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n  const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n  if (format) {\n    return format;\n  }\n  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n}\n\nexports.gpuFormatToKTXBasisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat;\n//# sourceMappingURL=gpuFormatToKTXBasisTranscoderFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst ktxTranscoderUrls = {\n  jsUrl: \"https://files.pixijs.download/transcoders/ktx/libktx.js\",\n  wasmUrl: \"https://files.pixijs.download/transcoders/ktx/libktx.wasm\"\n};\nfunction setKTXTranscoderPath(config) {\n  Object.assign(ktxTranscoderUrls, config);\n}\n\nexports.ktxTranscoderUrls = ktxTranscoderUrls;\nexports.setKTXTranscoderPath = setKTXTranscoderPath;\n//# sourceMappingURL=setKTXTranscoderPath.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst vkFormatToGPUFormatMap = {\n  23: \"rgb8unorm\",\n  // VK_FORMAT_R8G8B8_UNORM\n  37: \"rgba8unorm\",\n  // VK_FORMAT_R8G8B8A8_UNORM\n  43: \"rgba8unorm-srgb\"\n  // VK_FORMAT_R8G8B8A8_SRGB\n  // TODO add more!\n};\nfunction vkFormatToGPUFormat(vkFormat) {\n  const format = vkFormatToGPUFormatMap[vkFormat];\n  if (format) {\n    return format;\n  }\n  throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n}\n\nexports.vkFormatToGPUFormat = vkFormatToGPUFormat;\n//# sourceMappingURL=vkFormatToGPUFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ktx_worker = __webpack_require__(/*! ../../../_virtual/ktx.worker.js */ \"./node_modules/pixi.js/lib/_virtual/ktx.worker.js\");\nvar setKTXTranscoderPath = __webpack_require__(/*! ../utils/setKTXTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js\");\n\n\"use strict\";\nlet ktxWorker;\nconst urlHash = {};\nfunction getKTX2Worker(supportedTextures) {\n  if (!ktxWorker) {\n    ktxWorker = new ktx_worker.default().worker;\n    ktxWorker.onmessage = (messageEvent) => {\n      const { success, url, textureOptions } = messageEvent.data;\n      if (!success) {\n        console.warn(\"Failed to load KTX texture\", url);\n      }\n      urlHash[url](textureOptions);\n    };\n    ktxWorker.postMessage({\n      type: \"init\",\n      jsUrl: setKTXTranscoderPath.ktxTranscoderUrls.jsUrl,\n      wasmUrl: setKTXTranscoderPath.ktxTranscoderUrls.wasmUrl,\n      supportedTextures\n    });\n  }\n  return ktxWorker;\n}\nfunction loadKTX2onWorker(url, supportedTextures) {\n  const ktxWorker2 = getKTX2Worker(supportedTextures);\n  return new Promise((resolve) => {\n    urlHash[url] = resolve;\n    ktxWorker2.postMessage({ type: \"load\", url });\n  });\n}\n\nexports.loadKTX2onWorker = loadKTX2onWorker;\n//# sourceMappingURL=loadKTX2onWorker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar getSupportedCompressedTextureFormats = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js\");\nvar isWebGLSupported = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\nvar resolveCompressedTextureUrl = __webpack_require__(/*! ./resolveCompressedTextureUrl.js */ \"./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js\");\n\n\"use strict\";\nlet compressedTextureExtensions;\nconst detectCompressed = {\n  extension: {\n    type: Extensions.ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    if (await isWebGPUSupported.isWebGPUSupported())\n      return true;\n    if (isWebGLSupported.isWebGLSupported())\n      return true;\n    return false;\n  },\n  add: async (formats) => {\n    const supportedCompressedTextureFormats = await getSupportedCompressedTextureFormats.getSupportedCompressedTextureFormats();\n    compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);\n    return [...compressedTextureExtensions, ...formats];\n  },\n  remove: async (formats) => {\n    if (compressedTextureExtensions) {\n      return formats.filter((f) => !(f in compressedTextureExtensions));\n    }\n    return formats;\n  }\n};\nfunction extractExtensionsForCompressedTextureFormats(formats) {\n  const extensions = [\"basis\"];\n  const dupeMap = {};\n  formats.forEach((format) => {\n    const extension = format.split(\"-\")[0];\n    if (extension && !dupeMap[extension]) {\n      dupeMap[extension] = true;\n      extensions.push(extension);\n    }\n  });\n  extensions.sort((a, b) => {\n    const aIndex = resolveCompressedTextureUrl.validFormats.indexOf(a);\n    const bIndex = resolveCompressedTextureUrl.validFormats.indexOf(b);\n    if (aIndex === -1) {\n      return 1;\n    }\n    if (bIndex === -1) {\n      return -1;\n    }\n    return aIndex - bIndex;\n  });\n  return extensions;\n}\n\nexports.detectCompressed = detectCompressed;\n//# sourceMappingURL=detectCompressed.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Resolver = __webpack_require__(/*! ../../assets/resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\nvar checkExtension = __webpack_require__(/*! ../../assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst validFormats = [\"basis\", \"bc7\", \"bc6h\", \"astc\", \"etc2\", \"bc5\", \"bc4\", \"bc3\", \"bc2\", \"bc1\", \"eac\"];\nconst resolveCompressedTextureUrl = {\n  extension: Extensions.ExtensionType.ResolveParser,\n  test: (value) => checkExtension.checkExtension(value, [\".ktx\", \".ktx2\", \".dds\"]),\n  parse: (value) => {\n    let format;\n    const splitValue = value.split(\".\");\n    if (splitValue.length > 2) {\n      const newFormat = splitValue[splitValue.length - 2];\n      if (validFormats.includes(newFormat)) {\n        format = newFormat;\n      }\n    } else {\n      format = splitValue[splitValue.length - 1];\n    }\n    return {\n      resolution: parseFloat(Resolver.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n      format,\n      src: value\n    };\n  }\n};\n\nexports.resolveCompressedTextureUrl = resolveCompressedTextureUrl;\nexports.validFormats = validFormats;\n//# sourceMappingURL=resolveCompressedTextureUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/Culler.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/Culler.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Bounds = __webpack_require__(/*! ../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ../scene/container/bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\n\n\"use strict\";\nconst tempBounds = new Bounds.Bounds();\nconst _Culler = class _Culler {\n  /**\n   * Culls the children of a specific container based on the given view rectangle.\n   * This determines which objects should be rendered and which can be skipped.\n   * @param container - The container to cull. Must be a Container instance.\n   * @param view - The view rectangle that defines the visible area\n   * @param skipUpdateTransform - Whether to skip updating transforms for better performance\n   * @example\n   * ```ts\n   * // Basic culling with view bounds\n   * const culler = new Culler();\n   * culler.cull(stage, {\n   *     x: 0,\n   *     y: 0,\n   *     width: 800,\n   *     height: 600\n   * });\n   *\n   * // Culling to renderer screen\n   * culler.cull(stage, renderer.screen, false);\n   * ```\n   * @remarks\n   * - Recursively processes all cullable children\n   * - Uses cullArea if defined, otherwise calculates bounds\n   * - Performance depends on scene complexity\n   * @see {@link CullingMixinConstructor.cullable} For enabling culling on objects\n   * @see {@link CullingMixinConstructor.cullArea} For custom culling boundaries\n   */\n  cull(container, view, skipUpdateTransform = true) {\n    this._cullRecursive(container, view, skipUpdateTransform);\n  }\n  _cullRecursive(container, view, skipUpdateTransform = true) {\n    if (container.cullable && container.measurable && container.includeInBuild) {\n      const bounds = container.cullArea ?? getGlobalBounds.getGlobalBounds(container, skipUpdateTransform, tempBounds);\n      container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;\n    } else {\n      container.culled = false;\n    }\n    if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild)\n      return;\n    for (let i = 0; i < container.children.length; i++) {\n      this._cullRecursive(container.children[i], view, skipUpdateTransform);\n    }\n  }\n};\n/**\n * A shared instance of the Culler class. Provides a global culler instance for convenience.\n * @example\n * ```ts\n * // Use the shared instance instead of creating a new one\n * Culler.shared.cull(stage, {\n *     x: 0,\n *     y: 0,\n *     width: 800,\n *     height: 600\n * });\n * ```\n * @see {@link CullerPlugin} For automatic culling using this instance\n */\n_Culler.shared = new _Culler();\nlet Culler = _Culler;\n\nexports.Culler = Culler;\n//# sourceMappingURL=Culler.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/culling/Culler.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/CullerPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/CullerPlugin.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Culler = __webpack_require__(/*! ./Culler.js */ \"./node_modules/pixi.js/lib/culling/Culler.js\");\n\n\"use strict\";\nclass CullerPlugin {\n  /** @internal */\n  static init() {\n    this._renderRef = this.render.bind(this);\n    this.render = () => {\n      Culler.Culler.shared.cull(this.stage, this.renderer.screen);\n      this.renderer.render({ container: this.stage });\n    };\n  }\n  /** @internal */\n  static destroy() {\n    this.render = this._renderRef;\n  }\n}\n/** @ignore */\nCullerPlugin.extension = {\n  priority: 10,\n  type: Extensions.ExtensionType.Application,\n  name: \"culler\"\n};\n\nexports.CullerPlugin = CullerPlugin;\n//# sourceMappingURL=CullerPlugin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/culling/CullerPlugin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/cullingMixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/cullingMixin.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexports.cullingMixin = cullingMixin;\n//# sourceMappingURL=cullingMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/culling/cullingMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/index.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Culler = __webpack_require__(/*! ./Culler.js */ \"./node_modules/pixi.js/lib/culling/Culler.js\");\nvar CullerPlugin = __webpack_require__(/*! ./CullerPlugin.js */ \"./node_modules/pixi.js/lib/culling/CullerPlugin.js\");\nvar cullingMixin = __webpack_require__(/*! ./cullingMixin.js */ \"./node_modules/pixi.js/lib/culling/cullingMixin.js\");\n\n\"use strict\";\n\nexports.Culler = Culler.Culler;\nexports.CullerPlugin = CullerPlugin.CullerPlugin;\nexports.cullingMixin = cullingMixin.cullingMixin;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/culling/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/DOMContainer.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/DOMContainer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar ViewContainer = __webpack_require__(/*! ../scene/view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\n\n\"use strict\";\nclass DOMContainer extends ViewContainer.ViewContainer {\n  /**\n   * @param options - The options for creating the DOM container.\n   */\n  constructor(options = {}) {\n    const { element, anchor, ...rest } = options;\n    super({\n      label: \"DOMContainer\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"dom\";\n    /** @internal */\n    this.batched = false;\n    this._anchor = new Point.Point(0, 0);\n    if (anchor) {\n      this.anchor = anchor;\n    }\n    this.element = options.element || document.createElement(\"div\");\n  }\n  /**\n   * The anchor sets the origin point of the container.\n   * Controls the relative positioning of the DOM element.\n   *\n   * The default is `(0,0)`, this means the container's origin is the top left.\n   * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.\n   * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.\n   * @example\n   * ```ts\n   * const container = new DOMContainer();\n   *\n   * // Set anchor to center (shorthand)\n   * container.anchor = 0.5;\n   *\n   * // Set anchor to bottom-right\n   * container.anchor = { x: 1, y: 1 };\n   *\n   * // Set anchor to custom position\n   * container.anchor = new Point(0.3, 0.7);\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  /**\n   * Sets the anchor point of the container.\n   * @param value - New anchor value:\n   * - number: Sets both x and y to same value\n   * - PointData: Sets x and y separately\n   */\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * Sets the DOM element for this container.\n   * This will replace the current element and update the view.\n   * @param value - The new DOM element to use\n   * @example\n   * ```ts\n   * const domContainer = new DOMContainer();\n   * domContainer.element = document.createElement('input');\n   * ```\n   */\n  set element(value) {\n    if (this._element === value)\n      return;\n    this._element = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The DOM element associated with this container.\n   * @example\n   * ```ts\n   * const domContainer = new DOMContainer();\n   * domContainer.element.innerHTML = 'Hello World!';\n   * document.body.appendChild(domContainer.element);\n   * ```\n   */\n  get element() {\n    return this._element;\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const element = this._element;\n    if (!element) {\n      bounds.minX = 0;\n      bounds.minY = 0;\n      bounds.maxX = 0;\n      bounds.maxY = 0;\n      return;\n    }\n    const { offsetWidth, offsetHeight } = element;\n    bounds.minX = 0;\n    bounds.maxX = offsetWidth;\n    bounds.minY = 0;\n    bounds.maxY = offsetHeight;\n  }\n  /**\n   * Destroys this DOM container.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that\n   * @example\n   * domContainer.destroy();\n   * domContainer.destroy(true);\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._element?.parentNode?.removeChild(this._element);\n    this._element = null;\n    this._anchor = null;\n  }\n}\n\nexports.DOMContainer = DOMContainer;\n//# sourceMappingURL=DOMContainer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/dom/DOMContainer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/DOMPipe.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/DOMPipe.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass DOMPipe {\n  /**\n   * Constructor for the DOMPipe class.\n   * @param renderer - The renderer instance that this DOMPipe will be associated with.\n   */\n  constructor(renderer) {\n    /** Array to keep track of attached DOM elements */\n    this._attachedDomElements = [];\n    this._renderer = renderer;\n    this._renderer.runners.postrender.add(this);\n    this._domElement = document.createElement(\"div\");\n    this._domElement.style.position = \"absolute\";\n    this._domElement.style.top = \"0\";\n    this._domElement.style.left = \"0\";\n    this._domElement.style.pointerEvents = \"none\";\n    this._domElement.style.zIndex = \"1000\";\n  }\n  /**\n   * Adds a renderable DOM container to the list of attached elements.\n   * @param domContainer - The DOM container to be added.\n   * @param _instructionSet - The instruction set (unused).\n   */\n  addRenderable(domContainer, _instructionSet) {\n    if (!this._attachedDomElements.includes(domContainer)) {\n      this._attachedDomElements.push(domContainer);\n    }\n  }\n  /**\n   * Updates a renderable DOM container.\n   * @param _domContainer - The DOM container to be updated (unused).\n   */\n  updateRenderable(_domContainer) {\n  }\n  /**\n   * Validates a renderable DOM container.\n   * @param _domContainer - The DOM container to be validated (unused).\n   * @returns Always returns true as validation is not required.\n   */\n  validateRenderable(_domContainer) {\n    return true;\n  }\n  /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n  postrender() {\n    const attachedDomElements = this._attachedDomElements;\n    if (attachedDomElements.length === 0) {\n      this._domElement.remove();\n      return;\n    }\n    const canvas = this._renderer.view.canvas;\n    if (this._domElement.parentNode !== canvas.parentNode) {\n      canvas.parentNode?.appendChild(this._domElement);\n    }\n    const sx = parseFloat(canvas.style.width) / canvas.width * this._renderer.resolution;\n    const sy = parseFloat(canvas.style.height) / canvas.height * this._renderer.resolution;\n    this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px) scale(${sx}, ${sy})`;\n    for (let i = 0; i < attachedDomElements.length; i++) {\n      const domContainer = attachedDomElements[i];\n      const element = domContainer.element;\n      if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {\n        element?.remove();\n        attachedDomElements.splice(i, 1);\n        i--;\n      } else {\n        if (!this._domElement.contains(element)) {\n          element.style.position = \"absolute\";\n          element.style.pointerEvents = \"auto\";\n          this._domElement.appendChild(element);\n        }\n        const wt = domContainer.worldTransform;\n        const anchor = domContainer._anchor;\n        const ax = domContainer.width * anchor.x;\n        const ay = domContainer.height * anchor.y;\n        element.style.transformOrigin = `${ax}px ${ay}px`;\n        element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n        element.style.opacity = domContainer.groupAlpha.toString();\n      }\n    }\n  }\n  /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n  destroy() {\n    this._renderer.runners.postrender.remove(this);\n    for (let i = 0; i < this._attachedDomElements.length; i++) {\n      const domContainer = this._attachedDomElements[i];\n      domContainer.element?.remove();\n    }\n    this._attachedDomElements.length = 0;\n    this._domElement.remove();\n    this._renderer = null;\n  }\n}\n/**\n * Static property defining the extension type and name for the DOMPipe.\n * This is used to register the DOMPipe with different rendering pipelines.\n */\nDOMPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"dom\"\n};\n\nexports.DOMPipe = DOMPipe;\n//# sourceMappingURL=DOMPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/dom/DOMPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar DOMContainer = __webpack_require__(/*! ./DOMContainer.js */ \"./node_modules/pixi.js/lib/dom/DOMContainer.js\");\nvar DOMPipe = __webpack_require__(/*! ./DOMPipe.js */ \"./node_modules/pixi.js/lib/dom/DOMPipe.js\");\n\n\"use strict\";\n\nexports.DOMContainer = DOMContainer.DOMContainer;\nexports.DOMPipe = DOMPipe.DOMPipe;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/dom/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/init.js":
/*!**********************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/init.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar DOMPipe = __webpack_require__(/*! ./DOMPipe.js */ \"./node_modules/pixi.js/lib/dom/DOMPipe.js\");\n__webpack_require__(/*! ./index.js */ \"./node_modules/pixi.js/lib/dom/index.js\");\nvar DOMContainer = __webpack_require__(/*! ./DOMContainer.js */ \"./node_modules/pixi.js/lib/dom/DOMContainer.js\");\n\n\"use strict\";\nExtensions.extensions.add(DOMPipe.DOMPipe);\n\nexports.DOMPipe = DOMPipe.DOMPipe;\nexports.DOMContainer = DOMContainer.DOMContainer;\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/dom/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexports.BrowserAdapter = BrowserAdapter;\n//# sourceMappingURL=BrowserAdapter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/browserAll.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/browserAll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! ../accessibility/init.js */ \"./node_modules/pixi.js/lib/accessibility/init.js\");\n__webpack_require__(/*! ../app/init.js */ \"./node_modules/pixi.js/lib/app/init.js\");\n__webpack_require__(/*! ../events/init.js */ \"./node_modules/pixi.js/lib/events/init.js\");\n__webpack_require__(/*! ../dom/init.js */ \"./node_modules/pixi.js/lib/dom/init.js\");\n__webpack_require__(/*! ../spritesheet/init.js */ \"./node_modules/pixi.js/lib/spritesheet/init.js\");\n__webpack_require__(/*! ../rendering/init.js */ \"./node_modules/pixi.js/lib/rendering/init.js\");\n__webpack_require__(/*! ../scene/graphics/init.js */ \"./node_modules/pixi.js/lib/scene/graphics/init.js\");\n__webpack_require__(/*! ../scene/mesh/init.js */ \"./node_modules/pixi.js/lib/scene/mesh/init.js\");\n__webpack_require__(/*! ../scene/particle-container/init.js */ \"./node_modules/pixi.js/lib/scene/particle-container/init.js\");\n__webpack_require__(/*! ../scene/text/init.js */ \"./node_modules/pixi.js/lib/scene/text/init.js\");\n__webpack_require__(/*! ../scene/text-bitmap/init.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/init.js\");\n__webpack_require__(/*! ../scene/text-html/init.js */ \"./node_modules/pixi.js/lib/scene/text-html/init.js\");\n__webpack_require__(/*! ../scene/sprite-tiling/init.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/init.js\");\n__webpack_require__(/*! ../scene/sprite-nine-slice/init.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.js\");\n__webpack_require__(/*! ../filters/init.js */ \"./node_modules/pixi.js/lib/filters/init.js\");\n\n\"use strict\";\n//# sourceMappingURL=browserAll.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-browser/browserAll.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/browserExt.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/browserExt.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst browserExt = {\n  extension: {\n    type: Extensions.ExtensionType.Environment,\n    name: \"browser\",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await Promise.resolve().then(function () { return __webpack_require__(/*! ./browserAll.js */ \"./node_modules/pixi.js/lib/environment-browser/browserAll.js\"); });\n  }\n};\n\nexports.browserExt = browserExt;\n//# sourceMappingURL=browserExt.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-browser/browserExt.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BrowserAdapter = __webpack_require__(/*! ./BrowserAdapter.js */ \"./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js\");\nvar browserExt = __webpack_require__(/*! ./browserExt.js */ \"./node_modules/pixi.js/lib/environment-browser/browserExt.js\");\n\n\"use strict\";\n\nexports.BrowserAdapter = BrowserAdapter.BrowserAdapter;\nexports.browserExt = browserExt.browserExt;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-browser/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar xmldom = __webpack_require__(/*! @xmldom/xmldom */ \"./node_modules/@xmldom/xmldom/lib/index.js\");\n\n\"use strict\";\nconst WebWorkerAdapter = {\n  createCanvas: (width, height) => new OffscreenCanvas(width ?? 0, height ?? 0),\n  getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => globalThis.location.href,\n  getFontFaceSet: () => globalThis.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new xmldom.DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexports.WebWorkerAdapter = WebWorkerAdapter;\n//# sourceMappingURL=WebWorkerAdapter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar WebWorkerAdapter = __webpack_require__(/*! ./WebWorkerAdapter.js */ \"./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.js\");\nvar webworkerExt = __webpack_require__(/*! ./webworkerExt.js */ \"./node_modules/pixi.js/lib/environment-webworker/webworkerExt.js\");\n\n\"use strict\";\n\nexports.WebWorkerAdapter = WebWorkerAdapter.WebWorkerAdapter;\nexports.webworkerExt = webworkerExt.webworkerExt;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-webworker/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/webworkerAll.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/webworkerAll.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! ../app/init.js */ \"./node_modules/pixi.js/lib/app/init.js\");\n__webpack_require__(/*! ../spritesheet/init.js */ \"./node_modules/pixi.js/lib/spritesheet/init.js\");\n__webpack_require__(/*! ../rendering/init.js */ \"./node_modules/pixi.js/lib/rendering/init.js\");\n__webpack_require__(/*! ../scene/graphics/init.js */ \"./node_modules/pixi.js/lib/scene/graphics/init.js\");\n__webpack_require__(/*! ../scene/mesh/init.js */ \"./node_modules/pixi.js/lib/scene/mesh/init.js\");\n__webpack_require__(/*! ../scene/particle-container/init.js */ \"./node_modules/pixi.js/lib/scene/particle-container/init.js\");\n__webpack_require__(/*! ../scene/text/init.js */ \"./node_modules/pixi.js/lib/scene/text/init.js\");\n__webpack_require__(/*! ../scene/text-bitmap/init.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/init.js\");\n__webpack_require__(/*! ../scene/text-html/init.js */ \"./node_modules/pixi.js/lib/scene/text-html/init.js\");\n__webpack_require__(/*! ../scene/sprite-tiling/init.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/init.js\");\n__webpack_require__(/*! ../scene/sprite-nine-slice/init.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.js\");\n__webpack_require__(/*! ../filters/init.js */ \"./node_modules/pixi.js/lib/filters/init.js\");\n\n\"use strict\";\n//# sourceMappingURL=webworkerAll.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-webworker/webworkerAll.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/webworkerExt.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/webworkerExt.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst webworkerExt = {\n  extension: {\n    type: Extensions.ExtensionType.Environment,\n    name: \"webworker\",\n    priority: 0\n  },\n  test: () => typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await Promise.resolve().then(function () { return __webpack_require__(/*! ./webworkerAll.js */ \"./node_modules/pixi.js/lib/environment-webworker/webworkerAll.js\"); });\n  }\n};\n\nexports.webworkerExt = webworkerExt;\n//# sourceMappingURL=webworkerExt.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment-webworker/webworkerExt.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/adapter.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/adapter.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BrowserAdapter = __webpack_require__(/*! ../environment-browser/BrowserAdapter.js */ \"./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js\");\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter.BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexports.DOMAdapter = DOMAdapter;\n//# sourceMappingURL=adapter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment/adapter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst environments = [];\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\nexports.autoDetectEnvironment = autoDetectEnvironment;\nexports.loadEnvironmentExtensions = loadEnvironmentExtensions;\n//# sourceMappingURL=autoDetectEnvironment.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/canvas/ICanvas.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/canvas/ICanvas.js ***!
  \****************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=ICanvas.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment/canvas/ICanvas.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/canvas/ICanvasRenderingContext2D.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/canvas/ICanvasRenderingContext2D.js ***!
  \**********************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=ICanvasRenderingContext2D.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment/canvas/ICanvasRenderingContext2D.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ./adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar autoDetectEnvironment = __webpack_require__(/*! ./autoDetectEnvironment.js */ \"./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js\");\n__webpack_require__(/*! ./canvas/ICanvas.js */ \"./node_modules/pixi.js/lib/environment/canvas/ICanvas.js\");\n__webpack_require__(/*! ./canvas/ICanvasRenderingContext2D.js */ \"./node_modules/pixi.js/lib/environment/canvas/ICanvasRenderingContext2D.js\");\n\n\"use strict\";\n\nexports.DOMAdapter = adapter.DOMAdapter;\nexports.autoDetectEnvironment = autoDetectEnvironment.autoDetectEnvironment;\nexports.loadEnvironmentExtensions = autoDetectEnvironment.loadEnvironmentExtensions;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/environment/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventBoundary.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventBoundary.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar Point = __webpack_require__(/*! ../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar warn = __webpack_require__(/*! ../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar EventTicker = __webpack_require__(/*! ./EventTicker.js */ \"./node_modules/pixi.js/lib/events/EventTicker.js\");\nvar FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedMouseEvent.js\");\nvar FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedPointerEvent.js\");\nvar FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedWheelEvent.js\");\n\n\"use strict\";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point.Point();\nconst tempLocalMapping = new Point.Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new EventEmitter();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      warn.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventTicker.EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target `e.target`.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * `target`. The last element in the path is `target`.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventTicker.EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventTicker.EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === \"none\") {\n      return true;\n    }\n    if (container.eventMode === \"passive\" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type ?? (type = e.type);\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerdown\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchstart\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, \"pointerout\");\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\");\n      if (isMouse)\n        this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, \"mouseenter\");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n    allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n    if (e.pointerType === \"touch\") {\n      this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n      allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n      allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\");\n    if (isMouse)\n      this.dispatchEvent(e, \"mouseover\");\n    if (e.pointerType === \"mouse\")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, \"mouseenter\");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, \"mouseleave\");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerup\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchend\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else if (clickEvent.pointerType === \"touch\") {\n        this.dispatchEvent(clickEvent, \"tap\");\n      }\n      this.dispatchEvent(clickEvent, \"pointertap\");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The `originalEvent` for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === \"string\") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose `originalEvent` is `from`.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event `from`, with an optional `type` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.defaultPrevented = false;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (\"fn\" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\nexports.EventBoundary = EventBoundary;\n//# sourceMappingURL=EventBoundary.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/EventBoundary.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventBoundaryTypes.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventBoundaryTypes.js ***!
  \***************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=EventBoundaryTypes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/EventBoundaryTypes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventSystem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ \"./node_modules/pixi.js/lib/events/EventBoundary.js\");\nvar EventTicker = __webpack_require__(/*! ./EventTicker.js */ \"./node_modules/pixi.js/lib/events/EventTicker.js\");\nvar FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedPointerEvent.js\");\nvar FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedWheelEvent.js\");\n\n\"use strict\";\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: \"pointerdown\",\n  touchend: \"pointerup\",\n  touchendoutside: \"pointerupoutside\",\n  touchmove: \"pointermove\",\n  touchcancel: \"pointercancel\"\n};\nconst _EventSystem = class _EventSystem {\n  /**\n   * @param {Renderer} renderer\n   */\n  constructor(renderer) {\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    this.domElement = null;\n    /** The resolution used to convert between the DOM client space into world space. */\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary.EventBoundary(null);\n    EventTicker.EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this._eventsAdded = false;\n    this._rootPointerEvent = new FederatedPointerEvent.FederatedPointerEvent(null);\n    this._rootWheelEvent = new FederatedWheelEvent.FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === \"globalMove\") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this._onPointerDown = this._onPointerDown.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerUp = this._onPointerUp.bind(this);\n    this._onPointerOverOut = this._onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const { canvas, resolution } = this.renderer;\n    this.setTargetElement(canvas);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? \"passive\";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n    this._currentCursor = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n   * @param mode - Cursor mode to set. Can be:\n   * - A CSS cursor string (e.g., 'pointer', 'grab')\n   * - A key from the cursorStyles dictionary\n   * - null/undefined to reset to default\n   * @example\n   * ```ts\n   * // Using predefined cursor styles\n   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n   * app.renderer.events.setCursor('grab');       // Set grab cursor\n   * app.renderer.events.setCursor(null);         // Reset to default\n   *\n   * // Using custom cursor styles\n   * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n   * app.renderer.events.setCursor('custom');     // Apply custom cursor\n   *\n   * // Using callback-based cursor\n   * app.renderer.events.cursorStyles.dynamic = (mode) => {\n   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n   * };\n   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n   * ```\n   * @remarks\n   * - Has no effect on OffscreenCanvas except for callback-based cursors\n   * - Caches current cursor to avoid unnecessary DOM updates\n   * - Supports CSS cursor values, style objects, and callback functions\n   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n   */\n  setCursor(mode) {\n    mode || (mode = \"default\");\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this._currentCursor === mode) {\n      return;\n    }\n    this._currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case \"string\":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case \"function\":\n          style(mode);\n          break;\n        case \"object\":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  /**\n   * The global pointer event instance containing the most recent pointer state.\n   * This is useful for accessing pointer information without listening to events.\n   * @example\n   * ```ts\n   * // Access current pointer position at any time\n   * const eventSystem = app.renderer.events;\n   * const pointer = eventSystem.pointer;\n   *\n   * // Get global coordinates\n   * console.log('Position:', pointer.global.x, pointer.global.y);\n   *\n   * // Check button state\n   * console.log('Buttons pressed:', pointer.buttons);\n   *\n   * // Get pointer type and pressure\n   * console.log('Type:', pointer.pointerType);\n   * console.log('Pressure:', pointer.pressure);\n   * ```\n   * @readonly\n   * @since 7.2.0\n   * @see {@link FederatedPointerEvent} For all available pointer properties\n   */\n  get pointer() {\n    return this._rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this._normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  _onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    EventTicker.EventsTicker.pointerMoved();\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? \"outside\" : \"\";\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   * This method manages the DOM event bindings for the event system, allowing you to\n   * change or remove the target element that receives input events.\n   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n   * > should not need to call this unless you are using a custom element.\n   * @param element - The new DOM element to bind events to, or null to remove all event bindings\n   * @example\n   * ```ts\n   * // Set a new canvas element as the target\n   * const canvas = document.createElement('canvas');\n   * app.renderer.events.setTargetElement(canvas);\n   *\n   * // Remove all event bindings\n   * app.renderer.events.setTargetElement(null);\n   *\n   * // Switch to a different canvas\n   * const newCanvas = document.querySelector('#game-canvas');\n   * app.renderer.events.setTargetElement(newCanvas);\n   * ```\n   * @remarks\n   * - Automatically removes event listeners from previous element\n   * - Required for the event system to function\n   * - Safe to call multiple times\n   * @see {@link EventSystem#domElement} The current DOM element\n   * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n   */\n  setTargetElement(element) {\n    this._removeEvents();\n    this.domElement = element;\n    EventTicker.EventsTicker.domElement = element;\n    this._addEvents();\n  }\n  /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n  _addEvents() {\n    if (this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventTicker.EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"none\";\n        style.msTouchAction = \"none\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"none\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.addEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.addEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.addEventListener(\"wheel\", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this._eventsAdded = true;\n  }\n  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n  _removeEvents() {\n    if (!this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventTicker.EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"\";\n        style.msTouchAction = \"\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.removeEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.removeEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n    this.domElement = null;\n    this._eventsAdded = false;\n  }\n  /**\n   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n   * This takes into account the current scale, position, and resolution of the DOM element.\n   * @param point - The point to store the mapped coordinates in\n   * @param x - The x coordinate in DOM/client space\n   * @param y - The y coordinate in DOM/client space\n   * @example\n   * ```ts\n   * // Map mouse coordinates to PixiJS space\n   * const point = new Point();\n   * app.renderer.events.mapPositionToPoint(\n   *     point,\n   *     event.clientX,\n   *     event.clientY\n   * );\n   * console.log('Mapped position:', point.x, point.y);\n   *\n   * // Using with pointer events\n   * sprite.on('pointermove', (event) => {\n   *     // event.global already contains mapped coordinates\n   *     console.log('Global:', event.global.x, event.global.y);\n   *\n   *     // Map to local coordinates\n   *     const local = event.getLocalPosition(sprite);\n   *     console.log('Local:', local.x, local.y);\n   * });\n   * ```\n   * @remarks\n   * - Accounts for element scaling and positioning\n   * - Adjusts for device pixel ratio/resolution\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    };\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  _normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === \"undefined\")\n          touch.button = 0;\n        if (typeof touch.buttons === \"undefined\")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === \"undefined\") {\n          touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n        }\n        if (typeof touch.width === \"undefined\")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === \"undefined\")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === \"undefined\")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === \"undefined\")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === \"undefined\")\n          touch.pointerType = \"touch\";\n        if (typeof touch.pointerId === \"undefined\")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === \"undefined\")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === \"undefined\")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === \"undefined\")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === \"undefined\")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === \"undefined\")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === \"undefined\")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === \"undefined\")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === \"undefined\")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === \"undefined\")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === \"undefined\")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === \"undefined\")\n        tempEvent.pointerType = \"mouse\";\n      if (typeof tempEvent.pointerId === \"undefined\")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === \"undefined\")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === \"undefined\")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === \"undefined\")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this._rootWheelEvent;\n    this._transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  _bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this._transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === \"pointerleave\") {\n      event.type = \"pointerout\";\n    }\n    if (event.type.startsWith(\"mouse\")) {\n      event.type = event.type.replace(\"mouse\", \"pointer\");\n    }\n    if (event.type.startsWith(\"touch\")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  /**\n   * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  _transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n/** @ignore */\n_EventSystem.extension = {\n  name: \"events\",\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.CanvasSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * @since 7.2.0\n * @example\n * ```ts\n * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n * // Access the default event features\n * EventSystem.defaultEventFeatures = {\n *     // Enable pointer movement events\n *     move: true,\n *     // Enable global pointer move events\n *     globalMove: true,\n *     // Enable click events\n *     click: true,\n *     // Enable wheel events\n *     wheel: true,\n * };\n * ```\n */\n_EventSystem.defaultEventFeatures = {\n  /** Enables pointer events associated with pointer movement. */\n  move: true,\n  /** Enables global pointer move events. */\n  globalMove: true,\n  /** Enables pointer events associated with clicking. */\n  click: true,\n  /** Enables wheel events. */\n  wheel: true\n};\nlet EventSystem = _EventSystem;\n\nexports.EventSystem = EventSystem;\n//# sourceMappingURL=EventSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/EventSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventTicker.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventTicker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../ticker/const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\n\n\"use strict\";\nclass EventsTickerClass {\n  constructor() {\n    /** The frequency that fake events will be fired. */\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    if (this._tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker.Ticker.system.add(this._tickerUpdate, this, _const.UPDATE_PRIORITY.INTERACTION);\n    this._tickerAdded = true;\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    if (!this._tickerAdded) {\n      return;\n    }\n    Ticker.Ticker.system.remove(this._tickerUpdate, this);\n    this._tickerAdded = false;\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = true;\n  }\n  /** Updates the state of interactive objects. */\n  _update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events[\"_rootPointerEvent\"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === \"touch\") {\n      return;\n    }\n    globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent(\"pointermove\", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY,\n      pointerType: rootPointerEvent.pointerType,\n      pointerId: rootPointerEvent.pointerId\n    }) : new MouseEvent(\"mousemove\", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */\n  _tickerUpdate(ticker) {\n    this._deltaTime += ticker.deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this._update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\nexports.EventsTicker = EventsTicker;\n//# sourceMappingURL=EventTicker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/EventTicker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedEvent.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedEvent.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\n\n\"use strict\";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary's jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new Point.Point();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new Point.Point();\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    this.NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    this.CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    this.AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated `InteractionEvent.data`.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /**\n   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n   * @advanced\n   */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n   * @deprecated\n   * @ignore\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error(\"initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n   * @ignore\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error(\"initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /**\n   * Prevent default behavior of both PixiJS and the user agent.\n   * @example\n   * ```ts\n   * sprite.on('click', (event) => {\n   *     // Prevent both browser's default click behavior\n   *     // and PixiJS's default handling\n   *     event.preventDefault();\n   *\n   *     // Custom handling\n   *     customClickHandler();\n   * });\n   * ```\n   * @remarks\n   * - Only works if the native event is cancelable\n   * - Does not stop event propagation\n   */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any additional listeners, including those\n   * on the current target and any following targets in the propagation path.\n   * @example\n   * ```ts\n   * container.on('pointerdown', (event) => {\n   *     // Stop all further event handling\n   *     event.stopImmediatePropagation();\n   *\n   *     // These handlers won't be called:\n   *     // - Other pointerdown listeners on this container\n   *     // - Any pointerdown listeners on parent containers\n   * });\n   * ```\n   * @remarks\n   * - Immediately stops all event propagation\n   * - Prevents other listeners on same target from being called\n   * - More aggressive than stopPropagation()\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next target in the propagation path.\n   * The rest of the listeners on the current target will still be notified.\n   * @example\n   * ```ts\n   * child.on('pointermove', (event) => {\n   *     // Handle event on child\n   *     updateChild();\n   *\n   *     // Prevent parent handlers from being called\n   *     event.stopPropagation();\n   * });\n   *\n   * // This won't be called if child handles the event\n   * parent.on('pointermove', (event) => {\n   *     updateParent();\n   * });\n   * ```\n   * @remarks\n   * - Stops event bubbling to parent containers\n   * - Does not prevent other listeners on same target\n   * - Less aggressive than stopImmediatePropagation()\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\nexports.FederatedEvent = FederatedEvent;\n//# sourceMappingURL=FederatedEvent.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedEvent.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedEventMap.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedEventMap.js ***!
  \**************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=FederatedEventMap.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedEventMap.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedEventTarget.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedEventTarget.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventSystem = __webpack_require__(/*! ./EventSystem.js */ \"./node_modules/pixi.js/lib/events/EventSystem.js\");\nvar FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedEvent.js\");\n\n\"use strict\";\nconst FederatedContainer = {\n  onclick: null,\n  onmousedown: null,\n  onmouseenter: null,\n  onmouseleave: null,\n  onmousemove: null,\n  onglobalmousemove: null,\n  onmouseout: null,\n  onmouseover: null,\n  onmouseup: null,\n  onmouseupoutside: null,\n  onpointercancel: null,\n  onpointerdown: null,\n  onpointerenter: null,\n  onpointerleave: null,\n  onpointermove: null,\n  onglobalpointermove: null,\n  onpointerout: null,\n  onpointerover: null,\n  onpointertap: null,\n  onpointerup: null,\n  onpointerupoutside: null,\n  onrightclick: null,\n  onrightdown: null,\n  onrightup: null,\n  onrightupoutside: null,\n  ontap: null,\n  ontouchcancel: null,\n  ontouchend: null,\n  ontouchendoutside: null,\n  ontouchmove: null,\n  onglobaltouchmove: null,\n  ontouchstart: null,\n  onwheel: null,\n  get interactive() {\n    return this.eventMode === \"dynamic\" || this.eventMode === \"static\";\n  },\n  set interactive(value) {\n    this.eventMode = value ? \"static\" : \"passive\";\n  },\n  _internalEventMode: void 0,\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalEventMode = value;\n  },\n  isInteractive() {\n    return this.eventMode === \"static\" || this.eventMode === \"dynamic\";\n  },\n  interactiveChildren: true,\n  hitArea: null,\n  addEventListener(type, listener, options) {\n    const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n    const signal = typeof options === \"object\" ? options.signal : void 0;\n    const once = typeof options === \"object\" ? options.once === true : false;\n    const context = typeof listener === \"function\" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    const listenerFn = typeof listener === \"function\" ? listener : listener.handleEvent;\n    const emitter = this;\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        emitter.off(type, listenerFn, context);\n      });\n    }\n    if (once) {\n      emitter.once(type, listenerFn, context);\n    } else {\n      emitter.on(type, listenerFn, context);\n    }\n  },\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n    const context = typeof listener === \"function\" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === \"function\" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent.FederatedEvent)) {\n      throw new Error(\"Container cannot propagate events outside of the Federated Events API\");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\n\nexports.FederatedContainer = FederatedContainer;\n//# sourceMappingURL=FederatedEventTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedEventTarget.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedMouseEvent.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedEvent.js\");\n\n\"use strict\";\nclass FederatedMouseEvent extends FederatedEvent.FederatedEvent {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new Point.Point();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new Point.Point();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new Point.Point();\n    /** The pointer coordinates in world space. */\n    this.global = new Point.Point();\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new Point.Point();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * Converts global coordinates into container-local coordinates.\n   *\n   * This method transforms coordinates from world space to a container's local space,\n   * useful for precise positioning and hit testing.\n   * @param container - The Container to get local coordinates for\n   * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n   * @returns The local coordinates as a Point object\n   * @example\n   * ```ts\n   * // Basic usage - get local coordinates relative to a container\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Get position relative to the sprite\n   *     const localPos = event.getLocalPosition(sprite);\n   *     console.log('Local position:', localPos.x, localPos.y);\n   * });\n   * // Using custom global coordinates\n   * const customGlobal = new Point(100, 100);\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Transform custom coordinates\n   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n   *     console.log('Custom local position:', localPos.x, localPos.y);\n   * });\n   * ```\n   * @see {@link Container.worldTransform} For the transformation matrix\n   * @see {@link Point} For the point class used to store coordinates\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   * @ignore\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\nexports.FederatedMouseEvent = FederatedMouseEvent;\n//# sourceMappingURL=FederatedMouseEvent.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedMouseEvent.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedPointerEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedPointerEvent.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedMouseEvent.js\");\n\n\"use strict\";\nclass FederatedPointerEvent extends FederatedMouseEvent.FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getCoalescedEvents() {\n    if (this.type === \"pointermove\" || this.type === \"mousemove\" || this.type === \"touchmove\") {\n      return [this];\n    }\n    return [];\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getPredictedEvents() {\n    throw new Error(\"getPredictedEvents is not supported!\");\n  }\n}\n\nexports.FederatedPointerEvent = FederatedPointerEvent;\n//# sourceMappingURL=FederatedPointerEvent.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedPointerEvent.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedWheelEvent.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedWheelEvent.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedMouseEvent.js\");\n\n\"use strict\";\nclass FederatedWheelEvent extends FederatedMouseEvent.FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    this.DOM_DELTA_PIXEL = 0;\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    this.DOM_DELTA_LINE = 1;\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\n/**\n * Units specified in pixels.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\n/**\n * Units specified in lines.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\n/**\n * Units specified in pages.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\nexports.FederatedWheelEvent = FederatedWheelEvent;\n//# sourceMappingURL=FederatedWheelEvent.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/FederatedWheelEvent.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/deprecatedTypes.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/deprecatedTypes.js ***!
  \************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=deprecatedTypes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/deprecatedTypes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/index.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n__webpack_require__(/*! ./deprecatedTypes.js */ \"./node_modules/pixi.js/lib/events/deprecatedTypes.js\");\nvar EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ \"./node_modules/pixi.js/lib/events/EventBoundary.js\");\n__webpack_require__(/*! ./EventBoundaryTypes.js */ \"./node_modules/pixi.js/lib/events/EventBoundaryTypes.js\");\nvar EventSystem = __webpack_require__(/*! ./EventSystem.js */ \"./node_modules/pixi.js/lib/events/EventSystem.js\");\nvar EventTicker = __webpack_require__(/*! ./EventTicker.js */ \"./node_modules/pixi.js/lib/events/EventTicker.js\");\nvar FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedEvent.js\");\n__webpack_require__(/*! ./FederatedEventMap.js */ \"./node_modules/pixi.js/lib/events/FederatedEventMap.js\");\nvar FederatedEventTarget = __webpack_require__(/*! ./FederatedEventTarget.js */ \"./node_modules/pixi.js/lib/events/FederatedEventTarget.js\");\nvar FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedMouseEvent.js\");\nvar FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedPointerEvent.js\");\nvar FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedWheelEvent.js\");\n\n\"use strict\";\n\nexports.EventBoundary = EventBoundary.EventBoundary;\nexports.EventSystem = EventSystem.EventSystem;\nexports.EventsTicker = EventTicker.EventsTicker;\nexports.FederatedEvent = FederatedEvent.FederatedEvent;\nexports.FederatedContainer = FederatedEventTarget.FederatedContainer;\nexports.FederatedMouseEvent = FederatedMouseEvent.FederatedMouseEvent;\nexports.FederatedPointerEvent = FederatedPointerEvent.FederatedPointerEvent;\nexports.FederatedWheelEvent = FederatedWheelEvent.FederatedWheelEvent;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/events/init.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/init.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Container = __webpack_require__(/*! ../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar EventSystem = __webpack_require__(/*! ./EventSystem.js */ \"./node_modules/pixi.js/lib/events/EventSystem.js\");\nvar FederatedEventTarget = __webpack_require__(/*! ./FederatedEventTarget.js */ \"./node_modules/pixi.js/lib/events/FederatedEventTarget.js\");\n\n\"use strict\";\nExtensions.extensions.add(EventSystem.EventSystem);\nExtensions.extensions.mixin(Container.Container, FederatedEventTarget.FederatedContainer);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/events/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/extensions/Extensions.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/extensions/Extensions.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n  ExtensionType2[\"Batcher\"] = \"batcher\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed. Can be:\n   * - Extension class with static `extension` property\n   * - Extension format object with `type` and `ref`\n   * - Multiple extensions as separate arguments\n   * @returns {extensions} this for chaining\n   * @example\n   * ```ts\n   * // Remove a single extension\n   * extensions.remove(MyRendererPlugin);\n   *\n   * // Remove multiple extensions\n   * extensions.remove(\n   *     MyRendererPlugin,\n   *     MySystemPlugin\n   * );\n   * ```\n   * @see {@link ExtensionType} For available extension types\n   * @see {@link ExtensionFormat} For extension format details\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:\n   * - As a class with a static `extension` property\n   * - As an extension format object\n   * - As multiple extensions passed as separate arguments\n   * @param extensions - Extensions to add to PixiJS. Each can be:\n   * - A class with static `extension` property\n   * - An extension format object with `type` and `ref`\n   * - Multiple extensions as separate arguments\n   * @returns This extensions instance for chaining\n   * @example\n   * ```ts\n   * // Register a simple extension\n   * extensions.add(MyRendererPlugin);\n   *\n   * // Register multiple extensions\n   * extensions.add(\n   *     MyRendererPlugin,\n   *     MySystemPlugin,\n   * });\n   * ```\n   * @see {@link ExtensionType} For available extension types\n   * @see {@link ExtensionFormat} For extension format details\n   * @see {@link extensions.remove} For removing registered extensions\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns this for chaining.\n   * @internal\n   * @ignore\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns this for chaining.\n   * @ignore\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns this for chaining.\n   * @ignore\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns this for chaining.\n   * @ignore\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Mixin the source object(s) properties into the target class's prototype.\n   * Copies all property descriptors from source objects to the target's prototype.\n   * @param Target - The target class to mix properties into\n   * @param sources - One or more source objects containing properties to mix in\n   * @example\n   * ```ts\n   * // Create a mixin with shared properties\n   * const moveable = {\n   *     x: 0,\n   *     y: 0,\n   *     move(x: number, y: number) {\n   *         this.x += x;\n   *         this.y += y;\n   *     }\n   * };\n   *\n   * // Create a mixin with computed properties\n   * const scalable = {\n   *     scale: 1,\n   *     get scaled() {\n   *         return this.scale > 1;\n   *     }\n   * };\n   *\n   * // Apply mixins to a class\n   * extensions.mixin(Sprite, moveable, scalable);\n   *\n   * // Use mixed-in properties\n   * const sprite = new Sprite();\n   * sprite.move(10, 20);\n   * console.log(sprite.x, sprite.y); // 10, 20\n   * ```\n   * @remarks\n   * - Copies all properties including getters/setters\n   * - Does not modify source objects\n   * - Preserves property descriptors\n   * @see {@link Object.defineProperties} For details on property descriptors\n   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying\n   */\n  mixin(Target, ...sources) {\n    for (const source of sources) {\n      Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n  }\n};\n\nexports.ExtensionType = ExtensionType;\nexports.extensions = extensions;\nexports.normalizeExtensionPriority = normalizeExtensionPriority;\n//# sourceMappingURL=Extensions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/extensions/Extensions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/extensions/index.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/extensions/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ./Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\n\nexports.ExtensionType = Extensions.ExtensionType;\nexports.extensions = Extensions.extensions;\nexports.normalizeExtensionPriority = Extensions.normalizeExtensionPriority;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/extensions/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/Filter.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/Filter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar Shader = __webpack_require__(/*! ../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar State = __webpack_require__(/*! ../rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader.Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexports.Filter = Filter;\n//# sourceMappingURL=Filter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/Filter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterEffect.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterEffect.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = \"filter\";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexports.FilterEffect = FilterEffect;\n//# sourceMappingURL=FilterEffect.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/FilterEffect.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterPipe.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterPipe.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexports.FilterPipe = FilterPipe;\n//# sourceMappingURL=FilterPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/FilterPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterSystem.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterSystem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar BindGroup = __webpack_require__(/*! ../rendering/renderers/gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar Geometry = __webpack_require__(/*! ../rendering/renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar UniformGroup = __webpack_require__(/*! ../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Texture = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TexturePool = __webpack_require__(/*! ../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar types = __webpack_require__(/*! ../rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar Bounds = __webpack_require__(/*! ../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getRenderableBounds = __webpack_require__(/*! ../scene/container/bounds/getRenderableBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js\");\nvar warn = __webpack_require__(/*! ../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nconst quadGeometry = new Geometry.Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds.Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup.UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup.BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    this._setupBindGroupsAndRender(filter, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === types.RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.Texture.EMPTY;\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    filterData.inputTexture = TexturePool.TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture.Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture.Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getRenderableBounds.getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn.warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 1) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexports.FilterSystem = FilterSystem;\n//# sourceMappingURL=FilterSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/FilterSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar Filter = __webpack_require__(/*! ../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar blendTemplate$1 = __webpack_require__(/*! ./blend-template.frag.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js\");\nvar blendTemplate$2 = __webpack_require__(/*! ./blend-template.vert.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js\");\nvar blendTemplate = __webpack_require__(/*! ./blend-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js\");\n\n\"use strict\";\nclass BlendModeFilter extends Filter.Filter {\n  constructor(options) {\n    const gpuOptions = options.gpu;\n    const gpuSource = compileBlendModeShader({ source: blendTemplate.default, ...gpuOptions });\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: gpuSource,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: gpuSource,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glOptions = options.gl;\n    const glSource = compileBlendModeShader({ source: blendTemplate$1.default, ...glOptions });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: blendTemplate$2.default,\n      fragment: glSource\n    });\n    const uniformGroup = new UniformGroup.UniformGroup({\n      uBlend: {\n        value: 1,\n        type: \"f32\"\n      }\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      blendRequired: true,\n      resources: {\n        blendUniforms: uniformGroup,\n        uBackTexture: Texture.Texture.EMPTY\n      }\n    });\n  }\n}\nfunction compileBlendModeShader(options) {\n  const { source, functions, main } = options;\n  return source.replace(\"{FUNCTIONS}\", functions).replace(\"{MAIN}\", main);\n}\n\nexports.BlendModeFilter = BlendModeFilter;\n//# sourceMappingURL=BlendModeFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar blendTemplateFrag = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uBlend;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uBackTexture;\\n\\n{FUNCTIONS}\\n\\nvoid main()\\n{ \\n    vec4 back = texture(uBackTexture, vTextureCoord);\\n    vec4 front = texture(uTexture, vTextureCoord);\\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\\n    \\n    {MAIN}\\n}\\n\";\n\nexports[\"default\"] = blendTemplateFrag;\n//# sourceMappingURL=blend-template.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar blendTemplateVert = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 backgroundUv;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexports[\"default\"] = blendTemplateVert;\n//# sourceMappingURL=blend-template.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar blendTemplate = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlendUniforms {\\n  uBlend:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\\n\\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n{FUNCTIONS}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>\\n) -> @location(0) vec4<f32> {\\n\\n\\n   var back =  textureSample(uBackTexture, uSampler, uv);\\n   var front = textureSample(uTexture, uSampler, uv);\\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\\n   \\n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\\n\\n   {MAIN}\\n\\n   return out;\\n}\";\n\nexports[\"default\"] = blendTemplate;\n//# sourceMappingURL=blend-template.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst hslgl = `\n\tfloat getLuminosity(vec3 c) {\n\t\treturn 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n\t}\n\n\tvec3 setLuminosity(vec3 c, float lum) {\n\t\tfloat modLum = lum - getLuminosity(c);\n\t\tvec3 color = c.rgb + vec3(modLum);\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tvec3 modLumVec = vec3(modLum);\n\n\t\tfloat cMin = min(color.r, min(color.g, color.b));\n\t\tfloat cMax = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0) {\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0) {\n\t\t\tcolor = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfloat getSaturation(vec3 c) {\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tvec3 setSaturationMinMidMax(vec3 cSorted, float s) {\n\t\tvec3 colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x) {\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse {\n\t\t\tcolorSorted.y = 0.0;\n\t\t\tcolorSorted.z = 0.0;\n\t\t}\n\n\t\tcolorSorted.x = 0.0;\n\n\t\treturn colorSorted;\n\t}\n\n\tvec3 setSaturation(vec3 c, float s) {\n\t\tvec3 color = c;\n\n\t\tif(color.r <= color.g && color.r <= color.b) {\n\t\t\tif(color.g <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rgb, s).rgb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rbg, s).rbg;\n\t\t\t}\n\t\t}\n\t\telse if(color.g <= color.r && color.g <= color.b) {\n\t\t\tif(color.r <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.grb, s).grb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.gbr, s).gbr;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif(color.r <= color.g) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.brg, s).brg;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.bgr, s).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n    `;\n\nexports.hslgl = hslgl;\n//# sourceMappingURL=GLhls.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst hslgpu = `\n\tfn getLuminosity(c: vec3<f32>) -> f32\n\t{\n\t\treturn 0.3*c.r + 0.59*c.g + 0.11*c.b;\n\t}\n\n\tfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>\n\t{\n\t\tvar modLum: f32 = lum - getLuminosity(c);\n\t\tvar color: vec3<f32> = c.rgb + modLum;\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tlet modLumVec = vec3<f32>(modLum);\n\n\t\tlet cMin: f32 = min(color.r, min(color.g, color.b));\n\t\tlet cMax: f32 = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfn getSaturation(c: vec3<f32>) -> f32\n\t{\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x)\n\t\t{\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolorSorted.y = 0;\n\t\t\tcolorSorted.z = 0;\n\t\t}\n\n\t\tcolorSorted.x = 0;\n\n\t\treturn colorSorted;\n\t}\n\n\tfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar color = c;\n\n\t\tif (color.r <= color.g && color.r <= color.b)\n\t\t{\n\t\t\tif (color.g <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;\n\t\t\t}\n\t\t}\n\t\telse if (color.g <= color.r && color.g <= color.b)\n\t\t{\n\t\t\tif (color.r <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif (color.r <= color.g)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n\t`;\n\nexports.hslgpu = hslgpu;\n//# sourceMappingURL=GPUhls.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar hsl = \"fn getLuminosity(c: vec3<f32>) -> f32 {\\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\\n}\\n\\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\\n  let d: f32 = lum - getLuminosity(c);\\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\\n\\n  // clip back into legal range\\n  let newLum: f32 = getLuminosity(newColor);\\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\\n\\n  let t1: f32 = newLum / (newLum - cMin);\\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\\n\\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\\n\\n  return finalColor;\\n}\\n\\nfn getSaturation(c: vec3<f32>) -> f32 {\\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\\n}\\n\\n// Set saturation if color components are sorted in ascending order.\\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\\n  var result: vec3<f32>;\\n  if (cSorted.z > cSorted.x) {\\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\\n    result = vec3<f32>(0.0, newY, s);\\n  } else {\\n    result = vec3<f32>(0.0, 0.0, 0.0);\\n  }\\n  return vec3<f32>(result.x, result.y, result.z);\\n}\\n\\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\\n    var result: vec3<f32> = c;\\n\\n    if (c.r <= c.g && c.r <= c.b) {\\n        if (c.g <= c.b) {\\n            result = setSaturationMinMidMax(result, s);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.r, temp.b, temp.g);\\n        }\\n    } else if (c.g <= c.r && c.g <= c.b) {\\n        if (c.r <= c.b) {\\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.g, temp.r, temp.b);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.g, temp.b, temp.r);\\n        }\\n    } else {\\n        if (c.r <= c.g) {\\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.b, temp.r, temp.g);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.b, temp.g, temp.r);\\n        }\\n    }\\n\\n    return result;\\n}\";\n\nexports[\"default\"] = hsl;\n//# sourceMappingURL=hsl.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar defaultFilter = __webpack_require__(/*! ../defaultFilter.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js\");\nvar alpha$1 = __webpack_require__(/*! ./alpha.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js\");\nvar alpha = __webpack_require__(/*! ./alpha.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js\");\n\n\"use strict\";\nconst _AlphaFilter = class _AlphaFilter extends Filter.Filter {\n  constructor(options) {\n    options = { ..._AlphaFilter.defaultOptions, ...options };\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: alpha.default,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: alpha.default,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: defaultFilter.default,\n      fragment: alpha$1.default,\n      name: \"alpha-filter\"\n    });\n    const { alpha: alpha$2, ...rest } = options;\n    const alphaUniforms = new UniformGroup.UniformGroup({\n      uAlpha: { value: alpha$2, type: \"f32\" }\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        alphaUniforms\n      }\n    });\n  }\n  /**\n   * The alpha value of the filter.\n   * Controls the transparency of the filtered display object.\n   * @example\n   * ```ts\n   * // Create filter with initial alpha\n   * const filter = new AlphaFilter({ alpha: 0.5 });\n   *\n   * // Update alpha value dynamically\n   * filter.alpha = 0.8;\n   * ```\n   * @default 1\n   * @remarks\n   * - 0 = fully transparent\n   * - 1 = fully opaque\n   * - Values are clamped between 0 and 1\n   */\n  get alpha() {\n    return this.resources.alphaUniforms.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.resources.alphaUniforms.uniforms.uAlpha = value;\n  }\n};\n/**\n * Default options for the AlphaFilter.\n * @example\n * ```ts\n * AlphaFilter.defaultOptions = {\n *     alpha: 0.5, // Default alpha value\n * };\n * // Use default options\n * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n * ```\n */\n_AlphaFilter.defaultOptions = {\n  /**\n   * Amount of alpha transparency to apply.\n   * - 0 = fully transparent\n   * - 1 = fully opaque (default)\n   * @default 1\n   */\n  alpha: 1\n};\nlet AlphaFilter = _AlphaFilter;\n\nexports.AlphaFilter = AlphaFilter;\n//# sourceMappingURL=AlphaFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"\\nin vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform float uAlpha;\\nuniform sampler2D uTexture;\\n\\nvoid main()\\n{\\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\\n}\\n\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=alpha.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct AlphaUniforms {\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    \\n    return sample * alphaUniforms.uAlpha;\\n}\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=alpha.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TexturePool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar types = __webpack_require__(/*! ../../../rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar BlurFilterPass = __webpack_require__(/*! ./BlurFilterPass.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js\");\n\n\"use strict\";\nclass BlurFilter extends Filter.Filter {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation.deprecation(deprecation.v8_0_0, \"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.resolution = args[2] || \"inherit\";\n      if (args[3] !== void 0)\n        options.kernelSize = args[3];\n    }\n    options = { ...BlurFilterPass.BlurFilterPass.defaultOptions, ...options };\n    const { strength, strengthX, strengthY, quality, ...rest } = options;\n    super({\n      ...rest,\n      compatibleRenderers: types.RendererType.BOTH,\n      resources: {}\n    });\n    this._repeatEdgePixels = false;\n    this.blurXFilter = new BlurFilterPass.BlurFilterPass({ horizontal: true, ...options });\n    this.blurYFilter = new BlurFilterPass.BlurFilterPass({ horizontal: false, ...options });\n    this.quality = quality;\n    this.strengthX = strengthX ?? strength;\n    this.strengthY = strengthY ?? strength;\n    this.repeatEdgePixels = false;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   * @advanced\n   */\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength);\n    const yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const tempTexture = TexturePool.TexturePool.getSameSizeTexture(input);\n      this.blurXFilter.blendMode = \"normal\";\n      this.blurXFilter.apply(filterManager, input, tempTexture, true);\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);\n      TexturePool.TexturePool.returnTexture(tempTexture);\n    } else if (yStrength) {\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.blendMode = this.blendMode;\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  }\n  updatePadding() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;\n    }\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously.\n   * Controls the overall intensity of the Gaussian blur effect.\n   * @example\n   * ```ts\n   * // Set equal blur strength for both axes\n   * filter.strength = 8;\n   *\n   * // Will throw error if X and Y are different\n   * filter.strengthX = 4;\n   * filter.strengthY = 8;\n   * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n   * ```\n   * @default 8\n   * @throws {Error} If strengthX and strengthY are different values\n   */\n  get strength() {\n    if (this.strengthX !== this.strengthY) {\n      throw new Error(\"BlurFilter's strengthX and strengthY are different\");\n    }\n    return this.strengthX;\n  }\n  set strength(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the number of passes for blur. More passes means higher quality blurring.\n   * Controls the precision and smoothness of the blur effect at the cost of performance.\n   * @example\n   * ```ts\n   * // High quality blur (slower)\n   * filter.quality = 8;\n   *\n   * // Low quality blur (faster)\n   * filter.quality = 2;\n   * ```\n   * @default 4\n   * @remarks Higher values produce better quality but impact performance\n   */\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  /**\n   * Sets the strength of horizontal blur.\n   * Controls the blur intensity along the x-axis independently.\n   * @example\n   * ```ts\n   * // Apply horizontal-only blur\n   * filter.strengthX = 8;\n   * filter.strengthY = 0;\n   *\n   * // Create motion blur effect\n   * filter.strengthX = 16;\n   * filter.strengthY = 2;\n   * ```\n   * @default 8\n   */\n  get strengthX() {\n    return this.blurXFilter.blur;\n  }\n  set strengthX(value) {\n    this.blurXFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of the vertical blur.\n   * Controls the blur intensity along the y-axis independently.\n   * @example\n   * ```ts\n   * // Apply vertical-only blur\n   * filter.strengthX = 0;\n   * filter.strengthY = 8;\n   *\n   * // Create radial blur effect\n   * filter.strengthX = 8;\n   * filter.strengthY = 8;\n   * ```\n   * @default 8\n   */\n  get strengthY() {\n    return this.blurYFilter.blur;\n  }\n  set strengthY(value) {\n    this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strength\n   */\n  get blur() {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    return this.strength;\n  }\n  set blur(value) {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    this.strength = value;\n  }\n  /**\n   * Sets the strength of the blurX property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthX\n   */\n  get blurX() {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    return this.strengthX;\n  }\n  set blurX(value) {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    this.strengthX = value;\n  }\n  /**\n   * Sets the strength of the blurY property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthY\n   */\n  get blurY() {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    return this.strengthY;\n  }\n  set blurY(value) {\n    deprecation.deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    this.strengthY = value;\n  }\n  /**\n   * If set to true the edge of the target will be clamped\n   * @default false\n   */\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value;\n    this.updatePadding();\n  }\n}\n/**\n * Default blur filter options\n * @example\n * ```ts\n * // Set default options for all BlurFilters\n * BlurFilter.defaultOptions = {\n *     strength: 10,       // Default blur strength\n *     quality: 2,        // Default blur quality\n *     kernelSize: 7      // Default kernel size\n * };\n * // Create a filter with these defaults\n * const filter = new BlurFilter(); // Uses default options\n * ```\n * @remarks\n * - These options are used when creating a new BlurFilter without specific parameters\n * - Can be overridden by passing options to the constructor\n * - Useful for setting global defaults for all blur filters in your application\n * @see {@link BlurFilterOptions} For detailed options\n * @see {@link BlurFilter} The filter that uses these options\n */\nBlurFilter.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\n\nexports.BlurFilter = BlurFilter;\n//# sourceMappingURL=BlurFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TexturePool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar types = __webpack_require__(/*! ../../../rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar generateBlurGlProgram = __webpack_require__(/*! ./gl/generateBlurGlProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js\");\nvar generateBlurProgram = __webpack_require__(/*! ./gpu/generateBlurProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js\");\n\n\"use strict\";\nconst _BlurFilterPass = class _BlurFilterPass extends Filter.Filter {\n  /**\n   * @param options\n   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n   * @param options.strength - The strength of the blur filter.\n   * @param options.quality - The quality of the blur filter.\n   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n   */\n  constructor(options) {\n    options = { ..._BlurFilterPass.defaultOptions, ...options };\n    const glProgram = generateBlurGlProgram.generateBlurGlProgram(options.horizontal, options.kernelSize);\n    const gpuProgram = generateBlurProgram.generateBlurProgram(options.horizontal, options.kernelSize);\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        blurUniforms: {\n          uStrength: { value: 0, type: \"f32\" }\n        }\n      },\n      ...options\n    });\n    this.horizontal = options.horizontal;\n    this._quality = 0;\n    this.quality = options.quality;\n    this.blur = options.strength;\n    this._uniforms = this.resources.blurUniforms.uniforms;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   */\n  apply(filterManager, input, output, clearMode) {\n    this._uniforms.uStrength = this.strength / this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const tempTexture = TexturePool.TexturePool.getSameSizeTexture(input);\n      let flip = input;\n      let flop = tempTexture;\n      this._state.blend = false;\n      const shouldClear = filterManager.renderer.type === types.RendererType.WEBGPU;\n      for (let i = 0; i < this.passes - 1; i++) {\n        filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);\n        const temp = flop;\n        flop = flip;\n        flip = temp;\n      }\n      this._state.blend = true;\n      filterManager.applyFilter(this, flip, output, clearMode);\n      TexturePool.TexturePool.returnTexture(tempTexture);\n    }\n  }\n  /**\n   * Sets the strength of both the blur.\n   * @default 16\n   */\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2;\n    this.strength = value;\n  }\n  /**\n   * Sets the quality of the blur by modifying the number of passes. More passes means higher\n   * quality blurring but the lower the performance.\n   * @default 4\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.passes = value;\n  }\n};\n/** Default blur filter pass options */\n_BlurFilterPass.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\nlet BlurFilterPass = _BlurFilterPass;\n\nexports.BlurFilterPass = BlurFilterPass;\n//# sourceMappingURL=BlurFilterPass.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/const.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/const.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\n\nexports.GAUSSIAN_VALUES = GAUSSIAN_VALUES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/const.js\");\n\n\"use strict\";\nconst fragTemplate = [\n  \"in vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uTexture;\",\n  \"out vec4 finalColor;\",\n  \"void main(void)\",\n  \"{\",\n  \"    finalColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(\"\\n\");\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = _const.GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  let fragSource = fragTemplate;\n  let blurLoop = \"\";\n  const template = \"finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;\";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    value = i;\n    if (i >= halfLength) {\n      value = kernelSize - i - 1;\n    }\n    blur = blur.replace(\"%value%\", kernel[value].toString());\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  fragSource = fragSource.replace(\"%blur%\", blurLoop);\n  fragSource = fragSource.replace(\"%size%\", kernelSize.toString());\n  return fragSource;\n}\n\nexports.generateBlurFragSource = generateBlurFragSource;\n//# sourceMappingURL=generateBlurFragSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar generateBlurFragSource = __webpack_require__(/*! ./generateBlurFragSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js\");\nvar generateBlurVertSource = __webpack_require__(/*! ./generateBlurVertSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js\");\n\n\"use strict\";\nfunction generateBlurGlProgram(horizontal, kernelSize) {\n  const vertex = generateBlurVertSource.generateBlurVertSource(kernelSize, horizontal);\n  const fragment = generateBlurFragSource.generateBlurFragSource(kernelSize);\n  return GlProgram.GlProgram.from({\n    vertex,\n    fragment,\n    name: `blur-${horizontal ? \"horizontal\" : \"vertical\"}-pass-filter`\n  });\n}\n\nexports.generateBlurGlProgram = generateBlurGlProgram;\n//# sourceMappingURL=generateBlurGlProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst vertTemplate = `\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate;\n  let blurLoop = \"\";\n  let template;\n  if (x) {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);\";\n  } else {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);\";\n  }\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    blur = blur.replace(\"%sampleIndex%\", `${i - (halfLength - 1)}.0`);\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  vertSource = vertSource.replace(\"%blur%\", blurLoop);\n  vertSource = vertSource.replace(\"%size%\", kernelSize.toString());\n  vertSource = vertSource.replace(\"%dimension%\", x ? \"z\" : \"w\");\n  return vertSource;\n}\n\nexports.generateBlurVertSource = generateBlurVertSource;\n//# sourceMappingURL=generateBlurVertSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlurUniforms {\\n  uStrength:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    %blur-struct%\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n\\n  let filteredCord = filterTextureCoord(aPosition);\\n\\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\\n\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n    %blur-vertex-out%\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  %blur-fragment-in%\\n) -> @location(0) vec4<f32> {\\n\\n    var   finalColor = vec4(0.0);\\n\\n    %blur-sampling%\\n\\n    return finalColor;\\n}\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=blur-template.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GpuProgram = __webpack_require__(/*! ../../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/const.js\");\nvar blurTemplate = __webpack_require__(/*! ./blur-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js\");\n\n\"use strict\";\nfunction generateBlurProgram(horizontal, kernelSize) {\n  const kernel = _const.GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  const blurStructSource = [];\n  const blurOutSource = [];\n  const blurSamplingSource = [];\n  for (let i = 0; i < kernelSize; i++) {\n    blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;\n    if (horizontal) {\n      blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;\n    } else {\n      blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;\n    }\n    const kernelIndex = i < halfLength ? i : kernelSize - i - 1;\n    const kernelValue = kernel[kernelIndex].toString();\n    blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;\n  }\n  const blurStruct = blurStructSource.join(\"\\n\");\n  const blurOut = blurOutSource.join(\"\\n\");\n  const blurSampling = blurSamplingSource.join(\"\\n\");\n  const finalSource = blurTemplate.default.replace(\"%blur-struct%\", blurStruct).replace(\"%blur-vertex-out%\", blurOut).replace(\"%blur-fragment-in%\", blurStruct).replace(\"%blur-sampling%\", blurSampling).replace(\"%dimension%\", horizontal ? \"z\" : \"w\");\n  return GpuProgram.GpuProgram.from({\n    vertex: {\n      source: finalSource,\n      entryPoint: \"mainVertex\"\n    },\n    fragment: {\n      source: finalSource,\n      entryPoint: \"mainFragment\"\n    }\n  });\n}\n\nexports.generateBlurProgram = generateBlurProgram;\n//# sourceMappingURL=generateBlurProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar GlProgram = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar defaultFilter = __webpack_require__(/*! ../defaultFilter.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js\");\nvar colorMatrixFilter$1 = __webpack_require__(/*! ./colorMatrixFilter.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js\");\nvar colorMatrixFilter = __webpack_require__(/*! ./colorMatrixFilter.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js\");\n\n\"use strict\";\nclass ColorMatrixFilter extends Filter.Filter {\n  constructor(options = {}) {\n    const colorMatrixUniforms = new UniformGroup.UniformGroup({\n      uColorMatrix: {\n        value: [\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0\n        ],\n        type: \"f32\",\n        size: 20\n      },\n      uAlpha: {\n        value: 1,\n        type: \"f32\"\n      }\n    });\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: colorMatrixFilter.default,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: colorMatrixFilter.default,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: defaultFilter.default,\n      fragment: colorMatrixFilter$1.default,\n      name: \"color-matrix-filter\"\n    });\n    super({\n      ...options,\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorMatrixUniforms\n      }\n    });\n    this.alpha = 1;\n  }\n  /**\n   * Transforms current matrix and set the new one\n   * @param {number[]} matrix - 5x4 matrix\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with matrix\n   */\n  _loadMatrix(matrix, multiply = false) {\n    let newMatrix = matrix;\n    if (multiply) {\n      this._multiply(newMatrix, this.matrix, matrix);\n      newMatrix = this._colorMatrix(newMatrix);\n    }\n    this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;\n    this.resources.colorMatrixUniforms.update();\n  }\n  /**\n   * Multiplies two mat5's\n   * @private\n   * @param out - 5x4 matrix the receiving matrix\n   * @param a - 5x4 matrix the first operand\n   * @param b - 5x4 matrix the second operand\n   * @returns {number[]} 5x4 matrix\n   */\n  _multiply(out, a, b) {\n    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];\n    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];\n    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];\n    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];\n    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];\n    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];\n    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];\n    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];\n    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];\n    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];\n    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];\n    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];\n    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];\n    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];\n    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];\n    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];\n    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];\n    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];\n    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];\n    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];\n    return out;\n  }\n  /**\n   * Create a Float32 Array and normalize the offset component to 0-1\n   * @param {number[]} matrix - 5x4 matrix\n   * @returns {number[]} 5x4 matrix with all values between 0-1\n   */\n  _colorMatrix(matrix) {\n    const m = new Float32Array(matrix);\n    m[4] /= 255;\n    m[9] /= 255;\n    m[14] /= 255;\n    m[19] /= 255;\n    return m;\n  }\n  /**\n   * Adjusts the brightness of a display object.\n   *\n   * The brightness adjustment works by multiplying the RGB channels by a scalar value while keeping\n   * the alpha channel unchanged. Values below 1 darken the image, while values above 1 brighten it.\n   * @param b - The brightness multiplier to apply. Values between 0-1 darken the image (0 being black),\n   *           while values > 1 brighten it (2.0 would make it twice as bright)\n   * @param multiply - When true, the new matrix is multiplied with the current one instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * // Create a new color matrix filter\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Darken the image to 50% brightness\n   * colorMatrix.brightness(0.5, false);\n   *\n   * // Chain with other effects by using multiply\n   * colorMatrix\n   *     .brightness(1.2, true)  // Brighten by 20%\n   *     .saturate(1.1, true);   // Increase saturation by 10%\n   * ```\n   */\n  brightness(b, multiply) {\n    const matrix = [\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Sets each channel on the diagonal of the color matrix to apply a color tint.\n   *\n   * This method provides a way to tint display objects using the color matrix filter, similar to\n   * the tint property available on Sprites and other display objects. The tint is applied by\n   * scaling the RGB channels of each pixel.\n   * @param color - The color to use for tinting, this can be any valid color source.\n   * @param multiply - When true, the new tint matrix is multiplied with the current matrix instead\n   *                  of replacing it. This allows for combining tints with other color effects.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply a red tint\n   * colorMatrix.tint(0xff0000);\n   *\n   * // Layer a green tint on top of existing effects\n   * colorMatrix.tint('green', true);\n   *\n   * // Chain with other color adjustments\n   * colorMatrix\n   *     .tint('blue')       // Blue tint\n   *     .brightness(1.2, true) // Increase brightness\n   * ```\n   */\n  tint(color, multiply) {\n    const [r, g, b] = Color.Color.shared.setValue(color).toArray();\n    const matrix = [\n      r,\n      0,\n      0,\n      0,\n      0,\n      0,\n      g,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Converts the display object to greyscale by applying a weighted matrix transformation.\n   *\n   * The greyscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n   * effectively removing color information while preserving luminance.\n   * @param scale - The intensity of the greyscale effect. Value between 0-1, where:\n   *               - 0 produces black\n   *               - 0.5 produces 50% grey\n   *               - 1 produces white\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Convert to 50% grey\n   * colorMatrix.greyscale(0.5, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .greyscale(0.6, true)    // Add grey tint\n   *     .brightness(1.2, true);   // Brighten the result\n   * ```\n   */\n  greyscale(scale, multiply) {\n    const matrix = [\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Converts the display object to grayscale by applying a weighted matrix transformation.\n   *\n   * The grayscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n   * effectively removing color information while preserving luminance.\n   * @param scale - The intensity of the grayscale effect. Value between 0-1, where:\n   *               - 0 produces black\n   *               - 0.5 produces 50% grey\n   *               - 1 produces white\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Convert to 50% grey\n   * colorMatrix.grayscale(0.5, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .grayscale(0.6, true)    // Add grey tint\n   *     .brightness(1.2, true);   // Brighten the result\n   * ```\n   */\n  grayscale(scale, multiply) {\n    this.greyscale(scale, multiply);\n  }\n  /**\n   * Converts the display object to pure black and white using a luminance-based threshold.\n   *\n   * This method applies a matrix transformation that removes all color information and reduces\n   * the image to just black and white values based on the luminance of each pixel. The transformation\n   * uses standard luminance weightings: 30% red, 60% green, and 10% blue.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Convert to black and white\n   * colorMatrix.blackAndWhite(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .blackAndWhite(true)     // Apply B&W effect\n   *     .brightness(1.2, true);   // Then increase brightness\n   * ```\n   */\n  blackAndWhite(multiply) {\n    const matrix = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Adjusts the hue of the display object by rotating the color values around the color wheel.\n   *\n   * This method uses an optimized matrix transformation that accurately rotates the RGB color space\n   * around its luminance axis. The implementation is based on RGB cube rotation in 3D space, providing\n   * better results than traditional matrices with magic luminance constants.\n   * @param rotation - The angle of rotation in degrees around the color wheel:\n   *                  - 0 = no change\n   *                  - 90 = rotate colors 90° clockwise\n   *                  - 180 = invert all colors\n   *                  - 270 = rotate colors 90° counter-clockwise\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Rotate hue by 90 degrees\n   * colorMatrix.hue(90, false);\n   *\n   * // Chain multiple color adjustments\n   * colorMatrix\n   *     .hue(45, true)          // Rotate colors by 45°\n   *     .saturate(1.2, true)    // Increase saturation\n   *     .brightness(1.1, true); // Slightly brighten\n   * ```\n   */\n  hue(rotation, multiply) {\n    rotation = (rotation || 0) / 180 * Math.PI;\n    const cosR = Math.cos(rotation);\n    const sinR = Math.sin(rotation);\n    const sqrt = Math.sqrt;\n    const w = 1 / 3;\n    const sqrW = sqrt(w);\n    const a00 = cosR + (1 - cosR) * w;\n    const a01 = w * (1 - cosR) - sqrW * sinR;\n    const a02 = w * (1 - cosR) + sqrW * sinR;\n    const a10 = w * (1 - cosR) + sqrW * sinR;\n    const a11 = cosR + w * (1 - cosR);\n    const a12 = w * (1 - cosR) - sqrW * sinR;\n    const a20 = w * (1 - cosR) - sqrW * sinR;\n    const a21 = w * (1 - cosR) + sqrW * sinR;\n    const a22 = cosR + w * (1 - cosR);\n    const matrix = [\n      a00,\n      a01,\n      a02,\n      0,\n      0,\n      a10,\n      a11,\n      a12,\n      0,\n      0,\n      a20,\n      a21,\n      a22,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Adjusts the contrast of the display object by modifying the separation between dark and bright values.\n   *\n   * This method applies a matrix transformation that affects the difference between dark and light areas\n   * in the image. Increasing contrast makes shadows darker and highlights brighter, while decreasing\n   * contrast brings shadows up and highlights down, reducing the overall dynamic range.\n   * @param amount - The contrast adjustment value. Range is 0 to 1, where:\n   *                - 0 represents minimum contrast (flat gray)\n   *                - 0.5 represents normal contrast\n   *                - 1 represents maximum contrast\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Increase contrast by 50%\n   * colorMatrix.contrast(0.75, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .contrast(0.6, true)     // Boost contrast\n   *     .brightness(1.1, true)   // Slightly brighten\n   *     .saturate(1.2, true);    // Increase color intensity\n   * ```\n   */\n  contrast(amount, multiply) {\n    const v = (amount || 0) + 1;\n    const o = -0.5 * (v - 1);\n    const matrix = [\n      v,\n      0,\n      0,\n      0,\n      o,\n      0,\n      v,\n      0,\n      0,\n      o,\n      0,\n      0,\n      v,\n      0,\n      o,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Adjusts the saturation of the display object by modifying color separation.\n   *\n   * This method applies a matrix transformation that affects the intensity of colors.\n   * Increasing saturation makes colors more vivid and intense, while decreasing saturation\n   * moves colors toward grayscale.\n   * @param amount - The saturation adjustment value. Range is -1 to 1, where:\n   *                - -1 produces grayscale\n   *                - 0 represents no change\n   *                - 1 produces maximum saturation\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Double the saturation\n   * colorMatrix.saturate(1, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .saturate(0.5, true)     // Increase saturation by 50%\n   *     .brightness(1.1, true)    // Slightly brighten\n   *     .contrast(0.8, true);     // Reduce contrast\n   * ```\n   */\n  saturate(amount = 0, multiply) {\n    const x = amount * 2 / 3 + 1;\n    const y = (x - 1) * -0.5;\n    const matrix = [\n      x,\n      y,\n      y,\n      0,\n      0,\n      y,\n      x,\n      y,\n      0,\n      0,\n      y,\n      y,\n      x,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Completely removes color information from the display object, creating a grayscale version.\n   *\n   * This is a convenience method that calls `saturate(-1)` internally. The transformation preserves\n   * the luminance of the original image while removing all color information.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Convert image to grayscale\n   * colorMatrix.desaturate();\n   *\n   * // Can be chained with other effects\n   * colorMatrix\n   *     .desaturate()         // Remove all color\n   *     .brightness(1.2);     // Then increase brightness\n   * ```\n   */\n  desaturate() {\n    this.saturate(-1);\n  }\n  /**\n   * Creates a negative effect by inverting all colors in the display object.\n   *\n   * This method applies a matrix transformation that inverts the RGB values of each pixel\n   * while preserving the alpha channel. The result is similar to a photographic negative.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Create negative effect\n   * colorMatrix.negative(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .negative(true)       // Apply negative effect\n   *     .brightness(1.2, true) // Increase brightness\n   *     .contrast(0.8, true);  // Reduce contrast\n   * ```\n   */\n  negative(multiply) {\n    const matrix = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a sepia tone effect to the display object, creating a warm brown tint reminiscent of vintage photographs.\n   *\n   * This method applies a matrix transformation that converts colors to various shades of brown while\n   * preserving the original luminance values.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply sepia effect\n   * colorMatrix.sepia(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .sepia(true)           // Add sepia tone\n   *     .brightness(1.1, true)  // Slightly brighten\n   *     .contrast(0.9, true);   // Reduce contrast\n   * ```\n   */\n  sepia(multiply) {\n    const matrix = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a Technicolor-style effect that simulates the early color motion picture process.\n   *\n   * This method applies a matrix transformation that recreates the distinctive look of the\n   * Technicolor process. The effect produces highly\n   * saturated colors with a particular emphasis on reds, greens, and blues.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply Technicolor effect\n   * colorMatrix.technicolor(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .technicolor(true)      // Add Technicolor effect\n   *     .contrast(1.1, true)    // Boost contrast\n   *     .brightness(0.9, true); // Slightly darken\n   * ```\n   */\n  technicolor(multiply) {\n    const matrix = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a vintage Polaroid camera effect to the display object.\n   *\n   * This method applies a matrix transformation that simulates the distinctive look of\n   * Polaroid instant photographs, characterized by slightly enhanced contrast, subtle color shifts,\n   * and a warm overall tone.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply Polaroid effect\n   * colorMatrix.polaroid(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .polaroid(true)         // Add Polaroid effect\n   *     .brightness(1.1, true)  // Slightly brighten\n   *     .contrast(1.1, true);   // Boost contrast\n   * ```\n   */\n  polaroid(multiply) {\n    const matrix = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Swaps the red and blue color channels in the display object.\n   *\n   * This method applies a matrix transformation that exchanges the red and blue color values\n   * while keeping the green channel and alpha unchanged.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Swap red and blue channels\n   * colorMatrix.toBGR(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .toBGR(true)           // Swap R and B channels\n   *     .brightness(1.1, true)  // Slightly brighten\n   *     .contrast(0.9, true);   // Reduce contrast\n   * ```\n   */\n  toBGR(multiply) {\n    const matrix = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a Kodachrome color effect that simulates the iconic film stock.\n   *\n   * This method applies a matrix transformation that recreates the distinctive look of Kodachrome film,\n   * known for its rich, vibrant colors and excellent image preservation qualities. The effect emphasizes\n   * reds and blues while producing deep, true blacks.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply Kodachrome effect\n   * colorMatrix.kodachrome(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .kodachrome(true)       // Add Kodachrome effect\n   *     .contrast(1.1, true)    // Boost contrast\n   *     .brightness(0.9, true); // Slightly darken\n   * ```\n   */\n  kodachrome(multiply) {\n    const matrix = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a stylized brown-tinted effect to the display object.\n   *\n   * This method applies a matrix transformation that creates a rich, warm brown tone\n   * with enhanced contrast and subtle color shifts.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply browni effect\n   * colorMatrix.browni(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .browni(true)          // Add brown tint\n   *     .brightness(1.1, true)  // Slightly brighten\n   *     .contrast(1.2, true);   // Boost contrast\n   * ```\n   */\n  browni(multiply) {\n    const matrix = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a vintage photo effect that simulates old photography techniques.\n   *\n   * This method applies a matrix transformation that creates a nostalgic, aged look\n   * with muted colors, enhanced warmth, and subtle vignetting.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply vintage effect\n   * colorMatrix.vintage(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .vintage(true)          // Add vintage look\n   *     .brightness(0.9, true)  // Slightly darken\n   *     .contrast(1.1, true);   // Boost contrast\n   * ```\n   */\n  vintage(multiply) {\n    const matrix = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * We don't know exactly what it does, kind of gradient map, but funny to play with!\n   * @param desaturation - Tone values.\n   * @param toned - Tone values.\n   * @param lightColor - Tone values, example: `0xFFE580`\n   * @param darkColor - Tone values, example: `0xFFE580`\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with matrix\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Create sepia-like effect with custom colors\n   * colorMatrix.colorTone(\n   *     0.3,        // Moderate desaturation\n   *     0.2,        // Moderate toning\n   *     0xFFE580,   // Warm highlight color\n   *     0x338000,   // Dark green shadows\n   *     false\n   * );\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .colorTone(0.2, 0.15, 0xFFE580, 0x338000, true)\n   *     .brightness(1.1, true);  // Slightly brighten\n   * ```\n   */\n  colorTone(desaturation, toned, lightColor, darkColor, multiply) {\n    desaturation || (desaturation = 0.2);\n    toned || (toned = 0.15);\n    lightColor || (lightColor = 16770432);\n    darkColor || (darkColor = 3375104);\n    const temp = Color.Color.shared;\n    const [lR, lG, lB] = temp.setValue(lightColor).toArray();\n    const [dR, dG, dB] = temp.setValue(darkColor).toArray();\n    const matrix = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      lR,\n      lG,\n      lB,\n      desaturation,\n      0,\n      dR,\n      dG,\n      dB,\n      toned,\n      0,\n      lR - dR,\n      lG - dG,\n      lB - dB,\n      0,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a night vision effect to the display object.\n   *\n   * This method applies a matrix transformation that simulates night vision by enhancing\n   * certain color channels while suppressing others, creating a green-tinted effect\n   * similar to night vision goggles.\n   * @param intensity - The intensity of the night effect (0-1):\n   *                   - 0 produces no effect\n   *                   - 0.1 produces a subtle night vision effect (default)\n   *                   - 1 produces maximum night vision effect\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply night vision effect\n   * colorMatrix.night(0.3, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .night(0.2, true)        // Add night vision\n   *     .brightness(1.1, true)    // Slightly brighten\n   *     .contrast(1.2, true);     // Boost contrast\n   * ```\n   */\n  night(intensity, multiply) {\n    intensity || (intensity = 0.1);\n    const matrix = [\n      intensity * -2,\n      -intensity,\n      0,\n      0,\n      0,\n      -intensity,\n      0,\n      intensity,\n      0,\n      0,\n      0,\n      intensity,\n      intensity * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Predator effect\n   *\n   * Erase the current matrix by setting a new independent one\n   * @param amount - how much the predator feels his future victim\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with matrix\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply thermal vision effect\n   * colorMatrix.predator(0.5, false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .predator(0.3, true)      // Add thermal effect\n   *     .contrast(1.2, true)      // Boost contrast\n   *     .brightness(1.1, true);   // Slightly brighten\n   * ```\n   */\n  predator(amount, multiply) {\n    const matrix = [\n      // row 1\n      11.224130630493164 * amount,\n      -4.794486999511719 * amount,\n      -2.8746118545532227 * amount,\n      0 * amount,\n      0.40342438220977783 * amount,\n      // row 2\n      -3.6330697536468506 * amount,\n      9.193157196044922 * amount,\n      -2.951810836791992 * amount,\n      0 * amount,\n      -1.316135048866272 * amount,\n      // row 3\n      -3.2184197902679443 * amount,\n      -4.2375030517578125 * amount,\n      7.476448059082031 * amount,\n      0 * amount,\n      0.8044459223747253 * amount,\n      // row 4\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Applies a psychedelic color effect that creates dramatic color shifts.\n   *\n   * This method applies a matrix transformation that produces vibrant colors\n   * through channel mixing and amplification. Creates an effect reminiscent of\n   * color distortions in psychedelic art.\n   * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n   *                  This allows for cumulative effects when calling multiple color adjustments.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply psychedelic effect\n   * colorMatrix.lsd(false);\n   *\n   * // Chain with other effects\n   * colorMatrix\n   *     .lsd(true)             // Add color distortion\n   *     .brightness(0.9, true)  // Slightly darken\n   *     .contrast(1.2, true);   // Boost contrast\n   * ```\n   */\n  lsd(multiply) {\n    const matrix = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Resets the color matrix filter to its default state.\n   *\n   * This method resets all color transformations by setting the matrix back to its identity state.\n   * The identity matrix leaves colors unchanged, effectively removing all previously applied effects.\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply some effects\n   * colorMatrix\n   *     .sepia(true)\n   *     .brightness(1.2, true);\n   *\n   * // Reset back to original colors\n   * colorMatrix.reset();\n   * ```\n   */\n  reset() {\n    const matrix = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, false);\n  }\n  /**\n   * The current color transformation matrix of the filter.\n   *\n   * This 5x4 matrix transforms RGBA color and alpha values of each pixel. The matrix is stored\n   * as a 20-element array in row-major order.\n   * @type {ColorMatrix}\n   * @default [\n   *     1, 0, 0, 0, 0,  // Red channel\n   *     0, 1, 0, 0, 0,  // Green channel\n   *     0, 0, 1, 0, 0,  // Blue channel\n   *     0, 0, 0, 1, 0   // Alpha channel\n   * ]\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   * // Get the current color matrix\n   * const currentMatrix = colorMatrix.matrix;\n   * // Modify the matrix\n   * colorMatrix.matrix = [\n   *     1, 0, 0, 0, 0,\n   *     0, 1, 0, 0, 0,\n   *     0, 0, 1, 0, 0,\n   *     0, 0, 0, 1, 0\n   * ];\n   */\n  get matrix() {\n    return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;\n  }\n  set matrix(value) {\n    this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;\n  }\n  /**\n   * The opacity value used to blend between the original and transformed colors.\n   *\n   * This value controls how much of the color transformation is applied:\n   * - 0 = Original color only (no effect)\n   * - 0.5 = 50% blend of original and transformed colors\n   * - 1 = Fully transformed color (default)\n   * @default 1\n   * @example\n   * ```ts\n   * const colorMatrix = new ColorMatrixFilter();\n   *\n   * // Apply sepia at 50% strength\n   * colorMatrix.sepia(false);\n   * colorMatrix.alpha = 0.5;\n   *\n   * // Fade between effects\n   * colorMatrix\n   *     .saturate(1.5)      // Increase saturation\n   *     .contrast(1.2);     // Boost contrast\n   * colorMatrix.alpha = 0.7; // Apply at 70% strength\n   * ```\n   */\n  get alpha() {\n    return this.resources.colorMatrixUniforms.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.resources.colorMatrixUniforms.uniforms.uAlpha = value;\n  }\n}\n\nexports.ColorMatrixFilter = ColorMatrixFilter;\n//# sourceMappingURL=ColorMatrixFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uColorMatrix[20];\\nuniform float uAlpha;\\n\\nuniform sampler2D uTexture;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\\n    float diff = (randomValue - 0.5) *  0.5;\\n\\n    if (uAlpha == 0.0) {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    vec4 result;\\n\\n    result.r = (uColorMatrix[0] * color.r);\\n        result.r += (uColorMatrix[1] * color.g);\\n        result.r += (uColorMatrix[2] * color.b);\\n        result.r += (uColorMatrix[3] * color.a);\\n        result.r += uColorMatrix[4];\\n\\n    result.g = (uColorMatrix[5] * color.r);\\n        result.g += (uColorMatrix[6] * color.g);\\n        result.g += (uColorMatrix[7] * color.b);\\n        result.g += (uColorMatrix[8] * color.a);\\n        result.g += uColorMatrix[9];\\n\\n    result.b = (uColorMatrix[10] * color.r);\\n       result.b += (uColorMatrix[11] * color.g);\\n       result.b += (uColorMatrix[12] * color.b);\\n       result.b += (uColorMatrix[13] * color.a);\\n       result.b += uColorMatrix[14];\\n\\n    result.a = (uColorMatrix[15] * color.r);\\n       result.a += (uColorMatrix[16] * color.g);\\n       result.a += (uColorMatrix[17] * color.b);\\n       result.a += (uColorMatrix[18] * color.a);\\n       result.a += uColorMatrix[19];\\n\\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\\n\\n    // Premultiply alpha again.\\n    rgb *= result.a;\\n\\n    finalColor = vec4(rgb, result.a);\\n}\\n\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=colorMatrixFilter.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct ColorMatrixUniforms {\\n  uColorMatrix:array<vec4<f32>, 5>,\\n  uAlpha:f32,\\n};\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n  };\\n  \\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n  );\\n}\\n\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n\\n  var c = textureSample(uTexture, uSampler, uv);\\n  \\n  if (colorMatrixUniforms.uAlpha == 0.0) {\\n    return c;\\n  }\\n\\n \\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (c.a > 0.0) {\\n      c.r /= c.a;\\n      c.g /= c.a;\\n      c.b /= c.a;\\n    }\\n\\n    var cm = colorMatrixUniforms.uColorMatrix;\\n\\n\\n    var result = vec4<f32>(0.);\\n\\n    result.r = (cm[0][0] * c.r);\\n    result.r += (cm[0][1] * c.g);\\n    result.r += (cm[0][2] * c.b);\\n    result.r += (cm[0][3] * c.a);\\n    result.r += cm[1][0];\\n\\n    result.g = (cm[1][1] * c.r);\\n    result.g += (cm[1][2] * c.g);\\n    result.g += (cm[1][3] * c.b);\\n    result.g += (cm[2][0] * c.a);\\n    result.g += cm[2][1];\\n\\n    result.b = (cm[2][2] * c.r);\\n    result.b += (cm[2][3] * c.g);\\n    result.b += (cm[3][0] * c.b);\\n    result.b += (cm[3][1] * c.a);\\n    result.b += cm[3][2];\\n\\n    result.a = (cm[3][3] * c.r);\\n    result.a += (cm[4][0] * c.g);\\n    result.a += (cm[4][1] * c.b);\\n    result.a += (cm[4][2] * c.a);\\n    result.a += cm[4][3];\\n\\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\\n\\n    rgb.r *= result.a;\\n    rgb.g *= result.a;\\n    rgb.b *= result.a;\\n\\n    return vec4(rgb, result.a);\\n}\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=colorMatrixFilter.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexports[\"default\"] = vertex;\n//# sourceMappingURL=defaultFilter.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Point = __webpack_require__(/*! ../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar GlProgram = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Sprite = __webpack_require__(/*! ../../../scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar displacement$1 = __webpack_require__(/*! ./displacement.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js\");\nvar displacement = __webpack_require__(/*! ./displacement.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js\");\nvar displacement$2 = __webpack_require__(/*! ./displacement.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js\");\n\n\"use strict\";\nclass DisplacementFilter extends Filter.Filter {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Sprite.Sprite) {\n      if (args[1]) {\n        deprecation.deprecation(deprecation.v8_0_0, \"DisplacementFilter now uses options object instead of params. {sprite, scale}\");\n      }\n      options = { sprite: options, scale: args[1] };\n    }\n    const { sprite, scale: scaleOption, ...rest } = options;\n    let scale = scaleOption ?? 20;\n    if (typeof scale === \"number\") {\n      scale = new Point.Point(scale, scale);\n    }\n    const filterUniforms = new UniformGroup.UniformGroup({\n      uFilterMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uScale: { value: scale, type: \"vec2<f32>\" },\n      uRotation: { value: new Float32Array([0, 0, 0, 0]), type: \"mat2x2<f32>\" }\n    });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: displacement.default,\n      fragment: displacement$1.default,\n      name: \"displacement-filter\"\n    });\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: displacement$2.default,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: displacement$2.default,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const textureSource = sprite.texture.source;\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMapTexture: textureSource,\n        uMapSampler: textureSource.style\n      }\n    });\n    this._sprite = options.sprite;\n    this._sprite.renderable = false;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - clearMode.\n   * @advanced\n   */\n  apply(filterManager, input, output, clearMode) {\n    const uniforms = this.resources.filterUniforms.uniforms;\n    filterManager.calculateSpriteMatrix(\n      uniforms.uFilterMatrix,\n      this._sprite\n    );\n    const wt = this._sprite.worldTransform;\n    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    if (lenX !== 0 && lenY !== 0) {\n      uniforms.uRotation[0] = wt.a / lenX;\n      uniforms.uRotation[1] = wt.b / lenX;\n      uniforms.uRotation[2] = wt.c / lenY;\n      uniforms.uRotation[3] = wt.d / lenY;\n    }\n    this.resources.uMapTexture = this._sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The scale of the displacement effect.\n   *\n   * Gets the current x and y scaling values used for the displacement mapping.\n   * - x: Horizontal displacement scale\n   * - y: Vertical displacement scale\n   * @returns {Point} The current scale as a Point object\n   * @example\n   * ```ts\n   * const filter = new DisplacementFilter({ sprite });\n   *\n   * // Get current scale\n   * console.log(filter.scale.x, filter.scale.y);\n   *\n   * // Update scale\n   * filter.scale.x = 100;\n   * filter.scale.y = 50;\n   * ```\n   */\n  get scale() {\n    return this.resources.filterUniforms.uniforms.uScale;\n  }\n}\n\nexports.DisplacementFilter = DisplacementFilter;\n//# sourceMappingURL=DisplacementFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"\\nin vec2 vTextureCoord;\\nin vec2 vFilterUv;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\n\\nuniform vec4 uInputClamp;\\nuniform highp vec4 uInputSize;\\nuniform mat2 uRotation;\\nuniform vec2 uScale;\\n\\nvoid main()\\n{\\n    vec4 map = texture(uMapTexture, vFilterUv);\\n    \\n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \\n\\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\\n}\\n\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=displacement.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterUv;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( void )\\n{\\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\\n}\\n\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterUv = getFilterCoord();\\n}\\n\";\n\nexports[\"default\"] = vertex;\n//# sourceMappingURL=displacement.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct DisplacementUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uScale:vec2<f32>,\\n  uRotation:mat2x2<f32>\\n};\\n\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\\n\\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \\n   \\n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n}\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=displacement.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Filter = __webpack_require__(/*! ../../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar defaultFilter = __webpack_require__(/*! ../defaultFilter.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js\");\nvar noise$1 = __webpack_require__(/*! ./noise.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js\");\nvar noise = __webpack_require__(/*! ./noise.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js\");\n\n\"use strict\";\nconst _NoiseFilter = class _NoiseFilter extends Filter.Filter {\n  /**\n   * @param options - The options of the noise filter.\n   */\n  constructor(options = {}) {\n    options = { ..._NoiseFilter.defaultOptions, ...options };\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: noise.default,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: noise.default,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: defaultFilter.default,\n      fragment: noise$1.default,\n      name: \"noise-filter\"\n    });\n    const { noise: noise$2, seed, ...rest } = options;\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        noiseUniforms: new UniformGroup.UniformGroup({\n          uNoise: { value: 1, type: \"f32\" },\n          uSeed: { value: 1, type: \"f32\" }\n        })\n      }\n    });\n    this.noise = noise$2;\n    this.seed = seed ?? Math.random();\n  }\n  /**\n   * The amount of noise to apply to the filtered content.\n   *\n   * This value controls the intensity of the random noise effect:\n   * - Values close to 0 produce subtle noise\n   * - Values around 0.5 produce moderate noise\n   * - Values close to 1 produce strong noise\n   * @default 0.5\n   * @example\n   * ```ts\n   * const noiseFilter = new NoiseFilter();\n   *\n   * // Set to subtle noise\n   * noiseFilter.noise = 0.2;\n   *\n   * // Set to maximum noise\n   * noiseFilter.noise = 1.0;\n   * ```\n   */\n  get noise() {\n    return this.resources.noiseUniforms.uniforms.uNoise;\n  }\n  set noise(value) {\n    this.resources.noiseUniforms.uniforms.uNoise = value;\n  }\n  /**\n   * The seed value used for random noise generation.\n   *\n   * This value determines the noise pattern:\n   * - Using the same seed will generate identical noise patterns\n   * - Different seeds produce different but consistent patterns\n   * - `Math.random()` can be used for random patterns\n   * @default Math.random()\n   * @example\n   * ```ts\n   * const noiseFilter = new NoiseFilter();\n   *\n   * // Use a fixed seed for consistent noise\n   * noiseFilter.seed = 12345;\n   *\n   * // Generate new random pattern\n   * noiseFilter.seed = Math.random();\n   * ```\n   */\n  get seed() {\n    return this.resources.noiseUniforms.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.resources.noiseUniforms.uniforms.uSeed = value;\n  }\n};\n/**\n * The default configuration options for the NoiseFilter.\n *\n * These values will be used when no specific options are provided to the constructor.\n * You can override any of these values by passing your own options object.\n * @example\n * ```ts\n * NoiseFilter.defaultOptions.noise = 0.7; // Change default noise to 0.7\n * const filter = new NoiseFilter(); // Will use noise 0.7 by default\n * ```\n */\n_NoiseFilter.defaultOptions = {\n  noise: 0.5\n};\nlet NoiseFilter = _NoiseFilter;\n\nexports.NoiseFilter = NoiseFilter;\n//# sourceMappingURL=NoiseFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uNoise;\\nuniform float uSeed;\\nuniform sampler2D uTexture;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\\n    float diff = (randomValue - 0.5) *  uNoise;\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    // Premultiply alpha again.\\n    color.rgb *= color.a;\\n\\n    finalColor = color;\\n}\\n\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=noise.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct NoiseUniforms {\\n  uNoise:f32,\\n  uSeed:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\nfn rand(co:vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\n\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\\n  \\n    \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\\n  \\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (sample.a > 0.0) {\\n      sample.r /= sample.a;\\n      sample.g /= sample.a;\\n      sample.b /= sample.a;\\n    }\\n\\n    sample.r += diff;\\n    sample.g += diff;\\n    sample.b += diff;\\n\\n    // Premultiply alpha again.\\n    sample.r *= sample.a;\\n    sample.g *= sample.a;\\n    sample.b *= sample.a;\\n    \\n    return sample;\\n}\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=noise.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/index.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BlendModeFilter = __webpack_require__(/*! ./blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\nvar GLhls = __webpack_require__(/*! ./blend-modes/hls/GLhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js\");\nvar GPUhls = __webpack_require__(/*! ./blend-modes/hls/GPUhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js\");\nvar AlphaFilter = __webpack_require__(/*! ./defaults/alpha/AlphaFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.js\");\nvar BlurFilter = __webpack_require__(/*! ./defaults/blur/BlurFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.js\");\nvar BlurFilterPass = __webpack_require__(/*! ./defaults/blur/BlurFilterPass.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js\");\nvar _const = __webpack_require__(/*! ./defaults/blur/const.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/const.js\");\nvar generateBlurFragSource = __webpack_require__(/*! ./defaults/blur/gl/generateBlurFragSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js\");\nvar generateBlurGlProgram = __webpack_require__(/*! ./defaults/blur/gl/generateBlurGlProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js\");\nvar generateBlurVertSource = __webpack_require__(/*! ./defaults/blur/gl/generateBlurVertSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js\");\nvar generateBlurProgram = __webpack_require__(/*! ./defaults/blur/gpu/generateBlurProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js\");\nvar ColorMatrixFilter = __webpack_require__(/*! ./defaults/color-matrix/ColorMatrixFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.js\");\nvar DisplacementFilter = __webpack_require__(/*! ./defaults/displacement/DisplacementFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.js\");\nvar NoiseFilter = __webpack_require__(/*! ./defaults/noise/NoiseFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.js\");\nvar Filter = __webpack_require__(/*! ./Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar FilterEffect = __webpack_require__(/*! ./FilterEffect.js */ \"./node_modules/pixi.js/lib/filters/FilterEffect.js\");\nvar FilterPipe = __webpack_require__(/*! ./FilterPipe.js */ \"./node_modules/pixi.js/lib/filters/FilterPipe.js\");\nvar FilterSystem = __webpack_require__(/*! ./FilterSystem.js */ \"./node_modules/pixi.js/lib/filters/FilterSystem.js\");\nvar MaskFilter = __webpack_require__(/*! ./mask/MaskFilter.js */ \"./node_modules/pixi.js/lib/filters/mask/MaskFilter.js\");\nvar blendTemplate = __webpack_require__(/*! ./blend-modes/blend-template.frag.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js\");\nvar blendTemplate$1 = __webpack_require__(/*! ./blend-modes/blend-template.vert.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js\");\nvar blendTemplate$2 = __webpack_require__(/*! ./blend-modes/blend-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js\");\nvar hsl = __webpack_require__(/*! ./blend-modes/hsl.wgsl.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.js\");\nvar alpha = __webpack_require__(/*! ./defaults/alpha/alpha.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js\");\nvar alpha$1 = __webpack_require__(/*! ./defaults/alpha/alpha.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js\");\nvar blurTemplate = __webpack_require__(/*! ./defaults/blur/gpu/blur-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js\");\nvar colorMatrixFilter = __webpack_require__(/*! ./defaults/color-matrix/colorMatrixFilter.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js\");\nvar colorMatrixFilter$1 = __webpack_require__(/*! ./defaults/color-matrix/colorMatrixFilter.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js\");\nvar defaultFilter = __webpack_require__(/*! ./defaults/defaultFilter.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js\");\nvar displacement = __webpack_require__(/*! ./defaults/displacement/displacement.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js\");\nvar displacement$1 = __webpack_require__(/*! ./defaults/displacement/displacement.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js\");\nvar displacement$2 = __webpack_require__(/*! ./defaults/displacement/displacement.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js\");\nvar noise = __webpack_require__(/*! ./defaults/noise/noise.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js\");\nvar noise$1 = __webpack_require__(/*! ./defaults/noise/noise.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js\");\nvar mask = __webpack_require__(/*! ./mask/mask.frag.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.frag.js\");\nvar mask$1 = __webpack_require__(/*! ./mask/mask.vert.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.vert.js\");\nvar mask$2 = __webpack_require__(/*! ./mask/mask.wgsl.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js\");\n\n\"use strict\";\n\nexports.BlendModeFilter = BlendModeFilter.BlendModeFilter;\nexports.hslgl = GLhls.hslgl;\nexports.hslgpu = GPUhls.hslgpu;\nexports.AlphaFilter = AlphaFilter.AlphaFilter;\nexports.BlurFilter = BlurFilter.BlurFilter;\nexports.BlurFilterPass = BlurFilterPass.BlurFilterPass;\nexports.GAUSSIAN_VALUES = _const.GAUSSIAN_VALUES;\nexports.generateBlurFragSource = generateBlurFragSource.generateBlurFragSource;\nexports.generateBlurGlProgram = generateBlurGlProgram.generateBlurGlProgram;\nexports.generateBlurVertSource = generateBlurVertSource.generateBlurVertSource;\nexports.generateBlurProgram = generateBlurProgram.generateBlurProgram;\nexports.ColorMatrixFilter = ColorMatrixFilter.ColorMatrixFilter;\nexports.DisplacementFilter = DisplacementFilter.DisplacementFilter;\nexports.NoiseFilter = NoiseFilter.NoiseFilter;\nexports.Filter = Filter.Filter;\nexports.FilterEffect = FilterEffect.FilterEffect;\nexports.FilterPipe = FilterPipe.FilterPipe;\nexports.FilterSystem = FilterSystem.FilterSystem;\nexports.MaskFilter = MaskFilter.MaskFilter;\nexports.blendTemplateFrag = blendTemplate.default;\nexports.blendTemplateVert = blendTemplate$1.default;\nexports.blendTemplateWgsl = blendTemplate$2.default;\nexports.hslWgsl = hsl.default;\nexports.alphaFrag = alpha.default;\nexports.alphaWgsl = alpha$1.default;\nexports.blurTemplateWgsl = blurTemplate.default;\nexports.colorMatrixFilterFrag = colorMatrixFilter.default;\nexports.colorMatrixFilterWgsl = colorMatrixFilter$1.default;\nexports.defaultFilterVert = defaultFilter.default;\nexports.displacementFrag = displacement.default;\nexports.displacementVert = displacement$1.default;\nexports.displacementWgsl = displacement$2.default;\nexports.noiseFrag = noise.default;\nexports.noiseWgsl = noise$1.default;\nexports.maskFrag = mask.default;\nexports.maskVert = mask$1.default;\nexports.maskWgsl = mask$2.default;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/init.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/init.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar FilterPipe = __webpack_require__(/*! ./FilterPipe.js */ \"./node_modules/pixi.js/lib/filters/FilterPipe.js\");\nvar FilterSystem = __webpack_require__(/*! ./FilterSystem.js */ \"./node_modules/pixi.js/lib/filters/FilterSystem.js\");\n\n\"use strict\";\nExtensions.extensions.add(FilterSystem.FilterSystem);\nExtensions.extensions.add(FilterPipe.FilterPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/MaskFilter.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/MaskFilter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar GlProgram = __webpack_require__(/*! ../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar UniformGroup = __webpack_require__(/*! ../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar TextureMatrix = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TextureMatrix.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js\");\nvar Filter = __webpack_require__(/*! ../Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar mask$2 = __webpack_require__(/*! ./mask.frag.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.frag.js\");\nvar mask$1 = __webpack_require__(/*! ./mask.vert.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.vert.js\");\nvar mask = __webpack_require__(/*! ./mask.wgsl.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js\");\n\n\"use strict\";\nclass MaskFilter extends Filter.Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix.TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup.UniformGroup({\n      uFilterMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      vertex: {\n        source: mask.default,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: mask.default,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: mask$1.default,\n      fragment: mask$2.default,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexports.MaskFilter = MaskFilter;\n//# sourceMappingURL=MaskFilter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/mask/MaskFilter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.frag.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.frag.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=mask.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/mask/mask.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.vert.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.vert.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexports[\"default\"] = vertex;\n//# sourceMappingURL=mask.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/mask/mask.vert.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexports[\"default\"] = source;\n//# sourceMappingURL=mask.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/pixi.js/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar browserExt = __webpack_require__(/*! ./environment-browser/browserExt.js */ \"./node_modules/pixi.js/lib/environment-browser/browserExt.js\");\nvar webworkerExt = __webpack_require__(/*! ./environment-webworker/webworkerExt.js */ \"./node_modules/pixi.js/lib/environment-webworker/webworkerExt.js\");\nvar Extensions = __webpack_require__(/*! ./extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n__webpack_require__(/*! ./rendering/init.js */ \"./node_modules/pixi.js/lib/rendering/init.js\");\n__webpack_require__(/*! ./spritesheet/init.js */ \"./node_modules/pixi.js/lib/spritesheet/init.js\");\n__webpack_require__(/*! ./accessibility/index.js */ \"./node_modules/pixi.js/lib/accessibility/index.js\");\n__webpack_require__(/*! ./advanced-blend-modes/index.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/index.js\");\n__webpack_require__(/*! ./app/index.js */ \"./node_modules/pixi.js/lib/app/index.js\");\n__webpack_require__(/*! ./assets/index.js */ \"./node_modules/pixi.js/lib/assets/index.js\");\n__webpack_require__(/*! ./color/index.js */ \"./node_modules/pixi.js/lib/color/index.js\");\n__webpack_require__(/*! ./compressed-textures/index.js */ \"./node_modules/pixi.js/lib/compressed-textures/index.js\");\n__webpack_require__(/*! ./culling/index.js */ \"./node_modules/pixi.js/lib/culling/index.js\");\n__webpack_require__(/*! ./dom/index.js */ \"./node_modules/pixi.js/lib/dom/index.js\");\n__webpack_require__(/*! ./environment/index.js */ \"./node_modules/pixi.js/lib/environment/index.js\");\n__webpack_require__(/*! ./environment-browser/index.js */ \"./node_modules/pixi.js/lib/environment-browser/index.js\");\n__webpack_require__(/*! ./environment-webworker/index.js */ \"./node_modules/pixi.js/lib/environment-webworker/index.js\");\n__webpack_require__(/*! ./events/index.js */ \"./node_modules/pixi.js/lib/events/index.js\");\n__webpack_require__(/*! ./extensions/index.js */ \"./node_modules/pixi.js/lib/extensions/index.js\");\n__webpack_require__(/*! ./filters/index.js */ \"./node_modules/pixi.js/lib/filters/index.js\");\n__webpack_require__(/*! ./maths/index.js */ \"./node_modules/pixi.js/lib/maths/index.js\");\n__webpack_require__(/*! ./prepare/index.js */ \"./node_modules/pixi.js/lib/prepare/index.js\");\n__webpack_require__(/*! ./rendering/index.js */ \"./node_modules/pixi.js/lib/rendering/index.js\");\n__webpack_require__(/*! ./scene/index.js */ \"./node_modules/pixi.js/lib/scene/index.js\");\n__webpack_require__(/*! ./spritesheet/index.js */ \"./node_modules/pixi.js/lib/spritesheet/index.js\");\n__webpack_require__(/*! ./ticker/index.js */ \"./node_modules/pixi.js/lib/ticker/index.js\");\n__webpack_require__(/*! ./utils/index.js */ \"./node_modules/pixi.js/lib/utils/index.js\");\nvar AccessibilitySystem = __webpack_require__(/*! ./accessibility/AccessibilitySystem.js */ \"./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.js\");\nvar accessibilityTarget = __webpack_require__(/*! ./accessibility/accessibilityTarget.js */ \"./node_modules/pixi.js/lib/accessibility/accessibilityTarget.js\");\nvar ColorBlend = __webpack_require__(/*! ./advanced-blend-modes/ColorBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.js\");\nvar ColorBurnBlend = __webpack_require__(/*! ./advanced-blend-modes/ColorBurnBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.js\");\nvar ColorDodgeBlend = __webpack_require__(/*! ./advanced-blend-modes/ColorDodgeBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.js\");\nvar DarkenBlend = __webpack_require__(/*! ./advanced-blend-modes/DarkenBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.js\");\nvar DifferenceBlend = __webpack_require__(/*! ./advanced-blend-modes/DifferenceBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.js\");\nvar DivideBlend = __webpack_require__(/*! ./advanced-blend-modes/DivideBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.js\");\nvar ExclusionBlend = __webpack_require__(/*! ./advanced-blend-modes/ExclusionBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.js\");\nvar HardLightBlend = __webpack_require__(/*! ./advanced-blend-modes/HardLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.js\");\nvar HardMixBlend = __webpack_require__(/*! ./advanced-blend-modes/HardMixBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.js\");\nvar LightenBlend = __webpack_require__(/*! ./advanced-blend-modes/LightenBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.js\");\nvar LinearBurnBlend = __webpack_require__(/*! ./advanced-blend-modes/LinearBurnBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.js\");\nvar LinearDodgeBlend = __webpack_require__(/*! ./advanced-blend-modes/LinearDodgeBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.js\");\nvar LinearLightBlend = __webpack_require__(/*! ./advanced-blend-modes/LinearLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.js\");\nvar LuminosityBlend = __webpack_require__(/*! ./advanced-blend-modes/LuminosityBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.js\");\nvar NegationBlend = __webpack_require__(/*! ./advanced-blend-modes/NegationBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.js\");\nvar OverlayBlend = __webpack_require__(/*! ./advanced-blend-modes/OverlayBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.js\");\nvar PinLightBlend = __webpack_require__(/*! ./advanced-blend-modes/PinLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.js\");\nvar SaturationBlend = __webpack_require__(/*! ./advanced-blend-modes/SaturationBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.js\");\nvar SoftLightBlend = __webpack_require__(/*! ./advanced-blend-modes/SoftLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.js\");\nvar SubtractBlend = __webpack_require__(/*! ./advanced-blend-modes/SubtractBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.js\");\nvar VividLightBlend = __webpack_require__(/*! ./advanced-blend-modes/VividLightBlend.js */ \"./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.js\");\nvar Application = __webpack_require__(/*! ./app/Application.js */ \"./node_modules/pixi.js/lib/app/Application.js\");\nvar ResizePlugin = __webpack_require__(/*! ./app/ResizePlugin.js */ \"./node_modules/pixi.js/lib/app/ResizePlugin.js\");\nvar TickerPlugin = __webpack_require__(/*! ./app/TickerPlugin.js */ \"./node_modules/pixi.js/lib/app/TickerPlugin.js\");\nvar Assets = __webpack_require__(/*! ./assets/Assets.js */ \"./node_modules/pixi.js/lib/assets/Assets.js\");\nvar BackgroundLoader = __webpack_require__(/*! ./assets/BackgroundLoader.js */ \"./node_modules/pixi.js/lib/assets/BackgroundLoader.js\");\nvar Cache = __webpack_require__(/*! ./assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar cacheTextureArray = __webpack_require__(/*! ./assets/cache/parsers/cacheTextureArray.js */ \"./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.js\");\nvar detectAvif = __webpack_require__(/*! ./assets/detections/parsers/detectAvif.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.js\");\nvar detectDefaults = __webpack_require__(/*! ./assets/detections/parsers/detectDefaults.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.js\");\nvar detectMp4 = __webpack_require__(/*! ./assets/detections/parsers/detectMp4.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.js\");\nvar detectOgv = __webpack_require__(/*! ./assets/detections/parsers/detectOgv.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.js\");\nvar detectWebm = __webpack_require__(/*! ./assets/detections/parsers/detectWebm.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.js\");\nvar detectWebp = __webpack_require__(/*! ./assets/detections/parsers/detectWebp.js */ \"./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.js\");\nvar testImageFormat = __webpack_require__(/*! ./assets/detections/utils/testImageFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.js\");\nvar testVideoFormat = __webpack_require__(/*! ./assets/detections/utils/testVideoFormat.js */ \"./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.js\");\nvar Loader = __webpack_require__(/*! ./assets/loader/Loader.js */ \"./node_modules/pixi.js/lib/assets/loader/Loader.js\");\nvar LoaderParser = __webpack_require__(/*! ./assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar loadJson = __webpack_require__(/*! ./assets/loader/parsers/loadJson.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.js\");\nvar loadTxt = __webpack_require__(/*! ./assets/loader/parsers/loadTxt.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.js\");\nvar loadWebFont = __webpack_require__(/*! ./assets/loader/parsers/loadWebFont.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.js\");\nvar loadSVG = __webpack_require__(/*! ./assets/loader/parsers/textures/loadSVG.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.js\");\nvar loadTextures = __webpack_require__(/*! ./assets/loader/parsers/textures/loadTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.js\");\nvar loadVideoTextures = __webpack_require__(/*! ./assets/loader/parsers/textures/loadVideoTextures.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.js\");\nvar createTexture = __webpack_require__(/*! ./assets/loader/parsers/textures/utils/createTexture.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.js\");\nvar WorkerManager = __webpack_require__(/*! ./assets/loader/workers/WorkerManager.js */ \"./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.js\");\nvar resolveJsonUrl = __webpack_require__(/*! ./assets/resolver/parsers/resolveJsonUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.js\");\nvar resolveTextureUrl = __webpack_require__(/*! ./assets/resolver/parsers/resolveTextureUrl.js */ \"./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.js\");\nvar Resolver = __webpack_require__(/*! ./assets/resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\nvar checkDataUrl = __webpack_require__(/*! ./assets/utils/checkDataUrl.js */ \"./node_modules/pixi.js/lib/assets/utils/checkDataUrl.js\");\nvar checkExtension = __webpack_require__(/*! ./assets/utils/checkExtension.js */ \"./node_modules/pixi.js/lib/assets/utils/checkExtension.js\");\nvar convertToList = __webpack_require__(/*! ./assets/utils/convertToList.js */ \"./node_modules/pixi.js/lib/assets/utils/convertToList.js\");\nvar copySearchParams = __webpack_require__(/*! ./assets/utils/copySearchParams.js */ \"./node_modules/pixi.js/lib/assets/utils/copySearchParams.js\");\nvar createStringVariations = __webpack_require__(/*! ./assets/utils/createStringVariations.js */ \"./node_modules/pixi.js/lib/assets/utils/createStringVariations.js\");\nvar isSingleItem = __webpack_require__(/*! ./assets/utils/isSingleItem.js */ \"./node_modules/pixi.js/lib/assets/utils/isSingleItem.js\");\nvar Color = __webpack_require__(/*! ./color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar detectBasis = __webpack_require__(/*! ./compressed-textures/basis/detectBasis.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.js\");\nvar loadBasis = __webpack_require__(/*! ./compressed-textures/basis/loadBasis.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.js\");\nvar createLevelBuffers = __webpack_require__(/*! ./compressed-textures/basis/utils/createLevelBuffers.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.js\");\nvar gpuFormatToBasisTranscoderFormat = __webpack_require__(/*! ./compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.js\");\nvar setBasisTranscoderPath = __webpack_require__(/*! ./compressed-textures/basis/utils/setBasisTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.js\");\nvar loadBasisOnWorker = __webpack_require__(/*! ./compressed-textures/basis/worker/loadBasisOnWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.js\");\nvar _const = __webpack_require__(/*! ./compressed-textures/dds/const.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/const.js\");\nvar loadDDS = __webpack_require__(/*! ./compressed-textures/dds/loadDDS.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.js\");\nvar parseDDS = __webpack_require__(/*! ./compressed-textures/dds/parseDDS.js */ \"./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.js\");\nvar loadKTX = __webpack_require__(/*! ./compressed-textures/ktx/loadKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.js\");\nvar parseKTX = __webpack_require__(/*! ./compressed-textures/ktx/parseKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.js\");\nvar _const$1 = __webpack_require__(/*! ./compressed-textures/ktx2/const.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/const.js\");\nvar loadKTX2 = __webpack_require__(/*! ./compressed-textures/ktx2/loadKTX2.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.js\");\nvar convertFormatIfRequired = __webpack_require__(/*! ./compressed-textures/ktx2/utils/convertFormatIfRequired.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.js\");\nvar createLevelBuffersFromKTX = __webpack_require__(/*! ./compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.js\");\nvar getTextureFormatFromKTXTexture = __webpack_require__(/*! ./compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.js\");\nvar glFormatToGPUFormat = __webpack_require__(/*! ./compressed-textures/ktx2/utils/glFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.js\");\nvar gpuFormatToKTXBasisTranscoderFormat = __webpack_require__(/*! ./compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.js\");\nvar setKTXTranscoderPath = __webpack_require__(/*! ./compressed-textures/ktx2/utils/setKTXTranscoderPath.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.js\");\nvar vkFormatToGPUFormat = __webpack_require__(/*! ./compressed-textures/ktx2/utils/vkFormatToGPUFormat.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.js\");\nvar loadKTX2onWorker = __webpack_require__(/*! ./compressed-textures/ktx2/worker/loadKTX2onWorker.js */ \"./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.js\");\nvar detectCompressed = __webpack_require__(/*! ./compressed-textures/shared/detectCompressed.js */ \"./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.js\");\nvar resolveCompressedTextureUrl = __webpack_require__(/*! ./compressed-textures/shared/resolveCompressedTextureUrl.js */ \"./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.js\");\nvar Culler = __webpack_require__(/*! ./culling/Culler.js */ \"./node_modules/pixi.js/lib/culling/Culler.js\");\nvar CullerPlugin = __webpack_require__(/*! ./culling/CullerPlugin.js */ \"./node_modules/pixi.js/lib/culling/CullerPlugin.js\");\nvar cullingMixin = __webpack_require__(/*! ./culling/cullingMixin.js */ \"./node_modules/pixi.js/lib/culling/cullingMixin.js\");\nvar DOMContainer = __webpack_require__(/*! ./dom/DOMContainer.js */ \"./node_modules/pixi.js/lib/dom/DOMContainer.js\");\nvar DOMPipe = __webpack_require__(/*! ./dom/DOMPipe.js */ \"./node_modules/pixi.js/lib/dom/DOMPipe.js\");\nvar adapter = __webpack_require__(/*! ./environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar autoDetectEnvironment = __webpack_require__(/*! ./environment/autoDetectEnvironment.js */ \"./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js\");\nvar BrowserAdapter = __webpack_require__(/*! ./environment-browser/BrowserAdapter.js */ \"./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.js\");\nvar WebWorkerAdapter = __webpack_require__(/*! ./environment-webworker/WebWorkerAdapter.js */ \"./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.js\");\nvar EventBoundary = __webpack_require__(/*! ./events/EventBoundary.js */ \"./node_modules/pixi.js/lib/events/EventBoundary.js\");\nvar EventSystem = __webpack_require__(/*! ./events/EventSystem.js */ \"./node_modules/pixi.js/lib/events/EventSystem.js\");\nvar EventTicker = __webpack_require__(/*! ./events/EventTicker.js */ \"./node_modules/pixi.js/lib/events/EventTicker.js\");\nvar FederatedEvent = __webpack_require__(/*! ./events/FederatedEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedEvent.js\");\nvar FederatedEventTarget = __webpack_require__(/*! ./events/FederatedEventTarget.js */ \"./node_modules/pixi.js/lib/events/FederatedEventTarget.js\");\nvar FederatedMouseEvent = __webpack_require__(/*! ./events/FederatedMouseEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedMouseEvent.js\");\nvar FederatedPointerEvent = __webpack_require__(/*! ./events/FederatedPointerEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedPointerEvent.js\");\nvar FederatedWheelEvent = __webpack_require__(/*! ./events/FederatedWheelEvent.js */ \"./node_modules/pixi.js/lib/events/FederatedWheelEvent.js\");\nvar blendTemplate = __webpack_require__(/*! ./filters/blend-modes/blend-template.frag.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.js\");\nvar blendTemplate$1 = __webpack_require__(/*! ./filters/blend-modes/blend-template.vert.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.js\");\nvar blendTemplate$2 = __webpack_require__(/*! ./filters/blend-modes/blend-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.js\");\nvar hsl = __webpack_require__(/*! ./filters/blend-modes/hsl.wgsl.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.js\");\nvar alpha = __webpack_require__(/*! ./filters/defaults/alpha/alpha.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.js\");\nvar alpha$1 = __webpack_require__(/*! ./filters/defaults/alpha/alpha.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.js\");\nvar blurTemplate = __webpack_require__(/*! ./filters/defaults/blur/gpu/blur-template.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.js\");\nvar colorMatrixFilter = __webpack_require__(/*! ./filters/defaults/color-matrix/colorMatrixFilter.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.js\");\nvar colorMatrixFilter$1 = __webpack_require__(/*! ./filters/defaults/color-matrix/colorMatrixFilter.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.js\");\nvar defaultFilter = __webpack_require__(/*! ./filters/defaults/defaultFilter.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.js\");\nvar displacement = __webpack_require__(/*! ./filters/defaults/displacement/displacement.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.js\");\nvar displacement$1 = __webpack_require__(/*! ./filters/defaults/displacement/displacement.vert.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.js\");\nvar displacement$2 = __webpack_require__(/*! ./filters/defaults/displacement/displacement.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.js\");\nvar noise = __webpack_require__(/*! ./filters/defaults/noise/noise.frag.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.js\");\nvar noise$1 = __webpack_require__(/*! ./filters/defaults/noise/noise.wgsl.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.js\");\nvar mask = __webpack_require__(/*! ./filters/mask/mask.frag.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.frag.js\");\nvar mask$1 = __webpack_require__(/*! ./filters/mask/mask.vert.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.vert.js\");\nvar mask$2 = __webpack_require__(/*! ./filters/mask/mask.wgsl.js */ \"./node_modules/pixi.js/lib/filters/mask/mask.wgsl.js\");\nvar BlendModeFilter = __webpack_require__(/*! ./filters/blend-modes/BlendModeFilter.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.js\");\nvar GLhls = __webpack_require__(/*! ./filters/blend-modes/hls/GLhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.js\");\nvar GPUhls = __webpack_require__(/*! ./filters/blend-modes/hls/GPUhls.js */ \"./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.js\");\nvar AlphaFilter = __webpack_require__(/*! ./filters/defaults/alpha/AlphaFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.js\");\nvar BlurFilter = __webpack_require__(/*! ./filters/defaults/blur/BlurFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.js\");\nvar BlurFilterPass = __webpack_require__(/*! ./filters/defaults/blur/BlurFilterPass.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.js\");\nvar _const$2 = __webpack_require__(/*! ./filters/defaults/blur/const.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/const.js\");\nvar generateBlurFragSource = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurFragSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.js\");\nvar generateBlurGlProgram = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurGlProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.js\");\nvar generateBlurVertSource = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurVertSource.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.js\");\nvar generateBlurProgram = __webpack_require__(/*! ./filters/defaults/blur/gpu/generateBlurProgram.js */ \"./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.js\");\nvar ColorMatrixFilter = __webpack_require__(/*! ./filters/defaults/color-matrix/ColorMatrixFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.js\");\nvar DisplacementFilter = __webpack_require__(/*! ./filters/defaults/displacement/DisplacementFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.js\");\nvar NoiseFilter = __webpack_require__(/*! ./filters/defaults/noise/NoiseFilter.js */ \"./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.js\");\nvar Filter = __webpack_require__(/*! ./filters/Filter.js */ \"./node_modules/pixi.js/lib/filters/Filter.js\");\nvar FilterEffect = __webpack_require__(/*! ./filters/FilterEffect.js */ \"./node_modules/pixi.js/lib/filters/FilterEffect.js\");\nvar FilterPipe = __webpack_require__(/*! ./filters/FilterPipe.js */ \"./node_modules/pixi.js/lib/filters/FilterPipe.js\");\nvar FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ \"./node_modules/pixi.js/lib/filters/FilterSystem.js\");\nvar MaskFilter = __webpack_require__(/*! ./filters/mask/MaskFilter.js */ \"./node_modules/pixi.js/lib/filters/mask/MaskFilter.js\");\nvar groupD8 = __webpack_require__(/*! ./maths/matrix/groupD8.js */ \"./node_modules/pixi.js/lib/maths/matrix/groupD8.js\");\nvar Matrix = __webpack_require__(/*! ./maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar _const$3 = __webpack_require__(/*! ./maths/misc/const.js */ \"./node_modules/pixi.js/lib/maths/misc/const.js\");\nvar pow2 = __webpack_require__(/*! ./maths/misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\nvar squaredDistanceToLineSegment = __webpack_require__(/*! ./maths/misc/squaredDistanceToLineSegment.js */ \"./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js\");\nvar ObservablePoint = __webpack_require__(/*! ./maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar Point = __webpack_require__(/*! ./maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar pointInTriangle = __webpack_require__(/*! ./maths/point/pointInTriangle.js */ \"./node_modules/pixi.js/lib/maths/point/pointInTriangle.js\");\nvar Circle = __webpack_require__(/*! ./maths/shapes/Circle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Circle.js\");\nvar Ellipse = __webpack_require__(/*! ./maths/shapes/Ellipse.js */ \"./node_modules/pixi.js/lib/maths/shapes/Ellipse.js\");\nvar Polygon = __webpack_require__(/*! ./maths/shapes/Polygon.js */ \"./node_modules/pixi.js/lib/maths/shapes/Polygon.js\");\nvar Rectangle = __webpack_require__(/*! ./maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar RoundedRectangle = __webpack_require__(/*! ./maths/shapes/RoundedRectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js\");\nvar Triangle = __webpack_require__(/*! ./maths/shapes/Triangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Triangle.js\");\nvar PrepareBase = __webpack_require__(/*! ./prepare/PrepareBase.js */ \"./node_modules/pixi.js/lib/prepare/PrepareBase.js\");\nvar PrepareQueue = __webpack_require__(/*! ./prepare/PrepareQueue.js */ \"./node_modules/pixi.js/lib/prepare/PrepareQueue.js\");\nvar PrepareSystem = __webpack_require__(/*! ./prepare/PrepareSystem.js */ \"./node_modules/pixi.js/lib/prepare/PrepareSystem.js\");\nvar PrepareUpload = __webpack_require__(/*! ./prepare/PrepareUpload.js */ \"./node_modules/pixi.js/lib/prepare/PrepareUpload.js\");\nvar GlBatchAdaptor = __webpack_require__(/*! ./rendering/batcher/gl/GlBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js\");\nvar checkMaxIfStatementsInShader = __webpack_require__(/*! ./rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js\");\nvar maxRecommendedTextures = __webpack_require__(/*! ./rendering/batcher/gl/utils/maxRecommendedTextures.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js\");\nvar generateGPULayout = __webpack_require__(/*! ./rendering/batcher/gpu/generateGPULayout.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.js\");\nvar generateLayout = __webpack_require__(/*! ./rendering/batcher/gpu/generateLayout.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.js\");\nvar getTextureBatchBindGroup = __webpack_require__(/*! ./rendering/batcher/gpu/getTextureBatchBindGroup.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js\");\nvar GpuBatchAdaptor = __webpack_require__(/*! ./rendering/batcher/gpu/GpuBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js\");\nvar Batcher = __webpack_require__(/*! ./rendering/batcher/shared/Batcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js\");\nvar BatcherPipe = __webpack_require__(/*! ./rendering/batcher/shared/BatcherPipe.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js\");\nvar BatchGeometry = __webpack_require__(/*! ./rendering/batcher/shared/BatchGeometry.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js\");\nvar BatchTextureArray = __webpack_require__(/*! ./rendering/batcher/shared/BatchTextureArray.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js\");\nvar DefaultBatcher = __webpack_require__(/*! ./rendering/batcher/shared/DefaultBatcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js\");\nvar DefaultShader = __webpack_require__(/*! ./rendering/batcher/shared/DefaultShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ./rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar compileHighShader = __webpack_require__(/*! ./rendering/high-shader/compiler/compileHighShader.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js\");\nvar addBits = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/addBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js\");\nvar compileHooks = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileHooks.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js\");\nvar compileInputs = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileInputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js\");\nvar compileOutputs = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileOutputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js\");\nvar formatShader = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/formatShader.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.js\");\nvar injectBits = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/injectBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js\");\nvar defaultProgramTemplate = __webpack_require__(/*! ./rendering/high-shader/defaultProgramTemplate.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js\");\nvar colorBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar globalUniformsBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/globalUniformsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js\");\nvar localUniformBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar textureBit = __webpack_require__(/*! ./rendering/high-shader/shader-bits/textureBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js\");\nvar AlphaMask = __webpack_require__(/*! ./rendering/mask/alpha/AlphaMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js\");\nvar AlphaMaskPipe = __webpack_require__(/*! ./rendering/mask/alpha/AlphaMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js\");\nvar ColorMask = __webpack_require__(/*! ./rendering/mask/color/ColorMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js\");\nvar ColorMaskPipe = __webpack_require__(/*! ./rendering/mask/color/ColorMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js\");\nvar MaskEffectManager = __webpack_require__(/*! ./rendering/mask/MaskEffectManager.js */ \"./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js\");\nvar ScissorMask = __webpack_require__(/*! ./rendering/mask/scissor/ScissorMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.js\");\nvar StencilMask = __webpack_require__(/*! ./rendering/mask/stencil/StencilMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js\");\nvar StencilMaskPipe = __webpack_require__(/*! ./rendering/mask/stencil/StencilMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js\");\nvar addMaskBounds = __webpack_require__(/*! ./rendering/mask/utils/addMaskBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js\");\nvar addMaskLocalBounds = __webpack_require__(/*! ./rendering/mask/utils/addMaskLocalBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js\");\nvar autoDetectRenderer = __webpack_require__(/*! ./rendering/renderers/autoDetectRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js\");\nvar _const$4 = __webpack_require__(/*! ./rendering/renderers/gl/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js\");\nvar GlBuffer = __webpack_require__(/*! ./rendering/renderers/gl/buffer/GlBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js\");\nvar GlBufferSystem = __webpack_require__(/*! ./rendering/renderers/gl/buffer/GlBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js\");\nvar _const$5 = __webpack_require__(/*! ./rendering/renderers/gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar GlContextSystem = __webpack_require__(/*! ./rendering/renderers/gl/context/GlContextSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js\");\nvar GlGeometrySystem = __webpack_require__(/*! ./rendering/renderers/gl/geometry/GlGeometrySystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js\");\nvar getGlTypeFromFormat = __webpack_require__(/*! ./rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js\");\nvar GlBackBufferSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlBackBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js\");\nvar GlColorMaskSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js\");\nvar GlEncoderSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js\");\nvar GlLimitsSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js\");\nvar GlRenderTarget = __webpack_require__(/*! ./rendering/renderers/gl/GlRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js\");\nvar GlStencilSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js\");\nvar GlUboSystem = __webpack_require__(/*! ./rendering/renderers/gl/GlUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js\");\nvar GlRenderTargetAdaptor = __webpack_require__(/*! ./rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js\");\nvar GlRenderTargetSystem = __webpack_require__(/*! ./rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js\");\nvar GenerateShaderSyncCode = __webpack_require__(/*! ./rendering/renderers/gl/shader/GenerateShaderSyncCode.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js\");\nvar getBatchSamplersUniformGroup = __webpack_require__(/*! ./rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js\");\nvar GlProgram = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GlProgramData = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlProgramData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js\");\nvar GlShaderSystem = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js\");\nvar GlUniformGroupSystem = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlUniformGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js\");\nvar migrateFragmentFromV7toV8 = __webpack_require__(/*! ./rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js\");\nvar compileShader = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/compileShader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js\");\nvar defaultValue = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/defaultValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js\");\nvar ensureAttributes = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/ensureAttributes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js\");\nvar extractAttributesFromGlProgram = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js\");\nvar generateProgram = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/generateProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js\");\nvar getMaxFragmentPrecision = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js\");\nvar getTestContext = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getTestContext.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js\");\nvar getUboData = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getUboData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js\");\nvar getUniformData = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getUniformData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js\");\nvar logProgramError = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/logProgramError.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js\");\nvar mapSize = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/mapSize.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.js\");\nvar mapType = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/mapType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js\");\nvar addProgramDefines = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js\");\nvar ensurePrecision = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js\");\nvar insertVersion = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/insertVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js\");\nvar setProgramName = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/setProgramName.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js\");\nvar stripVersion = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/stripVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js\");\nvar createUboElementsSTD40 = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/createUboElementsSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js\");\nvar createUboSyncSTD40 = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/createUboSyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js\");\nvar generateArraySyncSTD40 = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js\");\nvar generateUniformsSync = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateUniformsSync.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js\");\nvar generateUniformsSyncTypes = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js\");\nvar GlStateSystem = __webpack_require__(/*! ./rendering/renderers/gl/state/GlStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js\");\nvar mapWebGLBlendModesToPixi = __webpack_require__(/*! ./rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js\");\nvar _const$6 = __webpack_require__(/*! ./rendering/renderers/gl/texture/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js\");\nvar GlTexture = __webpack_require__(/*! ./rendering/renderers/gl/texture/GlTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js\");\nvar GlTextureSystem = __webpack_require__(/*! ./rendering/renderers/gl/texture/GlTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js\");\nvar glUploadBufferImageResource = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js\");\nvar glUploadCompressedTextureResource = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js\");\nvar glUploadImageResource = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js\");\nvar glUploadVideoResource = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js\");\nvar applyStyleParams = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/applyStyleParams.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js\");\nvar getSupportedGlCompressedTextureFormats = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js\");\nvar mapFormatToGlFormat = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js\");\nvar mapFormatToGlInternalFormat = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js\");\nvar mapFormatToGlType = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js\");\nvar pixiToGlMaps = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/pixiToGlMaps.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js\");\nvar unpremultiplyAlpha = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js\");\nvar WebGLRenderer = __webpack_require__(/*! ./rendering/renderers/gl/WebGLRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js\");\nvar BindGroupSystem = __webpack_require__(/*! ./rendering/renderers/gpu/BindGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js\");\nvar GpuBufferSystem = __webpack_require__(/*! ./rendering/renderers/gpu/buffer/GpuBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js\");\nvar UboBatch = __webpack_require__(/*! ./rendering/renderers/gpu/buffer/UboBatch.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js\");\nvar GpuColorMaskSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js\");\nvar GpuDeviceSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuDeviceSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js\");\nvar GpuEncoderSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js\");\nvar GpuLimitsSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js\");\nvar GpuStencilSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js\");\nvar GpuUboSystem = __webpack_require__(/*! ./rendering/renderers/gpu/GpuUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js\");\nvar GpuUniformBatchPipe = __webpack_require__(/*! ./rendering/renderers/gpu/GpuUniformBatchPipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js\");\nvar PipelineSystem = __webpack_require__(/*! ./rendering/renderers/gpu/pipeline/PipelineSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js\");\nvar calculateProjection = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/calculateProjection.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js\");\nvar GpuRenderTarget = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js\");\nvar GpuRenderTargetAdaptor = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js\");\nvar GpuRenderTargetSystem = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js\");\nvar BindGroup = __webpack_require__(/*! ./rendering/renderers/gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar GpuProgram = __webpack_require__(/*! ./rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar GpuShaderSystem = __webpack_require__(/*! ./rendering/renderers/gpu/shader/GpuShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js\");\nvar createUboElementsWGSL = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js\");\nvar createUboSyncFunctionWGSL = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js\");\nvar extractAttributesFromGpuProgram = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js\");\nvar extractStructAndGroups = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/extractStructAndGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js\");\nvar generateArraySyncWGSL = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js\");\nvar generateGpuLayoutGroups = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js\");\nvar generateLayoutHash = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateLayoutHash.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js\");\nvar removeStructAndGroupDuplicates = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js\");\nvar GpuBlendModesToPixi = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js\");\nvar GpuStateSystem = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js\");\nvar GpuStencilModesToPixi = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuStencilModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js\");\nvar GpuTextureSystem = __webpack_require__(/*! ./rendering/renderers/gpu/texture/GpuTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js\");\nvar gpuUploadBufferImageResource = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js\");\nvar gpuUploadCompressedTextureResource = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js\");\nvar gpuUploadImageSource = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js\");\nvar gpuUploadVideoSource = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js\");\nvar getSupportedGPUCompressedTextureFormats = __webpack_require__(/*! ./rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js\");\nvar GpuMipmapGenerator = __webpack_require__(/*! ./rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js\");\nvar WebGPURenderer = __webpack_require__(/*! ./rendering/renderers/gpu/WebGPURenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js\");\nvar BackgroundSystem = __webpack_require__(/*! ./rendering/renderers/shared/background/BackgroundSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js\");\nvar BlendModePipe = __webpack_require__(/*! ./rendering/renderers/shared/blendModes/BlendModePipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js\");\nvar Buffer = __webpack_require__(/*! ./rendering/renderers/shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar BufferResource = __webpack_require__(/*! ./rendering/renderers/shared/buffer/BufferResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js\");\nvar _const$7 = __webpack_require__(/*! ./rendering/renderers/shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar fastCopy = __webpack_require__(/*! ./rendering/renderers/shared/buffer/utils/fastCopy.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js\");\nvar ExtractSystem = __webpack_require__(/*! ./rendering/renderers/shared/extract/ExtractSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js\");\nvar GenerateTextureSystem = __webpack_require__(/*! ./rendering/renderers/shared/extract/GenerateTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js\");\nvar _const$8 = __webpack_require__(/*! ./rendering/renderers/shared/geometry/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.js\");\nvar Geometry = __webpack_require__(/*! ./rendering/renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar buildUvs = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/buildUvs.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js\");\nvar ensureIsBuffer = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/ensureIsBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js\");\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\nvar getGeometryBounds = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/getGeometryBounds.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js\");\nvar transformVertices = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/transformVertices.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js\");\nvar InstructionSet = __webpack_require__(/*! ./rendering/renderers/shared/instructions/InstructionSet.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js\");\nvar GlobalUniformSystem = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/GlobalUniformSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js\");\nvar isRenderingToScreen = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/isRenderingToScreen.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js\");\nvar RenderTarget = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/RenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js\");\nvar RenderTargetSystem = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/RenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js\");\nvar SchedulerSystem = __webpack_require__(/*! ./rendering/renderers/shared/SchedulerSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js\");\nvar _const$9 = __webpack_require__(/*! ./rendering/renderers/shared/shader/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js\");\nvar Shader = __webpack_require__(/*! ./rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar types = __webpack_require__(/*! ./rendering/renderers/shared/shader/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js\");\nvar UboSystem = __webpack_require__(/*! ./rendering/renderers/shared/shader/UboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js\");\nvar UniformGroup = __webpack_require__(/*! ./rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar createUboSyncFunction = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/createUboSyncFunction.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js\");\nvar getDefaultUniformValue = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/getDefaultUniformValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js\");\nvar uboSyncFunctions = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/uboSyncFunctions.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js\");\nvar uniformParsers = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/uniformParsers.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js\");\nvar HelloSystem = __webpack_require__(/*! ./rendering/renderers/shared/startup/HelloSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js\");\nvar _const$a = __webpack_require__(/*! ./rendering/renderers/shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ./rendering/renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar State = __webpack_require__(/*! ./rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar AbstractRenderer = __webpack_require__(/*! ./rendering/renderers/shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\nvar SharedSystems = __webpack_require__(/*! ./rendering/renderers/shared/system/SharedSystems.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js\");\nvar SystemRunner = __webpack_require__(/*! ./rendering/renderers/shared/system/SystemRunner.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js\");\nvar CanvasPool = __webpack_require__(/*! ./rendering/renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar _const$b = __webpack_require__(/*! ./rendering/renderers/shared/texture/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.js\");\nvar RenderableGCSystem = __webpack_require__(/*! ./rendering/renderers/shared/texture/RenderableGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js\");\nvar RenderTexture = __webpack_require__(/*! ./rendering/renderers/shared/texture/RenderTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js\");\nvar BufferImageSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/BufferImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js\");\nvar CanvasSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar CompressedSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar ImageSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar TextureSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar VideoSource = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/VideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js\");\nvar Texture = __webpack_require__(/*! ./rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TextureGCSystem = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js\");\nvar TextureMatrix = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureMatrix.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js\");\nvar TexturePool = __webpack_require__(/*! ./rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar TextureStyle = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar TextureUvs = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureUvs.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.js\");\nvar getCanvasTexture = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getCanvasTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js\");\nvar getSupportedCompressedTextureFormats = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar textureFrom = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/textureFrom.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js\");\nvar createIdFromString = __webpack_require__(/*! ./rendering/renderers/shared/utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar parseFunctionBody = __webpack_require__(/*! ./rendering/renderers/shared/utils/parseFunctionBody.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.js\");\nvar ViewSystem = __webpack_require__(/*! ./rendering/renderers/shared/view/ViewSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js\");\nvar types$1 = __webpack_require__(/*! ./rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar particles = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.frag.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js\");\nvar particles$1 = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.vert.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js\");\nvar particles$2 = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.wgsl.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js\");\nvar Bounds = __webpack_require__(/*! ./scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getFastGlobalBounds = __webpack_require__(/*! ./scene/container/bounds/getFastGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ./scene/container/bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\nvar getLocalBounds = __webpack_require__(/*! ./scene/container/bounds/getLocalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js\");\nvar getRenderableBounds = __webpack_require__(/*! ./scene/container/bounds/getRenderableBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ./scene/container/bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\nvar cacheAsTextureMixin = __webpack_require__(/*! ./scene/container/container-mixins/cacheAsTextureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js\");\nvar childrenHelperMixin = __webpack_require__(/*! ./scene/container/container-mixins/childrenHelperMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js\");\nvar collectRenderablesMixin = __webpack_require__(/*! ./scene/container/container-mixins/collectRenderablesMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js\");\nvar effectsMixin = __webpack_require__(/*! ./scene/container/container-mixins/effectsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js\");\nvar findMixin = __webpack_require__(/*! ./scene/container/container-mixins/findMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js\");\nvar getFastGlobalBoundsMixin = __webpack_require__(/*! ./scene/container/container-mixins/getFastGlobalBoundsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js\");\nvar getGlobalMixin = __webpack_require__(/*! ./scene/container/container-mixins/getGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js\");\nvar measureMixin = __webpack_require__(/*! ./scene/container/container-mixins/measureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js\");\nvar onRenderMixin = __webpack_require__(/*! ./scene/container/container-mixins/onRenderMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js\");\nvar sortMixin = __webpack_require__(/*! ./scene/container/container-mixins/sortMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js\");\nvar toLocalGlobalMixin = __webpack_require__(/*! ./scene/container/container-mixins/toLocalGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js\");\nvar Container = __webpack_require__(/*! ./scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar CustomRenderPipe = __webpack_require__(/*! ./scene/container/CustomRenderPipe.js */ \"./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js\");\nvar RenderContainer = __webpack_require__(/*! ./scene/container/RenderContainer.js */ \"./node_modules/pixi.js/lib/scene/container/RenderContainer.js\");\nvar RenderGroup = __webpack_require__(/*! ./scene/container/RenderGroup.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroup.js\");\nvar RenderGroupPipe = __webpack_require__(/*! ./scene/container/RenderGroupPipe.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js\");\nvar RenderGroupSystem = __webpack_require__(/*! ./scene/container/RenderGroupSystem.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js\");\nvar assignWithIgnore = __webpack_require__(/*! ./scene/container/utils/assignWithIgnore.js */ \"./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js\");\nvar checkChildrenDidChange = __webpack_require__(/*! ./scene/container/utils/checkChildrenDidChange.js */ \"./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js\");\nvar clearList = __webpack_require__(/*! ./scene/container/utils/clearList.js */ \"./node_modules/pixi.js/lib/scene/container/utils/clearList.js\");\nvar collectAllRenderables = __webpack_require__(/*! ./scene/container/utils/collectAllRenderables.js */ \"./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.js\");\nvar definedProps = __webpack_require__(/*! ./scene/container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar executeInstructions = __webpack_require__(/*! ./scene/container/utils/executeInstructions.js */ \"./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js\");\nvar multiplyColors = __webpack_require__(/*! ./scene/container/utils/multiplyColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js\");\nvar multiplyHexColors = __webpack_require__(/*! ./scene/container/utils/multiplyHexColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js\");\nvar updateLocalTransform = __webpack_require__(/*! ./scene/container/utils/updateLocalTransform.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.js\");\nvar updateRenderGroupTransforms = __webpack_require__(/*! ./scene/container/utils/updateRenderGroupTransforms.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js\");\nvar updateWorldTransform = __webpack_require__(/*! ./scene/container/utils/updateWorldTransform.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.js\");\nvar validateRenderables = __webpack_require__(/*! ./scene/container/utils/validateRenderables.js */ \"./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js\");\nvar GlGraphicsAdaptor = __webpack_require__(/*! ./scene/graphics/gl/GlGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js\");\nvar colorToUniform = __webpack_require__(/*! ./scene/graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar GpuGraphicsAdaptor = __webpack_require__(/*! ./scene/graphics/gpu/GpuGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js\");\nvar BatchableGraphics = __webpack_require__(/*! ./scene/graphics/shared/BatchableGraphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js\");\nvar buildAdaptiveBezier = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildAdaptiveBezier.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js\");\nvar buildAdaptiveQuadratic = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js\");\nvar buildArc = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArc.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js\");\nvar buildArcTo = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArcTo.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js\");\nvar buildArcToSvg = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArcToSvg.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js\");\nvar buildCircle = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildCircle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js\");\nvar buildLine = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js\");\nvar buildPixelLine = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildPixelLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js\");\nvar buildPolygon = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildPolygon.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js\");\nvar buildRectangle = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildRectangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js\");\nvar buildTriangle = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildTriangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js\");\nvar _const$c = __webpack_require__(/*! ./scene/graphics/shared/const.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/const.js\");\nvar FillGradient = __webpack_require__(/*! ./scene/graphics/shared/fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar FillPattern = __webpack_require__(/*! ./scene/graphics/shared/fill/FillPattern.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js\");\nvar Graphics = __webpack_require__(/*! ./scene/graphics/shared/Graphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js\");\nvar GraphicsContext = __webpack_require__(/*! ./scene/graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar GraphicsContextSystem = __webpack_require__(/*! ./scene/graphics/shared/GraphicsContextSystem.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js\");\nvar GraphicsPipe = __webpack_require__(/*! ./scene/graphics/shared/GraphicsPipe.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js\");\nvar GraphicsPath = __webpack_require__(/*! ./scene/graphics/shared/path/GraphicsPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js\");\nvar roundShape = __webpack_require__(/*! ./scene/graphics/shared/path/roundShape.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js\");\nvar ShapePath = __webpack_require__(/*! ./scene/graphics/shared/path/ShapePath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js\");\nvar parseSVGDefinitions = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGDefinitions.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js\");\nvar parseSVGFloatAttribute = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGFloatAttribute.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js\");\nvar parseSVGPath = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js\");\nvar parseSVGStyle = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js\");\nvar SVGParser = __webpack_require__(/*! ./scene/graphics/shared/svg/SVGParser.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js\");\nvar extractSvgUrlId = __webpack_require__(/*! ./scene/graphics/shared/svg/utils/extractSvgUrlId.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js\");\nvar buildContextBatches = __webpack_require__(/*! ./scene/graphics/shared/utils/buildContextBatches.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js\");\nvar convertFillInputToFillStyle = __webpack_require__(/*! ./scene/graphics/shared/utils/convertFillInputToFillStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js\");\nvar generateTextureFillMatrix = __webpack_require__(/*! ./scene/graphics/shared/utils/generateTextureFillMatrix.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js\");\nvar getOrientationOfPoints = __webpack_require__(/*! ./scene/graphics/shared/utils/getOrientationOfPoints.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js\");\nvar triangulateWithHoles = __webpack_require__(/*! ./scene/graphics/shared/utils/triangulateWithHoles.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js\");\nvar RenderLayer = __webpack_require__(/*! ./scene/layers/RenderLayer.js */ \"./node_modules/pixi.js/lib/scene/layers/RenderLayer.js\");\nvar PerspectiveMesh = __webpack_require__(/*! ./scene/mesh-perspective/PerspectiveMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.js\");\nvar PerspectivePlaneGeometry = __webpack_require__(/*! ./scene/mesh-perspective/PerspectivePlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js\");\nvar applyProjectiveTransformationToPlane = __webpack_require__(/*! ./scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js\");\nvar compute2DProjections = __webpack_require__(/*! ./scene/mesh-perspective/utils/compute2DProjections.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js\");\nvar MeshPlane = __webpack_require__(/*! ./scene/mesh-plane/MeshPlane.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.js\");\nvar PlaneGeometry = __webpack_require__(/*! ./scene/mesh-plane/PlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js\");\nvar MeshRope = __webpack_require__(/*! ./scene/mesh-simple/MeshRope.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.js\");\nvar MeshSimple = __webpack_require__(/*! ./scene/mesh-simple/MeshSimple.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.js\");\nvar RopeGeometry = __webpack_require__(/*! ./scene/mesh-simple/RopeGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js\");\nvar GlMeshAdaptor = __webpack_require__(/*! ./scene/mesh/gl/GlMeshAdaptor.js */ \"./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js\");\nvar GpuMeshAdapter = __webpack_require__(/*! ./scene/mesh/gpu/GpuMeshAdapter.js */ \"./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js\");\nvar BatchableMesh = __webpack_require__(/*! ./scene/mesh/shared/BatchableMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js\");\nvar getTextureDefaultMatrix = __webpack_require__(/*! ./scene/mesh/shared/getTextureDefaultMatrix.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.js\");\nvar Mesh = __webpack_require__(/*! ./scene/mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar MeshGeometry = __webpack_require__(/*! ./scene/mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\nvar MeshPipe = __webpack_require__(/*! ./scene/mesh/shared/MeshPipe.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js\");\nvar GlParticleContainerAdaptor = __webpack_require__(/*! ./scene/particle-container/gl/GlParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js\");\nvar GpuParticleContainerAdaptor = __webpack_require__(/*! ./scene/particle-container/gpu/GpuParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js\");\nvar GlParticleContainerPipe = __webpack_require__(/*! ./scene/particle-container/shared/GlParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js\");\nvar GpuParticleContainerPipe = __webpack_require__(/*! ./scene/particle-container/shared/GpuParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js\");\nvar Particle = __webpack_require__(/*! ./scene/particle-container/shared/Particle.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.js\");\nvar ParticleBuffer = __webpack_require__(/*! ./scene/particle-container/shared/ParticleBuffer.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js\");\nvar ParticleContainer = __webpack_require__(/*! ./scene/particle-container/shared/ParticleContainer.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.js\");\nvar ParticleContainerPipe = __webpack_require__(/*! ./scene/particle-container/shared/ParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js\");\nvar particleData = __webpack_require__(/*! ./scene/particle-container/shared/particleData.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js\");\nvar ParticleShader = __webpack_require__(/*! ./scene/particle-container/shared/shader/ParticleShader.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js\");\nvar createIndicesForQuads = __webpack_require__(/*! ./scene/particle-container/shared/utils/createIndicesForQuads.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js\");\nvar generateParticleUpdateFunction = __webpack_require__(/*! ./scene/particle-container/shared/utils/generateParticleUpdateFunction.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js\");\nvar AnimatedSprite = __webpack_require__(/*! ./scene/sprite-animated/AnimatedSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js\");\nvar NineSliceGeometry = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js\");\nvar NineSliceSprite = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.js\");\nvar NineSliceSpritePipe = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js\");\nvar tilingBit = __webpack_require__(/*! ./scene/sprite-tiling/shader/tilingBit.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js\");\nvar TilingSpriteShader = __webpack_require__(/*! ./scene/sprite-tiling/shader/TilingSpriteShader.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js\");\nvar TilingSprite = __webpack_require__(/*! ./scene/sprite-tiling/TilingSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js\");\nvar TilingSpritePipe = __webpack_require__(/*! ./scene/sprite-tiling/TilingSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js\");\nvar applyMatrix = __webpack_require__(/*! ./scene/sprite-tiling/utils/applyMatrix.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js\");\nvar QuadGeometry = __webpack_require__(/*! ./scene/sprite-tiling/utils/QuadGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js\");\nvar setPositions = __webpack_require__(/*! ./scene/sprite-tiling/utils/setPositions.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js\");\nvar setUvs = __webpack_require__(/*! ./scene/sprite-tiling/utils/setUvs.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js\");\nvar BatchableSprite = __webpack_require__(/*! ./scene/sprite/BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\nvar Sprite = __webpack_require__(/*! ./scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar SpritePipe = __webpack_require__(/*! ./scene/sprite/SpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js\");\nvar AbstractBitmapFont = __webpack_require__(/*! ./scene/text-bitmap/AbstractBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js\");\nvar bitmapFontTextParser = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontTextParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js\");\nvar bitmapFontXMLParser = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontXMLParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js\");\nvar bitmapFontXMLStringParser = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontXMLStringParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js\");\nvar loadBitmapFont = __webpack_require__(/*! ./scene/text-bitmap/asset/loadBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js\");\nvar BitmapFont = __webpack_require__(/*! ./scene/text-bitmap/BitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js\");\nvar BitmapFontManager = __webpack_require__(/*! ./scene/text-bitmap/BitmapFontManager.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js\");\nvar BitmapText = __webpack_require__(/*! ./scene/text-bitmap/BitmapText.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js\");\nvar BitmapTextPipe = __webpack_require__(/*! ./scene/text-bitmap/BitmapTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js\");\nvar DynamicBitmapFont = __webpack_require__(/*! ./scene/text-bitmap/DynamicBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js\");\nvar getBitmapTextLayout = __webpack_require__(/*! ./scene/text-bitmap/utils/getBitmapTextLayout.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js\");\nvar resolveCharacters = __webpack_require__(/*! ./scene/text-bitmap/utils/resolveCharacters.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js\");\nvar BatchableHTMLText = __webpack_require__(/*! ./scene/text-html/BatchableHTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js\");\nvar HTMLText = __webpack_require__(/*! ./scene/text-html/HTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLText.js\");\nvar HTMLTextPipe = __webpack_require__(/*! ./scene/text-html/HTMLTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js\");\nvar HTMLTextRenderData = __webpack_require__(/*! ./scene/text-html/HTMLTextRenderData.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js\");\nvar HTMLTextStyle = __webpack_require__(/*! ./scene/text-html/HTMLTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js\");\nvar HTMLTextSystem = __webpack_require__(/*! ./scene/text-html/HTMLTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js\");\nvar extractFontFamilies = __webpack_require__(/*! ./scene/text-html/utils/extractFontFamilies.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js\");\nvar getFontCss = __webpack_require__(/*! ./scene/text-html/utils/getFontCss.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js\");\nvar getSVGUrl = __webpack_require__(/*! ./scene/text-html/utils/getSVGUrl.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js\");\nvar getTemporaryCanvasFromImage = __webpack_require__(/*! ./scene/text-html/utils/getTemporaryCanvasFromImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js\");\nvar loadFontAsBase64 = __webpack_require__(/*! ./scene/text-html/utils/loadFontAsBase64.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js\");\nvar loadFontCSS = __webpack_require__(/*! ./scene/text-html/utils/loadFontCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js\");\nvar loadSVGImage = __webpack_require__(/*! ./scene/text-html/utils/loadSVGImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js\");\nvar measureHtmlText = __webpack_require__(/*! ./scene/text-html/utils/measureHtmlText.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js\");\nvar textStyleToCSS = __webpack_require__(/*! ./scene/text-html/utils/textStyleToCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js\");\nvar AbstractText = __webpack_require__(/*! ./scene/text/AbstractText.js */ \"./node_modules/pixi.js/lib/scene/text/AbstractText.js\");\nvar BatchableText = __webpack_require__(/*! ./scene/text/canvas/BatchableText.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js\");\nvar CanvasTextGenerator = __webpack_require__(/*! ./scene/text/canvas/CanvasTextGenerator.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ./scene/text/canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar CanvasTextPipe = __webpack_require__(/*! ./scene/text/canvas/CanvasTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js\");\nvar CanvasTextSystem = __webpack_require__(/*! ./scene/text/canvas/CanvasTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js\");\nvar fontStringFromTextStyle = __webpack_require__(/*! ./scene/text/canvas/utils/fontStringFromTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js\");\nvar getCanvasFillStyle = __webpack_require__(/*! ./scene/text/canvas/utils/getCanvasFillStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js\");\nvar SdfShader = __webpack_require__(/*! ./scene/text/sdfShader/SdfShader.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js\");\nvar localUniformMSDFBit = __webpack_require__(/*! ./scene/text/sdfShader/shader-bits/localUniformMSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js\");\nvar mSDFBit = __webpack_require__(/*! ./scene/text/sdfShader/shader-bits/mSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js\");\nvar Text = __webpack_require__(/*! ./scene/text/Text.js */ \"./node_modules/pixi.js/lib/scene/text/Text.js\");\nvar TextStyle = __webpack_require__(/*! ./scene/text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar generateTextStyleKey = __webpack_require__(/*! ./scene/text/utils/generateTextStyleKey.js */ \"./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js\");\nvar getPo2TextureFromSource = __webpack_require__(/*! ./scene/text/utils/getPo2TextureFromSource.js */ \"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js\");\nvar updateTextBounds = __webpack_require__(/*! ./scene/text/utils/updateTextBounds.js */ \"./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js\");\nvar ViewContainer = __webpack_require__(/*! ./scene/view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar Spritesheet = __webpack_require__(/*! ./spritesheet/Spritesheet.js */ \"./node_modules/pixi.js/lib/spritesheet/Spritesheet.js\");\nvar spritesheetAsset = __webpack_require__(/*! ./spritesheet/spritesheetAsset.js */ \"./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js\");\nvar _const$d = __webpack_require__(/*! ./ticker/const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ./ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\nvar TickerListener = __webpack_require__(/*! ./ticker/TickerListener.js */ \"./node_modules/pixi.js/lib/ticker/TickerListener.js\");\nvar detectVideoAlphaMode = __webpack_require__(/*! ./utils/browser/detectVideoAlphaMode.js */ \"./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js\");\nvar isMobile = __webpack_require__(/*! ./utils/browser/isMobile.js */ \"./node_modules/pixi.js/lib/utils/browser/isMobile.js\");\nvar isSafari = __webpack_require__(/*! ./utils/browser/isSafari.js */ \"./node_modules/pixi.js/lib/utils/browser/isSafari.js\");\nvar isWebGLSupported = __webpack_require__(/*! ./utils/browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ./utils/browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\nvar unsafeEvalSupported = __webpack_require__(/*! ./utils/browser/unsafeEvalSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js\");\nvar getCanvasBoundingBox = __webpack_require__(/*! ./utils/canvas/getCanvasBoundingBox.js */ \"./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js\");\nvar _const$e = __webpack_require__(/*! ./utils/const.js */ \"./node_modules/pixi.js/lib/utils/const.js\");\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar clean = __webpack_require__(/*! ./utils/data/clean.js */ \"./node_modules/pixi.js/lib/utils/data/clean.js\");\nvar removeItems = __webpack_require__(/*! ./utils/data/removeItems.js */ \"./node_modules/pixi.js/lib/utils/data/removeItems.js\");\nvar uid = __webpack_require__(/*! ./utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar updateQuadBounds = __webpack_require__(/*! ./utils/data/updateQuadBounds.js */ \"./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js\");\nvar ViewableBuffer = __webpack_require__(/*! ./utils/data/ViewableBuffer.js */ \"./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js\");\nvar globalHooks = __webpack_require__(/*! ./utils/global/globalHooks.js */ \"./node_modules/pixi.js/lib/utils/global/globalHooks.js\");\nvar deprecation = __webpack_require__(/*! ./utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar logDebugTexture = __webpack_require__(/*! ./utils/logging/logDebugTexture.js */ \"./node_modules/pixi.js/lib/utils/logging/logDebugTexture.js\");\nvar logScene = __webpack_require__(/*! ./utils/logging/logScene.js */ \"./node_modules/pixi.js/lib/utils/logging/logScene.js\");\nvar warn = __webpack_require__(/*! ./utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar NOOP = __webpack_require__(/*! ./utils/misc/NOOP.js */ \"./node_modules/pixi.js/lib/utils/misc/NOOP.js\");\nvar Transform = __webpack_require__(/*! ./utils/misc/Transform.js */ \"./node_modules/pixi.js/lib/utils/misc/Transform.js\");\nvar getResolutionOfUrl = __webpack_require__(/*! ./utils/network/getResolutionOfUrl.js */ \"./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js\");\nvar path = __webpack_require__(/*! ./utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar Pool = __webpack_require__(/*! ./utils/pool/Pool.js */ \"./node_modules/pixi.js/lib/utils/pool/Pool.js\");\nvar PoolGroup = __webpack_require__(/*! ./utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar sayHello = __webpack_require__(/*! ./utils/sayHello.js */ \"./node_modules/pixi.js/lib/utils/sayHello.js\");\nvar utils = __webpack_require__(/*! ./utils/utils.js */ \"./node_modules/pixi.js/lib/utils/utils.js\");\n\n\"use strict\";\nExtensions.extensions.add(browserExt.browserExt, webworkerExt.webworkerExt);\n\nexports.browserExt = browserExt.browserExt;\nexports.webworkerExt = webworkerExt.webworkerExt;\nexports.ExtensionType = Extensions.ExtensionType;\nexports.extensions = Extensions.extensions;\nexports.normalizeExtensionPriority = Extensions.normalizeExtensionPriority;\nexports.AccessibilitySystem = AccessibilitySystem.AccessibilitySystem;\nexports.accessibilityTarget = accessibilityTarget.accessibilityTarget;\nexports.ColorBlend = ColorBlend.ColorBlend;\nexports.ColorBurnBlend = ColorBurnBlend.ColorBurnBlend;\nexports.ColorDodgeBlend = ColorDodgeBlend.ColorDodgeBlend;\nexports.DarkenBlend = DarkenBlend.DarkenBlend;\nexports.DifferenceBlend = DifferenceBlend.DifferenceBlend;\nexports.DivideBlend = DivideBlend.DivideBlend;\nexports.ExclusionBlend = ExclusionBlend.ExclusionBlend;\nexports.HardLightBlend = HardLightBlend.HardLightBlend;\nexports.HardMixBlend = HardMixBlend.HardMixBlend;\nexports.LightenBlend = LightenBlend.LightenBlend;\nexports.LinearBurnBlend = LinearBurnBlend.LinearBurnBlend;\nexports.LinearDodgeBlend = LinearDodgeBlend.LinearDodgeBlend;\nexports.LinearLightBlend = LinearLightBlend.LinearLightBlend;\nexports.LuminosityBlend = LuminosityBlend.LuminosityBlend;\nexports.NegationBlend = NegationBlend.NegationBlend;\nexports.OverlayBlend = OverlayBlend.OverlayBlend;\nexports.PinLightBlend = PinLightBlend.PinLightBlend;\nexports.SaturationBlend = SaturationBlend.SaturationBlend;\nexports.SoftLightBlend = SoftLightBlend.SoftLightBlend;\nexports.SubtractBlend = SubtractBlend.SubtractBlend;\nexports.VividLightBlend = VividLightBlend.VividLightBlend;\nexports.Application = Application.Application;\nexports.ResizePlugin = ResizePlugin.ResizePlugin;\nexports.TickerPlugin = TickerPlugin.TickerPlugin;\nexports.Assets = Assets.Assets;\nexports.AssetsClass = Assets.AssetsClass;\nexports.BackgroundLoader = BackgroundLoader.BackgroundLoader;\nexports.Cache = Cache.Cache;\nexports.cacheTextureArray = cacheTextureArray.cacheTextureArray;\nexports.detectAvif = detectAvif.detectAvif;\nexports.detectDefaults = detectDefaults.detectDefaults;\nexports.detectMp4 = detectMp4.detectMp4;\nexports.detectOgv = detectOgv.detectOgv;\nexports.detectWebm = detectWebm.detectWebm;\nexports.detectWebp = detectWebp.detectWebp;\nexports.testImageFormat = testImageFormat.testImageFormat;\nexports.testVideoFormat = testVideoFormat.testVideoFormat;\nexports.Loader = Loader.Loader;\nexports.LoaderParserPriority = LoaderParser.LoaderParserPriority;\nexports.loadJson = loadJson.loadJson;\nexports.loadTxt = loadTxt.loadTxt;\nexports.getFontFamilyName = loadWebFont.getFontFamilyName;\nexports.loadWebFont = loadWebFont.loadWebFont;\nexports.loadSvg = loadSVG.loadSvg;\nexports.loadImageBitmap = loadTextures.loadImageBitmap;\nexports.loadTextures = loadTextures.loadTextures;\nexports.crossOrigin = loadVideoTextures.crossOrigin;\nexports.determineCrossOrigin = loadVideoTextures.determineCrossOrigin;\nexports.loadVideoTextures = loadVideoTextures.loadVideoTextures;\nexports.preloadVideo = loadVideoTextures.preloadVideo;\nexports.createTexture = createTexture.createTexture;\nexports.WorkerManager = WorkerManager.WorkerManager;\nexports.resolveJsonUrl = resolveJsonUrl.resolveJsonUrl;\nexports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;\nexports.Resolver = Resolver.Resolver;\nexports.getUrlExtension = Resolver.getUrlExtension;\nexports.checkDataUrl = checkDataUrl.checkDataUrl;\nexports.checkExtension = checkExtension.checkExtension;\nexports.convertToList = convertToList.convertToList;\nexports.copySearchParams = copySearchParams.copySearchParams;\nexports.createStringVariations = createStringVariations.createStringVariations;\nexports.isSingleItem = isSingleItem.isSingleItem;\nexports.Color = Color.Color;\nexports.detectBasis = detectBasis.detectBasis;\nexports.loadBasis = loadBasis.loadBasis;\nexports.createLevelBuffers = createLevelBuffers.createLevelBuffers;\nexports.gpuFormatToBasisTranscoderFormat = gpuFormatToBasisTranscoderFormat.gpuFormatToBasisTranscoderFormat;\nexports.basisTranscoderUrls = setBasisTranscoderPath.basisTranscoderUrls;\nexports.setBasisTranscoderPath = setBasisTranscoderPath.setBasisTranscoderPath;\nexports.loadBasisOnWorker = loadBasisOnWorker.loadBasisOnWorker;\nexports.D3D10_RESOURCE_DIMENSION = _const.D3D10_RESOURCE_DIMENSION;\nexports.D3DFMT = _const.D3DFMT;\nexports.DDS = _const.DDS;\nexports.DXGI_FORMAT = _const.DXGI_FORMAT;\nexports.DXGI_TO_TEXTURE_FORMAT = _const.DXGI_TO_TEXTURE_FORMAT;\nexports.FOURCC_TO_TEXTURE_FORMAT = _const.FOURCC_TO_TEXTURE_FORMAT;\nexports.TEXTURE_FORMAT_BLOCK_SIZE = _const.TEXTURE_FORMAT_BLOCK_SIZE;\nexports.loadDDS = loadDDS.loadDDS;\nexports.parseDDS = parseDDS.parseDDS;\nexports.loadKTX = loadKTX.loadKTX;\nexports.parseKTX = parseKTX.parseKTX;\nexports.GL_INTERNAL_FORMAT = _const$1.GL_INTERNAL_FORMAT;\nexports.KTX = _const$1.KTX;\nexports.loadKTX2 = loadKTX2.loadKTX2;\nexports.convertFormatIfRequired = convertFormatIfRequired.convertFormatIfRequired;\nexports.createLevelBuffersFromKTX = createLevelBuffersFromKTX.createLevelBuffersFromKTX;\nexports.getTextureFormatFromKTXTexture = getTextureFormatFromKTXTexture.getTextureFormatFromKTXTexture;\nexports.glFormatToGPUFormat = glFormatToGPUFormat.glFormatToGPUFormat;\nexports.gpuFormatToKTXBasisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat.gpuFormatToKTXBasisTranscoderFormat;\nexports.ktxTranscoderUrls = setKTXTranscoderPath.ktxTranscoderUrls;\nexports.setKTXTranscoderPath = setKTXTranscoderPath.setKTXTranscoderPath;\nexports.vkFormatToGPUFormat = vkFormatToGPUFormat.vkFormatToGPUFormat;\nexports.loadKTX2onWorker = loadKTX2onWorker.loadKTX2onWorker;\nexports.detectCompressed = detectCompressed.detectCompressed;\nexports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;\nexports.validFormats = resolveCompressedTextureUrl.validFormats;\nexports.Culler = Culler.Culler;\nexports.CullerPlugin = CullerPlugin.CullerPlugin;\nexports.cullingMixin = cullingMixin.cullingMixin;\nexports.DOMContainer = DOMContainer.DOMContainer;\nexports.DOMPipe = DOMPipe.DOMPipe;\nexports.DOMAdapter = adapter.DOMAdapter;\nexports.autoDetectEnvironment = autoDetectEnvironment.autoDetectEnvironment;\nexports.loadEnvironmentExtensions = autoDetectEnvironment.loadEnvironmentExtensions;\nexports.BrowserAdapter = BrowserAdapter.BrowserAdapter;\nexports.WebWorkerAdapter = WebWorkerAdapter.WebWorkerAdapter;\nexports.EventBoundary = EventBoundary.EventBoundary;\nexports.EventSystem = EventSystem.EventSystem;\nexports.EventsTicker = EventTicker.EventsTicker;\nexports.FederatedEvent = FederatedEvent.FederatedEvent;\nexports.FederatedContainer = FederatedEventTarget.FederatedContainer;\nexports.FederatedMouseEvent = FederatedMouseEvent.FederatedMouseEvent;\nexports.FederatedPointerEvent = FederatedPointerEvent.FederatedPointerEvent;\nexports.FederatedWheelEvent = FederatedWheelEvent.FederatedWheelEvent;\nexports.blendTemplateFrag = blendTemplate.default;\nexports.blendTemplateVert = blendTemplate$1.default;\nexports.blendTemplateWgsl = blendTemplate$2.default;\nexports.hslWgsl = hsl.default;\nexports.alphaFrag = alpha.default;\nexports.alphaWgsl = alpha$1.default;\nexports.blurTemplateWgsl = blurTemplate.default;\nexports.colorMatrixFilterFrag = colorMatrixFilter.default;\nexports.colorMatrixFilterWgsl = colorMatrixFilter$1.default;\nexports.defaultFilterVert = defaultFilter.default;\nexports.displacementFrag = displacement.default;\nexports.displacementVert = displacement$1.default;\nexports.displacementWgsl = displacement$2.default;\nexports.noiseFrag = noise.default;\nexports.noiseWgsl = noise$1.default;\nexports.maskFrag = mask.default;\nexports.maskVert = mask$1.default;\nexports.maskWgsl = mask$2.default;\nexports.BlendModeFilter = BlendModeFilter.BlendModeFilter;\nexports.hslgl = GLhls.hslgl;\nexports.hslgpu = GPUhls.hslgpu;\nexports.AlphaFilter = AlphaFilter.AlphaFilter;\nexports.BlurFilter = BlurFilter.BlurFilter;\nexports.BlurFilterPass = BlurFilterPass.BlurFilterPass;\nexports.GAUSSIAN_VALUES = _const$2.GAUSSIAN_VALUES;\nexports.generateBlurFragSource = generateBlurFragSource.generateBlurFragSource;\nexports.generateBlurGlProgram = generateBlurGlProgram.generateBlurGlProgram;\nexports.generateBlurVertSource = generateBlurVertSource.generateBlurVertSource;\nexports.generateBlurProgram = generateBlurProgram.generateBlurProgram;\nexports.ColorMatrixFilter = ColorMatrixFilter.ColorMatrixFilter;\nexports.DisplacementFilter = DisplacementFilter.DisplacementFilter;\nexports.NoiseFilter = NoiseFilter.NoiseFilter;\nexports.Filter = Filter.Filter;\nexports.FilterEffect = FilterEffect.FilterEffect;\nexports.FilterPipe = FilterPipe.FilterPipe;\nexports.FilterSystem = FilterSystem.FilterSystem;\nexports.MaskFilter = MaskFilter.MaskFilter;\nexports.groupD8 = groupD8.groupD8;\nexports.Matrix = Matrix.Matrix;\nexports.DEG_TO_RAD = _const$3.DEG_TO_RAD;\nexports.PI_2 = _const$3.PI_2;\nexports.RAD_TO_DEG = _const$3.RAD_TO_DEG;\nexports.isPow2 = pow2.isPow2;\nexports.log2 = pow2.log2;\nexports.nextPow2 = pow2.nextPow2;\nexports.squaredDistanceToLineSegment = squaredDistanceToLineSegment.squaredDistanceToLineSegment;\nexports.ObservablePoint = ObservablePoint.ObservablePoint;\nexports.Point = Point.Point;\nexports.pointInTriangle = pointInTriangle.pointInTriangle;\nexports.Circle = Circle.Circle;\nexports.Ellipse = Ellipse.Ellipse;\nexports.Polygon = Polygon.Polygon;\nexports.Rectangle = Rectangle.Rectangle;\nexports.RoundedRectangle = RoundedRectangle.RoundedRectangle;\nexports.Triangle = Triangle.Triangle;\nexports.PrepareBase = PrepareBase.PrepareBase;\nexports.PrepareQueue = PrepareQueue.PrepareQueue;\nexports.PrepareSystem = PrepareSystem.PrepareSystem;\nexports.PrepareUpload = PrepareUpload.PrepareUpload;\nexports.GlBatchAdaptor = GlBatchAdaptor.GlBatchAdaptor;\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;\nexports.getMaxTexturesPerBatch = maxRecommendedTextures.getMaxTexturesPerBatch;\nexports.generateGPULayout = generateGPULayout.generateGPULayout;\nexports.generateLayout = generateLayout.generateLayout;\nexports.getTextureBatchBindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup;\nexports.GpuBatchAdaptor = GpuBatchAdaptor.GpuBatchAdaptor;\nexports.Batch = Batcher.Batch;\nexports.Batcher = Batcher.Batcher;\nexports.BatcherPipe = BatcherPipe.BatcherPipe;\nexports.BatchGeometry = BatchGeometry.BatchGeometry;\nexports.BatchTextureArray = BatchTextureArray.BatchTextureArray;\nexports.DefaultBatcher = DefaultBatcher.DefaultBatcher;\nexports.DefaultShader = DefaultShader.DefaultShader;\nexports.compileHighShaderGlProgram = compileHighShaderToProgram.compileHighShaderGlProgram;\nexports.compileHighShaderGpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram;\nexports.compileHighShader = compileHighShader.compileHighShader;\nexports.compileHighShaderGl = compileHighShader.compileHighShaderGl;\nexports.addBits = addBits.addBits;\nexports.compileHooks = compileHooks.compileHooks;\nexports.compileInputs = compileInputs.compileInputs;\nexports.compileOutputs = compileOutputs.compileOutputs;\nexports.formatShader = formatShader.formatShader;\nexports.injectBits = injectBits.injectBits;\nexports.fragmentGPUTemplate = defaultProgramTemplate.fragmentGPUTemplate;\nexports.fragmentGlTemplate = defaultProgramTemplate.fragmentGlTemplate;\nexports.vertexGPUTemplate = defaultProgramTemplate.vertexGPUTemplate;\nexports.vertexGlTemplate = defaultProgramTemplate.vertexGlTemplate;\nexports.colorBit = colorBit.colorBit;\nexports.colorBitGl = colorBit.colorBitGl;\nexports.generateTextureBatchBit = generateTextureBatchBit.generateTextureBatchBit;\nexports.generateTextureBatchBitGl = generateTextureBatchBit.generateTextureBatchBitGl;\nexports.globalUniformsBit = globalUniformsBit.globalUniformsBit;\nexports.globalUniformsBitGl = globalUniformsBit.globalUniformsBitGl;\nexports.globalUniformsUBOBitGl = globalUniformsBit.globalUniformsUBOBitGl;\nexports.localUniformBit = localUniformBit.localUniformBit;\nexports.localUniformBitGl = localUniformBit.localUniformBitGl;\nexports.localUniformBitGroup2 = localUniformBit.localUniformBitGroup2;\nexports.roundPixelsBit = roundPixelsBit.roundPixelsBit;\nexports.roundPixelsBitGl = roundPixelsBit.roundPixelsBitGl;\nexports.textureBit = textureBit.textureBit;\nexports.textureBitGl = textureBit.textureBitGl;\nexports.AlphaMask = AlphaMask.AlphaMask;\nexports.AlphaMaskPipe = AlphaMaskPipe.AlphaMaskPipe;\nexports.ColorMask = ColorMask.ColorMask;\nexports.ColorMaskPipe = ColorMaskPipe.ColorMaskPipe;\nexports.MaskEffectManager = MaskEffectManager.MaskEffectManager;\nexports.MaskEffectManagerClass = MaskEffectManager.MaskEffectManagerClass;\nexports.ScissorMask = ScissorMask.ScissorMask;\nexports.StencilMask = StencilMask.StencilMask;\nexports.StencilMaskPipe = StencilMaskPipe.StencilMaskPipe;\nexports.addMaskBounds = addMaskBounds.addMaskBounds;\nexports.addMaskLocalBounds = addMaskLocalBounds.addMaskLocalBounds;\nexports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;\nexports.BUFFER_TYPE = _const$4.BUFFER_TYPE;\nexports.GlBuffer = GlBuffer.GlBuffer;\nexports.GlBufferSystem = GlBufferSystem.GlBufferSystem;\nexports.CLEAR = _const$5.CLEAR;\nexports.GlContextSystem = GlContextSystem.GlContextSystem;\nexports.GlGeometrySystem = GlGeometrySystem.GlGeometrySystem;\nexports.getGlTypeFromFormat = getGlTypeFromFormat.getGlTypeFromFormat;\nexports.GlBackBufferSystem = GlBackBufferSystem.GlBackBufferSystem;\nexports.GlColorMaskSystem = GlColorMaskSystem.GlColorMaskSystem;\nexports.GlEncoderSystem = GlEncoderSystem.GlEncoderSystem;\nexports.GlLimitsSystem = GlLimitsSystem.GlLimitsSystem;\nexports.GlRenderTarget = GlRenderTarget.GlRenderTarget;\nexports.GlStencilSystem = GlStencilSystem.GlStencilSystem;\nexports.GlUboSystem = GlUboSystem.GlUboSystem;\nexports.GlRenderTargetAdaptor = GlRenderTargetAdaptor.GlRenderTargetAdaptor;\nexports.GlRenderTargetSystem = GlRenderTargetSystem.GlRenderTargetSystem;\nexports.generateShaderSyncCode = GenerateShaderSyncCode.generateShaderSyncCode;\nexports.getBatchSamplersUniformGroup = getBatchSamplersUniformGroup.getBatchSamplersUniformGroup;\nexports.GlProgram = GlProgram.GlProgram;\nexports.GlProgramData = GlProgramData.GlProgramData;\nexports.IGLUniformData = GlProgramData.IGLUniformData;\nexports.GlShaderSystem = GlShaderSystem.GlShaderSystem;\nexports.GlUniformGroupSystem = GlUniformGroupSystem.GlUniformGroupSystem;\nexports.migrateFragmentFromV7toV8 = migrateFragmentFromV7toV8.migrateFragmentFromV7toV8;\nexports.compileShader = compileShader.compileShader;\nexports.defaultValue = defaultValue.defaultValue;\nexports.ensureAttributes = ensureAttributes.ensureAttributes;\nexports.extractAttributesFromGlProgram = extractAttributesFromGlProgram.extractAttributesFromGlProgram;\nexports.generateProgram = generateProgram.generateProgram;\nexports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;\nexports.getTestContext = getTestContext.getTestContext;\nexports.getUboData = getUboData.getUboData;\nexports.getUniformData = getUniformData.getUniformData;\nexports.logProgramError = logProgramError.logProgramError;\nexports.mapSize = mapSize.mapSize;\nexports.mapGlToVertexFormat = mapType.mapGlToVertexFormat;\nexports.mapType = mapType.mapType;\nexports.addProgramDefines = addProgramDefines.addProgramDefines;\nexports.ensurePrecision = ensurePrecision.ensurePrecision;\nexports.insertVersion = insertVersion.insertVersion;\nexports.setProgramName = setProgramName.setProgramName;\nexports.stripVersion = stripVersion.stripVersion;\nexports.WGSL_TO_STD40_SIZE = createUboElementsSTD40.WGSL_TO_STD40_SIZE;\nexports.createUboElementsSTD40 = createUboElementsSTD40.createUboElementsSTD40;\nexports.createUboSyncFunctionSTD40 = createUboSyncSTD40.createUboSyncFunctionSTD40;\nexports.generateArraySyncSTD40 = generateArraySyncSTD40.generateArraySyncSTD40;\nexports.generateUniformsSync = generateUniformsSync.generateUniformsSync;\nexports.UNIFORM_TO_ARRAY_SETTERS = generateUniformsSyncTypes.UNIFORM_TO_ARRAY_SETTERS;\nexports.UNIFORM_TO_SINGLE_SETTERS = generateUniformsSyncTypes.UNIFORM_TO_SINGLE_SETTERS;\nexports.GlStateSystem = GlStateSystem.GlStateSystem;\nexports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi;\nexports.GL_FORMATS = _const$6.GL_FORMATS;\nexports.GL_TARGETS = _const$6.GL_TARGETS;\nexports.GL_TYPES = _const$6.GL_TYPES;\nexports.GL_WRAP_MODES = _const$6.GL_WRAP_MODES;\nexports.GlTexture = GlTexture.GlTexture;\nexports.GlTextureSystem = GlTextureSystem.GlTextureSystem;\nexports.glUploadBufferImageResource = glUploadBufferImageResource.glUploadBufferImageResource;\nexports.glUploadCompressedTextureResource = glUploadCompressedTextureResource.glUploadCompressedTextureResource;\nexports.glUploadImageResource = glUploadImageResource.glUploadImageResource;\nexports.glUploadVideoResource = glUploadVideoResource.glUploadVideoResource;\nexports.applyStyleParams = applyStyleParams.applyStyleParams;\nexports.getSupportedGlCompressedTextureFormats = getSupportedGlCompressedTextureFormats.getSupportedGlCompressedTextureFormats;\nexports.mapFormatToGlFormat = mapFormatToGlFormat.mapFormatToGlFormat;\nexports.mapFormatToGlInternalFormat = mapFormatToGlInternalFormat.mapFormatToGlInternalFormat;\nexports.mapFormatToGlType = mapFormatToGlType.mapFormatToGlType;\nexports.compareModeToGlCompare = pixiToGlMaps.compareModeToGlCompare;\nexports.mipmapScaleModeToGlFilter = pixiToGlMaps.mipmapScaleModeToGlFilter;\nexports.scaleModeToGlFilter = pixiToGlMaps.scaleModeToGlFilter;\nexports.wrapModeToGlAddress = pixiToGlMaps.wrapModeToGlAddress;\nexports.unpremultiplyAlpha = unpremultiplyAlpha.unpremultiplyAlpha;\nexports.WebGLRenderer = WebGLRenderer.WebGLRenderer;\nexports.BindGroupSystem = BindGroupSystem.BindGroupSystem;\nexports.GpuBufferSystem = GpuBufferSystem.GpuBufferSystem;\nexports.UboBatch = UboBatch.UboBatch;\nexports.GpuColorMaskSystem = GpuColorMaskSystem.GpuColorMaskSystem;\nexports.GpuDeviceSystem = GpuDeviceSystem.GpuDeviceSystem;\nexports.GpuEncoderSystem = GpuEncoderSystem.GpuEncoderSystem;\nexports.GpuLimitsSystem = GpuLimitsSystem.GpuLimitsSystem;\nexports.GpuStencilSystem = GpuStencilSystem.GpuStencilSystem;\nexports.GpuUboSystem = GpuUboSystem.GpuUboSystem;\nexports.GpuUniformBatchPipe = GpuUniformBatchPipe.GpuUniformBatchPipe;\nexports.PipelineSystem = PipelineSystem.PipelineSystem;\nexports.calculateProjection = calculateProjection.calculateProjection;\nexports.GpuRenderTarget = GpuRenderTarget.GpuRenderTarget;\nexports.GpuRenderTargetAdaptor = GpuRenderTargetAdaptor.GpuRenderTargetAdaptor;\nexports.GpuRenderTargetSystem = GpuRenderTargetSystem.GpuRenderTargetSystem;\nexports.BindGroup = BindGroup.BindGroup;\nexports.GpuProgram = GpuProgram.GpuProgram;\nexports.GpuShaderSystem = GpuShaderSystem.GpuShaderSystem;\nexports.WGSL_ALIGN_SIZE_DATA = createUboElementsWGSL.WGSL_ALIGN_SIZE_DATA;\nexports.createUboElementsWGSL = createUboElementsWGSL.createUboElementsWGSL;\nexports.createUboSyncFunctionWGSL = createUboSyncFunctionWGSL.createUboSyncFunctionWGSL;\nexports.extractAttributesFromGpuProgram = extractAttributesFromGpuProgram.extractAttributesFromGpuProgram;\nexports.extractStructAndGroups = extractStructAndGroups.extractStructAndGroups;\nexports.generateArraySyncWGSL = generateArraySyncWGSL.generateArraySyncWGSL;\nexports.generateGpuLayoutGroups = generateGpuLayoutGroups.generateGpuLayoutGroups;\nexports.generateLayoutHash = generateLayoutHash.generateLayoutHash;\nexports.removeStructAndGroupDuplicates = removeStructAndGroupDuplicates.removeStructAndGroupDuplicates;\nexports.GpuBlendModesToPixi = GpuBlendModesToPixi.GpuBlendModesToPixi;\nexports.GpuStateSystem = GpuStateSystem.GpuStateSystem;\nexports.GpuStencilModesToPixi = GpuStencilModesToPixi.GpuStencilModesToPixi;\nexports.GpuTextureSystem = GpuTextureSystem.GpuTextureSystem;\nexports.gpuUploadBufferImageResource = gpuUploadBufferImageResource.gpuUploadBufferImageResource;\nexports.blockDataMap = gpuUploadCompressedTextureResource.blockDataMap;\nexports.gpuUploadCompressedTextureResource = gpuUploadCompressedTextureResource.gpuUploadCompressedTextureResource;\nexports.gpuUploadImageResource = gpuUploadImageSource.gpuUploadImageResource;\nexports.gpuUploadVideoResource = gpuUploadVideoSource.gpuUploadVideoResource;\nexports.getSupportedGPUCompressedTextureFormats = getSupportedGPUCompressedTextureFormats.getSupportedGPUCompressedTextureFormats;\nexports.GpuMipmapGenerator = GpuMipmapGenerator.GpuMipmapGenerator;\nexports.WebGPURenderer = WebGPURenderer.WebGPURenderer;\nexports.BackgroundSystem = BackgroundSystem.BackgroundSystem;\nexports.BlendModePipe = BlendModePipe.BlendModePipe;\nexports.Buffer = Buffer.Buffer;\nexports.BufferResource = BufferResource.BufferResource;\nexports.BufferUsage = _const$7.BufferUsage;\nexports.fastCopy = fastCopy.fastCopy;\nexports.ExtractSystem = ExtractSystem.ExtractSystem;\nexports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;\nexports.DRAW_MODES = _const$8.DRAW_MODES;\nexports.Geometry = Geometry.Geometry;\nexports.buildSimpleUvs = buildUvs.buildSimpleUvs;\nexports.buildUvs = buildUvs.buildUvs;\nexports.ensureIsBuffer = ensureIsBuffer.ensureIsBuffer;\nexports.getAttributeInfoFromFormat = getAttributeInfoFromFormat.getAttributeInfoFromFormat;\nexports.getGeometryBounds = getGeometryBounds.getGeometryBounds;\nexports.transformVertices = transformVertices.transformVertices;\nexports.InstructionSet = InstructionSet.InstructionSet;\nexports.GlobalUniformSystem = GlobalUniformSystem.GlobalUniformSystem;\nexports.isRenderingToScreen = isRenderingToScreen.isRenderingToScreen;\nexports.RenderTarget = RenderTarget.RenderTarget;\nexports.RenderTargetSystem = RenderTargetSystem.RenderTargetSystem;\nexports.SchedulerSystem = SchedulerSystem.SchedulerSystem;\nexports.ShaderStage = _const$9.ShaderStage;\nexports.Shader = Shader.Shader;\nexports.UNIFORM_TYPES_MAP = types.UNIFORM_TYPES_MAP;\nexports.UNIFORM_TYPES_VALUES = types.UNIFORM_TYPES_VALUES;\nexports.UboSystem = UboSystem.UboSystem;\nexports.UniformGroup = UniformGroup.UniformGroup;\nexports.createUboSyncFunction = createUboSyncFunction.createUboSyncFunction;\nexports.getDefaultUniformValue = getDefaultUniformValue.getDefaultUniformValue;\nexports.uboSyncFunctionsSTD40 = uboSyncFunctions.uboSyncFunctionsSTD40;\nexports.uboSyncFunctionsWGSL = uboSyncFunctions.uboSyncFunctionsWGSL;\nexports.uniformParsers = uniformParsers.uniformParsers;\nexports.HelloSystem = HelloSystem.HelloSystem;\nexports.BLEND_TO_NPM = _const$a.BLEND_TO_NPM;\nexports.STENCIL_MODES = _const$a.STENCIL_MODES;\nexports.getAdjustedBlendModeBlend = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend;\nexports.State = State.State;\nexports.AbstractRenderer = AbstractRenderer.AbstractRenderer;\nexports.SharedRenderPipes = SharedSystems.SharedRenderPipes;\nexports.SharedSystems = SharedSystems.SharedSystems;\nexports.SystemRunner = SystemRunner.SystemRunner;\nexports.CanvasPool = CanvasPool.CanvasPool;\nexports.CanvasPoolClass = CanvasPool.CanvasPoolClass;\nexports.DEPRECATED_SCALE_MODES = _const$b.DEPRECATED_SCALE_MODES;\nexports.DEPRECATED_WRAP_MODES = _const$b.DEPRECATED_WRAP_MODES;\nexports.SCALE_MODES = _const$b.SCALE_MODES;\nexports.WRAP_MODES = _const$b.WRAP_MODES;\nexports.RenderableGCSystem = RenderableGCSystem.RenderableGCSystem;\nexports.RenderTexture = RenderTexture.RenderTexture;\nexports.BufferImageSource = BufferImageSource.BufferImageSource;\nexports.CanvasSource = CanvasSource.CanvasSource;\nexports.CompressedSource = CompressedSource.CompressedSource;\nexports.ImageSource = ImageSource.ImageSource;\nexports.TextureSource = TextureSource.TextureSource;\nexports.VideoSource = VideoSource.VideoSource;\nexports.Texture = Texture.Texture;\nexports.TextureGCSystem = TextureGCSystem.TextureGCSystem;\nexports.TextureMatrix = TextureMatrix.TextureMatrix;\nexports.TexturePool = TexturePool.TexturePool;\nexports.TexturePoolClass = TexturePool.TexturePoolClass;\nexports.TextureStyle = TextureStyle.TextureStyle;\nexports.TextureUvs = TextureUvs.TextureUvs;\nexports.getCanvasTexture = getCanvasTexture.getCanvasTexture;\nexports.hasCachedCanvasTexture = getCanvasTexture.hasCachedCanvasTexture;\nexports.getSupportedCompressedTextureFormats = getSupportedCompressedTextureFormats.getSupportedCompressedTextureFormats;\nexports.getSupportedTextureFormats = getSupportedTextureFormats.getSupportedTextureFormats;\nexports.nonCompressedFormats = getSupportedTextureFormats.nonCompressedFormats;\nexports.autoDetectSource = textureFrom.autoDetectSource;\nexports.resourceToTexture = textureFrom.resourceToTexture;\nexports.textureFrom = textureFrom.textureFrom;\nexports.createIdFromString = createIdFromString.createIdFromString;\nexports.parseFunctionBody = parseFunctionBody.parseFunctionBody;\nexports.ViewSystem = ViewSystem.ViewSystem;\nexports.RendererType = types$1.RendererType;\nexports.particlesFrag = particles.default;\nexports.particlesVert = particles$1.default;\nexports.particlesWgsl = particles$2.default;\nexports.Bounds = Bounds.Bounds;\nexports.getFastGlobalBounds = getFastGlobalBounds.getFastGlobalBounds;\nexports.getGlobalBounds = getGlobalBounds.getGlobalBounds;\nexports.updateTransformBackwards = getGlobalBounds.updateTransformBackwards;\nexports.getLocalBounds = getLocalBounds.getLocalBounds;\nexports.getGlobalRenderableBounds = getRenderableBounds.getGlobalRenderableBounds;\nexports.boundsPool = matrixAndBoundsPool.boundsPool;\nexports.matrixPool = matrixAndBoundsPool.matrixPool;\nexports.cacheAsTextureMixin = cacheAsTextureMixin.cacheAsTextureMixin;\nexports.childrenHelperMixin = childrenHelperMixin.childrenHelperMixin;\nexports.collectRenderablesMixin = collectRenderablesMixin.collectRenderablesMixin;\nexports.effectsMixin = effectsMixin.effectsMixin;\nexports.findMixin = findMixin.findMixin;\nexports.getFastGlobalBoundsMixin = getFastGlobalBoundsMixin.getFastGlobalBoundsMixin;\nexports.bgr2rgb = getGlobalMixin.bgr2rgb;\nexports.getGlobalMixin = getGlobalMixin.getGlobalMixin;\nexports.measureMixin = measureMixin.measureMixin;\nexports.onRenderMixin = onRenderMixin.onRenderMixin;\nexports.sortMixin = sortMixin.sortMixin;\nexports.toLocalGlobalMixin = toLocalGlobalMixin.toLocalGlobalMixin;\nexports.Container = Container.Container;\nexports.UPDATE_BLEND = Container.UPDATE_BLEND;\nexports.UPDATE_COLOR = Container.UPDATE_COLOR;\nexports.UPDATE_TRANSFORM = Container.UPDATE_TRANSFORM;\nexports.UPDATE_VISIBLE = Container.UPDATE_VISIBLE;\nexports.CustomRenderPipe = CustomRenderPipe.CustomRenderPipe;\nexports.RenderContainer = RenderContainer.RenderContainer;\nexports.RenderGroup = RenderGroup.RenderGroup;\nexports.RenderGroupPipe = RenderGroupPipe.RenderGroupPipe;\nexports.RenderGroupSystem = RenderGroupSystem.RenderGroupSystem;\nexports.assignWithIgnore = assignWithIgnore.assignWithIgnore;\nexports.checkChildrenDidChange = checkChildrenDidChange.checkChildrenDidChange;\nexports.clearList = clearList.clearList;\nexports.collectAllRenderables = collectAllRenderables.collectAllRenderables;\nexports.definedProps = definedProps.definedProps;\nexports.executeInstructions = executeInstructions.executeInstructions;\nexports.multiplyColors = multiplyColors.multiplyColors;\nexports.multiplyHexColors = multiplyHexColors.multiplyHexColors;\nexports.updateLocalTransform = updateLocalTransform.updateLocalTransform;\nexports.updateRenderGroupTransform = updateRenderGroupTransforms.updateRenderGroupTransform;\nexports.updateRenderGroupTransforms = updateRenderGroupTransforms.updateRenderGroupTransforms;\nexports.updateTransformAndChildren = updateRenderGroupTransforms.updateTransformAndChildren;\nexports.updateWorldTransform = updateWorldTransform.updateWorldTransform;\nexports.validateRenderables = validateRenderables.validateRenderables;\nexports.GlGraphicsAdaptor = GlGraphicsAdaptor.GlGraphicsAdaptor;\nexports.color32BitToUniform = colorToUniform.color32BitToUniform;\nexports.colorToUniform = colorToUniform.colorToUniform;\nexports.GpuGraphicsAdaptor = GpuGraphicsAdaptor.GpuGraphicsAdaptor;\nexports.BatchableGraphics = BatchableGraphics.BatchableGraphics;\nexports.buildAdaptiveBezier = buildAdaptiveBezier.buildAdaptiveBezier;\nexports.buildAdaptiveQuadratic = buildAdaptiveQuadratic.buildAdaptiveQuadratic;\nexports.buildArc = buildArc.buildArc;\nexports.buildArcTo = buildArcTo.buildArcTo;\nexports.buildArcToSvg = buildArcToSvg.buildArcToSvg;\nexports.buildCircle = buildCircle.buildCircle;\nexports.buildEllipse = buildCircle.buildEllipse;\nexports.buildRoundedRectangle = buildCircle.buildRoundedRectangle;\nexports.buildLine = buildLine.buildLine;\nexports.buildPixelLine = buildPixelLine.buildPixelLine;\nexports.buildPolygon = buildPolygon.buildPolygon;\nexports.buildRectangle = buildRectangle.buildRectangle;\nexports.buildTriangle = buildTriangle.buildTriangle;\nexports.closePointEps = _const$c.closePointEps;\nexports.curveEps = _const$c.curveEps;\nexports.FillGradient = FillGradient.FillGradient;\nexports.FillPattern = FillPattern.FillPattern;\nexports.Graphics = Graphics.Graphics;\nexports.GraphicsContext = GraphicsContext.GraphicsContext;\nexports.GpuGraphicsContext = GraphicsContextSystem.GpuGraphicsContext;\nexports.GraphicsContextRenderData = GraphicsContextSystem.GraphicsContextRenderData;\nexports.GraphicsContextSystem = GraphicsContextSystem.GraphicsContextSystem;\nexports.GraphicsGpuData = GraphicsPipe.GraphicsGpuData;\nexports.GraphicsPipe = GraphicsPipe.GraphicsPipe;\nexports.GraphicsPath = GraphicsPath.GraphicsPath;\nexports.roundedShapeArc = roundShape.roundedShapeArc;\nexports.roundedShapeQuadraticCurve = roundShape.roundedShapeQuadraticCurve;\nexports.ShapePath = ShapePath.ShapePath;\nexports.parseSVGDefinitions = parseSVGDefinitions.parseSVGDefinitions;\nexports.parseSVGFloatAttribute = parseSVGFloatAttribute.parseSVGFloatAttribute;\nexports.parseSVGPath = parseSVGPath.parseSVGPath;\nexports.parseSVGStyle = parseSVGStyle.parseSVGStyle;\nexports.styleAttributes = parseSVGStyle.styleAttributes;\nexports.SVGParser = SVGParser.SVGParser;\nexports.extractSvgUrlId = extractSvgUrlId.extractSvgUrlId;\nexports.buildContextBatches = buildContextBatches.buildContextBatches;\nexports.shapeBuilders = buildContextBatches.shapeBuilders;\nexports.toFillStyle = convertFillInputToFillStyle.toFillStyle;\nexports.toStrokeStyle = convertFillInputToFillStyle.toStrokeStyle;\nexports.generateTextureMatrix = generateTextureFillMatrix.generateTextureMatrix;\nexports.getOrientationOfPoints = getOrientationOfPoints.getOrientationOfPoints;\nexports.triangulateWithHoles = triangulateWithHoles.triangulateWithHoles;\nexports.RenderLayer = RenderLayer.RenderLayer;\nexports.PerspectiveMesh = PerspectiveMesh.PerspectiveMesh;\nexports.PerspectivePlaneGeometry = PerspectivePlaneGeometry.PerspectivePlaneGeometry;\nexports.applyProjectiveTransformationToPlane = applyProjectiveTransformationToPlane.applyProjectiveTransformationToPlane;\nexports.compute2DProjection = compute2DProjections.compute2DProjection;\nexports.MeshPlane = MeshPlane.MeshPlane;\nexports.PlaneGeometry = PlaneGeometry.PlaneGeometry;\nexports.MeshRope = MeshRope.MeshRope;\nexports.MeshSimple = MeshSimple.MeshSimple;\nexports.RopeGeometry = RopeGeometry.RopeGeometry;\nexports.GlMeshAdaptor = GlMeshAdaptor.GlMeshAdaptor;\nexports.GpuMeshAdapter = GpuMeshAdapter.GpuMeshAdapter;\nexports.BatchableMesh = BatchableMesh.BatchableMesh;\nexports.getTextureDefaultMatrix = getTextureDefaultMatrix.getTextureDefaultMatrix;\nexports.Mesh = Mesh.Mesh;\nexports.MeshGeometry = MeshGeometry.MeshGeometry;\nexports.MeshGpuData = MeshPipe.MeshGpuData;\nexports.MeshPipe = MeshPipe.MeshPipe;\nexports.GlParticleContainerAdaptor = GlParticleContainerAdaptor.GlParticleContainerAdaptor;\nexports.GpuParticleContainerAdaptor = GpuParticleContainerAdaptor.GpuParticleContainerAdaptor;\nexports.GlParticleContainerPipe = GlParticleContainerPipe.GlParticleContainerPipe;\nexports.GpuParticleContainerPipe = GpuParticleContainerPipe.GpuParticleContainerPipe;\nexports.Particle = Particle.Particle;\nexports.ParticleBuffer = ParticleBuffer.ParticleBuffer;\nexports.ParticleContainer = ParticleContainer.ParticleContainer;\nexports.ParticleContainerPipe = ParticleContainerPipe.ParticleContainerPipe;\nexports.particleData = particleData.particleData;\nexports.ParticleShader = ParticleShader.ParticleShader;\nexports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;\nexports.generateParticleUpdateFunction = generateParticleUpdateFunction.generateParticleUpdateFunction;\nexports.AnimatedSprite = AnimatedSprite.AnimatedSprite;\nexports.NineSliceGeometry = NineSliceGeometry.NineSliceGeometry;\nexports.NineSlicePlane = NineSliceSprite.NineSlicePlane;\nexports.NineSliceSprite = NineSliceSprite.NineSliceSprite;\nexports.NineSliceSpriteGpuData = NineSliceSpritePipe.NineSliceSpriteGpuData;\nexports.NineSliceSpritePipe = NineSliceSpritePipe.NineSliceSpritePipe;\nexports.tilingBit = tilingBit.tilingBit;\nexports.tilingBitGl = tilingBit.tilingBitGl;\nexports.TilingSpriteShader = TilingSpriteShader.TilingSpriteShader;\nexports.TilingSprite = TilingSprite.TilingSprite;\nexports.TilingSpriteGpuData = TilingSpritePipe.TilingSpriteGpuData;\nexports.TilingSpritePipe = TilingSpritePipe.TilingSpritePipe;\nexports.applyMatrix = applyMatrix.applyMatrix;\nexports.QuadGeometry = QuadGeometry.QuadGeometry;\nexports.setPositions = setPositions.setPositions;\nexports.setUvs = setUvs.setUvs;\nexports.BatchableSprite = BatchableSprite.BatchableSprite;\nexports.Sprite = Sprite.Sprite;\nexports.SpritePipe = SpritePipe.SpritePipe;\nexports.AbstractBitmapFont = AbstractBitmapFont.AbstractBitmapFont;\nexports.bitmapFontTextParser = bitmapFontTextParser.bitmapFontTextParser;\nexports.bitmapFontXMLParser = bitmapFontXMLParser.bitmapFontXMLParser;\nexports.bitmapFontXMLStringParser = bitmapFontXMLStringParser.bitmapFontXMLStringParser;\nexports.bitmapFontCachePlugin = loadBitmapFont.bitmapFontCachePlugin;\nexports.loadBitmapFont = loadBitmapFont.loadBitmapFont;\nexports.BitmapFont = BitmapFont.BitmapFont;\nexports.BitmapFontManager = BitmapFontManager.BitmapFontManager;\nexports.BitmapText = BitmapText.BitmapText;\nexports.BitmapTextGraphics = BitmapTextPipe.BitmapTextGraphics;\nexports.BitmapTextPipe = BitmapTextPipe.BitmapTextPipe;\nexports.DynamicBitmapFont = DynamicBitmapFont.DynamicBitmapFont;\nexports.getBitmapTextLayout = getBitmapTextLayout.getBitmapTextLayout;\nexports.resolveCharacters = resolveCharacters.resolveCharacters;\nexports.BatchableHTMLText = BatchableHTMLText.BatchableHTMLText;\nexports.HTMLText = HTMLText.HTMLText;\nexports.HTMLTextPipe = HTMLTextPipe.HTMLTextPipe;\nexports.HTMLTextRenderData = HTMLTextRenderData.HTMLTextRenderData;\nexports.HTMLTextStyle = HTMLTextStyle.HTMLTextStyle;\nexports.HTMLTextSystem = HTMLTextSystem.HTMLTextSystem;\nexports.extractFontFamilies = extractFontFamilies.extractFontFamilies;\nexports.FontStylePromiseCache = getFontCss.FontStylePromiseCache;\nexports.getFontCss = getFontCss.getFontCss;\nexports.getSVGUrl = getSVGUrl.getSVGUrl;\nexports.getTemporaryCanvasFromImage = getTemporaryCanvasFromImage.getTemporaryCanvasFromImage;\nexports.loadFontAsBase64 = loadFontAsBase64.loadFontAsBase64;\nexports.loadFontCSS = loadFontCSS.loadFontCSS;\nexports.loadSVGImage = loadSVGImage.loadSVGImage;\nexports.measureHtmlText = measureHtmlText.measureHtmlText;\nexports.textStyleToCSS = textStyleToCSS.textStyleToCSS;\nexports.AbstractText = AbstractText.AbstractText;\nexports.ensureTextOptions = AbstractText.ensureTextOptions;\nexports.BatchableText = BatchableText.BatchableText;\nexports.CanvasTextGenerator = CanvasTextGenerator.CanvasTextGenerator;\nexports.CanvasTextMetrics = CanvasTextMetrics.CanvasTextMetrics;\nexports.CanvasTextPipe = CanvasTextPipe.CanvasTextPipe;\nexports.CanvasTextSystem = CanvasTextSystem.CanvasTextSystem;\nexports.fontStringFromTextStyle = fontStringFromTextStyle.fontStringFromTextStyle;\nexports.getCanvasFillStyle = getCanvasFillStyle.getCanvasFillStyle;\nexports.SdfShader = SdfShader.SdfShader;\nexports.localUniformMSDFBit = localUniformMSDFBit.localUniformMSDFBit;\nexports.localUniformMSDFBitGl = localUniformMSDFBit.localUniformMSDFBitGl;\nexports.mSDFBit = mSDFBit.mSDFBit;\nexports.mSDFBitGl = mSDFBit.mSDFBitGl;\nexports.Text = Text.Text;\nexports.TextStyle = TextStyle.TextStyle;\nexports.generateTextStyleKey = generateTextStyleKey.generateTextStyleKey;\nexports.getPo2TextureFromSource = getPo2TextureFromSource.getPo2TextureFromSource;\nexports.updateTextBounds = updateTextBounds.updateTextBounds;\nexports.ViewContainer = ViewContainer.ViewContainer;\nexports.Spritesheet = Spritesheet.Spritesheet;\nexports.spritesheetAsset = spritesheetAsset.spritesheetAsset;\nexports.UPDATE_PRIORITY = _const$d.UPDATE_PRIORITY;\nexports.Ticker = Ticker.Ticker;\nexports.TickerListener = TickerListener.TickerListener;\nexports.detectVideoAlphaMode = detectVideoAlphaMode.detectVideoAlphaMode;\nexports.isMobile = isMobile.isMobile;\nexports.isSafari = isSafari.isSafari;\nexports.isWebGLSupported = isWebGLSupported.isWebGLSupported;\nexports.isWebGPUSupported = isWebGPUSupported.isWebGPUSupported;\nexports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;\nexports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;\nexports.DATA_URI = _const$e.DATA_URI;\nexports.VERSION = _const$e.VERSION;\nexports.EventEmitter = EventEmitter;\nexports.cleanArray = clean.cleanArray;\nexports.cleanHash = clean.cleanHash;\nexports.removeItems = removeItems.removeItems;\nexports.resetUids = uid.resetUids;\nexports.uid = uid.uid;\nexports.updateQuadBounds = updateQuadBounds.updateQuadBounds;\nexports.ViewableBuffer = ViewableBuffer.ViewableBuffer;\nexports.ApplicationInitHook = globalHooks.ApplicationInitHook;\nexports.RendererInitHook = globalHooks.RendererInitHook;\nexports.deprecation = deprecation.deprecation;\nexports.v8_0_0 = deprecation.v8_0_0;\nexports.v8_3_4 = deprecation.v8_3_4;\nexports.logDebugTexture = logDebugTexture.logDebugTexture;\nexports.logRenderGroupScene = logScene.logRenderGroupScene;\nexports.logScene = logScene.logScene;\nexports.warn = warn.warn;\nexports.NOOP = NOOP.NOOP;\nexports.Transform = Transform.Transform;\nexports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;\nexports.path = path.path;\nexports.Pool = Pool.Pool;\nexports.BigPool = PoolGroup.BigPool;\nexports.PoolGroupClass = PoolGroup.PoolGroupClass;\nexports.sayHello = sayHello.sayHello;\nexports.earcut = utils.earcut;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/index.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar groupD8 = __webpack_require__(/*! ./matrix/groupD8.js */ \"./node_modules/pixi.js/lib/maths/matrix/groupD8.js\");\nvar Matrix = __webpack_require__(/*! ./matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar _const = __webpack_require__(/*! ./misc/const.js */ \"./node_modules/pixi.js/lib/maths/misc/const.js\");\nvar pow2 = __webpack_require__(/*! ./misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\n__webpack_require__(/*! ./misc/Size.js */ \"./node_modules/pixi.js/lib/maths/misc/Size.js\");\nvar squaredDistanceToLineSegment = __webpack_require__(/*! ./misc/squaredDistanceToLineSegment.js */ \"./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js\");\nvar ObservablePoint = __webpack_require__(/*! ./point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar Point = __webpack_require__(/*! ./point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\n__webpack_require__(/*! ./point/PointData.js */ \"./node_modules/pixi.js/lib/maths/point/PointData.js\");\nvar pointInTriangle = __webpack_require__(/*! ./point/pointInTriangle.js */ \"./node_modules/pixi.js/lib/maths/point/pointInTriangle.js\");\n__webpack_require__(/*! ./point/PointLike.js */ \"./node_modules/pixi.js/lib/maths/point/PointLike.js\");\nvar Circle = __webpack_require__(/*! ./shapes/Circle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Circle.js\");\nvar Ellipse = __webpack_require__(/*! ./shapes/Ellipse.js */ \"./node_modules/pixi.js/lib/maths/shapes/Ellipse.js\");\nvar Polygon = __webpack_require__(/*! ./shapes/Polygon.js */ \"./node_modules/pixi.js/lib/maths/shapes/Polygon.js\");\nvar Rectangle = __webpack_require__(/*! ./shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar RoundedRectangle = __webpack_require__(/*! ./shapes/RoundedRectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js\");\n__webpack_require__(/*! ./shapes/ShapePrimitive.js */ \"./node_modules/pixi.js/lib/maths/shapes/ShapePrimitive.js\");\nvar Triangle = __webpack_require__(/*! ./shapes/Triangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Triangle.js\");\n\n\"use strict\";\n\nexports.groupD8 = groupD8.groupD8;\nexports.Matrix = Matrix.Matrix;\nexports.DEG_TO_RAD = _const.DEG_TO_RAD;\nexports.PI_2 = _const.PI_2;\nexports.RAD_TO_DEG = _const.RAD_TO_DEG;\nexports.isPow2 = pow2.isPow2;\nexports.log2 = pow2.log2;\nexports.nextPow2 = pow2.nextPow2;\nexports.squaredDistanceToLineSegment = squaredDistanceToLineSegment.squaredDistanceToLineSegment;\nexports.ObservablePoint = ObservablePoint.ObservablePoint;\nexports.Point = Point.Point;\nexports.pointInTriangle = pointInTriangle.pointInTriangle;\nexports.Circle = Circle.Circle;\nexports.Ellipse = Ellipse.Ellipse;\nexports.Polygon = Polygon.Polygon;\nexports.Rectangle = Rectangle.Rectangle;\nexports.RoundedRectangle = RoundedRectangle.RoundedRectangle;\nexports.Triangle = Triangle.Triangle;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/matrix/Matrix.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/matrix/Matrix.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../misc/const.js */ \"./node_modules/pixi.js/lib/maths/misc/const.js\");\nvar Point = __webpack_require__(/*! ../point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /**\n     * Array representation of the matrix.\n     * Only populated when `toArray()` is called.\n     * @default null\n     * @see {@link Matrix.toArray} For filling this array\n     */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array.\n   * Populates matrix components from a flat array in column-major order.\n   *\n   * > [!NOTE] Array mapping order:\n   * > ```\n   * > array[0] = a  (x scale)\n   * > array[1] = b  (y skew)\n   * > array[2] = tx (x translation)\n   * > array[3] = c  (x skew)\n   * > array[4] = d  (y scale)\n   * > array[5] = ty (y translation)\n   * > ```\n   * @example\n   * ```ts\n   * // Create matrix from array\n   * const matrix = new Matrix();\n   * matrix.fromArray([\n   *     2, 0,  100,  // a, b, tx\n   *     0, 2,  100   // c, d, ty\n   * ]);\n   *\n   * // Create matrix from typed array\n   * const float32Array = new Float32Array([\n   *     1, 0, 0,     // Scale x1, no skew\n   *     0, 1, 0      // No skew, scale x1\n   * ]);\n   * matrix.fromArray(float32Array);\n   * ```\n   * @param array - The array to populate the matrix from\n   * @see {@link Matrix.toArray} For converting matrix to array\n   * @see {@link Matrix.set} For setting values directly\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties directly.\n   * All matrix components can be set in one call.\n   * @example\n   * ```ts\n   * // Set to identity matrix\n   * matrix.set(1, 0, 0, 1, 0, 0);\n   *\n   * // Set to scale matrix\n   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n   *\n   * // Set to translation matrix\n   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n   * ```\n   * @param a - Scale on x axis\n   * @param b - Shear on y axis\n   * @param c - Shear on x axis\n   * @param d - Scale on y axis\n   * @param tx - Translation on x axis\n   * @param ty - Translation on y axis\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.identity} For resetting to identity\n   * @see {@link Matrix.fromArray} For setting from array\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   *\n   * > [!NOTE] The array format is:\n   * > ```\n   * > Non-transposed:\n   * > [a, c, tx,\n   * > b, d, ty,\n   * > 0, 0, 1]\n   * >\n   * > Transposed:\n   * > [a, b, 0,\n   * > c, d, 0,\n   * > tx,ty,1]\n   * > ```\n   * @example\n   * ```ts\n   * // Basic array conversion\n   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n   * const array = matrix.toArray();\n   *\n   * // Using existing array\n   * const float32Array = new Float32Array(9);\n   * matrix.toArray(false, float32Array);\n   *\n   * // Get transposed array\n   * const transposed = matrix.toArray(true);\n   * ```\n   * @param transpose - Whether to transpose the matrix\n   * @param out - Optional Float32Array to store the result\n   * @returns The array containing the matrix values\n   * @see {@link Matrix.fromArray} For creating matrix from array\n   * @see {@link Matrix.array} For cached array storage\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   *\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @example\n   * ```ts\n   * // Basic point transformation\n   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n   * const point = new Point(10, 20);\n   * const transformed = matrix.apply(point);\n   *\n   * // Reuse existing point\n   * const output = new Point();\n   * matrix.apply(point, output);\n   * ```\n   * @param pos - The origin point to transform\n   * @param newPos - Optional point to store the result\n   * @returns The transformed point\n   * @see {@link Matrix.applyInverse} For inverse transformation\n   * @see {@link Point} For point operations\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point.Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   *\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @example\n   * ```ts\n   * // Basic inverse transformation\n   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n   * const worldPoint = new Point(150, 100);\n   * const localPoint = matrix.applyInverse(worldPoint);\n   *\n   * // Reuse existing point\n   * const output = new Point();\n   * matrix.applyInverse(worldPoint, output);\n   *\n   * // Convert mouse position to local space\n   * const mousePoint = new Point(mouseX, mouseY);\n   * const localMouse = matrix.applyInverse(mousePoint);\n   * ```\n   * @param pos - The origin point to inverse-transform\n   * @param newPos - Optional point to store the result\n   * @returns The inverse-transformed point\n   * @see {@link Matrix.apply} For forward transformation\n   * @see {@link Matrix.invert} For getting inverse matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point.Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y axes.\n   * Adds to the position values while preserving scale, rotation and skew.\n   * @example\n   * ```ts\n   * // Basic translation\n   * const matrix = new Matrix();\n   * matrix.translate(100, 50); // Move right 100, down 50\n   *\n   * // Chain with other transformations\n   * matrix\n   *     .scale(2, 2)\n   *     .translate(100, 0)\n   *     .rotate(Math.PI / 4);\n   * ```\n   * @param x - How much to translate on the x axis\n   * @param y - How much to translate on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.set} For setting position directly\n   * @see {@link Matrix.setTransform} For complete transform setup\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * Multiplies the scale values with existing matrix components.\n   * @example\n   * ```ts\n   * // Basic scaling\n   * const matrix = new Matrix();\n   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n   *\n   * // Chain with other transformations\n   * matrix\n   *     .translate(100, 100)\n   *     .scale(2, 2)     // Scales after translation\n   *     .rotate(Math.PI / 4);\n   * ```\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.setTransform} For setting scale directly\n   * @see {@link Matrix.append} For combining transformations\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   *\n   * Rotates around the origin (0,0) by the given angle in radians.\n   * @example\n   * ```ts\n   * // Basic rotation\n   * const matrix = new Matrix();\n   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n   *\n   * // Chain with other transformations\n   * matrix\n   *     .translate(100, 100) // Move to rotation center\n   *     .rotate(Math.PI)     // Rotate 180 degrees\n   *     .scale(2, 2);        // Scale after rotation\n   *\n   * // Common angles\n   * matrix.rotate(Math.PI / 2);  // 90 degrees\n   * matrix.rotate(Math.PI);      // 180 degrees\n   * matrix.rotate(Math.PI * 2);  // 360 degrees\n   * ```\n   * @remarks\n   * - Rotates around origin point (0,0)\n   * - Affects position if translation was set\n   * - Uses counter-clockwise rotation\n   * - Order of operations matters when chaining\n   * @param angle - The angle in radians\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.setTransform} For setting rotation directly\n   * @see {@link Matrix.append} For combining transformations\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * Combines two matrices by multiplying them together: this = this * matrix\n   * @example\n   * ```ts\n   * // Basic matrix combination\n   * const matrix = new Matrix();\n   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n   * matrix.append(other);\n   * ```\n   * @remarks\n   * - Order matters: A.append(B) !== B.append(A)\n   * - Modifies current matrix\n   * - Preserves transformation order\n   * - Commonly used for combining transforms\n   * @param matrix - The matrix to append\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.prepend} For prepending transformations\n   * @see {@link Matrix.appendFrom} For appending two external matrices\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrices and sets the result to this matrix.\n   * Performs matrix multiplication: this = A * B\n   * @example\n   * ```ts\n   * // Basic matrix multiplication\n   * const result = new Matrix();\n   * const matrixA = new Matrix().scale(2, 2);\n   * const matrixB = new Matrix().rotate(Math.PI / 4);\n   * result.appendFrom(matrixA, matrixB);\n   * ```\n   * @remarks\n   * - Order matters: A * B !== B * A\n   * - Creates a new transformation from two others\n   * - More efficient than append() for multiple operations\n   * - Does not modify input matrices\n   * @param a - The first matrix to multiply\n   * @param b - The second matrix to multiply\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.append} For single matrix combination\n   * @see {@link Matrix.prepend} For reverse order multiplication\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties.\n   * Combines position, scale, rotation, skew and pivot in a single operation.\n   * @example\n   * ```ts\n   * // Basic transform setup\n   * const matrix = new Matrix();\n   * matrix.setTransform(\n   *     100, 100,    // position\n   *     0, 0,        // pivot\n   *     2, 2,        // scale\n   *     Math.PI / 4, // rotation (45 degrees)\n   *     0, 0         // skew\n   * );\n   * ```\n   * @remarks\n   * - Updates all matrix components at once\n   * - More efficient than separate transform calls\n   * - Uses radians for rotation and skew\n   * - Pivot affects rotation center\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.decompose} For extracting transform properties\n   * @see {@link TransformableObject} For transform data structure\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * Combines two matrices by multiplying them together: this = matrix * this\n   * @example\n   * ```ts\n   * // Basic matrix prepend\n   * const matrix = new Matrix().scale(2, 2);\n   * const other = new Matrix().translate(100, 0);\n   * matrix.prepend(other); // Translation happens before scaling\n   * ```\n   * @remarks\n   * - Order matters: A.prepend(B) !== B.prepend(A)\n   * - Modifies current matrix\n   * - Reverses transformation order compared to append()\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.append} For appending transformations\n   * @see {@link Matrix.appendFrom} For combining external matrices\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix into its individual transform components.\n   * Extracts position, scale, rotation and skew values from the matrix.\n   * @example\n   * ```ts\n   * // Basic decomposition\n   * const matrix = new Matrix()\n   *     .translate(100, 100)\n   *     .rotate(Math.PI / 4)\n   *     .scale(2, 2);\n   *\n   * const transform = {\n   *     position: new Point(),\n   *     scale: new Point(),\n   *     pivot: new Point(),\n   *     skew: new Point(),\n   *     rotation: 0\n   * };\n   *\n   * matrix.decompose(transform);\n   * console.log(transform.position); // Point(100, 100)\n   * console.log(transform.rotation); // ~0.785 (PI/4)\n   * console.log(transform.scale); // Point(2, 2)\n   * ```\n   * @remarks\n   * - Handles combined transformations\n   * - Accounts for pivot points\n   * - Chooses between rotation/skew based on transform type\n   * - Uses radians for rotation and skew\n   * @param transform - The transform object to store the decomposed values\n   * @returns The transform with the newly applied properties\n   * @see {@link Matrix.setTransform} For composing from components\n   * @see {@link TransformableObject} For transform structure\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(_const.PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix.\n   * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n   * @example\n   * ```ts\n   * // Basic matrix inversion\n   * const matrix = new Matrix()\n   *     .translate(100, 50)\n   *     .scale(2, 2);\n   *\n   * matrix.invert(); // Now transforms in opposite direction\n   *\n   * // Verify inversion\n   * const point = new Point(50, 50);\n   * const transformed = matrix.apply(point);\n   * const original = matrix.invert().apply(transformed);\n   * // original ≈ point\n   * ```\n   * @remarks\n   * - Modifies the current matrix\n   * - Useful for reversing transformations\n   * - Cannot invert matrices with zero determinant\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.identity} For resetting to identity\n   * @see {@link Matrix.applyInverse} For inverse transformations\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /**\n   * Checks if this matrix is an identity matrix.\n   *\n   * An identity matrix has no transformations applied (default state).\n   * @example\n   * ```ts\n   * // Check if matrix is identity\n   * const matrix = new Matrix();\n   * console.log(matrix.isIdentity()); // true\n   *\n   * // Check after transformations\n   * matrix.translate(100, 0);\n   * console.log(matrix.isIdentity()); // false\n   *\n   * // Reset and verify\n   * matrix.identity();\n   * console.log(matrix.isIdentity()); // true\n   * ```\n   * @remarks\n   * - Verifies a = 1, d = 1 (no scale)\n   * - Verifies b = 0, c = 0 (no skew)\n   * - Verifies tx = 0, ty = 0 (no translation)\n   * @returns True if matrix has no transformations\n   * @see {@link Matrix.identity} For resetting to identity\n   * @see {@link Matrix.IDENTITY} For constant identity matrix\n   */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * Sets all components to their default values: scale=1, no skew, no translation.\n   * @example\n   * ```ts\n   * // Reset transformed matrix\n   * const matrix = new Matrix()\n   *     .scale(2, 2)\n   *     .rotate(Math.PI / 4);\n   * matrix.identity(); // Back to default state\n   *\n   * // Chain after reset\n   * matrix\n   *     .identity()\n   *     .translate(100, 100)\n   *     .scale(2, 2);\n   *\n   * // Compare with identity constant\n   * const isDefault = matrix.equals(Matrix.IDENTITY);\n   * ```\n   * @remarks\n   * - Sets a=1, d=1 (default scale)\n   * - Sets b=0, c=0 (no skew)\n   * - Sets tx=0, ty=0 (no translation)\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.IDENTITY} For constant identity matrix\n   * @see {@link Matrix.isIdentity} For checking identity state\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @param matrix\n   * @example\n   * ```ts\n   * // Basic matrix cloning\n   * const matrix = new Matrix()\n   *     .translate(100, 100)\n   *     .rotate(Math.PI / 4);\n   * const copy = matrix.clone();\n   *\n   * // Clone and modify\n   * const modified = matrix.clone()\n   *     .scale(2, 2);\n   *\n   * // Compare matrices\n   * console.log(matrix.equals(copy));     // true\n   * console.log(matrix.equals(modified)); // false\n   * ```\n   * @returns A copy of this matrix. Good for chaining method calls.\n   * @see {@link Matrix.copyTo} For copying to existing matrix\n   * @see {@link Matrix.copyFrom} For copying from another matrix\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix.\n   * @example\n   * ```ts\n   * // Basic matrix copying\n   * const source = new Matrix()\n   *     .translate(100, 100)\n   *     .rotate(Math.PI / 4);\n   * const target = new Matrix();\n   * target.copyFrom(source);\n   * ```\n   * @param matrix - The matrix to copy from\n   * @returns This matrix. Good for chaining method calls.\n   * @see {@link Matrix.clone} For creating new matrix copy\n   * @see {@link Matrix.copyTo} For copying to another matrix\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * Checks if this matrix equals another matrix.\n   * Compares all components for exact equality.\n   * @example\n   * ```ts\n   * // Basic equality check\n   * const m1 = new Matrix();\n   * const m2 = new Matrix();\n   * console.log(m1.equals(m2)); // true\n   *\n   * // Compare transformed matrices\n   * const transform = new Matrix()\n   *     .translate(100, 100)\n   * const clone = new Matrix()\n   *     .scale(2, 2);\n   * console.log(transform.equals(clone)); // false\n   * ```\n   * @param matrix - The matrix to compare to\n   * @returns True if matrices are identical\n   * @see {@link Matrix.copyFrom} For copying matrix values\n   * @see {@link Matrix.isIdentity} For identity comparison\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix with no transformations applied.\n   *\n   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n   * @example\n   * ```ts\n   * // Get identity matrix reference\n   * const identity = Matrix.IDENTITY;\n   * console.log(identity.isIdentity()); // true\n   *\n   * // Compare with identity\n   * const matrix = new Matrix();\n   * console.log(matrix.equals(Matrix.IDENTITY)); // true\n   *\n   * // Create new matrix instead of modifying IDENTITY\n   * const transform = new Matrix()\n   *     .copyFrom(Matrix.IDENTITY)\n   *     .translate(100, 100);\n   * ```\n   * @readonly\n   * @returns A read-only identity matrix\n   * @see {@link Matrix.shared} For temporary calculations\n   * @see {@link Matrix.identity} For resetting matrices\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   *\n   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n   * @example\n   * ```ts\n   * // Use for temporary calculations\n   * const tempMatrix = Matrix.shared;\n   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n   * const point = tempMatrix.apply({ x: 10, y: 20 });\n   *\n   * // Will be reset to identity on next access\n   * const fresh = Matrix.shared; // Back to identity\n   * ```\n   * @remarks\n   * - Always returns identity matrix\n   * - Safe to modify temporarily\n   * - Not safe to store references\n   * - Useful for one-off calculations\n   * @readonly\n   * @returns A fresh identity matrix for temporary use\n   * @see {@link Matrix.IDENTITY} For immutable identity matrix\n   * @see {@link Matrix.identity} For resetting matrices\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexports.Matrix = Matrix;\n//# sourceMappingURL=Matrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/matrix/Matrix.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/matrix/groupD8.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/matrix/groupD8.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ./Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix.Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @group groupD8\n   * @type {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @group groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @group groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @group groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @group groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @group groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @group groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @group groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @group groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @group groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @group groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @group groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexports.groupD8 = groupD8;\n//# sourceMappingURL=groupD8.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/matrix/groupD8.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/Size.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/Size.js ***!
  \*****************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=Size.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/misc/Size.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/const.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/const.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexports.DEG_TO_RAD = DEG_TO_RAD;\nexports.PI_2 = PI_2;\nexports.RAD_TO_DEG = RAD_TO_DEG;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/misc/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/pow2.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/pow2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexports.isPow2 = isPow2;\nexports.log2 = log2;\nexports.nextPow2 = nextPow2;\n//# sourceMappingURL=pow2.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/misc/pow2.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexports.squaredDistanceToLineSegment = squaredDistanceToLineSegment;\n//# sourceMappingURL=squaredDistanceToLineSegment.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/ObservablePoint.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const point = new ObservablePoint(observer, 100, 200);\n   * const copy = point.clone();\n   *\n   * // Clone with new observer\n   * const newObserver = {\n   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n   * };\n   * const watched = point.clone(newObserver);\n   *\n   * // Verify independence\n   * watched.set(300, 400); // Only triggers new observer\n   * ```\n   * @param observer - Optional observer to pass to the new observable point\n   * @returns A copy of this observable point\n   * @see {@link ObservablePoint.copyFrom} For copying into existing point\n   * @see {@link Observer} For observer interface details\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new x and y position.\n   *\n   * If y is omitted, both x and y will be set to x.\n   * @example\n   * ```ts\n   * // Basic position setting\n   * const point = new ObservablePoint(observer);\n   * point.set(100, 200);\n   *\n   * // Set both x and y to same value\n   * point.set(50); // x=50, y=50\n   * ```\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis, defaults to x\n   * @returns The point instance itself\n   * @see {@link ObservablePoint.copyFrom} For copying from another point\n   * @see {@link ObservablePoint.equals} For comparing positions\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point into this point.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new ObservablePoint(observer, 100, 200);\n   * const target = new ObservablePoint();\n   * target.copyFrom(source);\n   *\n   * // Copy and chain operations\n   * const point = new ObservablePoint()\n   *     .copyFrom(source)\n   *     .set(x + 50, y + 50);\n   *\n   * // Copy from any PointData\n   * const data = { x: 10, y: 20 };\n   * point.copyFrom(data);\n   * ```\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   * @see {@link ObservablePoint.copyTo} For copying to another point\n   * @see {@link ObservablePoint.clone} For creating new point copy\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new ObservablePoint(100, 200);\n   * const target = new ObservablePoint();\n   * source.copyTo(target);\n   * ```\n   * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n   * @returns The point (`p`) with values updated\n   * @see {@link ObservablePoint.copyFrom} For copying from another point\n   * @see {@link ObservablePoint.clone} For creating new point copy\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Checks if another point is equal to this point.\n   *\n   * Compares x and y values using strict equality.\n   * @example\n   * ```ts\n   * // Basic equality check\n   * const p1 = new ObservablePoint(100, 200);\n   * const p2 = new ObservablePoint(100, 200);\n   * console.log(p1.equals(p2)); // true\n   *\n   * // Compare with PointData\n   * const data = { x: 100, y: 200 };\n   * console.log(p1.equals(data)); // true\n   *\n   * // Check different points\n   * const p3 = new ObservablePoint(200, 300);\n   * console.log(p1.equals(p3)); // false\n   * ```\n   * @param p - The point to check\n   * @returns `true` if both `x` and `y` are equal\n   * @see {@link ObservablePoint.copyFrom} For making points equal\n   * @see {@link PointData} For point data interface\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;\n  }\n  /**\n   * Position of the observable point on the x axis.\n   * Triggers observer callback when value changes.\n   * @example\n   * ```ts\n   * // Basic x position\n   * const point = new ObservablePoint(observer);\n   * point.x = 100; // Triggers observer\n   *\n   * // Use in calculations\n   * const width = rightPoint.x - leftPoint.x;\n   * ```\n   * @default 0\n   */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /**\n   * Position of the observable point on the y axis.\n   * Triggers observer callback when value changes.\n   * @example\n   * ```ts\n   * // Basic y position\n   * const point = new ObservablePoint(observer);\n   * point.y = 200; // Triggers observer\n   *\n   * // Use in calculations\n   * const height = bottomPoint.y - topPoint.y;\n   * ```\n   * @default 0\n   */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexports.ObservablePoint = ObservablePoint;\n//# sourceMappingURL=ObservablePoint.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/point/ObservablePoint.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/Point.js":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/Point.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /**\n     * Position of the point on the x axis\n     * @example\n     * ```ts\n     * // Set x position\n     * const point = new Point();\n     * point.x = 100;\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     */\n    this.x = 0;\n    /**\n     * Position of the point on the y axis\n     * @example\n     * ```ts\n     * // Set y position\n     * const point = new Point();\n     * point.y = 200;\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.\n   * @example\n   * ```ts\n   * // Basic point cloning\n   * const original = new Point(100, 200);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.set(300, 400);\n   *\n   * // Verify independence\n   * console.log(original); // Point(100, 200)\n   * console.log(modified); // Point(300, 400)\n   * ```\n   * @remarks\n   * - Creates new Point instance\n   * - Deep copies x and y values\n   * - Independent from original\n   * - Useful for preserving values\n   * @returns A clone of this point\n   * @see {@link Point.copyFrom} For copying into existing point\n   * @see {@link Point.copyTo} For copying to existing point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies x and y from the given point into this point.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Point(100, 200);\n   * const target = new Point();\n   * target.copyFrom(source);\n   *\n   * // Copy and chain operations\n   * const point = new Point()\n   *     .copyFrom(source)\n   *     .set(x + 50, y + 50);\n   *\n   * // Copy from any PointData\n   * const data = { x: 10, y: 20 };\n   * point.copyFrom(data);\n   * ```\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   * @see {@link Point.copyTo} For copying to another point\n   * @see {@link Point.clone} For creating new point copy\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Point(100, 200);\n   * const target = new Point();\n   * source.copyTo(target);\n   * ```\n   * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n   * @returns The point (`p`) with values updated\n   * @see {@link Point.copyFrom} For copying from another point\n   * @see {@link Point.clone} For creating new point copy\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Checks if another point is equal to this point.\n   *\n   * Compares x and y values using strict equality.\n   * @example\n   * ```ts\n   * // Basic equality check\n   * const p1 = new Point(100, 200);\n   * const p2 = new Point(100, 200);\n   * console.log(p1.equals(p2)); // true\n   *\n   * // Compare with PointData\n   * const data = { x: 100, y: 200 };\n   * console.log(p1.equals(data)); // true\n   *\n   * // Check different points\n   * const p3 = new Point(200, 300);\n   * console.log(p1.equals(p3)); // false\n   * ```\n   * @param p - The point to check\n   * @returns `true` if both `x` and `y` are equal\n   * @see {@link Point.copyFrom} For making points equal\n   * @see {@link PointData} For point data interface\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new x and y position.\n   *\n   * If y is omitted, both x and y will be set to x.\n   * @example\n   * ```ts\n   * // Basic position setting\n   * const point = new Point();\n   * point.set(100, 200);\n   *\n   * // Set both x and y to same value\n   * point.set(50); // x=50, y=50\n   *\n   * // Chain with other operations\n   * point\n   *     .set(10, 20)\n   *     .copyTo(otherPoint);\n   * ```\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis, defaults to x\n   * @returns The point instance itself\n   * @see {@link Point.copyFrom} For copying from another point\n   * @see {@link Point.equals} For comparing positions\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`.\n   *\n   * This shared instance is reset to zero values when accessed.\n   *\n   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.\n   * @example\n   * ```ts\n   * // Use for temporary calculations\n   * const tempPoint = Point.shared;\n   * tempPoint.set(100, 200);\n   * matrix.apply(tempPoint);\n   *\n   * // Will be reset to (0,0) on next access\n   * const fresh = Point.shared; // x=0, y=0\n   * ```\n   * @readonly\n   * @returns A fresh zeroed point for temporary use\n   * @see {@link Point.constructor} For creating new points\n   * @see {@link PointData} For basic point interface\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexports.Point = Point;\n//# sourceMappingURL=Point.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/point/Point.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/PointData.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/PointData.js ***!
  \***********************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=PointData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/point/PointData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/PointLike.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/PointLike.js ***!
  \***********************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=PointLike.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/point/PointLike.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/pointInTriangle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/pointInTriangle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {\n  const v2x = x3 - x1;\n  const v2y = y3 - y1;\n  const v1x = x2 - x1;\n  const v1y = y2 - y1;\n  const v0x = px - x1;\n  const v0y = py - y1;\n  const dot00 = v2x * v2x + v2y * v2y;\n  const dot01 = v2x * v1x + v2y * v1y;\n  const dot02 = v2x * v0x + v2y * v0y;\n  const dot11 = v1x * v1x + v1y * v1y;\n  const dot12 = v1x * v0x + v1y * v0y;\n  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n  const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n  const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n  return u >= 0 && v >= 0 && u + v < 1;\n}\n\nexports.pointInTriangle = pointInTriangle;\n//# sourceMappingURL=pointInTriangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/point/pointInTriangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Circle.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Circle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks.\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Circle(0, 0, 50);\n     * console.log(shape.type); // 'circle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'circle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @remarks\n     * - Used for shape type checking\n     * - More efficient than instanceof\n     * - Read-only property\n     * @readonly\n     * @default 'circle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     * @see {@link ShapePrimitive} For shape interface\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance.\n   * @example\n   * ```ts\n   * // Basic circle cloning\n   * const original = new Circle(100, 100, 50);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.radius = 75;\n   *\n   * // Verify independence\n   * console.log(original.radius); // 50\n   * console.log(modified.radius); // 75\n   * ```\n   * @returns A copy of the Circle\n   * @see {@link Circle.copyFrom} For copying into existing circle\n   * @see {@link Circle.copyTo} For copying to another circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle.\n   *\n   * Uses the distance formula to determine if a point is inside the circle's radius.\n   *\n   * Commonly used for hit testing in PixiJS events and graphics.\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const circle = new Circle(100, 100, 50);\n   * const isInside = circle.contains(120, 120);\n   *\n   * // Check mouse position\n   * const circle = new Circle(0, 0, 100);\n   * container.hitArea = circle;\n   * container.on('pointermove', (e) => {\n   *     // only called if pointer is within circle\n   * });\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   * @see {@link Circle.strokeContains} For checking stroke intersection\n   * @see {@link Circle.getBounds} For getting bounding box\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const circle = new Circle(100, 100, 50);\n   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = circle.strokeContains(150, 100, 4, 0);   // Inside\n   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n   * const outerStroke = circle.strokeContains(150, 100, 4, 1);   // Outside\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this Circle's stroke\n   * @see {@link Circle.contains} For checking fill containment\n   * @see {@link Circle.getBounds} For getting stroke bounds\n   */\n  strokeContains(x, y, width, alignment = 0.5) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const radius = this.radius;\n    const outerWidth = (1 - alignment) * width;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= radius + outerWidth && distance > radius - (width - outerWidth);\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object.\n   * @example\n   * ```ts\n   * // Basic bounds calculation\n   * const circle = new Circle(100, 100, 50);\n   * const bounds = circle.getBounds();\n   * // bounds: x=50, y=50, width=100, height=100\n   *\n   * // Reuse existing rectangle\n   * const rect = new Rectangle();\n   * circle.getBounds(rect);\n   * ```\n   * @param out - Optional Rectangle object to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle} For rectangle properties\n   * @see {@link Circle.contains} For point containment\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Circle(100, 100, 50);\n   * const target = new Circle();\n   * target.copyFrom(source);\n   * ```\n   * @param circle - The circle to copy from\n   * @returns Returns itself\n   * @see {@link Circle.copyTo} For copying to another circle\n   * @see {@link Circle.clone} For creating new circle copy\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Circle(100, 100, 50);\n   * const target = new Circle();\n   * source.copyTo(target);\n   * ```\n   * @param circle - The circle to copy to\n   * @returns Returns given parameter\n   * @see {@link Circle.copyFrom} For copying from another circle\n   * @see {@link Circle.clone} For creating new circle copy\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexports.Circle = Circle;\n//# sourceMappingURL=Circle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/Circle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Ellipse.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Ellipse.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Ellipse(0, 0, 50, 25);\n     * console.log(shape.type); // 'ellipse'\n     *\n     * // Use in type guards\n     * if (shape.type === 'ellipse') {\n     *     console.log(shape.halfWidth, shape.halfHeight);\n     * }\n     * ```\n     * @readonly\n     * @default 'ellipse'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance.\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const original = new Ellipse(100, 100, 50, 25);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.halfWidth *= 2;\n   * modified.halfHeight *= 2;\n   *\n   * // Verify independence\n   * console.log(original.halfWidth);  // 50\n   * console.log(modified.halfWidth);  // 100\n   * ```\n   * @returns A copy of the ellipse\n   * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n   * @see {@link Ellipse.copyTo} For copying to another ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse.\n   * Uses normalized coordinates and the ellipse equation to determine containment.\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const ellipse = new Ellipse(100, 100, 50, 25);\n   * const isInside = ellipse.contains(120, 110);\n   * ```\n   * @remarks\n   * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)\n   * - Returns false if dimensions are 0 or negative\n   * - Normalized to center (0,0) for calculation\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   * @see {@link Ellipse.strokeContains} For checking stroke intersection\n   * @see {@link Ellipse.getBounds} For getting containing rectangle\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const ellipse = new Ellipse(100, 100, 50, 25);\n   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Inside\n   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n   * const outerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Outside\n   * ```\n   * @remarks\n   * - Uses normalized ellipse equations\n   * - Considers stroke alignment\n   * - Returns false if dimensions are 0\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke (0 = inner, 0.5 = centered, 1 = outer)\n   * @returns Whether the x/y coords are within this ellipse's stroke\n   * @see {@link Ellipse.contains} For checking fill containment\n   * @see {@link Ellipse.getBounds} For getting stroke bounds\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const strokeOuterWidth = strokeWidth * (1 - alignment);\n    const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n    const innerHorizontal = halfWidth - strokeInnerWidth;\n    const innerVertical = halfHeight - strokeInnerWidth;\n    const outerHorizontal = halfWidth + strokeOuterWidth;\n    const outerVertical = halfHeight + strokeOuterWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);\n    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object.\n   * @example\n   * ```ts\n   * // Basic bounds calculation\n   * const ellipse = new Ellipse(100, 100, 50, 25);\n   * const bounds = ellipse.getBounds();\n   * // bounds: x=50, y=75, width=100, height=50\n   *\n   * // Reuse existing rectangle\n   * const rect = new Rectangle();\n   * ellipse.getBounds(rect);\n   * ```\n   * @remarks\n   * - Creates Rectangle if none provided\n   * - Top-left is (x-halfWidth, y-halfHeight)\n   * - Width is halfWidth * 2\n   * - Height is halfHeight * 2\n   * @param out - Optional Rectangle object to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle} For rectangle properties\n   * @see {@link Ellipse.contains} For checking if a point is inside\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Ellipse(100, 100, 50, 25);\n   * const target = new Ellipse();\n   * target.copyFrom(source);\n   * ```\n   * @param ellipse - The ellipse to copy from\n   * @returns Returns itself\n   * @see {@link Ellipse.copyTo} For copying to another ellipse\n   * @see {@link Ellipse.clone} For creating new ellipse copy\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Ellipse(100, 100, 50, 25);\n   * const target = new Ellipse();\n   * source.copyTo(target);\n   * ```\n   * @param ellipse - The ellipse to copy to\n   * @returns Returns given parameter\n   * @see {@link Ellipse.copyFrom} For copying from another ellipse\n   * @see {@link Ellipse.clone} For creating new ellipse copy\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexports.Ellipse = Ellipse;\n//# sourceMappingURL=Ellipse.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/Ellipse.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Polygon.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Polygon.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar squaredDistanceToLineSegment = __webpack_require__(/*! ../misc/squaredDistanceToLineSegment.js */ \"./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js\");\nvar Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nlet tempRect;\nlet tempRect2;\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(shape.type); // 'polygon'\n     *\n     * // Use in type guards\n     * if (shape.type === 'polygon') {\n     *     // TypeScript knows this is a Polygon\n     *     console.log(shape.points.length);\n     * }\n     * ```\n     * @readonly\n     * @default 'polygon'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Determines whether the polygon's points are arranged in a clockwise direction.\n   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n   *\n   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n   *\n   * The formula sums up the cross products of adjacent vertices:\n   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n   * The final sum divided by 2 gives the signed area - positive for clockwise.\n   * @example\n   * ```ts\n   * // Check polygon winding\n   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n   * console.log(polygon.isClockwise()); // Check direction\n   *\n   * // Use in path construction\n   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n   * if (hole.isClockwise() === shape.isClockwise()) {\n   *     hole.points.reverse(); // Reverse for proper hole winding\n   * }\n   * ```\n   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n   */\n  isClockwise() {\n    let area = 0;\n    const points = this.points;\n    const length = points.length;\n    for (let i = 0; i < length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % length];\n      const y2 = points[(i + 3) % length];\n      area += (x2 - x1) * (y2 + y1);\n    }\n    return area < 0;\n  }\n  /**\n   * Checks if this polygon completely contains another polygon.\n   * Used for detecting holes in shapes, like when parsing SVG paths.\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n   *\n   * outerSquare.containsPolygon(innerSquare); // Returns true\n   * innerSquare.containsPolygon(outerSquare); // Returns false\n   * ```\n   * @remarks\n   * - Uses bounds check for quick rejection\n   * - Tests all points for containment\n   * @param polygon - The polygon to test for containment\n   * @returns True if this polygon completely contains the other polygon\n   * @see {@link Polygon.contains} For single point testing\n   * @see {@link Polygon.getBounds} For bounds calculation\n   */\n  containsPolygon(polygon) {\n    const thisBounds = this.getBounds(tempRect);\n    const otherBounds = polygon.getBounds(tempRect2);\n    if (!thisBounds.containsRect(otherBounds)) {\n      return false;\n    }\n    const points = polygon.points;\n    for (let i = 0; i < points.length; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      if (!this.contains(x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.points[0] = 10; // Modify first x coordinate\n   * ```\n   * @returns A copy of the polygon\n   * @see {@link Polygon.copyFrom} For copying into existing polygon\n   * @see {@link Polygon.copyTo} For copying to another polygon\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * Uses raycasting algorithm for point-in-polygon testing.\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const isInside = polygon.contains(25, 25); // true\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this polygon\n   * @see {@link Polygon.strokeContains} For checking stroke intersection\n   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = polygon.strokeContains(25, 25, 4, 0);   // Inside\n   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n   * const outerStroke = polygon.strokeContains(25, 25, 4, 1);   // Outside\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke (0 = inner, 0.5 = centered, 1 = outer)\n   * @returns Whether the x/y coordinates are within this polygon's stroke\n   * @see {@link Polygon.contains} For checking fill containment\n   * @see {@link Polygon.getBounds} For getting stroke bounds\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const strokeWidthSquared = strokeWidth * strokeWidth;\n    const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSquared = squaredDistanceToLineSegment.squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object.\n   * @example\n   * ```ts\n   * // Basic bounds calculation\n   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const bounds = polygon.getBounds();\n   * // bounds: x=0, y=0, width=100, height=100\n   *\n   * // Reuse existing rectangle\n   * const rect = new Rectangle();\n   * polygon.getBounds(rect);\n   * ```\n   * @param out - Optional rectangle to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle} For rectangle properties\n   * @see {@link Polygon.contains} For checking if a point is inside\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const target = new Polygon();\n   * target.copyFrom(source);\n   * ```\n   * @param polygon - The polygon to copy from\n   * @returns Returns itself\n   * @see {@link Polygon.copyTo} For copying to another polygon\n   * @see {@link Polygon.clone} For creating new polygon copy\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n   * const target = new Polygon();\n   * source.copyTo(target);\n   * ```\n   * @param polygon - The polygon to copy to\n   * @returns Returns given parameter\n   * @see {@link Polygon.copyFrom} For copying from another polygon\n   * @see {@link Polygon.clone} For creating new polygon copy\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon.\n   * @example\n   * ```ts\n   * // Basic coordinate access\n   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n   * console.log(polygon.lastX); // 300\n   * ```\n   * @readonly\n   * @returns The x-coordinate of the last vertex\n   * @see {@link Polygon.lastY} For last Y coordinate\n   * @see {@link Polygon.points} For raw points array\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon.\n   * @example\n   * ```ts\n   * // Basic coordinate access\n   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n   * console.log(polygon.lastY); // 400\n   * ```\n   * @readonly\n   * @returns The y-coordinate of the last vertex\n   * @see {@link Polygon.lastX} For last X coordinate\n   * @see {@link Polygon.points} For raw points array\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexports.Polygon = Polygon;\n//# sourceMappingURL=Polygon.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/Polygon.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Rectangle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\n\n\"use strict\";\nconst tempPoints = [new Point.Point(), new Point.Point(), new Point.Point(), new Point.Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Rectangle(0, 0, 100, 100);\n     * console.log(shape.type); // 'rectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'rectangle') {\n     *     console.log(shape.width, shape.height);\n     * }\n     * ```\n     * @readonly\n     * @default 'rectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /**\n   * Returns the left edge (x-coordinate) of the rectangle.\n   * @example\n   * ```ts\n   * // Get left edge position\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * console.log(rect.left); // 100\n   *\n   * // Use in alignment calculations\n   * sprite.x = rect.left + padding;\n   *\n   * // Compare positions\n   * if (point.x > rect.left) {\n   *     console.log('Point is right of rectangle');\n   * }\n   * ```\n   * @readonly\n   * @returns The x-coordinate of the left edge\n   * @see {@link Rectangle.right} For right edge position\n   * @see {@link Rectangle.x} For direct x-coordinate access\n   */\n  get left() {\n    return this.x;\n  }\n  /**\n   * Returns the right edge (x + width) of the rectangle.\n   * @example\n   * ```ts\n   * // Get right edge position\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * console.log(rect.right); // 300\n   *\n   * // Align to right edge\n   * sprite.x = rect.right - sprite.width;\n   *\n   * // Check boundaries\n   * if (point.x < rect.right) {\n   *     console.log('Point is inside right bound');\n   * }\n   * ```\n   * @readonly\n   * @returns The x-coordinate of the right edge\n   * @see {@link Rectangle.left} For left edge position\n   * @see {@link Rectangle.width} For width value\n   */\n  get right() {\n    return this.x + this.width;\n  }\n  /**\n   * Returns the top edge (y-coordinate) of the rectangle.\n   * @example\n   * ```ts\n   * // Get top edge position\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * console.log(rect.top); // 100\n   *\n   * // Position above rectangle\n   * sprite.y = rect.top - sprite.height;\n   *\n   * // Check vertical position\n   * if (point.y > rect.top) {\n   *     console.log('Point is below top edge');\n   * }\n   * ```\n   * @readonly\n   * @returns The y-coordinate of the top edge\n   * @see {@link Rectangle.bottom} For bottom edge position\n   * @see {@link Rectangle.y} For direct y-coordinate access\n   */\n  get top() {\n    return this.y;\n  }\n  /**\n   * Returns the bottom edge (y + height) of the rectangle.\n   * @example\n   * ```ts\n   * // Get bottom edge position\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * console.log(rect.bottom); // 250\n   *\n   * // Stack below rectangle\n   * sprite.y = rect.bottom + margin;\n   *\n   * // Check vertical bounds\n   * if (point.y < rect.bottom) {\n   *     console.log('Point is above bottom edge');\n   * }\n   * ```\n   * @readonly\n   * @returns The y-coordinate of the bottom edge\n   * @see {@link Rectangle.top} For top edge position\n   * @see {@link Rectangle.height} For height value\n   */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /**\n   * Determines whether the Rectangle is empty (has no area).\n   * @example\n   * ```ts\n   * // Check zero dimensions\n   * const rect = new Rectangle(100, 100, 0, 50);\n   * console.log(rect.isEmpty()); // true\n   * ```\n   * @returns True if the rectangle has no area\n   * @see {@link Rectangle.width} For width value\n   * @see {@link Rectangle.height} For height value\n   */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /**\n   * A constant empty rectangle. This is a new object every time the property is accessed.\n   * @example\n   * ```ts\n   * // Get fresh empty rectangle\n   * const empty = Rectangle.EMPTY;\n   * console.log(empty.isEmpty()); // true\n   * ```\n   * @returns A new empty rectangle instance\n   * @see {@link Rectangle.isEmpty} For empty state testing\n   */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const original = new Rectangle(100, 100, 200, 150);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.width *= 2;\n   * modified.height += 50;\n   *\n   * // Verify independence\n   * console.log(original.width);  // 200\n   * console.log(modified.width);  // 400\n   * ```\n   * @returns A copy of the rectangle\n   * @see {@link Rectangle.copyFrom} For copying into existing rectangle\n   * @see {@link Rectangle.copyTo} For copying to another rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @example\n   * ```ts\n   * // Convert bounds to rectangle\n   * const bounds = container.getBounds();\n   * const rect = new Rectangle().copyFromBounds(bounds);\n   * ```\n   * @param bounds - The bounds to copy and convert to a rectangle\n   * @returns Returns itself\n   * @see {@link Bounds} For bounds object structure\n   * @see {@link Rectangle.getBounds} For getting rectangle bounds\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Rectangle(100, 100, 200, 150);\n   * const target = new Rectangle();\n   * target.copyFrom(source);\n   *\n   * // Chain with other operations\n   * const rect = new Rectangle()\n   *     .copyFrom(source)\n   *     .pad(10);\n   * ```\n   * @param rectangle - The rectangle to copy from\n   * @returns Returns itself\n   * @see {@link Rectangle.copyTo} For copying to another rectangle\n   * @see {@link Rectangle.clone} For creating new rectangle copy\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Rectangle(100, 100, 200, 150);\n   * const target = new Rectangle();\n   * source.copyTo(target);\n   *\n   * // Chain with other operations\n   * const result = source\n   *     .copyTo(new Rectangle())\n   *     .getBounds();\n   * ```\n   * @param rectangle - The rectangle to copy to\n   * @returns Returns given parameter\n   * @see {@link Rectangle.copyFrom} For copying from another rectangle\n   * @see {@link Rectangle.clone} For creating new rectangle copy\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * const isInside = rect.contains(150, 125); // true\n   * // Check edge cases\n   * console.log(rect.contains(100, 100)); // true (on edge)\n   * console.log(rect.contains(300, 250)); // false (outside)\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   * @see {@link Rectangle.containsRect} For rectangle containment\n   * @see {@link Rectangle.strokeContains} For checking stroke intersection\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = rect.strokeContains(150, 100, 4, 0);   // Inside\n   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n   * const outerStroke = rect.strokeContains(150, 100, 4, 1);   // Outside\n   * ```\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke (0 = inner, 0.5 = centered, 1 = outer)\n   * @returns Whether the x/y coordinates are within this rectangle's stroke\n   * @see {@link Rectangle.contains} For checking fill containment\n   * @see {@link Rectangle.getBounds} For getting stroke bounds\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const outerLeft = _x - strokeWidthOuter;\n    const outerRight = _x + width + strokeWidthOuter;\n    const outerTop = _y - strokeWidthOuter;\n    const outerBottom = _y + height + strokeWidthOuter;\n    const innerLeft = _x + strokeWidthInner;\n    const innerRight = _x + width - strokeWidthInner;\n    const innerTop = _y + strokeWidthInner;\n    const innerBottom = _y + height - strokeWidthInner;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   *\n   * Returns true only if the area of the intersection is greater than 0.\n   * This means that rectangles sharing only a side are not considered intersecting.\n   * @example\n   * ```ts\n   * // Basic intersection check\n   * const rect1 = new Rectangle(0, 0, 100, 100);\n   * const rect2 = new Rectangle(50, 50, 100, 100);\n   * console.log(rect1.intersects(rect2)); // true\n   *\n   * // With transformation matrix\n   * const matrix = new Matrix();\n   * matrix.rotate(Math.PI / 4); // 45 degrees\n   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation\n   *\n   * // Edge cases\n   * const zeroWidth = new Rectangle(0, 0, 0, 100);\n   * console.log(rect1.intersects(zeroWidth)); // false (no area)\n   * ```\n   * @remarks\n   * - Returns true only if intersection area is > 0\n   * - Rectangles sharing only a side are not intersecting\n   * - Zero-area rectangles cannot intersect anything\n   * - Supports optional transformation matrix\n   * @param other - The Rectangle to intersect with `this`\n   * @param transform - Optional transformation matrix of `other`\n   * @returns True if the transformed `other` Rectangle intersects with `this`\n   * @see {@link Rectangle.containsRect} For containment testing\n   * @see {@link Rectangle.contains} For point testing\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   *\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @example\n   * ```ts\n   * // Basic padding\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * rect.pad(10); // Adds 10px padding on all sides\n   *\n   * // Different horizontal and vertical padding\n   * const uiRect = new Rectangle(0, 0, 100, 50);\n   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical\n   * ```\n   * @remarks\n   * - Adjusts x/y by subtracting padding\n   * - Increases width/height by padding * 2\n   * - Common in UI layout calculations\n   * - Chainable with other methods\n   * @param paddingX - The horizontal padding amount\n   * @param paddingY - The vertical padding amount\n   * @returns Returns itself\n   * @see {@link Rectangle.enlarge} For growing to include another rectangle\n   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @example\n   * ```ts\n   * // Basic fitting\n   * const container = new Rectangle(0, 0, 100, 100);\n   * const content = new Rectangle(25, 25, 200, 200);\n   * content.fit(container); // Clips to container bounds\n   * ```\n   * @param rectangle - The rectangle to fit around\n   * @returns Returns itself\n   * @see {@link Rectangle.enlarge} For growing to include another rectangle\n   * @see {@link Rectangle.pad} For adding padding around the rectangle\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle so that its corners lie on a grid defined by resolution.\n   * @example\n   * ```ts\n   * // Basic grid alignment\n   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);\n   * rect.ceil(); // Aligns to whole pixels\n   *\n   * // Custom resolution grid\n   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);\n   * uiRect.ceil(0.5); // Aligns to half pixels\n   *\n   * // Use with precision value\n   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);\n   * preciseRect.ceil(1, 0.01); // Handles small decimal variations\n   * ```\n   * @param resolution - The grid size to align to (1 = whole pixels)\n   * @param eps - Small number to prevent floating point errors\n   * @returns Returns itself\n   * @see {@link Rectangle.fit} For constraining to bounds\n   * @see {@link Rectangle.enlarge} For growing dimensions\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @example\n   * ```ts\n   * // Basic enlargement\n   * const rect = new Rectangle(50, 50, 100, 100);\n   * const other = new Rectangle(0, 0, 200, 75);\n   * rect.enlarge(other);\n   * // rect is now: x=0, y=0, width=200, height=150\n   *\n   * // Use for bounding box calculation\n   * const bounds = new Rectangle();\n   * objects.forEach((obj) => {\n   *     bounds.enlarge(obj.getBounds());\n   * });\n   * ```\n   * @param rectangle - The rectangle to include\n   * @returns Returns itself\n   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n   * @see {@link Rectangle.pad} For adding padding around the rectangle\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @example\n   * ```ts\n   * // Basic bounds retrieval\n   * const rect = new Rectangle(100, 100, 200, 150);\n   * const bounds = rect.getBounds();\n   *\n   * // Reuse existing rectangle\n   * const out = new Rectangle();\n   * rect.getBounds(out);\n   * ```\n   * @param out - Optional rectangle to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle.copyFrom} For direct copying\n   * @see {@link Rectangle.clone} For creating new copy\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.copyFrom(this);\n    return out;\n  }\n  /**\n   * Determines whether another Rectangle is fully contained within this Rectangle.\n   *\n   * Rectangles that occupy the same space are considered to be containing each other.\n   *\n   * Rectangles without area (width or height equal to zero) can't contain anything,\n   * not even other arealess rectangles.\n   * @example\n   * ```ts\n   * // Check if one rectangle contains another\n   * const container = new Rectangle(0, 0, 100, 100);\n   * const inner = new Rectangle(25, 25, 50, 50);\n   *\n   * console.log(container.containsRect(inner)); // true\n   *\n   * // Check overlapping rectangles\n   * const partial = new Rectangle(75, 75, 50, 50);\n   * console.log(container.containsRect(partial)); // false\n   *\n   * // Zero-area rectangles\n   * const empty = new Rectangle(0, 0, 0, 100);\n   * console.log(container.containsRect(empty)); // false\n   * ```\n   * @param other - The Rectangle to check for containment\n   * @returns True if other is fully contained within this Rectangle\n   * @see {@link Rectangle.contains} For point containment\n   * @see {@link Rectangle.intersects} For overlap testing\n   */\n  containsRect(other) {\n    if (this.width <= 0 || this.height <= 0)\n      return false;\n    const x1 = other.x;\n    const y1 = other.y;\n    const x2 = other.x + other.width;\n    const y2 = other.y + other.height;\n    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;\n  }\n  /**\n   * Sets the position and dimensions of the rectangle.\n   * @example\n   * ```ts\n   * // Basic usage\n   * const rect = new Rectangle();\n   * rect.set(100, 100, 200, 150);\n   *\n   * // Chain with other operations\n   * const bounds = new Rectangle()\n   *     .set(0, 0, 100, 100)\n   *     .pad(10);\n   * ```\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   * @returns Returns itself for method chaining\n   * @see {@link Rectangle.copyFrom} For copying from another rectangle\n   * @see {@link Rectangle.clone} For creating a new copy\n   */\n  set(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexports.Rectangle = Rectangle;\n//# sourceMappingURL=Rectangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/Rectangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n     * console.log(shape.type); // 'roundedRectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'roundedRectangle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @readonly\n     * @default 'roundedRectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @example\n   * ```ts\n   * // Basic bounds calculation\n   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const bounds = rect.getBounds();\n   * // bounds: x=100, y=100, width=200, height=150\n   *\n   * // Reuse existing rectangle\n   * const out = new Rectangle();\n   * rect.getBounds(out);\n   * ```\n   * @remarks\n   * - Rectangle matches outer dimensions\n   * - Ignores corner radius\n   * @param out - Optional rectangle to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle} For rectangle properties\n   * @see {@link RoundedRectangle.contains} For checking if a point is inside\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.radius = 30;\n   * modified.width *= 2;\n   *\n   * // Verify independence\n   * console.log(original.radius);  // 20\n   * console.log(modified.radius);  // 30\n   * ```\n   * @returns A copy of the rounded rectangle\n   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const target = new RoundedRectangle();\n   * target.copyFrom(source);\n   *\n   * // Chain with other operations\n   * const rect = new RoundedRectangle()\n   *     .copyFrom(source)\n   *     .getBounds(rect);\n   * ```\n   * @param rectangle - The rectangle to copy from\n   * @returns Returns itself\n   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n   * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const target = new RoundedRectangle();\n   * source.copyTo(target);\n   *\n   * // Chain with other operations\n   * const result = source\n   *     .copyTo(new RoundedRectangle())\n   *     .getBounds();\n   * ```\n   * @param rectangle - The rectangle to copy to\n   * @returns Returns given parameter\n   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n   * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const isInside = rect.contains(150, 125); // true\n   * // Check corner radius\n   * const corner = rect.contains(100, 100); // false if within corner curve\n   * ```\n   * @remarks\n   * - Returns false if width/height is 0 or negative\n   * - Handles rounded corners with radius check\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rounded Rectangle\n   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = rect.strokeContains(150, 100, 4, 0);   // Inside\n   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n   * const outerStroke = rect.strokeContains(150, 100, 4, 1);   // Outside\n   * ```\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke (0 = inner, 0.5 = centered, 1 = outer)\n   * @returns Whether the x/y coordinates are within this rectangle's stroke\n   * @see {@link RoundedRectangle.contains} For checking fill containment\n   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n   */\n  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {\n    const { x, y, width, height, radius } = this;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(\n        pX,\n        pY,\n        innerX,\n        innerY,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(\n        pX,\n        pY,\n        rightBound - radius,\n        innerY,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(\n        pX,\n        pY,\n        rightBound - radius,\n        bottomBound - radius,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(\n        pX,\n        pY,\n        innerX,\n        bottomBound - radius,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      )\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexports.RoundedRectangle = RoundedRectangle;\n//# sourceMappingURL=RoundedRectangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/ShapePrimitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/ShapePrimitive.js ***!
  \*****************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=ShapePrimitive.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/ShapePrimitive.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Triangle.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Triangle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar squaredDistanceToLineSegment = __webpack_require__(/*! ../misc/squaredDistanceToLineSegment.js */ \"./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.js\");\nvar Rectangle = __webpack_require__(/*! ./Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nclass Triangle {\n  /**\n   * @param x - The X coord of the first point.\n   * @param y - The Y coord of the first point.\n   * @param x2 - The X coord of the second point.\n   * @param y2 - The Y coord of the second point.\n   * @param x3 - The X coord of the third point.\n   * @param y3 - The Y coord of the third point.\n   */\n  constructor(x = 0, y = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Triangle(0, 0, 100, 0, 50, 100);\n     * console.log(shape.type); // 'triangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'triangle') {\n     *     console.log(shape.x2, shape.y2);\n     * }\n     * ```\n     * @readonly\n     * @default 'triangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    this.type = \"triangle\";\n    this.x = x;\n    this.y = y;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.x3 = x3;\n    this.y3 = y3;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this triangle\n   * @example\n   * ```ts\n   * // Basic containment check\n   * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n   * const isInside = triangle.contains(25, 25); // true\n   * ```\n   * @remarks\n   * - Uses barycentric coordinate system\n   * - Works with any triangle shape\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Triangle\n   * @see {@link Triangle.strokeContains} For checking stroke intersection\n   * @see {@link Triangle.getBounds} For getting containing rectangle\n   */\n  contains(x, y) {\n    const s = (this.x - this.x3) * (y - this.y3) - (this.y - this.y3) * (x - this.x3);\n    const t = (this.x2 - this.x) * (y - this.y) - (this.y2 - this.y) * (x - this.x);\n    if (s < 0 !== t < 0 && s !== 0 && t !== 0) {\n      return false;\n    }\n    const d = (this.x3 - this.x2) * (y - this.y2) - (this.y3 - this.y2) * (x - this.x2);\n    return d === 0 || d < 0 === s + t <= 0;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this triangle including the stroke.\n   * @example\n   * ```ts\n   * // Basic stroke check\n   * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n   * const isOnStroke = triangle.strokeContains(25, 25, 4); // 4px line width\n   *\n   * // Check with different alignments\n   * const innerStroke = triangle.strokeContains(25, 25, 4, 0);   // Inside\n   * const centerStroke = triangle.strokeContains(25, 25, 4, 0.5); // Centered\n   * const outerStroke = triangle.strokeContains(25, 25, 4, 1);   // Outside\n   * ```\n   * @param pointX - The X coordinate of the point to test\n   * @param pointY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param _alignment - The alignment of the stroke (0 = inner, 0.5 = centered, 1 = outer)\n   * @returns Whether the x/y coordinates are within this triangle's stroke\n   * @see {@link Triangle.contains} For checking fill containment\n   * @see {@link Triangle.getBounds} For getting stroke bounds\n   */\n  strokeContains(pointX, pointY, strokeWidth, _alignment = 0.5) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;\n    const { x, x2, x3, y, y2, y3 } = this;\n    if (squaredDistanceToLineSegment.squaredDistanceToLineSegment(pointX, pointY, x, y, x2, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment.squaredDistanceToLineSegment(pointX, pointY, x2, y2, x3, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment.squaredDistanceToLineSegment(pointX, pointY, x3, y3, x, y) <= halfStrokeWidthSquared) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Creates a clone of this Triangle\n   * @example\n   * ```ts\n   * // Basic cloning\n   * const original = new Triangle(0, 0, 100, 0, 50, 100);\n   * const copy = original.clone();\n   *\n   * // Clone and modify\n   * const modified = original.clone();\n   * modified.x3 = 75;\n   * modified.y3 = 150;\n   *\n   * // Verify independence\n   * console.log(original.y3);  // 100\n   * console.log(modified.y3);  // 150\n   * ```\n   * @returns A copy of the triangle\n   * @see {@link Triangle.copyFrom} For copying into existing triangle\n   * @see {@link Triangle.copyTo} For copying to another triangle\n   */\n  clone() {\n    const triangle = new Triangle(\n      this.x,\n      this.y,\n      this.x2,\n      this.y2,\n      this.x3,\n      this.y3\n    );\n    return triangle;\n  }\n  /**\n   * Copies another triangle to this one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Triangle(0, 0, 100, 0, 50, 100);\n   * const target = new Triangle();\n   * target.copyFrom(source);\n   *\n   * // Chain with other operations\n   * const triangle = new Triangle()\n   *     .copyFrom(source)\n   *     .getBounds(rect);\n   * ```\n   * @param triangle - The triangle to copy from\n   * @returns Returns itself\n   * @see {@link Triangle.copyTo} For copying to another triangle\n   * @see {@link Triangle.clone} For creating new triangle copy\n   */\n  copyFrom(triangle) {\n    this.x = triangle.x;\n    this.y = triangle.y;\n    this.x2 = triangle.x2;\n    this.y2 = triangle.y2;\n    this.x3 = triangle.x3;\n    this.y3 = triangle.y3;\n    return this;\n  }\n  /**\n   * Copies this triangle to another one.\n   * @example\n   * ```ts\n   * // Basic copying\n   * const source = new Triangle(0, 0, 100, 0, 50, 100);\n   * const target = new Triangle();\n   * source.copyTo(target);\n   *\n   * // Chain with other operations\n   * const result = source\n   *     .copyTo(new Triangle())\n   *     .getBounds();\n   * ```\n   * @remarks\n   * - Updates target triangle values\n   * - Copies all point coordinates\n   * - Returns target for chaining\n   * - More efficient than clone()\n   * @param triangle - The triangle to copy to\n   * @returns Returns given parameter\n   * @see {@link Triangle.copyFrom} For copying from another triangle\n   * @see {@link Triangle.clone} For creating new triangle copy\n   */\n  copyTo(triangle) {\n    triangle.copyFrom(this);\n    return triangle;\n  }\n  /**\n   * Returns the framing rectangle of the triangle as a Rectangle object\n   * @example\n   * ```ts\n   * // Basic bounds calculation\n   * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n   * const bounds = triangle.getBounds();\n   * // bounds: x=0, y=0, width=100, height=100\n   *\n   * // Reuse existing rectangle\n   * const rect = new Rectangle();\n   * triangle.getBounds(rect);\n   * ```\n   * @param out - Optional rectangle to store the result\n   * @returns The framing rectangle\n   * @see {@link Rectangle} For rectangle properties\n   * @see {@link Triangle.contains} For checking if a point is inside\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    const minX = Math.min(this.x, this.x2, this.x3);\n    const maxX = Math.max(this.x, this.x2, this.x3);\n    const minY = Math.min(this.y, this.y2, this.y3);\n    const maxY = Math.max(this.y, this.y2, this.y3);\n    out.x = minX;\n    out.y = minY;\n    out.width = maxX - minX;\n    out.height = maxY - minY;\n    return out;\n  }\n}\n\nexports.Triangle = Triangle;\n//# sourceMappingURL=Triangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/maths/shapes/Triangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareBase.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareBase.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Container = __webpack_require__(/*! ../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar _const = __webpack_require__(/*! ../ticker/const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\n\n\"use strict\";\nconst _PrepareBase = class _PrepareBase {\n  /**\n   * @param {Renderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    /** called per frame by the ticker, defer processing to next tick */\n    this._tick = () => {\n      this.timeout = setTimeout(this._processQueue, 0);\n    };\n    /** process the queue up to max item limit per frame */\n    this._processQueue = () => {\n      const { queue } = this;\n      let itemsProcessed = 0;\n      while (queue.length && itemsProcessed < _PrepareBase.uploadsPerFrame) {\n        const queueItem = queue.shift();\n        this.uploadQueueItem(queueItem);\n        itemsProcessed++;\n      }\n      if (queue.length) {\n        Ticker.Ticker.system.addOnce(this._tick, this, _const.UPDATE_PRIORITY.UTILITY);\n      } else {\n        this._resolve();\n      }\n    };\n    this.renderer = renderer;\n    this.queue = [];\n    this.resolves = [];\n  }\n  /**\n   * Return a copy of the queue\n   * @returns {PrepareQueueItem[]} The queue\n   */\n  getQueue() {\n    return [...this.queue];\n  }\n  /**\n   * Add a textures or graphics resource to the queue\n   * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n   */\n  add(resource) {\n    const resourceArray = Array.isArray(resource) ? resource : [resource];\n    for (const resourceItem of resourceArray) {\n      if (resourceItem instanceof Container.Container) {\n        this._addContainer(resourceItem);\n      } else {\n        this.resolveQueueItem(resourceItem, this.queue);\n      }\n    }\n    return this;\n  }\n  /**\n   * Recursively add a container and its children to the queue\n   * @param {Container} container - The container to add to the queue\n   */\n  _addContainer(container) {\n    this.resolveQueueItem(container, this.queue);\n    for (const child of container.children) {\n      this._addContainer(child);\n    }\n  }\n  /**\n   * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n   * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n   */\n  upload(resource) {\n    if (resource) {\n      this.add(resource);\n    }\n    return new Promise((resolve) => {\n      if (this.queue.length) {\n        this.resolves.push(resolve);\n        this.dedupeQueue();\n        Ticker.Ticker.system.addOnce(this._tick, this, _const.UPDATE_PRIORITY.UTILITY);\n      } else {\n        resolve();\n      }\n    });\n  }\n  /** eliminate duplicates before processing */\n  dedupeQueue() {\n    const hash = /* @__PURE__ */ Object.create(null);\n    let nextUnique = 0;\n    for (let i = 0; i < this.queue.length; i++) {\n      const current = this.queue[i];\n      if (!hash[current.uid]) {\n        hash[current.uid] = true;\n        this.queue[nextUnique++] = current;\n      }\n    }\n    this.queue.length = nextUnique;\n  }\n  /** Call all the resolve callbacks */\n  _resolve() {\n    const { resolves } = this;\n    const array = resolves.slice(0);\n    resolves.length = 0;\n    for (const resolve of array) {\n      resolve();\n    }\n  }\n};\n/** The number of uploads to process per frame */\n_PrepareBase.uploadsPerFrame = 4;\nlet PrepareBase = _PrepareBase;\n\nexports.PrepareBase = PrepareBase;\n//# sourceMappingURL=PrepareBase.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/prepare/PrepareBase.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareQueue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureSource = __webpack_require__(/*! ../rendering/renderers/shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar Container = __webpack_require__(/*! ../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar Graphics = __webpack_require__(/*! ../scene/graphics/shared/Graphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js\");\nvar GraphicsContext = __webpack_require__(/*! ../scene/graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar Mesh = __webpack_require__(/*! ../scene/mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar Sprite = __webpack_require__(/*! ../scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar AnimatedSprite = __webpack_require__(/*! ../scene/sprite-animated/AnimatedSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js\");\nvar TilingSprite = __webpack_require__(/*! ../scene/sprite-tiling/TilingSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js\");\nvar Text = __webpack_require__(/*! ../scene/text/Text.js */ \"./node_modules/pixi.js/lib/scene/text/Text.js\");\nvar PrepareBase = __webpack_require__(/*! ./PrepareBase.js */ \"./node_modules/pixi.js/lib/prepare/PrepareBase.js\");\n\n\"use strict\";\nclass PrepareQueue extends PrepareBase.PrepareBase {\n  /**\n   * Resolve the given resource type and return an item for the queue\n   * @param source\n   * @param queue\n   */\n  resolveQueueItem(source, queue) {\n    if (source instanceof Container.Container) {\n      this.resolveContainerQueueItem(source, queue);\n    } else if (source instanceof TextureSource.TextureSource || source instanceof Texture.Texture) {\n      queue.push(source.source);\n    } else if (source instanceof GraphicsContext.GraphicsContext) {\n      queue.push(source);\n    }\n    return null;\n  }\n  /**\n   * Resolve the given container and return an item for the queue\n   * @param container\n   * @param queue\n   */\n  resolveContainerQueueItem(container, queue) {\n    if (container instanceof Sprite.Sprite || container instanceof TilingSprite.TilingSprite || container instanceof Mesh.Mesh) {\n      queue.push(container.texture.source);\n    } else if (container instanceof Text.Text) {\n      queue.push(container);\n    } else if (container instanceof Graphics.Graphics) {\n      queue.push(container.context);\n    } else if (container instanceof AnimatedSprite.AnimatedSprite) {\n      container.textures.forEach((textureOrFrame) => {\n        if (textureOrFrame.source) {\n          queue.push(textureOrFrame.source);\n        } else {\n          queue.push(textureOrFrame.texture.source);\n        }\n      });\n    }\n  }\n  /**\n   * Resolve the given graphics context and return an item for the queue\n   * @param graphicsContext\n   */\n  resolveGraphicsContextQueueItem(graphicsContext) {\n    this.renderer.graphicsContext.getGpuContext(graphicsContext);\n    const { instructions } = graphicsContext;\n    for (const instruction of instructions) {\n      if (instruction.action === \"texture\") {\n        const { image } = instruction.data;\n        return image.source;\n      } else if (instruction.action === \"fill\") {\n        const { texture } = instruction.data.style;\n        return texture.source;\n      }\n    }\n    return null;\n  }\n}\n\nexports.PrepareQueue = PrepareQueue;\n//# sourceMappingURL=PrepareQueue.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/prepare/PrepareQueue.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareSystem.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareSystem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar PrepareUpload = __webpack_require__(/*! ./PrepareUpload.js */ \"./node_modules/pixi.js/lib/prepare/PrepareUpload.js\");\n\n\"use strict\";\nclass PrepareSystem extends PrepareUpload.PrepareUpload {\n  /** Destroys the plugin, don't use after this. */\n  destroy() {\n    clearTimeout(this.timeout);\n    this.renderer = null;\n    this.queue = null;\n    this.resolves = null;\n  }\n}\n/** @ignore */\nPrepareSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"prepare\"\n};\n\nexports.PrepareSystem = PrepareSystem;\n//# sourceMappingURL=PrepareSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/prepare/PrepareSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareUpload.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareUpload.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureSource = __webpack_require__(/*! ../rendering/renderers/shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar GraphicsContext = __webpack_require__(/*! ../scene/graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar Text = __webpack_require__(/*! ../scene/text/Text.js */ \"./node_modules/pixi.js/lib/scene/text/Text.js\");\nvar BitmapText = __webpack_require__(/*! ../scene/text-bitmap/BitmapText.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js\");\nvar HTMLText = __webpack_require__(/*! ../scene/text-html/HTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLText.js\");\nvar PrepareQueue = __webpack_require__(/*! ./PrepareQueue.js */ \"./node_modules/pixi.js/lib/prepare/PrepareQueue.js\");\n\n\"use strict\";\nclass PrepareUpload extends PrepareQueue.PrepareQueue {\n  /**\n   * Upload the given queue item\n   * @param item\n   */\n  uploadQueueItem(item) {\n    if (item instanceof TextureSource.TextureSource) {\n      this.uploadTextureSource(item);\n    } else if (item instanceof Text.Text) {\n      this.uploadText(item);\n    } else if (item instanceof HTMLText.HTMLText) {\n      this.uploadHTMLText(item);\n    } else if (item instanceof BitmapText.BitmapText) {\n      this.uploadBitmapText(item);\n    } else if (item instanceof GraphicsContext.GraphicsContext) {\n      this.uploadGraphicsContext(item);\n    }\n  }\n  uploadTextureSource(textureSource) {\n    this.renderer.texture.initSource(textureSource);\n  }\n  uploadText(_text) {\n    this.renderer.renderPipes.text.initGpuText(_text);\n  }\n  uploadBitmapText(_text) {\n    this.renderer.renderPipes.bitmapText.initGpuText(_text);\n  }\n  uploadHTMLText(_text) {\n    this.renderer.renderPipes.htmlText.initGpuText(_text);\n  }\n  /**\n   * Resolve the given graphics context and return an item for the queue\n   * @param graphicsContext\n   */\n  uploadGraphicsContext(graphicsContext) {\n    this.renderer.graphicsContext.getGpuContext(graphicsContext);\n    const { instructions } = graphicsContext;\n    for (const instruction of instructions) {\n      if (instruction.action === \"texture\") {\n        const { image } = instruction.data;\n        this.uploadTextureSource(image.source);\n      } else if (instruction.action === \"fill\") {\n        const { texture } = instruction.data.style;\n        this.uploadTextureSource(texture.source);\n      }\n    }\n    return null;\n  }\n}\n\nexports.PrepareUpload = PrepareUpload;\n//# sourceMappingURL=PrepareUpload.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/prepare/PrepareUpload.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/index.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar PrepareBase = __webpack_require__(/*! ./PrepareBase.js */ \"./node_modules/pixi.js/lib/prepare/PrepareBase.js\");\nvar PrepareQueue = __webpack_require__(/*! ./PrepareQueue.js */ \"./node_modules/pixi.js/lib/prepare/PrepareQueue.js\");\nvar PrepareSystem = __webpack_require__(/*! ./PrepareSystem.js */ \"./node_modules/pixi.js/lib/prepare/PrepareSystem.js\");\nvar PrepareUpload = __webpack_require__(/*! ./PrepareUpload.js */ \"./node_modules/pixi.js/lib/prepare/PrepareUpload.js\");\n\n\"use strict\";\n\nexports.PrepareBase = PrepareBase.PrepareBase;\nexports.PrepareQueue = PrepareQueue.PrepareQueue;\nexports.PrepareSystem = PrepareSystem.PrepareSystem;\nexports.PrepareUpload = PrepareUpload.PrepareUpload;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/prepare/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\n\n\"use strict\";\nclass GlBatchAdaptor {\n  constructor() {\n    this._tempState = State.State.for2d();\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    this._didUploadHash = {};\n  }\n  init(batcherPipe) {\n    batcherPipe.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._didUploadHash = {};\n  }\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const didUpload = this._didUploadHash[shader.uid];\n    renderer.shader.bind(shader, didUpload);\n    if (!didUpload) {\n      this._didUploadHash[shader.uid] = true;\n    }\n    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n    renderer.geometry.bind(geometry, shader.glProgram);\n  }\n  execute(batchPipe, batch) {\n    const renderer = batchPipe.renderer;\n    this._tempState.blendMode = batch.blendMode;\n    renderer.state.set(this._tempState);\n    const textures = batch.textures.textures;\n    for (let i = 0; i < batch.textures.count; i++) {\n      renderer.texture.bind(textures[i], i);\n    }\n    renderer.geometry.draw(batch.topology, batch.size, batch.start);\n  }\n}\n/** @ignore */\nGlBatchAdaptor.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexports.GlBatchAdaptor = GlBatchAdaptor;\n//# sourceMappingURL=GlBatchAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;\n//# sourceMappingURL=checkMaxIfStatementsInShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getTestContext = __webpack_require__(/*! ../../../renderers/gl/shader/program/getTestContext.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js\");\nvar checkMaxIfStatementsInShader = __webpack_require__(/*! ./checkMaxIfStatementsInShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js\");\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext.getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexports.getMaxTexturesPerBatch = getMaxTexturesPerBatch;\n//# sourceMappingURL=maxRecommendedTextures.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar getTextureBatchBindGroup = __webpack_require__(/*! ./getTextureBatchBindGroup.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js\");\n\n\"use strict\";\nconst tempState = State.State.for2d();\nclass GpuBatchAdaptor {\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = shader.gpuProgram;\n    this._shader = shader;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup(\n        textureBatch.textures,\n        textureBatch.count,\n        renderer.limits.maxBatchableTextures\n      );\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState,\n      batch.topology\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexports.GpuBatchAdaptor = GpuBatchAdaptor;\n//# sourceMappingURL=GpuBatchAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction generateGPULayout(maxTextures) {\n  const gpuLayout = [];\n  let bindIndex = 0;\n  for (let i = 0; i < maxTextures; i++) {\n    gpuLayout[bindIndex] = {\n      texture: {\n        sampleType: \"float\",\n        viewDimension: \"2d\",\n        multisampled: false\n      },\n      binding: bindIndex,\n      visibility: GPUShaderStage.FRAGMENT\n    };\n    bindIndex++;\n    gpuLayout[bindIndex] = {\n      sampler: {\n        type: \"filtering\"\n      },\n      binding: bindIndex,\n      visibility: GPUShaderStage.FRAGMENT\n    };\n    bindIndex++;\n  }\n  return gpuLayout;\n}\n\nexports.generateGPULayout = generateGPULayout;\n//# sourceMappingURL=generateGPULayout.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction generateLayout(maxTextures) {\n  const layout = {};\n  let bindIndex = 0;\n  for (let i = 0; i < maxTextures; i++) {\n    layout[`textureSource${i + 1}`] = bindIndex++;\n    layout[`textureSampler${i + 1}`] = bindIndex++;\n  }\n  return layout;\n}\n\nexports.generateLayout = generateLayout;\n//# sourceMappingURL=generateLayout.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BindGroup = __webpack_require__(/*! ../../renderers/gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar Texture = __webpack_require__(/*! ../../renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size, maxTextures) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);\n}\nfunction generateTextureBatchBindGroup(textures, size, key, maxTextures) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : Texture.Texture.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new BindGroup.BindGroup(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\nexports.getTextureBatchBindGroup = getTextureBatchBindGroup;\n//# sourceMappingURL=getTextureBatchBindGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Buffer = __webpack_require__(/*! ../../renderers/shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar _const = __webpack_require__(/*! ../../renderers/shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar Geometry = __webpack_require__(/*! ../../renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry.Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer.Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer.Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: _const.BufferUsage.INDEX | _const.BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexports.BatchGeometry = BatchGeometry;\n//# sourceMappingURL=BatchGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexports.BatchTextureArray = BatchTextureArray;\n//# sourceMappingURL=BatchTextureArray.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uid = __webpack_require__(/*! ../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar ViewableBuffer = __webpack_require__(/*! ../../../utils/data/ViewableBuffer.js */ \"./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar fastCopy = __webpack_require__(/*! ../../renderers/shared/buffer/utils/fastCopy.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ../../renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar maxRecommendedTextures = __webpack_require__(/*! ../gl/utils/maxRecommendedTextures.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js\");\nvar BatchTextureArray = __webpack_require__(/*! ./BatchTextureArray.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js\");\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray.BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options) {\n    /** unique id for this batcher */\n    this.uid = uid.uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    options = { ..._Batcher.defaultOptions, ...options };\n    if (!options.maxTextures) {\n      deprecation.deprecation(\"v8.8.0\", \"maxTextures is a required option for Batcher now, please pass it in the options\");\n      options.maxTextures = maxRecommendedTextures.getMaxTexturesPerBatch();\n    }\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer.ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer.ViewableBuffer(newSize);\n    fastCopy.fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy.fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexports.Batch = Batch;\nexports.Batcher = Batcher;\n//# sourceMappingURL=Batcher.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar DefaultBatcher = __webpack_require__(/*! ./DefaultBatcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js\");\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher.DefaultBatcher({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nExtensions.extensions.handleByMap(Extensions.ExtensionType.Batcher, BatcherPipe._availableBatchers);\nExtensions.extensions.add(DefaultBatcher.DefaultBatcher);\n\nexports.BatcherPipe = BatcherPipe;\n//# sourceMappingURL=BatcherPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Batcher = __webpack_require__(/*! ./Batcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js\");\nvar BatchGeometry = __webpack_require__(/*! ./BatchGeometry.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js\");\nvar DefaultShader = __webpack_require__(/*! ./DefaultShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js\");\n\n\"use strict\";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher.Batcher {\n  constructor(options) {\n    super(options);\n    this.geometry = new BatchGeometry.BatchGeometry();\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n    defaultShader ?? (defaultShader = new DefaultShader.DefaultShader(options.maxTextures));\n    this.shader = defaultShader;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    Extensions.ExtensionType.Batcher\n  ],\n  name: \"default\"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\nexports.DefaultBatcher = DefaultBatcher;\n//# sourceMappingURL=DefaultBatcher.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar colorBit = __webpack_require__(/*! ../../high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ../../high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar getBatchSamplersUniformGroup = __webpack_require__(/*! ../../renderers/gl/shader/getBatchSamplersUniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js\");\nvar Shader = __webpack_require__(/*! ../../renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\n\n\"use strict\";\nclass DefaultShader extends Shader.Shader {\n  constructor(maxTextures) {\n    const glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBit.colorBitGl,\n        generateTextureBatchBit.generateTextureBatchBitGl(maxTextures),\n        roundPixelsBit.roundPixelsBitGl\n      ]\n    });\n    const gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit.colorBit,\n        generateTextureBatchBit.generateTextureBatchBit(maxTextures),\n        roundPixelsBit.roundPixelsBit\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: getBatchSamplersUniformGroup.getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexports.DefaultShader = DefaultShader;\n//# sourceMappingURL=DefaultShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlProgram = __webpack_require__(/*! ../renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar compileHighShader = __webpack_require__(/*! ./compiler/compileHighShader.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js\");\nvar defaultProgramTemplate = __webpack_require__(/*! ./defaultProgramTemplate.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js\");\nvar globalUniformsBit = __webpack_require__(/*! ./shader-bits/globalUniformsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js\");\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader.compileHighShader({\n    template: {\n      fragment: defaultProgramTemplate.fragmentGPUTemplate,\n      vertex: defaultProgramTemplate.vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit.globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram.GlProgram({\n    name,\n    ...compileHighShader.compileHighShaderGl({\n      template: {\n        vertex: defaultProgramTemplate.vertexGlTemplate,\n        fragment: defaultProgramTemplate.fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBit.globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexports.compileHighShaderGlProgram = compileHighShaderGlProgram;\nexports.compileHighShaderGpuProgram = compileHighShaderGpuProgram;\n//# sourceMappingURL=compileHighShaderToProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar addBits = __webpack_require__(/*! ./utils/addBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js\");\nvar compileHooks = __webpack_require__(/*! ./utils/compileHooks.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js\");\nvar compileInputs = __webpack_require__(/*! ./utils/compileInputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js\");\nvar compileOutputs = __webpack_require__(/*! ./utils/compileOutputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js\");\nvar injectBits = __webpack_require__(/*! ./utils/injectBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js\");\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs.compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs.compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs.compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks.compileHooks(vertex);\n  const fragmentParts = compileHooks.compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits.addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits.addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits.injectBits(vertex, vertexParts),\n    fragment: injectBits.injectBits(fragment, fragmentParts)\n  };\n}\n\nexports.compileHighShader = compileHighShader;\nexports.compileHighShaderGl = compileHighShaderGl;\n//# sourceMappingURL=compileHighShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/types.js ***!
  \**************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn.warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexports.addBits = addBits;\n//# sourceMappingURL=addBits.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexports.compileHooks = compileHooks;\n//# sourceMappingURL=compileHooks.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexports.compileInputs = compileInputs;\n//# sourceMappingURL=compileInputs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexports.compileOutputs = compileOutputs;\n//# sourceMappingURL=compileOutputs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction formatShader(shader) {\n  const spl = shader.split(/([\\n{}])/g).map((a) => a.trim()).filter((a) => a.length);\n  let indent = \"\";\n  const formatted = spl.map((a) => {\n    let indentedLine = indent + a;\n    if (a === \"{\") {\n      indent += \"    \";\n    } else if (a === \"}\") {\n      indent = indent.substr(0, indent.length - 4);\n      indentedLine = indent + a;\n    }\n    return indentedLine;\n  }).join(\"\\n\");\n  return formatted;\n}\n\nexports.formatShader = formatShader;\n//# sourceMappingURL=formatShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexports.injectBits = injectBits;\n//# sourceMappingURL=injectBits.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`\n);\n\nexports.fragmentGPUTemplate = fragmentGPUTemplate;\nexports.fragmentGlTemplate = fragmentGlTemplate;\nexports.vertexGPUTemplate = vertexGPUTemplate;\nexports.vertexGlTemplate = vertexGlTemplate;\n//# sourceMappingURL=defaultProgramTemplate.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexports.colorBit = colorBit;\nexports.colorBitGl = colorBitGl;\n//# sourceMappingURL=colorBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexports.generateTextureBatchBit = generateTextureBatchBit;\nexports.generateTextureBatchBitGl = generateTextureBatchBitGl;\n//# sourceMappingURL=generateTextureBatchBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexports.globalUniformsBit = globalUniformsBit;\nexports.globalUniformsBitGl = globalUniformsBitGl;\nexports.globalUniformsUBOBitGl = globalUniformsUBOBitGl;\n//# sourceMappingURL=globalUniformsBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexports.localUniformBit = localUniformBit;\nexports.localUniformBitGl = localUniformBitGl;\nexports.localUniformBitGroup2 = localUniformBitGroup2;\n//# sourceMappingURL=localUniformBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexports.roundPixelsBit = roundPixelsBit;\nexports.roundPixelsBitGl = roundPixelsBitGl;\n//# sourceMappingURL=roundPixelsBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexports.textureBit = textureBit;\nexports.textureBitGl = textureBitGl;\n//# sourceMappingURL=textureBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GlBatchAdaptor = __webpack_require__(/*! ./batcher/gl/GlBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js\");\nvar checkMaxIfStatementsInShader = __webpack_require__(/*! ./batcher/gl/utils/checkMaxIfStatementsInShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js\");\nvar maxRecommendedTextures = __webpack_require__(/*! ./batcher/gl/utils/maxRecommendedTextures.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.js\");\nvar generateGPULayout = __webpack_require__(/*! ./batcher/gpu/generateGPULayout.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.js\");\nvar generateLayout = __webpack_require__(/*! ./batcher/gpu/generateLayout.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.js\");\nvar getTextureBatchBindGroup = __webpack_require__(/*! ./batcher/gpu/getTextureBatchBindGroup.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js\");\nvar GpuBatchAdaptor = __webpack_require__(/*! ./batcher/gpu/GpuBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js\");\nvar Batcher = __webpack_require__(/*! ./batcher/shared/Batcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.js\");\nvar BatcherPipe = __webpack_require__(/*! ./batcher/shared/BatcherPipe.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js\");\nvar BatchGeometry = __webpack_require__(/*! ./batcher/shared/BatchGeometry.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.js\");\nvar BatchTextureArray = __webpack_require__(/*! ./batcher/shared/BatchTextureArray.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.js\");\nvar DefaultBatcher = __webpack_require__(/*! ./batcher/shared/DefaultBatcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js\");\nvar DefaultShader = __webpack_require__(/*! ./batcher/shared/DefaultShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ./high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar compileHighShader = __webpack_require__(/*! ./high-shader/compiler/compileHighShader.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.js\");\n__webpack_require__(/*! ./high-shader/compiler/types.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/types.js\");\nvar addBits = __webpack_require__(/*! ./high-shader/compiler/utils/addBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.js\");\nvar compileHooks = __webpack_require__(/*! ./high-shader/compiler/utils/compileHooks.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.js\");\nvar compileInputs = __webpack_require__(/*! ./high-shader/compiler/utils/compileInputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.js\");\nvar compileOutputs = __webpack_require__(/*! ./high-shader/compiler/utils/compileOutputs.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.js\");\nvar formatShader = __webpack_require__(/*! ./high-shader/compiler/utils/formatShader.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.js\");\nvar injectBits = __webpack_require__(/*! ./high-shader/compiler/utils/injectBits.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.js\");\nvar defaultProgramTemplate = __webpack_require__(/*! ./high-shader/defaultProgramTemplate.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.js\");\nvar colorBit = __webpack_require__(/*! ./high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ./high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar globalUniformsBit = __webpack_require__(/*! ./high-shader/shader-bits/globalUniformsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.js\");\nvar localUniformBit = __webpack_require__(/*! ./high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ./high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar textureBit = __webpack_require__(/*! ./high-shader/shader-bits/textureBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js\");\nvar AlphaMask = __webpack_require__(/*! ./mask/alpha/AlphaMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js\");\nvar AlphaMaskPipe = __webpack_require__(/*! ./mask/alpha/AlphaMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js\");\nvar ColorMask = __webpack_require__(/*! ./mask/color/ColorMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js\");\nvar ColorMaskPipe = __webpack_require__(/*! ./mask/color/ColorMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js\");\nvar MaskEffectManager = __webpack_require__(/*! ./mask/MaskEffectManager.js */ \"./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js\");\nvar ScissorMask = __webpack_require__(/*! ./mask/scissor/ScissorMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.js\");\nvar StencilMask = __webpack_require__(/*! ./mask/stencil/StencilMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js\");\nvar StencilMaskPipe = __webpack_require__(/*! ./mask/stencil/StencilMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js\");\nvar addMaskBounds = __webpack_require__(/*! ./mask/utils/addMaskBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js\");\nvar addMaskLocalBounds = __webpack_require__(/*! ./mask/utils/addMaskLocalBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js\");\nvar autoDetectRenderer = __webpack_require__(/*! ./renderers/autoDetectRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js\");\nvar _const = __webpack_require__(/*! ./renderers/gl/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js\");\nvar GlBuffer = __webpack_require__(/*! ./renderers/gl/buffer/GlBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js\");\nvar GlBufferSystem = __webpack_require__(/*! ./renderers/gl/buffer/GlBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js\");\nvar _const$1 = __webpack_require__(/*! ./renderers/gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar GlContextSystem = __webpack_require__(/*! ./renderers/gl/context/GlContextSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js\");\n__webpack_require__(/*! ./renderers/gl/context/GlRenderingContext.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlRenderingContext.js\");\n__webpack_require__(/*! ./renderers/gl/context/WebGLExtensions.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/context/WebGLExtensions.js\");\nvar GlGeometrySystem = __webpack_require__(/*! ./renderers/gl/geometry/GlGeometrySystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js\");\nvar getGlTypeFromFormat = __webpack_require__(/*! ./renderers/gl/geometry/utils/getGlTypeFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js\");\nvar GlBackBufferSystem = __webpack_require__(/*! ./renderers/gl/GlBackBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js\");\nvar GlColorMaskSystem = __webpack_require__(/*! ./renderers/gl/GlColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js\");\nvar GlEncoderSystem = __webpack_require__(/*! ./renderers/gl/GlEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js\");\nvar GlLimitsSystem = __webpack_require__(/*! ./renderers/gl/GlLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js\");\nvar GlRenderTarget = __webpack_require__(/*! ./renderers/gl/GlRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js\");\nvar GlStencilSystem = __webpack_require__(/*! ./renderers/gl/GlStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js\");\nvar GlUboSystem = __webpack_require__(/*! ./renderers/gl/GlUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js\");\nvar GlRenderTargetAdaptor = __webpack_require__(/*! ./renderers/gl/renderTarget/GlRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js\");\nvar GlRenderTargetSystem = __webpack_require__(/*! ./renderers/gl/renderTarget/GlRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js\");\n__webpack_require__(/*! ./renderers/gl/shader/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/const.js\");\nvar GenerateShaderSyncCode = __webpack_require__(/*! ./renderers/gl/shader/GenerateShaderSyncCode.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js\");\nvar getBatchSamplersUniformGroup = __webpack_require__(/*! ./renderers/gl/shader/getBatchSamplersUniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js\");\nvar GlProgram = __webpack_require__(/*! ./renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GlProgramData = __webpack_require__(/*! ./renderers/gl/shader/GlProgramData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js\");\nvar GlShaderSystem = __webpack_require__(/*! ./renderers/gl/shader/GlShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js\");\nvar GlUniformGroupSystem = __webpack_require__(/*! ./renderers/gl/shader/GlUniformGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js\");\nvar migrateFragmentFromV7toV8 = __webpack_require__(/*! ./renderers/gl/shader/migrateFragmentFromV7toV8.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js\");\nvar compileShader = __webpack_require__(/*! ./renderers/gl/shader/program/compileShader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js\");\nvar defaultValue = __webpack_require__(/*! ./renderers/gl/shader/program/defaultValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js\");\nvar ensureAttributes = __webpack_require__(/*! ./renderers/gl/shader/program/ensureAttributes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js\");\nvar extractAttributesFromGlProgram = __webpack_require__(/*! ./renderers/gl/shader/program/extractAttributesFromGlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js\");\nvar generateProgram = __webpack_require__(/*! ./renderers/gl/shader/program/generateProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js\");\nvar getMaxFragmentPrecision = __webpack_require__(/*! ./renderers/gl/shader/program/getMaxFragmentPrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js\");\nvar getTestContext = __webpack_require__(/*! ./renderers/gl/shader/program/getTestContext.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js\");\nvar getUboData = __webpack_require__(/*! ./renderers/gl/shader/program/getUboData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js\");\nvar getUniformData = __webpack_require__(/*! ./renderers/gl/shader/program/getUniformData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js\");\nvar logProgramError = __webpack_require__(/*! ./renderers/gl/shader/program/logProgramError.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js\");\nvar mapSize = __webpack_require__(/*! ./renderers/gl/shader/program/mapSize.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.js\");\nvar mapType = __webpack_require__(/*! ./renderers/gl/shader/program/mapType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js\");\nvar addProgramDefines = __webpack_require__(/*! ./renderers/gl/shader/program/preprocessors/addProgramDefines.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js\");\nvar ensurePrecision = __webpack_require__(/*! ./renderers/gl/shader/program/preprocessors/ensurePrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js\");\nvar insertVersion = __webpack_require__(/*! ./renderers/gl/shader/program/preprocessors/insertVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js\");\nvar setProgramName = __webpack_require__(/*! ./renderers/gl/shader/program/preprocessors/setProgramName.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js\");\nvar stripVersion = __webpack_require__(/*! ./renderers/gl/shader/program/preprocessors/stripVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js\");\nvar createUboElementsSTD40 = __webpack_require__(/*! ./renderers/gl/shader/utils/createUboElementsSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js\");\nvar createUboSyncSTD40 = __webpack_require__(/*! ./renderers/gl/shader/utils/createUboSyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js\");\nvar generateArraySyncSTD40 = __webpack_require__(/*! ./renderers/gl/shader/utils/generateArraySyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js\");\nvar generateUniformsSync = __webpack_require__(/*! ./renderers/gl/shader/utils/generateUniformsSync.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js\");\nvar generateUniformsSyncTypes = __webpack_require__(/*! ./renderers/gl/shader/utils/generateUniformsSyncTypes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js\");\nvar GlStateSystem = __webpack_require__(/*! ./renderers/gl/state/GlStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js\");\nvar mapWebGLBlendModesToPixi = __webpack_require__(/*! ./renderers/gl/state/mapWebGLBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js\");\nvar _const$2 = __webpack_require__(/*! ./renderers/gl/texture/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js\");\nvar GlTexture = __webpack_require__(/*! ./renderers/gl/texture/GlTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js\");\nvar GlTextureSystem = __webpack_require__(/*! ./renderers/gl/texture/GlTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js\");\n__webpack_require__(/*! ./renderers/gl/texture/uploaders/GLTextureUploader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/GLTextureUploader.js\");\nvar glUploadBufferImageResource = __webpack_require__(/*! ./renderers/gl/texture/uploaders/glUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js\");\nvar glUploadCompressedTextureResource = __webpack_require__(/*! ./renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js\");\nvar glUploadImageResource = __webpack_require__(/*! ./renderers/gl/texture/uploaders/glUploadImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js\");\nvar glUploadVideoResource = __webpack_require__(/*! ./renderers/gl/texture/uploaders/glUploadVideoResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js\");\nvar applyStyleParams = __webpack_require__(/*! ./renderers/gl/texture/utils/applyStyleParams.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js\");\nvar getSupportedGlCompressedTextureFormats = __webpack_require__(/*! ./renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js\");\nvar mapFormatToGlFormat = __webpack_require__(/*! ./renderers/gl/texture/utils/mapFormatToGlFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js\");\nvar mapFormatToGlInternalFormat = __webpack_require__(/*! ./renderers/gl/texture/utils/mapFormatToGlInternalFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js\");\nvar mapFormatToGlType = __webpack_require__(/*! ./renderers/gl/texture/utils/mapFormatToGlType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js\");\nvar pixiToGlMaps = __webpack_require__(/*! ./renderers/gl/texture/utils/pixiToGlMaps.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js\");\nvar unpremultiplyAlpha = __webpack_require__(/*! ./renderers/gl/texture/utils/unpremultiplyAlpha.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js\");\nvar WebGLRenderer = __webpack_require__(/*! ./renderers/gl/WebGLRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js\");\nvar BindGroupSystem = __webpack_require__(/*! ./renderers/gpu/BindGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js\");\nvar GpuBufferSystem = __webpack_require__(/*! ./renderers/gpu/buffer/GpuBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js\");\nvar UboBatch = __webpack_require__(/*! ./renderers/gpu/buffer/UboBatch.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js\");\nvar GpuColorMaskSystem = __webpack_require__(/*! ./renderers/gpu/GpuColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js\");\nvar GpuDeviceSystem = __webpack_require__(/*! ./renderers/gpu/GpuDeviceSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js\");\nvar GpuEncoderSystem = __webpack_require__(/*! ./renderers/gpu/GpuEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js\");\nvar GpuLimitsSystem = __webpack_require__(/*! ./renderers/gpu/GpuLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js\");\nvar GpuStencilSystem = __webpack_require__(/*! ./renderers/gpu/GpuStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js\");\nvar GpuUboSystem = __webpack_require__(/*! ./renderers/gpu/GpuUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js\");\nvar GpuUniformBatchPipe = __webpack_require__(/*! ./renderers/gpu/GpuUniformBatchPipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js\");\nvar PipelineSystem = __webpack_require__(/*! ./renderers/gpu/pipeline/PipelineSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js\");\nvar calculateProjection = __webpack_require__(/*! ./renderers/gpu/renderTarget/calculateProjection.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js\");\nvar GpuRenderTarget = __webpack_require__(/*! ./renderers/gpu/renderTarget/GpuRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js\");\nvar GpuRenderTargetAdaptor = __webpack_require__(/*! ./renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js\");\nvar GpuRenderTargetSystem = __webpack_require__(/*! ./renderers/gpu/renderTarget/GpuRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js\");\nvar BindGroup = __webpack_require__(/*! ./renderers/gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\n__webpack_require__(/*! ./renderers/gpu/shader/BindResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindResource.js\");\nvar GpuProgram = __webpack_require__(/*! ./renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar GpuShaderSystem = __webpack_require__(/*! ./renderers/gpu/shader/GpuShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js\");\nvar createUboElementsWGSL = __webpack_require__(/*! ./renderers/gpu/shader/utils/createUboElementsWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js\");\nvar createUboSyncFunctionWGSL = __webpack_require__(/*! ./renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js\");\nvar extractAttributesFromGpuProgram = __webpack_require__(/*! ./renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js\");\nvar extractStructAndGroups = __webpack_require__(/*! ./renderers/gpu/shader/utils/extractStructAndGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js\");\nvar generateArraySyncWGSL = __webpack_require__(/*! ./renderers/gpu/shader/utils/generateArraySyncWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js\");\nvar generateGpuLayoutGroups = __webpack_require__(/*! ./renderers/gpu/shader/utils/generateGpuLayoutGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js\");\nvar generateLayoutHash = __webpack_require__(/*! ./renderers/gpu/shader/utils/generateLayoutHash.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js\");\nvar removeStructAndGroupDuplicates = __webpack_require__(/*! ./renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js\");\nvar GpuBlendModesToPixi = __webpack_require__(/*! ./renderers/gpu/state/GpuBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js\");\nvar GpuStateSystem = __webpack_require__(/*! ./renderers/gpu/state/GpuStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js\");\nvar GpuStencilModesToPixi = __webpack_require__(/*! ./renderers/gpu/state/GpuStencilModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js\");\nvar GpuTextureSystem = __webpack_require__(/*! ./renderers/gpu/texture/GpuTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js\");\n__webpack_require__(/*! ./renderers/gpu/texture/uploaders/GpuTextureUploader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/GpuTextureUploader.js\");\nvar gpuUploadBufferImageResource = __webpack_require__(/*! ./renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js\");\nvar gpuUploadCompressedTextureResource = __webpack_require__(/*! ./renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js\");\nvar gpuUploadImageSource = __webpack_require__(/*! ./renderers/gpu/texture/uploaders/gpuUploadImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js\");\nvar gpuUploadVideoSource = __webpack_require__(/*! ./renderers/gpu/texture/uploaders/gpuUploadVideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js\");\nvar getSupportedGPUCompressedTextureFormats = __webpack_require__(/*! ./renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js\");\nvar GpuMipmapGenerator = __webpack_require__(/*! ./renderers/gpu/texture/utils/GpuMipmapGenerator.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js\");\nvar WebGPURenderer = __webpack_require__(/*! ./renderers/gpu/WebGPURenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js\");\nvar BackgroundSystem = __webpack_require__(/*! ./renderers/shared/background/BackgroundSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js\");\nvar BlendModePipe = __webpack_require__(/*! ./renderers/shared/blendModes/BlendModePipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js\");\nvar Buffer = __webpack_require__(/*! ./renderers/shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar BufferResource = __webpack_require__(/*! ./renderers/shared/buffer/BufferResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js\");\nvar _const$3 = __webpack_require__(/*! ./renderers/shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar fastCopy = __webpack_require__(/*! ./renderers/shared/buffer/utils/fastCopy.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js\");\nvar ExtractSystem = __webpack_require__(/*! ./renderers/shared/extract/ExtractSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js\");\nvar GenerateTextureSystem = __webpack_require__(/*! ./renderers/shared/extract/GenerateTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js\");\nvar _const$4 = __webpack_require__(/*! ./renderers/shared/geometry/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.js\");\nvar Geometry = __webpack_require__(/*! ./renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar buildUvs = __webpack_require__(/*! ./renderers/shared/geometry/utils/buildUvs.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js\");\nvar ensureIsBuffer = __webpack_require__(/*! ./renderers/shared/geometry/utils/ensureIsBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js\");\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ./renderers/shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\nvar getGeometryBounds = __webpack_require__(/*! ./renderers/shared/geometry/utils/getGeometryBounds.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js\");\nvar transformVertices = __webpack_require__(/*! ./renderers/shared/geometry/utils/transformVertices.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js\");\n__webpack_require__(/*! ./renderers/shared/instructions/Instruction.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/Instruction.js\");\nvar InstructionSet = __webpack_require__(/*! ./renderers/shared/instructions/InstructionSet.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js\");\n__webpack_require__(/*! ./renderers/shared/instructions/RenderPipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/RenderPipe.js\");\n__webpack_require__(/*! ./renderers/shared/Renderable.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/Renderable.js\");\nvar GlobalUniformSystem = __webpack_require__(/*! ./renderers/shared/renderTarget/GlobalUniformSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js\");\nvar isRenderingToScreen = __webpack_require__(/*! ./renderers/shared/renderTarget/isRenderingToScreen.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js\");\nvar RenderTarget = __webpack_require__(/*! ./renderers/shared/renderTarget/RenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js\");\nvar RenderTargetSystem = __webpack_require__(/*! ./renderers/shared/renderTarget/RenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js\");\nvar SchedulerSystem = __webpack_require__(/*! ./renderers/shared/SchedulerSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js\");\nvar _const$5 = __webpack_require__(/*! ./renderers/shared/shader/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js\");\nvar Shader = __webpack_require__(/*! ./renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\n__webpack_require__(/*! ./renderers/shared/shader/ShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/ShaderSystem.js\");\nvar types = __webpack_require__(/*! ./renderers/shared/shader/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js\");\nvar UboSystem = __webpack_require__(/*! ./renderers/shared/shader/UboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js\");\nvar UniformGroup = __webpack_require__(/*! ./renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar createUboSyncFunction = __webpack_require__(/*! ./renderers/shared/shader/utils/createUboSyncFunction.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js\");\nvar getDefaultUniformValue = __webpack_require__(/*! ./renderers/shared/shader/utils/getDefaultUniformValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js\");\nvar uboSyncFunctions = __webpack_require__(/*! ./renderers/shared/shader/utils/uboSyncFunctions.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js\");\nvar uniformParsers = __webpack_require__(/*! ./renderers/shared/shader/utils/uniformParsers.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js\");\nvar HelloSystem = __webpack_require__(/*! ./renderers/shared/startup/HelloSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js\");\nvar _const$6 = __webpack_require__(/*! ./renderers/shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ./renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar State = __webpack_require__(/*! ./renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar AbstractRenderer = __webpack_require__(/*! ./renderers/shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\nvar SharedSystems = __webpack_require__(/*! ./renderers/shared/system/SharedSystems.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js\");\n__webpack_require__(/*! ./renderers/shared/system/System.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/System.js\");\nvar SystemRunner = __webpack_require__(/*! ./renderers/shared/system/SystemRunner.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js\");\n__webpack_require__(/*! ./renderers/shared/system/utils/typeUtils.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/utils/typeUtils.js\");\nvar CanvasPool = __webpack_require__(/*! ./renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar _const$7 = __webpack_require__(/*! ./renderers/shared/texture/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.js\");\n__webpack_require__(/*! ./renderers/shared/texture/GenerateCanvas.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/GenerateCanvas.js\");\nvar RenderableGCSystem = __webpack_require__(/*! ./renderers/shared/texture/RenderableGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js\");\nvar RenderTexture = __webpack_require__(/*! ./renderers/shared/texture/RenderTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js\");\nvar BufferImageSource = __webpack_require__(/*! ./renderers/shared/texture/sources/BufferImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js\");\nvar CanvasSource = __webpack_require__(/*! ./renderers/shared/texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar CompressedSource = __webpack_require__(/*! ./renderers/shared/texture/sources/CompressedSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js\");\nvar ImageSource = __webpack_require__(/*! ./renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar TextureSource = __webpack_require__(/*! ./renderers/shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar VideoSource = __webpack_require__(/*! ./renderers/shared/texture/sources/VideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js\");\nvar Texture = __webpack_require__(/*! ./renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TextureGCSystem = __webpack_require__(/*! ./renderers/shared/texture/TextureGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js\");\nvar TextureMatrix = __webpack_require__(/*! ./renderers/shared/texture/TextureMatrix.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js\");\nvar TexturePool = __webpack_require__(/*! ./renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar TextureStyle = __webpack_require__(/*! ./renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar TextureUvs = __webpack_require__(/*! ./renderers/shared/texture/TextureUvs.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.js\");\nvar getCanvasTexture = __webpack_require__(/*! ./renderers/shared/texture/utils/getCanvasTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js\");\nvar getSupportedCompressedTextureFormats = __webpack_require__(/*! ./renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js\");\nvar getSupportedTextureFormats = __webpack_require__(/*! ./renderers/shared/texture/utils/getSupportedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js\");\nvar textureFrom = __webpack_require__(/*! ./renderers/shared/texture/utils/textureFrom.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js\");\nvar createIdFromString = __webpack_require__(/*! ./renderers/shared/utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar parseFunctionBody = __webpack_require__(/*! ./renderers/shared/utils/parseFunctionBody.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.js\");\n__webpack_require__(/*! ./renderers/shared/view/View.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/view/View.js\");\nvar ViewSystem = __webpack_require__(/*! ./renderers/shared/view/ViewSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js\");\nvar types$1 = __webpack_require__(/*! ./renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\n\n\"use strict\";\n\nexports.GlBatchAdaptor = GlBatchAdaptor.GlBatchAdaptor;\nexports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;\nexports.getMaxTexturesPerBatch = maxRecommendedTextures.getMaxTexturesPerBatch;\nexports.generateGPULayout = generateGPULayout.generateGPULayout;\nexports.generateLayout = generateLayout.generateLayout;\nexports.getTextureBatchBindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup;\nexports.GpuBatchAdaptor = GpuBatchAdaptor.GpuBatchAdaptor;\nexports.Batch = Batcher.Batch;\nexports.Batcher = Batcher.Batcher;\nexports.BatcherPipe = BatcherPipe.BatcherPipe;\nexports.BatchGeometry = BatchGeometry.BatchGeometry;\nexports.BatchTextureArray = BatchTextureArray.BatchTextureArray;\nexports.DefaultBatcher = DefaultBatcher.DefaultBatcher;\nexports.DefaultShader = DefaultShader.DefaultShader;\nexports.compileHighShaderGlProgram = compileHighShaderToProgram.compileHighShaderGlProgram;\nexports.compileHighShaderGpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram;\nexports.compileHighShader = compileHighShader.compileHighShader;\nexports.compileHighShaderGl = compileHighShader.compileHighShaderGl;\nexports.addBits = addBits.addBits;\nexports.compileHooks = compileHooks.compileHooks;\nexports.compileInputs = compileInputs.compileInputs;\nexports.compileOutputs = compileOutputs.compileOutputs;\nexports.formatShader = formatShader.formatShader;\nexports.injectBits = injectBits.injectBits;\nexports.fragmentGPUTemplate = defaultProgramTemplate.fragmentGPUTemplate;\nexports.fragmentGlTemplate = defaultProgramTemplate.fragmentGlTemplate;\nexports.vertexGPUTemplate = defaultProgramTemplate.vertexGPUTemplate;\nexports.vertexGlTemplate = defaultProgramTemplate.vertexGlTemplate;\nexports.colorBit = colorBit.colorBit;\nexports.colorBitGl = colorBit.colorBitGl;\nexports.generateTextureBatchBit = generateTextureBatchBit.generateTextureBatchBit;\nexports.generateTextureBatchBitGl = generateTextureBatchBit.generateTextureBatchBitGl;\nexports.globalUniformsBit = globalUniformsBit.globalUniformsBit;\nexports.globalUniformsBitGl = globalUniformsBit.globalUniformsBitGl;\nexports.globalUniformsUBOBitGl = globalUniformsBit.globalUniformsUBOBitGl;\nexports.localUniformBit = localUniformBit.localUniformBit;\nexports.localUniformBitGl = localUniformBit.localUniformBitGl;\nexports.localUniformBitGroup2 = localUniformBit.localUniformBitGroup2;\nexports.roundPixelsBit = roundPixelsBit.roundPixelsBit;\nexports.roundPixelsBitGl = roundPixelsBit.roundPixelsBitGl;\nexports.textureBit = textureBit.textureBit;\nexports.textureBitGl = textureBit.textureBitGl;\nexports.AlphaMask = AlphaMask.AlphaMask;\nexports.AlphaMaskPipe = AlphaMaskPipe.AlphaMaskPipe;\nexports.ColorMask = ColorMask.ColorMask;\nexports.ColorMaskPipe = ColorMaskPipe.ColorMaskPipe;\nexports.MaskEffectManager = MaskEffectManager.MaskEffectManager;\nexports.MaskEffectManagerClass = MaskEffectManager.MaskEffectManagerClass;\nexports.ScissorMask = ScissorMask.ScissorMask;\nexports.StencilMask = StencilMask.StencilMask;\nexports.StencilMaskPipe = StencilMaskPipe.StencilMaskPipe;\nexports.addMaskBounds = addMaskBounds.addMaskBounds;\nexports.addMaskLocalBounds = addMaskLocalBounds.addMaskLocalBounds;\nexports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;\nexports.BUFFER_TYPE = _const.BUFFER_TYPE;\nexports.GlBuffer = GlBuffer.GlBuffer;\nexports.GlBufferSystem = GlBufferSystem.GlBufferSystem;\nexports.CLEAR = _const$1.CLEAR;\nexports.GlContextSystem = GlContextSystem.GlContextSystem;\nexports.GlGeometrySystem = GlGeometrySystem.GlGeometrySystem;\nexports.getGlTypeFromFormat = getGlTypeFromFormat.getGlTypeFromFormat;\nexports.GlBackBufferSystem = GlBackBufferSystem.GlBackBufferSystem;\nexports.GlColorMaskSystem = GlColorMaskSystem.GlColorMaskSystem;\nexports.GlEncoderSystem = GlEncoderSystem.GlEncoderSystem;\nexports.GlLimitsSystem = GlLimitsSystem.GlLimitsSystem;\nexports.GlRenderTarget = GlRenderTarget.GlRenderTarget;\nexports.GlStencilSystem = GlStencilSystem.GlStencilSystem;\nexports.GlUboSystem = GlUboSystem.GlUboSystem;\nexports.GlRenderTargetAdaptor = GlRenderTargetAdaptor.GlRenderTargetAdaptor;\nexports.GlRenderTargetSystem = GlRenderTargetSystem.GlRenderTargetSystem;\nexports.generateShaderSyncCode = GenerateShaderSyncCode.generateShaderSyncCode;\nexports.getBatchSamplersUniformGroup = getBatchSamplersUniformGroup.getBatchSamplersUniformGroup;\nexports.GlProgram = GlProgram.GlProgram;\nexports.GlProgramData = GlProgramData.GlProgramData;\nexports.IGLUniformData = GlProgramData.IGLUniformData;\nexports.GlShaderSystem = GlShaderSystem.GlShaderSystem;\nexports.GlUniformGroupSystem = GlUniformGroupSystem.GlUniformGroupSystem;\nexports.migrateFragmentFromV7toV8 = migrateFragmentFromV7toV8.migrateFragmentFromV7toV8;\nexports.compileShader = compileShader.compileShader;\nexports.defaultValue = defaultValue.defaultValue;\nexports.ensureAttributes = ensureAttributes.ensureAttributes;\nexports.extractAttributesFromGlProgram = extractAttributesFromGlProgram.extractAttributesFromGlProgram;\nexports.generateProgram = generateProgram.generateProgram;\nexports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;\nexports.getTestContext = getTestContext.getTestContext;\nexports.getUboData = getUboData.getUboData;\nexports.getUniformData = getUniformData.getUniformData;\nexports.logProgramError = logProgramError.logProgramError;\nexports.mapSize = mapSize.mapSize;\nexports.mapGlToVertexFormat = mapType.mapGlToVertexFormat;\nexports.mapType = mapType.mapType;\nexports.addProgramDefines = addProgramDefines.addProgramDefines;\nexports.ensurePrecision = ensurePrecision.ensurePrecision;\nexports.insertVersion = insertVersion.insertVersion;\nexports.setProgramName = setProgramName.setProgramName;\nexports.stripVersion = stripVersion.stripVersion;\nexports.WGSL_TO_STD40_SIZE = createUboElementsSTD40.WGSL_TO_STD40_SIZE;\nexports.createUboElementsSTD40 = createUboElementsSTD40.createUboElementsSTD40;\nexports.createUboSyncFunctionSTD40 = createUboSyncSTD40.createUboSyncFunctionSTD40;\nexports.generateArraySyncSTD40 = generateArraySyncSTD40.generateArraySyncSTD40;\nexports.generateUniformsSync = generateUniformsSync.generateUniformsSync;\nexports.UNIFORM_TO_ARRAY_SETTERS = generateUniformsSyncTypes.UNIFORM_TO_ARRAY_SETTERS;\nexports.UNIFORM_TO_SINGLE_SETTERS = generateUniformsSyncTypes.UNIFORM_TO_SINGLE_SETTERS;\nexports.GlStateSystem = GlStateSystem.GlStateSystem;\nexports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi;\nexports.GL_FORMATS = _const$2.GL_FORMATS;\nexports.GL_TARGETS = _const$2.GL_TARGETS;\nexports.GL_TYPES = _const$2.GL_TYPES;\nexports.GL_WRAP_MODES = _const$2.GL_WRAP_MODES;\nexports.GlTexture = GlTexture.GlTexture;\nexports.GlTextureSystem = GlTextureSystem.GlTextureSystem;\nexports.glUploadBufferImageResource = glUploadBufferImageResource.glUploadBufferImageResource;\nexports.glUploadCompressedTextureResource = glUploadCompressedTextureResource.glUploadCompressedTextureResource;\nexports.glUploadImageResource = glUploadImageResource.glUploadImageResource;\nexports.glUploadVideoResource = glUploadVideoResource.glUploadVideoResource;\nexports.applyStyleParams = applyStyleParams.applyStyleParams;\nexports.getSupportedGlCompressedTextureFormats = getSupportedGlCompressedTextureFormats.getSupportedGlCompressedTextureFormats;\nexports.mapFormatToGlFormat = mapFormatToGlFormat.mapFormatToGlFormat;\nexports.mapFormatToGlInternalFormat = mapFormatToGlInternalFormat.mapFormatToGlInternalFormat;\nexports.mapFormatToGlType = mapFormatToGlType.mapFormatToGlType;\nexports.compareModeToGlCompare = pixiToGlMaps.compareModeToGlCompare;\nexports.mipmapScaleModeToGlFilter = pixiToGlMaps.mipmapScaleModeToGlFilter;\nexports.scaleModeToGlFilter = pixiToGlMaps.scaleModeToGlFilter;\nexports.wrapModeToGlAddress = pixiToGlMaps.wrapModeToGlAddress;\nexports.unpremultiplyAlpha = unpremultiplyAlpha.unpremultiplyAlpha;\nexports.WebGLRenderer = WebGLRenderer.WebGLRenderer;\nexports.BindGroupSystem = BindGroupSystem.BindGroupSystem;\nexports.GpuBufferSystem = GpuBufferSystem.GpuBufferSystem;\nexports.UboBatch = UboBatch.UboBatch;\nexports.GpuColorMaskSystem = GpuColorMaskSystem.GpuColorMaskSystem;\nexports.GpuDeviceSystem = GpuDeviceSystem.GpuDeviceSystem;\nexports.GpuEncoderSystem = GpuEncoderSystem.GpuEncoderSystem;\nexports.GpuLimitsSystem = GpuLimitsSystem.GpuLimitsSystem;\nexports.GpuStencilSystem = GpuStencilSystem.GpuStencilSystem;\nexports.GpuUboSystem = GpuUboSystem.GpuUboSystem;\nexports.GpuUniformBatchPipe = GpuUniformBatchPipe.GpuUniformBatchPipe;\nexports.PipelineSystem = PipelineSystem.PipelineSystem;\nexports.calculateProjection = calculateProjection.calculateProjection;\nexports.GpuRenderTarget = GpuRenderTarget.GpuRenderTarget;\nexports.GpuRenderTargetAdaptor = GpuRenderTargetAdaptor.GpuRenderTargetAdaptor;\nexports.GpuRenderTargetSystem = GpuRenderTargetSystem.GpuRenderTargetSystem;\nexports.BindGroup = BindGroup.BindGroup;\nexports.GpuProgram = GpuProgram.GpuProgram;\nexports.GpuShaderSystem = GpuShaderSystem.GpuShaderSystem;\nexports.WGSL_ALIGN_SIZE_DATA = createUboElementsWGSL.WGSL_ALIGN_SIZE_DATA;\nexports.createUboElementsWGSL = createUboElementsWGSL.createUboElementsWGSL;\nexports.createUboSyncFunctionWGSL = createUboSyncFunctionWGSL.createUboSyncFunctionWGSL;\nexports.extractAttributesFromGpuProgram = extractAttributesFromGpuProgram.extractAttributesFromGpuProgram;\nexports.extractStructAndGroups = extractStructAndGroups.extractStructAndGroups;\nexports.generateArraySyncWGSL = generateArraySyncWGSL.generateArraySyncWGSL;\nexports.generateGpuLayoutGroups = generateGpuLayoutGroups.generateGpuLayoutGroups;\nexports.generateLayoutHash = generateLayoutHash.generateLayoutHash;\nexports.removeStructAndGroupDuplicates = removeStructAndGroupDuplicates.removeStructAndGroupDuplicates;\nexports.GpuBlendModesToPixi = GpuBlendModesToPixi.GpuBlendModesToPixi;\nexports.GpuStateSystem = GpuStateSystem.GpuStateSystem;\nexports.GpuStencilModesToPixi = GpuStencilModesToPixi.GpuStencilModesToPixi;\nexports.GpuTextureSystem = GpuTextureSystem.GpuTextureSystem;\nexports.gpuUploadBufferImageResource = gpuUploadBufferImageResource.gpuUploadBufferImageResource;\nexports.blockDataMap = gpuUploadCompressedTextureResource.blockDataMap;\nexports.gpuUploadCompressedTextureResource = gpuUploadCompressedTextureResource.gpuUploadCompressedTextureResource;\nexports.gpuUploadImageResource = gpuUploadImageSource.gpuUploadImageResource;\nexports.gpuUploadVideoResource = gpuUploadVideoSource.gpuUploadVideoResource;\nexports.getSupportedGPUCompressedTextureFormats = getSupportedGPUCompressedTextureFormats.getSupportedGPUCompressedTextureFormats;\nexports.GpuMipmapGenerator = GpuMipmapGenerator.GpuMipmapGenerator;\nexports.WebGPURenderer = WebGPURenderer.WebGPURenderer;\nexports.BackgroundSystem = BackgroundSystem.BackgroundSystem;\nexports.BlendModePipe = BlendModePipe.BlendModePipe;\nexports.Buffer = Buffer.Buffer;\nexports.BufferResource = BufferResource.BufferResource;\nexports.BufferUsage = _const$3.BufferUsage;\nexports.fastCopy = fastCopy.fastCopy;\nexports.ExtractSystem = ExtractSystem.ExtractSystem;\nexports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;\nexports.DRAW_MODES = _const$4.DRAW_MODES;\nexports.Geometry = Geometry.Geometry;\nexports.buildSimpleUvs = buildUvs.buildSimpleUvs;\nexports.buildUvs = buildUvs.buildUvs;\nexports.ensureIsBuffer = ensureIsBuffer.ensureIsBuffer;\nexports.getAttributeInfoFromFormat = getAttributeInfoFromFormat.getAttributeInfoFromFormat;\nexports.getGeometryBounds = getGeometryBounds.getGeometryBounds;\nexports.transformVertices = transformVertices.transformVertices;\nexports.InstructionSet = InstructionSet.InstructionSet;\nexports.GlobalUniformSystem = GlobalUniformSystem.GlobalUniformSystem;\nexports.isRenderingToScreen = isRenderingToScreen.isRenderingToScreen;\nexports.RenderTarget = RenderTarget.RenderTarget;\nexports.RenderTargetSystem = RenderTargetSystem.RenderTargetSystem;\nexports.SchedulerSystem = SchedulerSystem.SchedulerSystem;\nexports.ShaderStage = _const$5.ShaderStage;\nexports.Shader = Shader.Shader;\nexports.UNIFORM_TYPES_MAP = types.UNIFORM_TYPES_MAP;\nexports.UNIFORM_TYPES_VALUES = types.UNIFORM_TYPES_VALUES;\nexports.UboSystem = UboSystem.UboSystem;\nexports.UniformGroup = UniformGroup.UniformGroup;\nexports.createUboSyncFunction = createUboSyncFunction.createUboSyncFunction;\nexports.getDefaultUniformValue = getDefaultUniformValue.getDefaultUniformValue;\nexports.uboSyncFunctionsSTD40 = uboSyncFunctions.uboSyncFunctionsSTD40;\nexports.uboSyncFunctionsWGSL = uboSyncFunctions.uboSyncFunctionsWGSL;\nexports.uniformParsers = uniformParsers.uniformParsers;\nexports.HelloSystem = HelloSystem.HelloSystem;\nexports.BLEND_TO_NPM = _const$6.BLEND_TO_NPM;\nexports.STENCIL_MODES = _const$6.STENCIL_MODES;\nexports.getAdjustedBlendModeBlend = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend;\nexports.State = State.State;\nexports.AbstractRenderer = AbstractRenderer.AbstractRenderer;\nexports.SharedRenderPipes = SharedSystems.SharedRenderPipes;\nexports.SharedSystems = SharedSystems.SharedSystems;\nexports.SystemRunner = SystemRunner.SystemRunner;\nexports.CanvasPool = CanvasPool.CanvasPool;\nexports.CanvasPoolClass = CanvasPool.CanvasPoolClass;\nexports.DEPRECATED_SCALE_MODES = _const$7.DEPRECATED_SCALE_MODES;\nexports.DEPRECATED_WRAP_MODES = _const$7.DEPRECATED_WRAP_MODES;\nexports.SCALE_MODES = _const$7.SCALE_MODES;\nexports.WRAP_MODES = _const$7.WRAP_MODES;\nexports.RenderableGCSystem = RenderableGCSystem.RenderableGCSystem;\nexports.RenderTexture = RenderTexture.RenderTexture;\nexports.BufferImageSource = BufferImageSource.BufferImageSource;\nexports.CanvasSource = CanvasSource.CanvasSource;\nexports.CompressedSource = CompressedSource.CompressedSource;\nexports.ImageSource = ImageSource.ImageSource;\nexports.TextureSource = TextureSource.TextureSource;\nexports.VideoSource = VideoSource.VideoSource;\nexports.Texture = Texture.Texture;\nexports.TextureGCSystem = TextureGCSystem.TextureGCSystem;\nexports.TextureMatrix = TextureMatrix.TextureMatrix;\nexports.TexturePool = TexturePool.TexturePool;\nexports.TexturePoolClass = TexturePool.TexturePoolClass;\nexports.TextureStyle = TextureStyle.TextureStyle;\nexports.TextureUvs = TextureUvs.TextureUvs;\nexports.getCanvasTexture = getCanvasTexture.getCanvasTexture;\nexports.hasCachedCanvasTexture = getCanvasTexture.hasCachedCanvasTexture;\nexports.getSupportedCompressedTextureFormats = getSupportedCompressedTextureFormats.getSupportedCompressedTextureFormats;\nexports.getSupportedTextureFormats = getSupportedTextureFormats.getSupportedTextureFormats;\nexports.nonCompressedFormats = getSupportedTextureFormats.nonCompressedFormats;\nexports.autoDetectSource = textureFrom.autoDetectSource;\nexports.resourceToTexture = textureFrom.resourceToTexture;\nexports.textureFrom = textureFrom.textureFrom;\nexports.createIdFromString = createIdFromString.createIdFromString;\nexports.parseFunctionBody = parseFunctionBody.parseFunctionBody;\nexports.ViewSystem = ViewSystem.ViewSystem;\nexports.RendererType = types$1.RendererType;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/init.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/init.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar AlphaMask = __webpack_require__(/*! ./mask/alpha/AlphaMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js\");\nvar ColorMask = __webpack_require__(/*! ./mask/color/ColorMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js\");\nvar StencilMask = __webpack_require__(/*! ./mask/stencil/StencilMask.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js\");\nvar BufferImageSource = __webpack_require__(/*! ./renderers/shared/texture/sources/BufferImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js\");\nvar CanvasSource = __webpack_require__(/*! ./renderers/shared/texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar ImageSource = __webpack_require__(/*! ./renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar VideoSource = __webpack_require__(/*! ./renderers/shared/texture/sources/VideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js\");\n__webpack_require__(/*! ./renderers/shared/texture/utils/textureFrom.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js\");\n__webpack_require__(/*! ./mask/MaskEffectManager.js */ \"./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js\");\n\n\"use strict\";\nExtensions.extensions.add(AlphaMask.AlphaMask, ColorMask.ColorMask, StencilMask.StencilMask, VideoSource.VideoSource, ImageSource.ImageSource, CanvasSource.CanvasSource, BufferImageSource.BufferImageSource);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar PoolGroup = __webpack_require__(/*! ../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /** @private */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return PoolGroup.BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    PoolGroup.BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nExtensions.extensions.handleByList(Extensions.ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexports.MaskEffectManager = MaskEffectManager;\nexports.MaskEffectManagerClass = MaskEffectManagerClass;\n//# sourceMappingURL=MaskEffectManager.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Sprite = __webpack_require__(/*! ../../../scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar addMaskBounds = __webpack_require__(/*! ../utils/addMaskBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js\");\nvar addMaskLocalBounds = __webpack_require__(/*! ../utils/addMaskLocalBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js\");\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.inverse = false;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite.Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    if (!this.inverse) {\n      addMaskBounds.addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds.addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite.Sprite;\n  }\n}\nAlphaMask.extension = Extensions.ExtensionType.MaskEffect;\n\nexports.AlphaMask = AlphaMask;\n//# sourceMappingURL=AlphaMask.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar FilterEffect = __webpack_require__(/*! ../../../filters/FilterEffect.js */ \"./node_modules/pixi.js/lib/filters/FilterEffect.js\");\nvar MaskFilter = __webpack_require__(/*! ../../../filters/mask/MaskFilter.js */ \"./node_modules/pixi.js/lib/filters/mask/MaskFilter.js\");\nvar Bounds = __webpack_require__(/*! ../../../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ../../../scene/container/bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\nvar Sprite = __webpack_require__(/*! ../../../scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar PoolGroup = __webpack_require__(/*! ../../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar Texture = __webpack_require__(/*! ../../renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TexturePool = __webpack_require__(/*! ../../renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar types = __webpack_require__(/*! ../../renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\n\n\"use strict\";\nconst tempBounds = new Bounds.Bounds();\nclass AlphaMaskEffect extends FilterEffect.FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter.MaskFilter({\n      sprite: new Sprite.Sprite(Texture.Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = PoolGroup.BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds.getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === types.RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.TexturePool.returnTexture(maskData.filterTexture);\n      }\n      PoolGroup.BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexports.AlphaMaskPipe = AlphaMaskPipe;\n//# sourceMappingURL=AlphaMaskPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = Extensions.ExtensionType.MaskEffect;\n\nexports.ColorMask = ColorMask;\n//# sourceMappingURL=ColorMask.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexports.ColorMaskPipe = ColorMaskPipe;\n//# sourceMappingURL=ColorMaskPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar addMaskBounds = __webpack_require__(/*! ../utils/addMaskBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js\");\nvar addMaskLocalBounds = __webpack_require__(/*! ../utils/addMaskLocalBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js\");\n\n\"use strict\";\nclass ScissorMask {\n  constructor(mask) {\n    this.priority = 0;\n    this.pipe = \"scissorMask\";\n    this.mask = mask;\n    this.mask.renderable = false;\n    this.mask.measurable = false;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds.addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds.addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  destroy() {\n    this.reset();\n  }\n}\n\nexports.ScissorMask = ScissorMask;\n//# sourceMappingURL=ScissorMask.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Container = __webpack_require__(/*! ../../../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar addMaskBounds = __webpack_require__(/*! ../utils/addMaskBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js\");\nvar addMaskLocalBounds = __webpack_require__(/*! ../utils/addMaskLocalBounds.js */ \"./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js\");\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds.addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds.addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container.Container;\n  }\n}\nStencilMask.extension = Extensions.ExtensionType.MaskEffect;\n\nexports.StencilMask = StencilMask;\n//# sourceMappingURL=StencilMask.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar _const$1 = __webpack_require__(/*! ../../renderers/gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar _const = __webpack_require__(/*! ../../renderers/shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(_const.STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, _const$1.CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(_const.STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexports.StencilMaskPipe = StencilMaskPipe;\n//# sourceMappingURL=StencilMaskPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Bounds = __webpack_require__(/*! ../../../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ../../../scene/container/bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\n\n\"use strict\";\nconst tempBounds = new Bounds.Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds.getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexports.addMaskBounds = addMaskBounds;\n//# sourceMappingURL=addMaskBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getLocalBounds = __webpack_require__(/*! ../../../scene/container/bounds/getLocalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ../../../scene/container/bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\nvar warn = __webpack_require__(/*! ../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = matrixAndBoundsPool.boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixAndBoundsPool.matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds.getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixAndBoundsPool.matrixPool.return(tempMatrix);\n  matrixAndBoundsPool.boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn.warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexports.addMaskLocalBounds = addMaskLocalBounds;\n//# sourceMappingURL=addMaskLocalBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isWebGLSupported = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\nvar AbstractRenderer = __webpack_require__(/*! ./shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\n\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && await isWebGPUSupported.isWebGPUSupported()) {\n      const { WebGPURenderer } = await Promise.resolve().then(function () { return __webpack_require__(/*! ./gpu/WebGPURenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js\"); });\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported.isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await Promise.resolve().then(function () { return __webpack_require__(/*! ./gl/WebGLRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js\"); });\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = { ...options };\n      throw new Error(\"CanvasRenderer is not yet implemented\");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error(\"No available renderer for the current environment\");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\nexports.autoDetectRenderer = autoDetectRenderer;\n//# sourceMappingURL=autoDetectRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar warn = __webpack_require__(/*! ../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar Geometry = __webpack_require__(/*! ../shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar Shader = __webpack_require__(/*! ../shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar State = __webpack_require__(/*! ../shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar TextureSource = __webpack_require__(/*! ../shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar GlProgram = __webpack_require__(/*! ./shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\n\n\"use strict\";\nconst bigTriangleGeometry = new Geometry.Geometry({\n  attributes: {\n    aPosition: [\n      -1,\n      -1,\n      // Bottom left corner\n      3,\n      -1,\n      // Bottom right corner, extending beyond right edge\n      -1,\n      3\n      // Top left corner, extending beyond top edge\n    ]\n  }\n});\nconst _GlBackBufferSystem = class _GlBackBufferSystem {\n  constructor(renderer) {\n    /** if true, the back buffer is used */\n    this.useBackBuffer = false;\n    this._useBackBufferThisRender = false;\n    this._renderer = renderer;\n  }\n  init(options = {}) {\n    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };\n    this.useBackBuffer = useBackBuffer;\n    this._antialias = antialias;\n    if (!this._renderer.context.supports.msaa) {\n      warn.warn(\"antialiasing, is not supported on when using the back buffer\");\n      this._antialias = false;\n    }\n    this._state = State.State.for2d();\n    const bigTriangleProgram = new GlProgram.GlProgram({\n      vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n      fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n      name: \"big-triangle\"\n    });\n    this._bigTriangleShader = new Shader.Shader({\n      glProgram: bigTriangleProgram,\n      resources: {\n        uTexture: Texture.Texture.WHITE.source\n      }\n    });\n  }\n  /**\n   * This is called before the RenderTargetSystem is started. This is where\n   * we replace the target with the back buffer if required.\n   * @param options - The options for this render.\n   */\n  renderStart(options) {\n    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n    if (this._useBackBufferThisRender) {\n      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);\n      this._targetTexture = renderTarget2.colorTexture;\n      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);\n    }\n  }\n  renderEnd() {\n    this._presentBackBuffer();\n  }\n  _presentBackBuffer() {\n    const renderer = this._renderer;\n    renderer.renderTarget.finishRenderPass();\n    if (!this._useBackBufferThisRender)\n      return;\n    renderer.renderTarget.bind(this._targetTexture, false);\n    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n    renderer.encoder.draw({\n      geometry: bigTriangleGeometry,\n      shader: this._bigTriangleShader,\n      state: this._state\n    });\n  }\n  _getBackBufferTexture(targetSourceTexture) {\n    this._backBufferTexture = this._backBufferTexture || new Texture.Texture({\n      source: new TextureSource.TextureSource({\n        width: targetSourceTexture.width,\n        height: targetSourceTexture.height,\n        resolution: targetSourceTexture._resolution,\n        antialias: this._antialias\n      })\n    });\n    this._backBufferTexture.source.resize(\n      targetSourceTexture.width,\n      targetSourceTexture.height,\n      targetSourceTexture._resolution\n    );\n    return this._backBufferTexture;\n  }\n  /** destroys the back buffer */\n  destroy() {\n    if (this._backBufferTexture) {\n      this._backBufferTexture.destroy();\n      this._backBufferTexture = null;\n    }\n  }\n};\n/** @ignore */\n_GlBackBufferSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"backBuffer\",\n  priority: 1\n};\n/** default options for the back buffer system */\n_GlBackBufferSystem.defaultOptions = {\n  /** if true will use the back buffer where required */\n  useBackBuffer: false\n};\nlet GlBackBufferSystem = _GlBackBufferSystem;\n\nexports.GlBackBufferSystem = GlBackBufferSystem;\n//# sourceMappingURL=GlBackBufferSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GlColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.gl.colorMask(\n      !!(colorMask & 8),\n      !!(colorMask & 4),\n      !!(colorMask & 2),\n      !!(colorMask & 1)\n    );\n  }\n}\n/** @ignore */\nGlColorMaskSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"colorMask\"\n};\n\nexports.GlColorMaskSystem = GlColorMaskSystem;\n//# sourceMappingURL=GlColorMaskSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GlEncoderSystem {\n  constructor(renderer) {\n    this.commandFinished = Promise.resolve();\n    this._renderer = renderer;\n  }\n  setGeometry(geometry, shader) {\n    this._renderer.geometry.bind(geometry, shader.glProgram);\n  }\n  finishRenderPass() {\n  }\n  draw(options) {\n    const renderer = this._renderer;\n    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n    renderer.shader.bind(shader, skipSync);\n    renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n    if (state) {\n      renderer.state.set(state);\n    }\n    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlEncoderSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"encoder\"\n};\n\nexports.GlEncoderSystem = GlEncoderSystem;\n//# sourceMappingURL=GlEncoderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar checkMaxIfStatementsInShader = __webpack_require__(/*! ../../batcher/gl/utils/checkMaxIfStatementsInShader.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.js\");\n\n\"use strict\";\nclass GlLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    const gl = this._renderer.gl;\n    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.maxBatchableTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(this.maxTextures, gl);\n    this.maxUniformBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGlLimitsSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"limits\"\n};\n\nexports.GlLimitsSystem = GlLimitsSystem;\n//# sourceMappingURL=GlLimitsSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GlRenderTarget {\n  constructor() {\n    this.width = -1;\n    this.height = -1;\n    this.msaa = false;\n    this.msaaRenderBuffer = [];\n  }\n}\n\nexports.GlRenderTarget = GlRenderTarget;\n//# sourceMappingURL=GlRenderTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GpuStencilModesToPixi = __webpack_require__(/*! ../gpu/state/GpuStencilModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js\");\nvar _const = __webpack_require__(/*! ../shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\n\n\"use strict\";\nclass GlStencilSystem {\n  constructor(renderer) {\n    this._stencilCache = {\n      enabled: false,\n      stencilReference: 0,\n      stencilMode: _const.STENCIL_MODES.NONE\n    };\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._comparisonFuncMapping = {\n      always: gl.ALWAYS,\n      never: gl.NEVER,\n      equal: gl.EQUAL,\n      \"not-equal\": gl.NOTEQUAL,\n      less: gl.LESS,\n      \"less-equal\": gl.LEQUAL,\n      greater: gl.GREATER,\n      \"greater-equal\": gl.GEQUAL\n    };\n    this._stencilOpsMapping = {\n      keep: gl.KEEP,\n      zero: gl.ZERO,\n      replace: gl.REPLACE,\n      invert: gl.INVERT,\n      \"increment-clamp\": gl.INCR,\n      \"decrement-clamp\": gl.DECR,\n      \"increment-wrap\": gl.INCR_WRAP,\n      \"decrement-wrap\": gl.DECR_WRAP\n    };\n    this.resetState();\n  }\n  onRenderTargetChange(renderTarget) {\n    if (this._activeRenderTarget === renderTarget)\n      return;\n    this._activeRenderTarget = renderTarget;\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: _const.STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  resetState() {\n    this._stencilCache.enabled = false;\n    this._stencilCache.stencilMode = _const.STENCIL_MODES.NONE;\n    this._stencilCache.stencilReference = 0;\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    const gl = this._gl;\n    const mode = GpuStencilModesToPixi.GpuStencilModesToPixi[stencilMode];\n    const _stencilCache = this._stencilCache;\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    if (stencilMode === _const.STENCIL_MODES.DISABLED) {\n      if (this._stencilCache.enabled) {\n        this._stencilCache.enabled = false;\n        gl.disable(gl.STENCIL_TEST);\n      }\n      return;\n    }\n    if (!this._stencilCache.enabled) {\n      this._stencilCache.enabled = true;\n      gl.enable(gl.STENCIL_TEST);\n    }\n    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {\n      _stencilCache.stencilMode = stencilMode;\n      _stencilCache.stencilReference = stencilReference;\n      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);\n      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n    }\n  }\n}\n/** @ignore */\nGlStencilSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"stencil\"\n};\n\nexports.GlStencilSystem = GlStencilSystem;\n//# sourceMappingURL=GlStencilSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar UboSystem = __webpack_require__(/*! ../shared/shader/UboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js\");\nvar createUboElementsSTD40 = __webpack_require__(/*! ./shader/utils/createUboElementsSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js\");\nvar createUboSyncSTD40 = __webpack_require__(/*! ./shader/utils/createUboSyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js\");\n\n\"use strict\";\nclass GlUboSystem extends UboSystem.UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsSTD40.createUboElementsSTD40,\n      generateUboSync: createUboSyncSTD40.createUboSyncFunctionSTD40\n    });\n  }\n}\n/** @ignore */\nGlUboSystem.extension = {\n  type: [Extensions.ExtensionType.WebGLSystem],\n  name: \"ubo\"\n};\n\nexports.GlUboSystem = GlUboSystem;\n//# sourceMappingURL=GlUboSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GlGraphicsAdaptor = __webpack_require__(/*! ../../../scene/graphics/gl/GlGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js\");\nvar GlMeshAdaptor = __webpack_require__(/*! ../../../scene/mesh/gl/GlMeshAdaptor.js */ \"./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js\");\nvar GlBatchAdaptor = __webpack_require__(/*! ../../batcher/gl/GlBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.js\");\nvar AbstractRenderer = __webpack_require__(/*! ../shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\nvar SharedSystems = __webpack_require__(/*! ../shared/system/SharedSystems.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js\");\nvar types = __webpack_require__(/*! ../types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar GlBufferSystem = __webpack_require__(/*! ./buffer/GlBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js\");\nvar GlContextSystem = __webpack_require__(/*! ./context/GlContextSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js\");\nvar GlGeometrySystem = __webpack_require__(/*! ./geometry/GlGeometrySystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js\");\nvar GlBackBufferSystem = __webpack_require__(/*! ./GlBackBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.js\");\nvar GlColorMaskSystem = __webpack_require__(/*! ./GlColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.js\");\nvar GlEncoderSystem = __webpack_require__(/*! ./GlEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.js\");\nvar GlLimitsSystem = __webpack_require__(/*! ./GlLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.js\");\nvar GlStencilSystem = __webpack_require__(/*! ./GlStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.js\");\nvar GlUboSystem = __webpack_require__(/*! ./GlUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.js\");\nvar GlRenderTargetSystem = __webpack_require__(/*! ./renderTarget/GlRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js\");\nvar GlShaderSystem = __webpack_require__(/*! ./shader/GlShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js\");\nvar GlUniformGroupSystem = __webpack_require__(/*! ./shader/GlUniformGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js\");\nvar GlStateSystem = __webpack_require__(/*! ./state/GlStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js\");\nvar GlTextureSystem = __webpack_require__(/*! ./texture/GlTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js\");\n\n\"use strict\";\nconst DefaultWebGLSystems = [\n  ...SharedSystems.SharedSystems,\n  GlUboSystem.GlUboSystem,\n  GlBackBufferSystem.GlBackBufferSystem,\n  GlContextSystem.GlContextSystem,\n  GlLimitsSystem.GlLimitsSystem,\n  GlBufferSystem.GlBufferSystem,\n  GlTextureSystem.GlTextureSystem,\n  GlRenderTargetSystem.GlRenderTargetSystem,\n  GlGeometrySystem.GlGeometrySystem,\n  GlUniformGroupSystem.GlUniformGroupSystem,\n  GlShaderSystem.GlShaderSystem,\n  GlEncoderSystem.GlEncoderSystem,\n  GlStateSystem.GlStateSystem,\n  GlStencilSystem.GlStencilSystem,\n  GlColorMaskSystem.GlColorMaskSystem\n];\nconst DefaultWebGLPipes = [...SharedSystems.SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor.GlBatchAdaptor, GlMeshAdaptor.GlMeshAdaptor, GlGraphicsAdaptor.GlGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGLSystem, systems);\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGLPipes, renderPipes);\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\nExtensions.extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\nclass WebGLRenderer extends AbstractRenderer.AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgl\",\n      type: types.RendererType.WEBGL,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexports.WebGLRenderer = WebGLRenderer;\n//# sourceMappingURL=WebGLRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GlBuffer {\n  constructor(buffer, type) {\n    this._lastBindBaseLocation = -1;\n    this._lastBindCallId = -1;\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.type = type;\n  }\n}\n\nexports.GlBuffer = GlBuffer;\n//# sourceMappingURL=GlBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar _const = __webpack_require__(/*! ../../shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar _const$1 = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js\");\nvar GlBuffer = __webpack_require__(/*! ./GlBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.js\");\n\n\"use strict\";\nclass GlBufferSystem {\n  /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    /** Cache keeping track of the base bound buffer bases */\n    this._boundBufferBases = /* @__PURE__ */ Object.create(null);\n    this._minBaseLocation = 0;\n    this._nextBindBaseIndex = this._minBaseLocation;\n    this._bindCallId = 0;\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuBuffers\");\n  }\n  /** @ignore */\n  destroy() {\n    this._renderer = null;\n    this._gl = null;\n    this._gpuBuffers = null;\n    this._boundBufferBases = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this._gl = this._renderer.gl;\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._maxBindings = this._renderer.limits.maxUniformBindings;\n  }\n  getGlBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param glBuffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(glBuffer, index) {\n    const { _gl: gl } = this;\n    if (this._boundBufferBases[index] !== glBuffer) {\n      this._boundBufferBases[index] = glBuffer;\n      glBuffer._lastBindBaseLocation = index;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  nextBindBase(hasTransformFeedback) {\n    this._bindCallId++;\n    this._minBaseLocation = 0;\n    if (hasTransformFeedback) {\n      this._boundBufferBases[0] = null;\n      this._minBaseLocation = 1;\n      if (this._nextBindBaseIndex < 1) {\n        this._nextBindBaseIndex = 1;\n      }\n    }\n  }\n  freeLocationForBufferBase(glBuffer) {\n    let freeIndex = this.getLastBindBaseLocation(glBuffer);\n    if (freeIndex >= this._minBaseLocation) {\n      glBuffer._lastBindCallId = this._bindCallId;\n      return freeIndex;\n    }\n    let loop = 0;\n    let nextIndex = this._nextBindBaseIndex;\n    while (loop < 2) {\n      if (nextIndex >= this._maxBindings) {\n        nextIndex = this._minBaseLocation;\n        loop++;\n      }\n      const curBuf = this._boundBufferBases[nextIndex];\n      if (curBuf && curBuf._lastBindCallId === this._bindCallId) {\n        nextIndex++;\n        continue;\n      }\n      break;\n    }\n    freeIndex = nextIndex;\n    this._nextBindBaseIndex = nextIndex + 1;\n    if (loop >= 2) {\n      return -1;\n    }\n    glBuffer._lastBindCallId = this._bindCallId;\n    this._boundBufferBases[freeIndex] = null;\n    return freeIndex;\n  }\n  getLastBindBaseLocation(glBuffer) {\n    const index = glBuffer._lastBindBaseLocation;\n    if (this._boundBufferBases[index] === glBuffer) {\n      return index;\n    }\n    return -1;\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param glBuffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   * @param size - the size to bind at (this is blocks of 256).\n   */\n  bindBufferRange(glBuffer, index, offset, size) {\n    const { _gl: gl } = this;\n    offset || (offset = 0);\n    index || (index = 0);\n    this._boundBufferBases[index] = null;\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */\n  updateBuffer(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return glBuffer;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    const data = buffer.data;\n    const drawType = buffer.descriptor.usage & _const.BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n    if (data) {\n      if (glBuffer.byteLength >= data.byteLength) {\n        gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n      } else {\n        glBuffer.byteLength = data.byteLength;\n        gl.bufferData(glBuffer.type, data, drawType);\n      }\n    } else {\n      glBuffer.byteLength = buffer.descriptor.size;\n      gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n    }\n    return glBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    const gl = this._gl;\n    for (const id in this._gpuBuffers) {\n      gl.deleteBuffer(this._gpuBuffers[id].buffer);\n    }\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onBufferDestroy(buffer, contextLost) {\n    const glBuffer = this._gpuBuffers[buffer.uid];\n    const gl = this._gl;\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    this._gpuBuffers[buffer.uid] = null;\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const { _gl: gl } = this;\n    let type = _const$1.BUFFER_TYPE.ARRAY_BUFFER;\n    if (buffer.descriptor.usage & _const.BufferUsage.INDEX) {\n      type = _const$1.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    } else if (buffer.descriptor.usage & _const.BufferUsage.UNIFORM) {\n      type = _const$1.BUFFER_TYPE.UNIFORM_BUFFER;\n    }\n    const glBuffer = new GlBuffer.GlBuffer(gl.createBuffer(), type);\n    this._gpuBuffers[buffer.uid] = glBuffer;\n    buffer.on(\"destroy\", this.onBufferDestroy, this);\n    return glBuffer;\n  }\n  resetState() {\n    this._boundBufferBases = /* @__PURE__ */ Object.create(null);\n  }\n}\n/** @ignore */\nGlBufferSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"buffer\"\n};\n\nexports.GlBufferSystem = GlBufferSystem;\n//# sourceMappingURL=GlBufferSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n  return BUFFER_TYPE2;\n})(BUFFER_TYPE || {});\n\nexports.BUFFER_TYPE = BUFFER_TYPE;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/const.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n  CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n  CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n  CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n  return CLEAR2;\n})(CLEAR || {});\n\nexports.CLEAR = CLEAR;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nconst _GlContextSystem = class _GlContextSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    this.supports = {\n      /** Support for 32-bit indices buffer. */\n      uint32Indices: true,\n      /** Support for UniformBufferObjects */\n      uniformBufferObject: true,\n      /** Support for VertexArrayObjects */\n      vertexArrayObject: true,\n      /** Support for SRGB texture format */\n      srgbTextures: true,\n      /** Support for wrapping modes if a texture is non-power of two */\n      nonPowOf2wrapping: true,\n      /** Support for MSAA (antialiasing of dynamic textures) */\n      msaa: true,\n      /** Support for mipmaps if a texture is non-power of two */\n      nonPowOf2mipmaps: true\n    };\n    this._renderer = renderer;\n    this.extensions = /* @__PURE__ */ Object.create(null);\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  /**\n   * `true` if the context is lost\n   * @readonly\n   */\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */\n  contextChange(gl) {\n    this.gl = gl;\n    this._renderer.gl = gl;\n  }\n  init(options) {\n    options = { ..._GlContextSystem.defaultOptions, ...options };\n    let multiView = this.multiView = options.multiView;\n    if (options.context && multiView) {\n      warn.warn(\"Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.\");\n      multiView = false;\n    }\n    if (multiView) {\n      this.canvas = adapter.DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n    } else {\n      this.canvas = this._renderer.view.canvas;\n    }\n    if (options.context) {\n      this.initFromContext(options.context);\n    } else {\n      const alpha = this._renderer.background.alpha < 1;\n      const premultipliedAlpha = options.premultipliedAlpha ?? true;\n      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n      this.createContext(options.preferWebGLVersion, {\n        alpha,\n        premultipliedAlpha,\n        antialias,\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference ?? \"default\"\n      });\n    }\n  }\n  ensureCanvasSize(targetCanvas) {\n    if (!this.multiView) {\n      if (targetCanvas !== this.canvas) {\n        warn.warn(\"multiView is disabled, but targetCanvas is not the main canvas\");\n      }\n      return;\n    }\n    const { canvas } = this;\n    if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {\n      canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n      canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n    }\n  }\n  /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */\n  initFromContext(gl) {\n    this.gl = gl;\n    this.webGLVersion = gl instanceof adapter.DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n    this.getExtensions();\n    this.validateContext(gl);\n    this._renderer.runners.contextChange.emit(gl);\n    const element = this._renderer.view.canvas;\n    element.addEventListener(\"webglcontextlost\", this.handleContextLost, false);\n    element.addEventListener(\"webglcontextrestored\", this.handleContextRestored, false);\n  }\n  /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param preferWebGLVersion\n   * @param {object} options - context attributes\n   */\n  createContext(preferWebGLVersion, options) {\n    let gl;\n    const canvas = this.canvas;\n    if (preferWebGLVersion === 2) {\n      gl = canvas.getContext(\"webgl2\", options);\n    }\n    if (!gl) {\n      gl = canvas.getContext(\"webgl\", options);\n      if (!gl) {\n        throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n      }\n    }\n    this.gl = gl;\n    this.initFromContext(this.gl);\n  }\n  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n  getExtensions() {\n    const { gl } = this;\n    const common = {\n      anisotropicFiltering: gl.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n      s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      // eslint-disable-line camelcase\n      etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: gl.getExtension(\"WEBGL_compressed_texture_astc\"),\n      bptc: gl.getExtension(\"EXT_texture_compression_bptc\"),\n      rgtc: gl.getExtension(\"EXT_texture_compression_rgtc\"),\n      loseContext: gl.getExtension(\"WEBGL_lose_context\")\n    };\n    if (this.webGLVersion === 1) {\n      this.extensions = {\n        ...common,\n        drawBuffers: gl.getExtension(\"WEBGL_draw_buffers\"),\n        depthTexture: gl.getExtension(\"WEBGL_depth_texture\"),\n        vertexArrayObject: gl.getExtension(\"OES_vertex_array_object\") || gl.getExtension(\"MOZ_OES_vertex_array_object\") || gl.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n        uint32ElementIndex: gl.getExtension(\"OES_element_index_uint\"),\n        // Floats and half-floats\n        floatTexture: gl.getExtension(\"OES_texture_float\"),\n        floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n        textureHalfFloat: gl.getExtension(\"OES_texture_half_float\"),\n        textureHalfFloatLinear: gl.getExtension(\"OES_texture_half_float_linear\"),\n        vertexAttribDivisorANGLE: gl.getExtension(\"ANGLE_instanced_arrays\"),\n        srgb: gl.getExtension(\"EXT_sRGB\")\n      };\n    } else {\n      this.extensions = {\n        ...common,\n        colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\")\n      };\n      const provokeExt = gl.getExtension(\"WEBGL_provoking_vertex\");\n      if (provokeExt) {\n        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n      }\n    }\n  }\n  /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n  handleContextLost(event) {\n    event.preventDefault();\n    if (this._contextLossForced) {\n      this._contextLossForced = false;\n      setTimeout(() => {\n        if (this.gl.isContextLost()) {\n          this.extensions.loseContext?.restoreContext();\n        }\n      }, 0);\n    }\n  }\n  /** Handles a restored webgl context. */\n  handleContextRestored() {\n    this.getExtensions();\n    this._renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const element = this._renderer.view.canvas;\n    this._renderer = null;\n    element.removeEventListener(\"webglcontextlost\", this.handleContextLost);\n    element.removeEventListener(\"webglcontextrestored\", this.handleContextRestored);\n    this.gl.useProgram(null);\n    this.extensions.loseContext?.loseContext();\n  }\n  /**\n   * this function can be called to force a webGL context loss\n   * this will release all resources on the GPU.\n   * Useful if you need to put Pixi to sleep, and save some GPU memory\n   *\n   * As soon as render is called - all resources will be created again.\n   */\n  forceContextLoss() {\n    this.extensions.loseContext?.loseContext();\n    this._contextLossForced = true;\n  }\n  /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes();\n    if (attributes && !attributes.stencil) {\n      warn.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    }\n    const supports = this.supports;\n    const isWebGl2 = this.webGLVersion === 2;\n    const extensions = this.extensions;\n    supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n    supports.uniformBufferObject = isWebGl2;\n    supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n    supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n    supports.nonPowOf2wrapping = isWebGl2;\n    supports.nonPowOf2mipmaps = isWebGl2;\n    supports.msaa = isWebGl2;\n    if (!supports.uint32Indices) {\n      warn.warn(\"Provided WebGL context does not support 32 index buffer, large scenes may not render correctly\");\n    }\n  }\n};\n/** @ignore */\n_GlContextSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"context\"\n};\n/** The default options for the system. */\n_GlContextSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.context}\n   * @default null\n   */\n  context: null,\n  /**\n   * {@link WebGLOptions.premultipliedAlpha}\n   * @default true\n   */\n  premultipliedAlpha: true,\n  /**\n   * {@link WebGLOptions.preserveDrawingBuffer}\n   * @default false\n   */\n  preserveDrawingBuffer: false,\n  /**\n   * {@link WebGLOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * {@link WebGLOptions.webGLVersion}\n   * @default 2\n   */\n  preferWebGLVersion: 2,\n  /**\n   * {@link WebGLOptions.multiView}\n   * @default false\n   */\n  multiView: false\n};\nlet GlContextSystem = _GlContextSystem;\n\nexports.GlContextSystem = GlContextSystem;\n//# sourceMappingURL=GlContextSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlRenderingContext.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlRenderingContext.js ***!
  \***************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=GlRenderingContext.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlRenderingContext.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/WebGLExtensions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/context/WebGLExtensions.js ***!
  \************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=WebGLExtensions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/context/WebGLExtensions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\nvar ensureAttributes = __webpack_require__(/*! ../shader/program/ensureAttributes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js\");\nvar getGlTypeFromFormat = __webpack_require__(/*! ./utils/getGlTypeFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js\");\n\n\"use strict\";\nconst topologyToGlMap = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 3,\n  \"triangle-list\": 4,\n  \"triangle-strip\": 5\n};\nclass GlGeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this._renderer.renderableGC.addManagedHash(this, \"_geometryVaoHash\");\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this._renderer.gl;\n    if (!this._renderer.context.supports.vertexArrayObject) {\n      throw new Error(\"[PixiJS] Vertex Array Objects are not supported on this device\");\n    }\n    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n    if (nativeVaoExtension) {\n      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);\n      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);\n    }\n    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n    if (nativeInstancedExtension) {\n      gl.drawArraysInstanced = (a, b, c, d) => {\n        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n      };\n      gl.drawElementsInstanced = (a, b, c, d, e) => {\n        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n      };\n      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n    }\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param program - Instance of program to use vao for.\n   */\n  bind(geometry, program) {\n    const gl = this.gl;\n    this._activeGeometry = geometry;\n    const vao = this.getVao(geometry, program);\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      gl.bindVertexArray(vao);\n    }\n    this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  resetState() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this._renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.updateBuffer(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n      }\n    }\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    const strings = [\"g\", geometry.uid];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  getVao(geometry, program) {\n    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param program\n   * @param _incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, program, _incRefCount = true) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    this._renderer.shader._getProgramData(program);\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    if (!this._geometryVaoHash[geometry.uid]) {\n      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);\n      geometry.on(\"destroy\", this.onGeometryDestroy, this);\n    }\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program._key] = vao;\n      return vao;\n    }\n    ensureAttributes.ensureAttributes(geometry, program._attributeData);\n    const buffers = geometry.buffers;\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program._key] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    return vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onGeometryDestroy(geometry, contextLost) {\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    const gl = this.gl;\n    if (vaoObjectHash) {\n      if (contextLost) {\n        for (const i in vaoObjectHash) {\n          if (this._activeVao !== vaoObjectHash[i]) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[i]);\n        }\n      }\n      this._geometryVaoHash[geometry.uid] = null;\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  destroyAll(contextLost = false) {\n    const gl = this.gl;\n    for (const i in this._geometryVaoHash) {\n      if (contextLost) {\n        for (const j in this._geometryVaoHash[i]) {\n          const vaoObjectHash = this._geometryVaoHash[i];\n          if (this._activeVao !== vaoObjectHash) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[j]);\n        }\n      }\n      this._geometryVaoHash[i] = null;\n    }\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = attribute.buffer;\n      const glBuffer = bufferSystem.getGlBuffer(buffer);\n      const programAttrib = program._attributeData[j];\n      if (programAttrib) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = programAttrib.location;\n        gl.enableVertexAttribArray(location);\n        const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(attribute.format);\n        const type = getGlTypeFromFormat.getGlTypeFromFormat(attribute.format);\n        if (programAttrib.format?.substring(1, 4) === \"int\") {\n          gl.vertexAttribIPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attribute.stride,\n            attribute.offset\n          );\n        } else {\n          gl.vertexAttribPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attributeInfo.normalised,\n            attribute.stride,\n            attribute.offset\n          );\n        }\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            const divisor = attribute.divisor ?? 1;\n            gl.vertexAttribDivisor(location, divisor);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param topology - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(topology, size, start, instanceCount) {\n    const { gl } = this._renderer;\n    const geometry = this._activeGeometry;\n    const glTopology = topologyToGlMap[topology || geometry.topology];\n    instanceCount ?? (instanceCount = geometry.instanceCount);\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (instanceCount > 1) {\n        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n      } else {\n        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n      }\n    } else if (instanceCount > 1) {\n      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n    } else {\n      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n    }\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this.gl = null;\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n}\n/** @ignore */\nGlGeometrySystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"geometry\"\n};\n\nexports.GlGeometrySystem = GlGeometrySystem;\n//# sourceMappingURL=GlGeometrySystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../../texture/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js\");\n\n\"use strict\";\nconst infoMap = {\n  uint8x2: _const.GL_TYPES.UNSIGNED_BYTE,\n  uint8x4: _const.GL_TYPES.UNSIGNED_BYTE,\n  sint8x2: _const.GL_TYPES.BYTE,\n  sint8x4: _const.GL_TYPES.BYTE,\n  unorm8x2: _const.GL_TYPES.UNSIGNED_BYTE,\n  unorm8x4: _const.GL_TYPES.UNSIGNED_BYTE,\n  snorm8x2: _const.GL_TYPES.BYTE,\n  snorm8x4: _const.GL_TYPES.BYTE,\n  uint16x2: _const.GL_TYPES.UNSIGNED_SHORT,\n  uint16x4: _const.GL_TYPES.UNSIGNED_SHORT,\n  sint16x2: _const.GL_TYPES.SHORT,\n  sint16x4: _const.GL_TYPES.SHORT,\n  unorm16x2: _const.GL_TYPES.UNSIGNED_SHORT,\n  unorm16x4: _const.GL_TYPES.UNSIGNED_SHORT,\n  snorm16x2: _const.GL_TYPES.SHORT,\n  snorm16x4: _const.GL_TYPES.SHORT,\n  float16x2: _const.GL_TYPES.HALF_FLOAT,\n  float16x4: _const.GL_TYPES.HALF_FLOAT,\n  float32: _const.GL_TYPES.FLOAT,\n  float32x2: _const.GL_TYPES.FLOAT,\n  float32x3: _const.GL_TYPES.FLOAT,\n  float32x4: _const.GL_TYPES.FLOAT,\n  uint32: _const.GL_TYPES.UNSIGNED_INT,\n  uint32x2: _const.GL_TYPES.UNSIGNED_INT,\n  uint32x3: _const.GL_TYPES.UNSIGNED_INT,\n  uint32x4: _const.GL_TYPES.UNSIGNED_INT,\n  sint32: _const.GL_TYPES.INT,\n  sint32x2: _const.GL_TYPES.INT,\n  sint32x3: _const.GL_TYPES.INT,\n  sint32x4: _const.GL_TYPES.INT\n};\nfunction getGlTypeFromFormat(format) {\n  return infoMap[format] ?? infoMap.float32;\n}\n\nexports.getGlTypeFromFormat = getGlTypeFromFormat;\n//# sourceMappingURL=getGlTypeFromFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar CanvasSource = __webpack_require__(/*! ../../shared/texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar GlRenderTarget = __webpack_require__(/*! ../GlRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.js\");\n\n\"use strict\";\nclass GlRenderTargetAdaptor {\n  constructor() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle.Rectangle();\n  }\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n    renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle.Rectangle();\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const renderer = this._renderer;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const gl = renderer.gl;\n    this.finishRenderPass(sourceRenderSurfaceTexture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    renderer.texture.bind(destinationTexture, 0);\n    gl.copyTexSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      originDest.x,\n      originDest.y,\n      originSrc.x,\n      originSrc.y,\n      size.width,\n      size.height\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const source = renderTarget.colorTexture;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    let viewPortY = viewport.y;\n    if (renderTarget.isRoot) {\n      viewPortY = source.pixelHeight - viewport.height;\n    }\n    renderTarget.colorTextures.forEach((texture) => {\n      this._renderer.texture.unbind(texture);\n    });\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n    const viewPortCache = this._viewPortCache;\n    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n      viewPortCache.x = viewport.x;\n      viewPortCache.y = viewPortY;\n      viewPortCache.width = viewport.width;\n      viewPortCache.height = viewport.height;\n      gl.viewport(\n        viewport.x,\n        viewPortY,\n        viewport.width,\n        viewport.height\n      );\n    }\n    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {\n      this._initStencil(gpuRenderTarget);\n    }\n    this.clear(renderTarget, clear, clearColor);\n  }\n  finishRenderPass(renderTarget) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (!glRenderTarget.msaa)\n      return;\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n    gl.blitFramebuffer(\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      gl.COLOR_BUFFER_BIT,\n      gl.NEAREST\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n  }\n  initGpuRenderTarget(renderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const glRenderTarget = new GlRenderTarget.GlRenderTarget();\n    const colorTexture = renderTarget.colorTexture;\n    if (colorTexture instanceof CanvasSource.CanvasSource) {\n      this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n      glRenderTarget.framebuffer = null;\n      return glRenderTarget;\n    }\n    this._initColor(renderTarget, glRenderTarget);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return glRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    const gl = this._renderer.gl;\n    if (gpuRenderTarget.framebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n      gpuRenderTarget.framebuffer = null;\n    }\n    if (gpuRenderTarget.resolveTargetFramebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n      gpuRenderTarget.resolveTargetFramebuffer = null;\n    }\n    if (gpuRenderTarget.depthStencilRenderBuffer) {\n      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n      gpuRenderTarget.depthStencilRenderBuffer = null;\n    }\n    gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {\n      gl.deleteRenderbuffer(renderBuffer);\n    });\n    gpuRenderTarget.msaaRenderBuffer = null;\n  }\n  clear(_renderTarget, clear, clearColor) {\n    if (!clear)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    if (typeof clear === \"boolean\") {\n      clear = clear ? _const.CLEAR.ALL : _const.CLEAR.NONE;\n    }\n    const gl = this._renderer.gl;\n    if (clear & _const.CLEAR.COLOR) {\n      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);\n      const clearColorCache = this._clearColorCache;\n      const clearColorArray = clearColor;\n      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n        clearColorCache[0] = clearColorArray[0];\n        clearColorCache[1] = clearColorArray[1];\n        clearColorCache[2] = clearColorArray[2];\n        clearColorCache[3] = clearColorArray[3];\n        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n      }\n    }\n    gl.clear(clear);\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    if (renderTarget.isRoot)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._resizeColor(renderTarget, glRenderTarget);\n    if (renderTarget.stencil || renderTarget.depth) {\n      this._resizeStencil(glRenderTarget);\n    }\n  }\n  _initColor(renderTarget, glRenderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const resolveTargetFramebuffer = gl.createFramebuffer();\n    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      const source = colorTexture.source;\n      if (source.antialias) {\n        if (renderer.context.supports.msaa) {\n          glRenderTarget.msaa = true;\n        } else {\n          warn.warn(\"[RenderTexture] Antialiasing on textures is not supported in WebGL1\");\n        }\n      }\n      renderer.texture.bindSource(source, 0);\n      const glSource = renderer.texture.getGlSource(source);\n      const glTexture = glSource.texture;\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0 + i,\n        3553,\n        // texture.target,\n        glTexture,\n        0\n      );\n    });\n    if (glRenderTarget.msaa) {\n      const viewFramebuffer = gl.createFramebuffer();\n      glRenderTarget.framebuffer = viewFramebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((_, i) => {\n        const msaaRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n      });\n    } else {\n      glRenderTarget.framebuffer = resolveTargetFramebuffer;\n    }\n    this._resizeColor(renderTarget, glRenderTarget);\n  }\n  _resizeColor(renderTarget, glRenderTarget) {\n    const source = renderTarget.colorTexture.source;\n    glRenderTarget.width = source.pixelWidth;\n    glRenderTarget.height = source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (i === 0)\n        return;\n      colorTexture.source.resize(source.width, source.height, source._resolution);\n    });\n    if (glRenderTarget.msaa) {\n      const renderer = this._renderer;\n      const gl = renderer.gl;\n      const viewFramebuffer = glRenderTarget.framebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const source2 = colorTexture.source;\n        renderer.texture.bindSource(source2, 0);\n        const glSource = renderer.texture.getGlSource(source2);\n        const glInternalFormat = glSource.internalFormat;\n        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n        gl.bindRenderbuffer(\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n        gl.renderbufferStorageMultisample(\n          gl.RENDERBUFFER,\n          4,\n          glInternalFormat,\n          source2.pixelWidth,\n          source2.pixelHeight\n        );\n        gl.framebufferRenderbuffer(\n          gl.FRAMEBUFFER,\n          gl.COLOR_ATTACHMENT0 + i,\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n      });\n    }\n  }\n  _initStencil(glRenderTarget) {\n    if (glRenderTarget.framebuffer === null)\n      return;\n    const gl = this._renderer.gl;\n    const depthStencilRenderBuffer = gl.createRenderbuffer();\n    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    gl.framebufferRenderbuffer(\n      gl.FRAMEBUFFER,\n      gl.DEPTH_STENCIL_ATTACHMENT,\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    this._resizeStencil(glRenderTarget);\n  }\n  _resizeStencil(glRenderTarget) {\n    const gl = this._renderer.gl;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      glRenderTarget.depthStencilRenderBuffer\n    );\n    if (glRenderTarget.msaa) {\n      gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        4,\n        gl.DEPTH24_STENCIL8,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    } else {\n      gl.renderbufferStorage(\n        gl.RENDERBUFFER,\n        this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    }\n  }\n  prerender(renderTarget) {\n    const resource = renderTarget.colorTexture.resource;\n    if (this._renderer.context.multiView && CanvasSource.CanvasSource.test(resource)) {\n      this._renderer.context.ensureCanvasSize(resource);\n    }\n  }\n  postrender(renderTarget) {\n    if (!this._renderer.context.multiView)\n      return;\n    if (CanvasSource.CanvasSource.test(renderTarget.colorTexture.resource)) {\n      const contextCanvas = this._renderer.context.canvas;\n      const canvasSource = renderTarget.colorTexture;\n      canvasSource.context2D.drawImage(\n        contextCanvas,\n        0,\n        canvasSource.pixelHeight - contextCanvas.height\n      );\n    }\n  }\n}\n\nexports.GlRenderTargetAdaptor = GlRenderTargetAdaptor;\n//# sourceMappingURL=GlRenderTargetAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar RenderTargetSystem = __webpack_require__(/*! ../../shared/renderTarget/RenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js\");\nvar GlRenderTargetAdaptor = __webpack_require__(/*! ./GlRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.js\");\n\n\"use strict\";\nclass GlRenderTargetSystem extends RenderTargetSystem.RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GlRenderTargetAdaptor.GlRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGlRenderTargetSystem.extension = {\n  type: [Extensions.ExtensionType.WebGLSystem],\n  name: \"renderTarget\"\n};\n\nexports.GlRenderTargetSystem = GlRenderTargetSystem;\n//# sourceMappingURL=GlRenderTargetSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BufferResource = __webpack_require__(/*! ../../shared/buffer/BufferResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js\");\nvar UniformGroup = __webpack_require__(/*! ../../shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar TextureSource = __webpack_require__(/*! ../../shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nfunction generateShaderSyncCode(shader, shaderSystem) {\n  const funcFragments = [];\n  const headerFragments = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n  let addedTextreSystem = false;\n  let textureCount = 0;\n  const programData = shaderSystem._getProgramData(shader.glProgram);\n  for (const i in shader.groups) {\n    const group = shader.groups[i];\n    funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n    for (const j in group.resources) {\n      const resource = group.resources[j];\n      if (resource instanceof UniformGroup.UniformGroup) {\n        if (resource.ubo) {\n          const resName = shader._uniformBindMap[i][Number(j)];\n          funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n        } else {\n          funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n        }\n      } else if (resource instanceof BufferResource.BufferResource) {\n        const resName = shader._uniformBindMap[i][Number(j)];\n        funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n      } else if (resource instanceof TextureSource.TextureSource) {\n        const uniformName = shader._uniformBindMap[i][j];\n        const uniformData = programData.uniformData[uniformName];\n        if (uniformData) {\n          if (!addedTextreSystem) {\n            addedTextreSystem = true;\n            headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n          }\n          shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n          funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n          textureCount++;\n        }\n      }\n    }\n  }\n  const functionSource = [...headerFragments, ...funcFragments].join(\"\\n\");\n  return new Function(\"r\", \"s\", \"sD\", functionSource);\n}\n\nexports.generateShaderSyncCode = generateShaderSyncCode;\n//# sourceMappingURL=GenerateShaderSyncCode.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createIdFromString = __webpack_require__(/*! ../../shared/utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar getMaxFragmentPrecision = __webpack_require__(/*! ./program/getMaxFragmentPrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js\");\nvar addProgramDefines = __webpack_require__(/*! ./program/preprocessors/addProgramDefines.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js\");\nvar ensurePrecision = __webpack_require__(/*! ./program/preprocessors/ensurePrecision.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js\");\nvar insertVersion = __webpack_require__(/*! ./program/preprocessors/insertVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js\");\nvar setProgramName = __webpack_require__(/*! ./program/preprocessors/setProgramName.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js\");\nvar stripVersion = __webpack_require__(/*! ./program/preprocessors/stripVersion.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js\");\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion: stripVersion.stripVersion,\n  // adds precision string if not already present\n  ensurePrecision: ensurePrecision.ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines: addProgramDefines.addProgramDefines,\n  // add the program name to the shader\n  setProgramName: setProgramName.setProgramName,\n  // add the version string to the shader header\n  insertVersion: insertVersion.insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision.getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n    this._key = createIdFromString.createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexports.GlProgram = GlProgram;\n//# sourceMappingURL=GlProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass IGLUniformData {\n}\nclass GlProgramData {\n  /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */\n  constructor(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBlockBindings = {};\n  }\n  /** Destroys this program. */\n  destroy() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBlockBindings = null;\n    this.program = null;\n  }\n}\n\nexports.GlProgramData = GlProgramData;\nexports.IGLUniformData = IGLUniformData;\n//# sourceMappingURL=GlProgramData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GenerateShaderSyncCode = __webpack_require__(/*! ./GenerateShaderSyncCode.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.js\");\nvar generateProgram = __webpack_require__(/*! ./program/generateProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js\");\n\n\"use strict\";\nconst defaultSyncData = {\n  textureCount: 0,\n  blockIndex: 0\n};\nclass GlShaderSystem {\n  constructor(renderer) {\n    /** @internal */\n    this._activeProgram = null;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_programDataHash\");\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n    this._activeProgram = null;\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, skipSync) {\n    this._setProgram(shader.glProgram);\n    if (skipSync)\n      return;\n    defaultSyncData.textureCount = 0;\n    defaultSyncData.blockIndex = 0;\n    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n    if (!syncFunction) {\n      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n    }\n    this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n    syncFunction(this._renderer, shader, defaultSyncData);\n  }\n  /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */\n  updateUniformGroup(uniformGroup) {\n    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n  }\n  /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */\n  bindUniformBlock(uniformGroup, name, index = 0) {\n    const bufferSystem = this._renderer.buffer;\n    const programData = this._getProgramData(this._activeProgram);\n    const isBufferResource = uniformGroup._bufferResource;\n    if (!isBufferResource) {\n      this._renderer.ubo.updateUniformGroup(uniformGroup);\n    }\n    const buffer = uniformGroup.buffer;\n    const glBuffer = bufferSystem.updateBuffer(buffer);\n    const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n    if (isBufferResource) {\n      const { offset, size } = uniformGroup;\n      if (offset === 0 && size === buffer.data.byteLength) {\n        bufferSystem.bindBufferBase(glBuffer, boundLocation);\n      } else {\n        bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n      }\n    } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {\n      bufferSystem.bindBufferBase(glBuffer, boundLocation);\n    }\n    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n    if (programData.uniformBlockBindings[index] === boundLocation)\n      return;\n    programData.uniformBlockBindings[index] = boundLocation;\n    this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n  }\n  _setProgram(program) {\n    if (this._activeProgram === program)\n      return;\n    this._activeProgram = program;\n    const programData = this._getProgramData(program);\n    this._gl.useProgram(programData.program);\n  }\n  /**\n   * @param program - the program to get the data for\n   * @internal\n   */\n  _getProgramData(program) {\n    return this._programDataHash[program._key] || this._createProgramData(program);\n  }\n  _createProgramData(program) {\n    const key = program._key;\n    this._programDataHash[key] = generateProgram.generateProgram(this._gl, program);\n    return this._programDataHash[key];\n  }\n  destroy() {\n    for (const key of Object.keys(this._programDataHash)) {\n      const programData = this._programDataHash[key];\n      programData.destroy();\n      this._programDataHash[key] = null;\n    }\n    this._programDataHash = null;\n  }\n  /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don't want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */\n  _generateShaderSync(shader, shaderSystem) {\n    return GenerateShaderSyncCode.generateShaderSyncCode(shader, shaderSystem);\n  }\n  resetState() {\n    this._activeProgram = null;\n  }\n}\n/** @ignore */\nGlShaderSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"shader\"\n};\n\nexports.GlShaderSystem = GlShaderSystem;\n//# sourceMappingURL=GlShaderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar generateUniformsSync = __webpack_require__(/*! ./utils/generateUniformsSync.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js\");\n\n\"use strict\";\nclass GlUniformGroupSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    this._cache = {};\n    this._uniformGroupSyncHash = {};\n    this._renderer = renderer;\n    this.gl = null;\n    this._cache = {};\n  }\n  contextChange(gl) {\n    this.gl = gl;\n  }\n  /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param group - the uniforms values that be applied to the current shader\n   * @param program\n   * @param syncData\n   * @param syncData.textureCount\n   */\n  updateUniformGroup(group, program, syncData) {\n    const programData = this._renderer.shader._getProgramData(program);\n    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {\n      programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n      const syncFunc = this._getUniformSyncFunction(group, program);\n      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n    }\n  }\n  /**\n   * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param program\n   */\n  _getUniformSyncFunction(group, program) {\n    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);\n  }\n  _createUniformSyncFunction(group, program) {\n    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});\n    const id = this._getSignature(group, program._uniformData, \"u\");\n    if (!this._cache[id]) {\n      this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n    }\n    uniformGroupSyncHash[program._key] = this._cache[id];\n    return uniformGroupSyncHash[program._key];\n  }\n  _generateUniformsSync(group, uniformData) {\n    return generateUniformsSync.generateUniformsSync(group, uniformData);\n  }\n  /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */\n  _getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms;\n    const strings = [`${preFix}-`];\n    for (const i in uniforms) {\n      strings.push(i);\n      if (uniformData[i]) {\n        strings.push(uniformData[i].type);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  /** Destroys this System and removes all its textures. */\n  destroy() {\n    this._renderer = null;\n    this._cache = null;\n  }\n}\n/** @ignore */\nGlUniformGroupSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"uniformGroup\"\n};\n\nexports.GlUniformGroupSystem = GlUniformGroupSystem;\n//# sourceMappingURL=GlUniformGroupSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/const.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/const.js ***!
  \*************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar UniformGroup = __webpack_require__(/*! ../../shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\n\n\"use strict\";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup.UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\nexports.getBatchSamplersUniformGroup = getBatchSamplersUniformGroup;\n//# sourceMappingURL=getBatchSamplersUniformGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction migrateFragmentFromV7toV8(fragmentShader) {\n  fragmentShader = fragmentShader.replaceAll(\"texture2D\", \"texture\").replaceAll(\"gl_FragColor\", \"finalColor\").replaceAll(\"varying\", \"in\");\n  fragmentShader = `\n        out vec4 finalColor;\n    ${fragmentShader}\n    `;\n  return fragmentShader;\n}\n\nexports.migrateFragmentFromV7toV8 = migrateFragmentFromV7toV8;\n//# sourceMappingURL=migrateFragmentFromV7toV8.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\n\nexports.compileShader = compileShader;\n//# sourceMappingURL=compileShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * size);\n    case \"vec3\":\n      return new Float32Array(3 * size);\n    case \"vec4\":\n      return new Float32Array(4 * size);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * size);\n    case \"ivec3\":\n      return new Int32Array(3 * size);\n    case \"ivec4\":\n      return new Int32Array(4 * size);\n    case \"uvec2\":\n      return new Uint32Array(2 * size);\n    case \"uvec3\":\n      return new Uint32Array(3 * size);\n    case \"uvec4\":\n      return new Uint32Array(4 * size);\n    case \"bool\":\n      return false;\n    case \"bvec2\":\n      return booleanArray(2 * size);\n    case \"bvec3\":\n      return booleanArray(3 * size);\n    case \"bvec4\":\n      return booleanArray(4 * size);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexports.defaultValue = defaultValue;\n//# sourceMappingURL=defaultValue.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn.warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat.getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat.getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexports.ensureAttributes = ensureAttributes;\n//# sourceMappingURL=ensureAttributes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\nvar mapType = __webpack_require__(/*! ./mapType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js\");\n\n\"use strict\";\nfunction extractAttributesFromGlProgram(program, gl, sortAttributes = false) {\n  const attributes = {};\n  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith(\"gl_\")) {\n      continue;\n    }\n    const format = mapType.mapGlToVertexFormat(gl, attribData.type);\n    attributes[attribData.name] = {\n      location: 0,\n      // set further down..\n      format,\n      stride: getAttributeInfoFromFormat.getAttributeInfoFromFormat(format).stride,\n      offset: 0,\n      instance: false,\n      start: 0\n    };\n  }\n  const keys = Object.keys(attributes);\n  if (sortAttributes) {\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = i;\n      gl.bindAttribLocation(program, i, keys[i]);\n    }\n    gl.linkProgram(program);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n    }\n  }\n  return attributes;\n}\n\nexports.extractAttributesFromGlProgram = extractAttributesFromGlProgram;\n//# sourceMappingURL=extractAttributesFromGlProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar GlProgramData = __webpack_require__(/*! ../GlProgramData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.js\");\nvar compileShader = __webpack_require__(/*! ./compileShader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.js\");\nvar defaultValue = __webpack_require__(/*! ./defaultValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js\");\nvar extractAttributesFromGlProgram = __webpack_require__(/*! ./extractAttributesFromGlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.js\");\nvar getUboData = __webpack_require__(/*! ./getUboData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js\");\nvar getUniformData = __webpack_require__(/*! ./getUniformData.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js\");\nvar logProgramError = __webpack_require__(/*! ./logProgramError.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js\");\n\n\"use strict\";\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n  const glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n  const webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== \"function\") {\n      warn.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n    } else {\n      gl.transformFeedbackVaryings(\n        webGLProgram,\n        transformFeedbackVaryings.names,\n        transformFeedbackVaryings.bufferMode === \"separate\" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS\n      );\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program._attributeData = extractAttributesFromGlProgram.extractAttributesFromGlProgram(\n    webGLProgram,\n    gl,\n    !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertex)\n  );\n  program._uniformData = getUniformData.getUniformData(webGLProgram, gl);\n  program._uniformBlockData = getUboData.getUboData(webGLProgram, gl);\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program._uniformData) {\n    const data = program._uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue.defaultValue(data.type, data.size)\n    };\n  }\n  const glProgram = new GlProgramData.GlProgramData(webGLProgram, uniformData);\n  return glProgram;\n}\n\nexports.generateProgram = generateProgram;\n//# sourceMappingURL=generateProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getTestContext = __webpack_require__(/*! ./getTestContext.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js\");\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext.getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexports.getMaxFragmentPrecision = getMaxFragmentPrecision;\n//# sourceMappingURL=getMaxFragmentPrecision.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = adapter.DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexports.getTestContext = getTestContext;\n//# sourceMappingURL=getTestContext.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getUboData(program, gl) {\n  if (!gl.ACTIVE_UNIFORM_BLOCKS)\n    return {};\n  const uniformBlocks = {};\n  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let i = 0; i < totalUniformsBlocks; i++) {\n    const name = gl.getActiveUniformBlockName(program, i);\n    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n    const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n    uniformBlocks[name] = {\n      name,\n      index: uniformBlockIndex,\n      size\n    };\n  }\n  return uniformBlocks;\n}\n\nexports.getUboData = getUboData;\n//# sourceMappingURL=getUboData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar defaultValue = __webpack_require__(/*! ./defaultValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.js\");\nvar mapType = __webpack_require__(/*! ./mapType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js\");\n\n\"use strict\";\nfunction getUniformData(program, gl) {\n  const uniforms = {};\n  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i);\n    const name = uniformData.name.replace(/\\[.*?\\]$/, \"\");\n    const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n    const type = mapType.mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue.defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\nexports.getUniformData = getUniformData;\n//# sourceMappingURL=getUniformData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split(\"\\n\").map((line, index) => `${index}: ${line}`);\n  const shaderLog = gl.getShaderInfoLog(shader);\n  const splitShader = shaderLog.split(\"\\n\");\n  const dedupe = {};\n  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"))).filter((n) => {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  const logArgs = [\"\"];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n    logArgs.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  const fragmentSourceToLog = shaderSrc.join(\"\\n\");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed(\"click to view full shader code\");\n  console.warn(...logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error(\"PixiJS Error: Could not initialize shader.\");\n    if (gl.getProgramInfoLog(program) !== \"\") {\n      console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", gl.getProgramInfoLog(program));\n    }\n  }\n}\n\nexports.logProgramError = logProgramError;\n//# sourceMappingURL=logProgramError.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\n\nexports.mapSize = mapSize;\n//# sourceMappingURL=mapSize.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nconst GLSL_TO_VERTEX_TYPES = {\n  float: \"float32\",\n  vec2: \"float32x2\",\n  vec3: \"float32x3\",\n  vec4: \"float32x4\",\n  int: \"sint32\",\n  ivec2: \"sint32x2\",\n  ivec3: \"sint32x3\",\n  ivec4: \"sint32x4\",\n  uint: \"uint32\",\n  uvec2: \"uint32x2\",\n  uvec3: \"uint32x3\",\n  uvec4: \"uint32x4\",\n  bool: \"uint32\",\n  bvec2: \"uint32x2\",\n  bvec3: \"uint32x3\",\n  bvec4: \"uint32x4\"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\nfunction mapGlToVertexFormat(gl, type) {\n  const typeValue = mapType(gl, type);\n  return GLSL_TO_VERTEX_TYPES[typeValue] || \"float32\";\n}\n\nexports.mapGlToVertexFormat = mapGlToVertexFormat;\nexports.mapType = mapType;\n//# sourceMappingURL=mapType.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexports.addProgramDefines = addProgramDefines;\n//# sourceMappingURL=addProgramDefines.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexports.ensurePrecision = ensurePrecision;\n//# sourceMappingURL=ensurePrecision.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexports.insertVersion = insertVersion;\n//# sourceMappingURL=insertVersion.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexports.setProgramName = setProgramName;\n//# sourceMappingURL=setProgramName.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexports.stripVersion = stripVersion;\n//# sourceMappingURL=stripVersion.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst WGSL_TO_STD40_SIZE = {\n  f32: 4,\n  i32: 4,\n  \"vec2<f32>\": 8,\n  \"vec3<f32>\": 12,\n  \"vec4<f32>\": 16,\n  \"vec2<i32>\": 8,\n  \"vec3<i32>\": 12,\n  \"vec4<i32>\": 16,\n  \"mat2x2<f32>\": 16 * 2,\n  \"mat3x3<f32>\": 16 * 3,\n  \"mat4x4<f32>\": 16 * 4\n  // TODO - not essential for now but support these in the future\n  // int:      4,\n  // ivec2:    8,\n  // ivec3:    12,\n  // ivec4:    16,\n  // uint:     4,\n  // uvec2:    8,\n  // uvec3:    12,\n  // uvec4:    16,\n  // bool:     4,\n  // bvec2:    8,\n  // bvec3:    12,\n  // bvec4:    16,\n  // mat2:     16 * 2,\n  // mat3:     16 * 3,\n  // mat4:     16 * 4,\n};\nfunction createUboElementsSTD40(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  const chunkSize = 16;\n  let size = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n    if (!size) {\n      throw new Error(`Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, chunkSize) * uboElement.data.size;\n    }\n    const boundary = size === 12 ? 16 : size;\n    uboElement.size = size;\n    const curOffset = offset % chunkSize;\n    if (curOffset > 0 && chunkSize - curOffset < boundary) {\n      offset += (chunkSize - curOffset) % 16;\n    } else {\n      offset += (size - curOffset % size) % size;\n    }\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexports.WGSL_TO_STD40_SIZE = WGSL_TO_STD40_SIZE;\nexports.createUboElementsSTD40 = createUboElementsSTD40;\n//# sourceMappingURL=createUboElementsSTD40.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createUboSyncFunction = __webpack_require__(/*! ../../../shared/shader/utils/createUboSyncFunction.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js\");\nvar uboSyncFunctions = __webpack_require__(/*! ../../../shared/shader/utils/uboSyncFunctions.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js\");\nvar generateArraySyncSTD40 = __webpack_require__(/*! ./generateArraySyncSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js\");\n\n\"use strict\";\nfunction createUboSyncFunctionSTD40(uboElements) {\n  return createUboSyncFunction.createUboSyncFunction(\n    uboElements,\n    \"uboStd40\",\n    generateArraySyncSTD40.generateArraySyncSTD40,\n    uboSyncFunctions.uboSyncFunctionsSTD40\n  );\n}\n\nexports.createUboSyncFunctionSTD40 = createUboSyncFunctionSTD40;\n//# sourceMappingURL=createUboSyncSTD40.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createUboElementsSTD40 = __webpack_require__(/*! ./createUboElementsSTD40.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.js\");\n\n\"use strict\";\nfunction generateArraySyncSTD40(uboElement, offsetToAdd) {\n  const rowSize = Math.max(createUboElementsSTD40.WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n  const elementSize = uboElement.data.value.length / uboElement.data.size;\n  const remainder = (4 - elementSize % 4) % 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                ${data}[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n        }\n    `;\n}\n\nexports.generateArraySyncSTD40 = generateArraySyncSTD40;\n//# sourceMappingURL=generateArraySyncSTD40.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BufferResource = __webpack_require__(/*! ../../../shared/buffer/BufferResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar uniformParsers = __webpack_require__(/*! ../../../shared/shader/utils/uniformParsers.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js\");\nvar generateUniformsSyncTypes = __webpack_require__(/*! ./generateUniformsSyncTypes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js\");\n\n\"use strict\";\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n  for (const i in group.uniforms) {\n    if (!uniformData[i]) {\n      if (group.uniforms[i] instanceof UniformGroup.UniformGroup) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n        }\n      } else if (group.uniforms[i] instanceof BufferResource.BufferResource) {\n        funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n      }\n      continue;\n    }\n    const uniform = group.uniformStructures[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {\n      const parser = uniformParsers.uniformParsers[j];\n      if (uniform.type === parser.type && parser.test(uniform)) {\n        funcFragments.push(`name = \"${i}\";`, uniformParsers.uniformParsers[j].uniform);\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = uniform.size === 1 ? generateUniformsSyncTypes.UNIFORM_TO_SINGLE_SETTERS : generateUniformsSyncTypes.UNIFORM_TO_ARRAY_SETTERS;\n      const template = templateType[uniform.type].replace(\"location\", `ud[\"${i}\"].location`);\n      funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\n\nexports.generateUniformsSync = generateUniformsSync;\n//# sourceMappingURL=generateUniformsSync.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst UNIFORM_TO_SINGLE_SETTERS = {\n  f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n  \"vec2<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n  \"vec3<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n  i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  \"vec2<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  \"vec3<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n  \"vec2<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n  \"vec3<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n  bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  \"vec2<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  \"vec3<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n  \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n  \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`\n};\nconst UNIFORM_TO_ARRAY_SETTERS = {\n  f32: `gl.uniform1fv(location, v);`,\n  \"vec2<f32>\": `gl.uniform2fv(location, v);`,\n  \"vec3<f32>\": `gl.uniform3fv(location, v);`,\n  \"vec4<f32>\": `gl.uniform4fv(location, v);`,\n  \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n  \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n  \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`,\n  i32: `gl.uniform1iv(location, v);`,\n  \"vec2<i32>\": `gl.uniform2iv(location, v);`,\n  \"vec3<i32>\": `gl.uniform3iv(location, v);`,\n  \"vec4<i32>\": `gl.uniform4iv(location, v);`,\n  u32: `gl.uniform1iv(location, v);`,\n  \"vec2<u32>\": `gl.uniform2iv(location, v);`,\n  \"vec3<u32>\": `gl.uniform3iv(location, v);`,\n  \"vec4<u32>\": `gl.uniform4iv(location, v);`,\n  bool: `gl.uniform1iv(location, v);`,\n  \"vec2<bool>\": `gl.uniform2iv(location, v);`,\n  \"vec3<bool>\": `gl.uniform3iv(location, v);`,\n  \"vec4<bool>\": `gl.uniform4iv(location, v);`\n};\n\nexports.UNIFORM_TO_ARRAY_SETTERS = UNIFORM_TO_ARRAY_SETTERS;\nexports.UNIFORM_TO_SINGLE_SETTERS = UNIFORM_TO_SINGLE_SETTERS;\n//# sourceMappingURL=generateUniformsSyncTypes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar mapWebGLBlendModesToPixi = __webpack_require__(/*! ./mapWebGLBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js\");\n\n\"use strict\";\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _GlStateSystem = class _GlStateSystem {\n  constructor(renderer) {\n    /**\n     * Whether to invert the front face when rendering\n     * This is used for render textures where the Y-coordinate is flipped\n     * @default false\n     */\n    this._invertFrontFace = false;\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = \"none\";\n    this._blendEq = false;\n    this.map = [];\n    this.map[BLEND] = this.setBlend;\n    this.map[OFFSET] = this.setOffset;\n    this.map[CULLING] = this.setCullFace;\n    this.map[DEPTH_TEST] = this.setDepthTest;\n    this.map[WINDING] = this.setFrontFace;\n    this.map[DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = State.State.for2d();\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    this._invertFrontFace = !renderTarget.isRoot;\n    if (this._cullFace) {\n      this.setFrontFace(this._frontFace);\n    } else {\n      this._frontFaceDirty = true;\n    }\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModesMap = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi(gl);\n    this.resetState();\n  }\n  /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */\n  set(state) {\n    state || (state = this.defaultState);\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff >>= 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */\n  forceState(state) {\n    state || (state = this.defaultState);\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */\n  setBlend(value) {\n    this._updateCheck(_GlStateSystem._checkBlendMode, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }\n  /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */\n  setOffset(value) {\n    this._updateCheck(_GlStateSystem._checkPolygonOffset, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */\n  setDepthTest(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }\n  /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */\n  setCullFace(value) {\n    this._cullFace = value;\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n    if (this._cullFace && this._frontFaceDirty) {\n      this.setFrontFace(this._frontFace);\n    }\n  }\n  /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */\n  setFrontFace(value) {\n    this._frontFace = value;\n    this._frontFaceDirty = false;\n    const faceMode = this._invertFrontFace ? !value : value;\n    if (this._glFrontFace !== faceMode) {\n      this._glFrontFace = faceMode;\n      this.gl.frontFace(this.gl[faceMode ? \"CW\" : \"CCW\"]);\n    }\n  }\n  /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */\n  setBlendMode(value) {\n    if (!this.blendModesMap[value]) {\n      value = \"normal\";\n    }\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModesMap[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  /** Resets all the logic and disables the VAOs. */\n  resetState() {\n    this._glFrontFace = false;\n    this._frontFace = false;\n    this._cullFace = false;\n    this._frontFaceDirty = false;\n    this._invertFrontFace = false;\n    this.gl.frontFace(this.gl.CCW);\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = \"\";\n    this.setBlendMode(\"normal\");\n  }\n  /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */\n  _updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  /** @ignore */\n  destroy() {\n    this.gl = null;\n    this.checks.length = 0;\n  }\n};\n/** @ignore */\n_GlStateSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"state\"\n};\nlet GlStateSystem = _GlStateSystem;\n\nexports.GlStateSystem = GlStateSystem;\n//# sourceMappingURL=GlStateSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nfunction mapWebGLBlendModesToPixi(gl) {\n  const blendMap = {};\n  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.add = [gl.ONE, gl.ONE];\n  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.none = [0, 0];\n  blendMap[\"normal-npm\"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap[\"add-npm\"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  blendMap[\"screen-npm\"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  const isWebGl2 = !(gl instanceof adapter.DOMAdapter.get().getWebGLRenderingContext());\n  if (isWebGl2) {\n    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n  } else {\n    const ext = gl.getExtension(\"EXT_blend_minmax\");\n    if (ext) {\n      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n    }\n  }\n  return blendMap;\n}\n\nexports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;\n//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js\");\n\n\"use strict\";\nclass GlTexture {\n  constructor(texture) {\n    this.target = _const.GL_TARGETS.TEXTURE_2D;\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.type = _const.GL_TYPES.UNSIGNED_BYTE;\n    this.internalFormat = _const.GL_FORMATS.RGBA;\n    this.format = _const.GL_FORMATS.RGBA;\n    this.samplerType = 0;\n  }\n}\n\nexports.GlTexture = GlTexture;\n//# sourceMappingURL=GlTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Texture = __webpack_require__(/*! ../../shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar GlTexture = __webpack_require__(/*! ./GlTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.js\");\nvar glUploadBufferImageResource = __webpack_require__(/*! ./uploaders/glUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js\");\nvar glUploadCompressedTextureResource = __webpack_require__(/*! ./uploaders/glUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js\");\nvar glUploadImageResource = __webpack_require__(/*! ./uploaders/glUploadImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js\");\nvar glUploadVideoResource = __webpack_require__(/*! ./uploaders/glUploadVideoResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js\");\nvar applyStyleParams = __webpack_require__(/*! ./utils/applyStyleParams.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js\");\nvar mapFormatToGlFormat = __webpack_require__(/*! ./utils/mapFormatToGlFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js\");\nvar mapFormatToGlInternalFormat = __webpack_require__(/*! ./utils/mapFormatToGlInternalFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js\");\nvar mapFormatToGlType = __webpack_require__(/*! ./utils/mapFormatToGlType.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js\");\n__webpack_require__(/*! ./utils/unpremultiplyAlpha.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js\");\n\n\"use strict\";\nconst BYTES_PER_PIXEL = 4;\nclass GlTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundTextures = [];\n    this._activeTextureLocation = -1;\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: glUploadImageResource.glUploadImageResource,\n      buffer: glUploadBufferImageResource.glUploadBufferImageResource,\n      video: glUploadVideoResource.glUploadVideoResource,\n      compressed: glUploadCompressedTextureResource.glUploadCompressedTextureResource\n    };\n    this._premultiplyAlpha = false;\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    this._useSeparateSamplers = false;\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_glTextures\");\n    this._renderer.renderableGC.addManagedHash(this, \"_glSamplers\");\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    if (!this._mapFormatToInternalFormat) {\n      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat.mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n      this._mapFormatToType = mapFormatToGlType.mapFormatToGlType(gl);\n      this._mapFormatToFormat = mapFormatToGlFormat.mapFormatToGlFormat(gl);\n    }\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    this._premultiplyAlpha = false;\n    for (let i = 0; i < 16; i++) {\n      this.bind(Texture.Texture.EMPTY, i);\n    }\n  }\n  initSource(source) {\n    this.bind(source);\n  }\n  bind(texture, location = 0) {\n    const source = texture.source;\n    if (texture) {\n      this.bindSource(source, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(source.style, location);\n      }\n    } else {\n      this.bindSource(null, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(null, location);\n      }\n    }\n  }\n  bindSource(source, location = 0) {\n    const gl = this._gl;\n    source._touched = this._renderer.textureGC.count;\n    if (this._boundTextures[location] !== source) {\n      this._boundTextures[location] = source;\n      this._activateLocation(location);\n      source || (source = Texture.Texture.EMPTY.source);\n      const glTexture = this.getGlSource(source);\n      gl.bindTexture(glTexture.target, glTexture.texture);\n    }\n  }\n  _bindSampler(style, location = 0) {\n    const gl = this._gl;\n    if (!style) {\n      this._boundSamplers[location] = null;\n      gl.bindSampler(location, null);\n      return;\n    }\n    const sampler = this._getGlSampler(style);\n    if (this._boundSamplers[location] !== sampler) {\n      this._boundSamplers[location] = sampler;\n      gl.bindSampler(location, sampler);\n    }\n  }\n  unbind(texture) {\n    const source = texture.source;\n    const boundTextures = this._boundTextures;\n    const gl = this._gl;\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === source) {\n        this._activateLocation(i);\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(glTexture.target, null);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  _activateLocation(location) {\n    if (this._activeTextureLocation !== location) {\n      this._activeTextureLocation = location;\n      this._gl.activeTexture(this._gl.TEXTURE0 + location);\n    }\n  }\n  _initSource(source) {\n    const gl = this._gl;\n    const glTexture = new GlTexture.GlTexture(gl.createTexture());\n    glTexture.type = this._mapFormatToType[source.format];\n    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n    glTexture.format = this._mapFormatToFormat[source.format];\n    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n      const biggestDimension = Math.max(source.width, source.height);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    this._glTextures[source.uid] = glTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceUpdate, this);\n      source.on(\"styleChange\", this.onStyleChange, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    this.updateStyle(source, false);\n    return glTexture;\n  }\n  onStyleChange(source) {\n    this.updateStyle(source, false);\n  }\n  updateStyle(source, firstCreation) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    applyStyleParams.applyStyleParams(\n      source.style,\n      gl,\n      source.mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      \"texParameteri\",\n      gl.TEXTURE_2D,\n      // will force a clamp to edge if the texture is not a power of two\n      !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n      firstCreation\n    );\n  }\n  onSourceUnload(source) {\n    const glTexture = this._glTextures[source.uid];\n    if (!glTexture)\n      return;\n    this.unbind(source);\n    this._glTextures[source.uid] = null;\n    this._gl.deleteTexture(glTexture.texture);\n  }\n  onSourceUpdate(source) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    if (this._premultiplyAlpha !== premultipliedAlpha) {\n      this._premultiplyAlpha = premultipliedAlpha;\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n    }\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source, false);\n    }\n  }\n  onUpdateMipmaps(source, bind = true) {\n    if (bind)\n      this.bindSource(source, 0);\n    const glTexture = this.getGlSource(source);\n    this._gl.generateMipmap(glTexture.target);\n  }\n  onSourceDestroy(source) {\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"styleChange\", this.onStyleChange, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  _initSampler(style) {\n    const gl = this._gl;\n    const glSampler = this._gl.createSampler();\n    this._glSamplers[style._resourceId] = glSampler;\n    applyStyleParams.applyStyleParams(\n      style,\n      gl,\n      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      \"samplerParameteri\",\n      glSampler,\n      false,\n      true\n    );\n    return this._glSamplers[style._resourceId];\n  }\n  _getGlSampler(sampler) {\n    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGlSource(source) {\n    return this._glTextures[source.uid] || this._initSource(source);\n  }\n  generateCanvas(texture) {\n    const { pixels, width, height } = this.getPixels(texture);\n    const canvas = adapter.DOMAdapter.get().createCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n  }\n  getPixels(texture) {\n    const resolution = texture.source.resolution;\n    const frame = texture.frame;\n    const width = Math.max(Math.round(frame.width * resolution), 1);\n    const height = Math.max(Math.round(frame.height * resolution), 1);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const renderer = this._renderer;\n    const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n    const gl = renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n    gl.readPixels(\n      Math.round(frame.x * resolution),\n      Math.round(frame.y * resolution),\n      width,\n      height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    if (false) // removed by dead control flow\n{}\n    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    this._renderer = null;\n  }\n  resetState() {\n    this._activeTextureLocation = -1;\n    this._boundTextures.fill(Texture.Texture.EMPTY.source);\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    const gl = this._gl;\n    this._premultiplyAlpha = false;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);\n  }\n}\n/** @ignore */\nGlTextureSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem\n  ],\n  name: \"texture\"\n};\n\nexports.GlTextureSystem = GlTextureSystem;\n//# sourceMappingURL=GlTextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {\n  GL_FORMATS2[GL_FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  GL_FORMATS2[GL_FORMATS2[\"RG\"] = 33319] = \"RG\";\n  GL_FORMATS2[GL_FORMATS2[\"RED\"] = 6403] = \"RED\";\n  GL_FORMATS2[GL_FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n  return GL_FORMATS2;\n})(GL_FORMATS || {});\nvar GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n  return GL_TARGETS2;\n})(GL_TARGETS || {});\nvar GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n  return GL_WRAP_MODES2;\n})(GL_WRAP_MODES || {});\nvar GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  GL_TYPES2[GL_TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  GL_TYPES2[GL_TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  GL_TYPES2[GL_TYPES2[\"INT\"] = 5124] = \"INT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  GL_TYPES2[GL_TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n  return GL_TYPES2;\n})(GL_TYPES || {});\n\nexports.GL_FORMATS = GL_FORMATS;\nexports.GL_TARGETS = GL_TARGETS;\nexports.GL_TYPES = GL_TYPES;\nexports.GL_WRAP_MODES = GL_WRAP_MODES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/GLTextureUploader.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/GLTextureUploader.js ***!
  \************************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=GLTextureUploader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/GLTextureUploader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst glUploadBufferImageResource = {\n  id: \"buffer\",\n  upload(source, glTexture, gl) {\n    if (glTexture.width === source.width || glTexture.height === source.height) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        source.width,\n        source.height,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        source.width,\n        source.height,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = source.width;\n    glTexture.height = source.height;\n  }\n};\n\nexports.glUploadBufferImageResource = glUploadBufferImageResource;\n//# sourceMappingURL=glUploadBufferImageResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst compressedFormatMap = {\n  \"bc1-rgba-unorm\": true,\n  \"bc1-rgba-unorm-srgb\": true,\n  \"bc2-rgba-unorm\": true,\n  \"bc2-rgba-unorm-srgb\": true,\n  \"bc3-rgba-unorm\": true,\n  \"bc3-rgba-unorm-srgb\": true,\n  \"bc4-r-unorm\": true,\n  \"bc4-r-snorm\": true,\n  \"bc5-rg-unorm\": true,\n  \"bc5-rg-snorm\": true,\n  \"bc6h-rgb-ufloat\": true,\n  \"bc6h-rgb-float\": true,\n  \"bc7-rgba-unorm\": true,\n  \"bc7-rgba-unorm-srgb\": true,\n  // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  \"etc2-rgb8unorm\": true,\n  \"etc2-rgb8unorm-srgb\": true,\n  \"etc2-rgb8a1unorm\": true,\n  \"etc2-rgb8a1unorm-srgb\": true,\n  \"etc2-rgba8unorm\": true,\n  \"etc2-rgba8unorm-srgb\": true,\n  \"eac-r11unorm\": true,\n  \"eac-r11snorm\": true,\n  \"eac-rg11unorm\": true,\n  \"eac-rg11snorm\": true,\n  // ASTC compressed formats usable if \"texture-compression-astc\" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  \"astc-4x4-unorm\": true,\n  \"astc-4x4-unorm-srgb\": true,\n  \"astc-5x4-unorm\": true,\n  \"astc-5x4-unorm-srgb\": true,\n  \"astc-5x5-unorm\": true,\n  \"astc-5x5-unorm-srgb\": true,\n  \"astc-6x5-unorm\": true,\n  \"astc-6x5-unorm-srgb\": true,\n  \"astc-6x6-unorm\": true,\n  \"astc-6x6-unorm-srgb\": true,\n  \"astc-8x5-unorm\": true,\n  \"astc-8x5-unorm-srgb\": true,\n  \"astc-8x6-unorm\": true,\n  \"astc-8x6-unorm-srgb\": true,\n  \"astc-8x8-unorm\": true,\n  \"astc-8x8-unorm-srgb\": true,\n  \"astc-10x5-unorm\": true,\n  \"astc-10x5-unorm-srgb\": true,\n  \"astc-10x6-unorm\": true,\n  \"astc-10x6-unorm-srgb\": true,\n  \"astc-10x8-unorm\": true,\n  \"astc-10x8-unorm-srgb\": true,\n  \"astc-10x10-unorm\": true,\n  \"astc-10x10-unorm-srgb\": true,\n  \"astc-12x10-unorm\": true,\n  \"astc-12x10-unorm-srgb\": true,\n  \"astc-12x12-unorm\": true,\n  \"astc-12x12-unorm-srgb\": true\n};\nconst glUploadCompressedTextureResource = {\n  id: \"compressed\",\n  upload(source, glTexture, gl) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const compressed = !!compressedFormatMap[source.format];\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      if (compressed) {\n        gl.compressedTexImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          levelBuffer\n        );\n      } else {\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          levelBuffer\n        );\n      }\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexports.glUploadCompressedTextureResource = glUploadCompressedTextureResource;\n//# sourceMappingURL=glUploadCompressedTextureResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst glUploadImageResource = {\n  id: \"image\",\n  upload(source, glTexture, gl, webGLVersion) {\n    const glWidth = glTexture.width;\n    const glHeight = glTexture.height;\n    const textureWidth = source.pixelWidth;\n    const textureHeight = source.pixelHeight;\n    const resourceWidth = source.resourceWidth;\n    const resourceHeight = source.resourceHeight;\n    if (resourceWidth < textureWidth || resourceHeight < textureHeight) {\n      if (glWidth !== textureWidth || glHeight !== textureHeight) {\n        gl.texImage2D(\n          glTexture.target,\n          0,\n          glTexture.internalFormat,\n          textureWidth,\n          textureHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          null\n        );\n      }\n      if (webGLVersion === 2) {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          resourceWidth,\n          resourceHeight,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      } else {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      }\n    } else if (glWidth === textureWidth && glHeight === textureHeight) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else if (webGLVersion === 2) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        textureWidth,\n        textureHeight,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = textureWidth;\n    glTexture.height = textureHeight;\n  }\n};\n\nexports.glUploadImageResource = glUploadImageResource;\n//# sourceMappingURL=glUploadImageResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar glUploadImageResource = __webpack_require__(/*! ./glUploadImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.js\");\n\n\"use strict\";\nconst glUploadVideoResource = {\n  id: \"video\",\n  upload(source, glTexture, gl, webGLVersion) {\n    if (!source.isValid) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        1,\n        1,\n        0,\n        glTexture.format,\n        glTexture.type,\n        null\n      );\n      return;\n    }\n    glUploadImageResource.glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n  }\n};\n\nexports.glUploadVideoResource = glUploadVideoResource;\n//# sourceMappingURL=glUploadVideoResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar pixiToGlMaps = __webpack_require__(/*! ./pixiToGlMaps.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js\");\n\n\"use strict\";\nfunction applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {\n  const castParam = firstParam;\n  if (!firstCreation || style.addressModeU !== \"repeat\" || style.addressModeV !== \"repeat\" || style.addressModeW !== \"repeat\") {\n    const wrapModeS = pixiToGlMaps.wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeU];\n    const wrapModeT = pixiToGlMaps.wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeV];\n    const wrapModeR = pixiToGlMaps.wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeW];\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n    if (gl.TEXTURE_WRAP_R)\n      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n  }\n  if (!firstCreation || style.magFilter !== \"linear\") {\n    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, pixiToGlMaps.scaleModeToGlFilter[style.magFilter]);\n  }\n  if (mipmaps) {\n    if (!firstCreation || style.mipmapFilter !== \"linear\") {\n      const glFilterMode = pixiToGlMaps.mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n    }\n  } else {\n    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, pixiToGlMaps.scaleModeToGlFilter[style.minFilter]);\n  }\n  if (anisotropicExt && style.maxAnisotropy > 1) {\n    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n  }\n  if (style.compare) {\n    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, pixiToGlMaps.compareModeToGlCompare[style.compare]);\n  }\n}\n\nexports.applyStyleParams = applyStyleParams;\n//# sourceMappingURL=applyStyleParams.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nlet supportedGLCompressedTextureFormats;\nfunction getSupportedGlCompressedTextureFormats() {\n  if (supportedGLCompressedTextureFormats)\n    return supportedGLCompressedTextureFormats;\n  const canvas = document.createElement(\"canvas\");\n  const gl = canvas.getContext(\"webgl\");\n  if (!gl) {\n    return [];\n  }\n  supportedGLCompressedTextureFormats = [\n    // BC compressed formats usable if \"texture-compression-bc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    // 'bc6h-rgb-ufloat'\n    // 'bc6h-rgb-float'\n    // 'bc7-rgba-unorm',\n    // 'bc7-rgba-unorm-srgb',\n    ...gl.getExtension(\"EXT_texture_compression_bptc\") ? [\n      \"bc6h-rgb-ufloat\",\n      \"bc6h-rgb-float\",\n      \"bc7-rgba-unorm\",\n      \"bc7-rgba-unorm-srgb\"\n    ] : [],\n    // BC compressed formats usable if \"texture-compression-bc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    // 'bc1-rgba-unorm',\n    // 'bc1-rgba-unorm-srgb',\n    // 'bc4-r-unorm'\n    // 'bc4-r-snorm'\n    // 'bc5-rg-unorm'\n    // 'bc5-rg-snorm'\n    ...gl.getExtension(\"WEBGL_compressed_texture_s3tc\") ? [\n      \"bc1-rgba-unorm\",\n      \"bc2-rgba-unorm\",\n      \"bc3-rgba-unorm\"\n    ] : [],\n    ...gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\") ? [\n      \"bc1-rgba-unorm-srgb\",\n      \"bc2-rgba-unorm-srgb\",\n      \"bc3-rgba-unorm-srgb\"\n    ] : [],\n    ...gl.getExtension(\"EXT_texture_compression_rgtc\") ? [\n      \"bc4-r-unorm\",\n      \"bc4-r-snorm\",\n      \"bc5-rg-unorm\",\n      \"bc5-rg-snorm\"\n    ] : [],\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    ...gl.getExtension(\"WEBGL_compressed_texture_etc\") ? [\n      \"etc2-rgb8unorm\",\n      \"etc2-rgb8unorm-srgb\",\n      \"etc2-rgba8unorm\",\n      \"etc2-rgba8unorm-srgb\",\n      \"etc2-rgb8a1unorm\",\n      \"etc2-rgb8a1unorm-srgb\",\n      \"eac-r11unorm\",\n      \"eac-rg11unorm\"\n    ] : [],\n    // 'eac-r11snorm',\n    // 'eac-rg11snorm',\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    ...gl.getExtension(\"WEBGL_compressed_texture_astc\") ? [\n      \"astc-4x4-unorm\",\n      \"astc-4x4-unorm-srgb\",\n      \"astc-5x4-unorm\",\n      \"astc-5x4-unorm-srgb\",\n      \"astc-5x5-unorm\",\n      \"astc-5x5-unorm-srgb\",\n      \"astc-6x5-unorm\",\n      \"astc-6x5-unorm-srgb\",\n      \"astc-6x6-unorm\",\n      \"astc-6x6-unorm-srgb\",\n      \"astc-8x5-unorm\",\n      \"astc-8x5-unorm-srgb\",\n      \"astc-8x6-unorm\",\n      \"astc-8x6-unorm-srgb\",\n      \"astc-8x8-unorm\",\n      \"astc-8x8-unorm-srgb\",\n      \"astc-10x5-unorm\",\n      \"astc-10x5-unorm-srgb\",\n      \"astc-10x6-unorm\",\n      \"astc-10x6-unorm-srgb\",\n      \"astc-10x8-unorm\",\n      \"astc-10x8-unorm-srgb\",\n      \"astc-10x10-unorm\",\n      \"astc-10x10-unorm-srgb\",\n      \"astc-12x10-unorm\",\n      \"astc-12x10-unorm-srgb\",\n      \"astc-12x12-unorm\",\n      \"astc-12x12-unorm-srgb\"\n    ] : []\n  ];\n  return supportedGLCompressedTextureFormats;\n}\n\nexports.getSupportedGlCompressedTextureFormats = getSupportedGlCompressedTextureFormats;\n//# sourceMappingURL=getSupportedGlCompressedTextureFormats.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction mapFormatToGlFormat(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.RED,\n    r8snorm: gl.RED,\n    r8uint: gl.RED,\n    r8sint: gl.RED,\n    // 16-bit formats\n    r16uint: gl.RED,\n    r16sint: gl.RED,\n    r16float: gl.RED,\n    rg8unorm: gl.RG,\n    rg8snorm: gl.RG,\n    rg8uint: gl.RG,\n    rg8sint: gl.RG,\n    // 32-bit formats\n    r32uint: gl.RED,\n    r32sint: gl.RED,\n    r32float: gl.RED,\n    rg16uint: gl.RG,\n    rg16sint: gl.RG,\n    rg16float: gl.RG,\n    rgba8unorm: gl.RGBA,\n    \"rgba8unorm-srgb\": gl.RGBA,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA,\n    rgba8uint: gl.RGBA,\n    rgba8sint: gl.RGBA,\n    bgra8unorm: gl.RGBA,\n    \"bgra8unorm-srgb\": gl.RGBA,\n    rgb9e5ufloat: gl.RGB,\n    rgb10a2unorm: gl.RGBA,\n    rg11b10ufloat: gl.RGB,\n    // 64-bit formats\n    rg32uint: gl.RG,\n    rg32sint: gl.RG,\n    rg32float: gl.RG,\n    rgba16uint: gl.RGBA,\n    rgba16sint: gl.RGBA,\n    rgba16float: gl.RGBA,\n    // 128-bit formats\n    rgba32uint: gl.RGBA,\n    rgba32sint: gl.RGBA,\n    rgba32float: gl.RGBA,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT,\n    depth24plus: gl.DEPTH_COMPONENT,\n    \"depth24plus-stencil8\": gl.DEPTH_STENCIL,\n    depth32float: gl.DEPTH_COMPONENT,\n    \"depth32float-stencil8\": gl.DEPTH_STENCIL\n  };\n}\n\nexports.mapFormatToGlFormat = mapFormatToGlFormat;\n//# sourceMappingURL=mapFormatToGlFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nfunction mapFormatToGlInternalFormat(gl, extensions) {\n  let srgb = {};\n  let bgra8unorm = gl.RGBA;\n  if (!(gl instanceof adapter.DOMAdapter.get().getWebGLRenderingContext())) {\n    srgb = {\n      \"rgba8unorm-srgb\": gl.SRGB8_ALPHA8,\n      \"bgra8unorm-srgb\": gl.SRGB8_ALPHA8\n    };\n    bgra8unorm = gl.RGBA8;\n  } else if (extensions.srgb) {\n    srgb = {\n      \"rgba8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT,\n      \"bgra8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT\n    };\n  }\n  return {\n    // 8-bit formats\n    r8unorm: gl.R8,\n    r8snorm: gl.R8_SNORM,\n    r8uint: gl.R8UI,\n    r8sint: gl.R8I,\n    // 16-bit formats\n    r16uint: gl.R16UI,\n    r16sint: gl.R16I,\n    r16float: gl.R16F,\n    rg8unorm: gl.RG8,\n    rg8snorm: gl.RG8_SNORM,\n    rg8uint: gl.RG8UI,\n    rg8sint: gl.RG8I,\n    // 32-bit formats\n    r32uint: gl.R32UI,\n    r32sint: gl.R32I,\n    r32float: gl.R32F,\n    rg16uint: gl.RG16UI,\n    rg16sint: gl.RG16I,\n    rg16float: gl.RG16F,\n    rgba8unorm: gl.RGBA,\n    ...srgb,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA8_SNORM,\n    rgba8uint: gl.RGBA8UI,\n    rgba8sint: gl.RGBA8I,\n    bgra8unorm,\n    rgb9e5ufloat: gl.RGB9_E5,\n    rgb10a2unorm: gl.RGB10_A2,\n    rg11b10ufloat: gl.R11F_G11F_B10F,\n    // 64-bit formats\n    rg32uint: gl.RG32UI,\n    rg32sint: gl.RG32I,\n    rg32float: gl.RG32F,\n    rgba16uint: gl.RGBA16UI,\n    rgba16sint: gl.RGBA16I,\n    rgba16float: gl.RGBA16F,\n    // 128-bit formats\n    rgba32uint: gl.RGBA32UI,\n    rgba32sint: gl.RGBA32I,\n    rgba32float: gl.RGBA32F,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT16,\n    depth24plus: gl.DEPTH_COMPONENT24,\n    \"depth24plus-stencil8\": gl.DEPTH24_STENCIL8,\n    depth32float: gl.DEPTH_COMPONENT32F,\n    \"depth32float-stencil8\": gl.DEPTH32F_STENCIL8,\n    // Compressed formats\n    ...extensions.s3tc ? {\n      \"bc1-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n      \"bc2-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n      \"bc3-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.s3tc_sRGB ? {\n      \"bc1-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n      \"bc2-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n      \"bc3-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.rgtc ? {\n      \"bc4-r-unorm\": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n      \"bc4-r-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n      \"bc5-rg-unorm\": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n      \"bc5-rg-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\n    } : {},\n    ...extensions.bptc ? {\n      \"bc6h-rgb-float\": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n      \"bc6h-rgb-ufloat\": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n      \"bc7-rgba-unorm\": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n      \"bc7-rgba-unorm-srgb\": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\n    } : {},\n    ...extensions.etc ? {\n      \"etc2-rgb8unorm\": extensions.etc.COMPRESSED_RGB8_ETC2,\n      \"etc2-rgb8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ETC2,\n      \"etc2-rgb8a1unorm\": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      \"etc2-rgb8a1unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      \"etc2-rgba8unorm\": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n      \"etc2-rgba8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n      \"eac-r11unorm\": extensions.etc.COMPRESSED_R11_EAC,\n      // 'eac-r11snorm'\n      \"eac-rg11unorm\": extensions.etc.COMPRESSED_SIGNED_RG11_EAC\n      // 'eac-rg11snorm'\n    } : {},\n    ...extensions.astc ? {\n      \"astc-4x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n      \"astc-4x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n      \"astc-5x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n      \"astc-5x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n      \"astc-5x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n      \"astc-5x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n      \"astc-6x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n      \"astc-6x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n      \"astc-6x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n      \"astc-6x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n      \"astc-8x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n      \"astc-8x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n      \"astc-8x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n      \"astc-8x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n      \"astc-8x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n      \"astc-8x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n      \"astc-10x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n      \"astc-10x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n      \"astc-10x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n      \"astc-10x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n      \"astc-10x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n      \"astc-10x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n      \"astc-10x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n      \"astc-10x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n      \"astc-12x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n      \"astc-12x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n      \"astc-12x12-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n      \"astc-12x12-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\n    } : {}\n  };\n}\n\nexports.mapFormatToGlInternalFormat = mapFormatToGlInternalFormat;\n//# sourceMappingURL=mapFormatToGlInternalFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction mapFormatToGlType(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.UNSIGNED_BYTE,\n    r8snorm: gl.BYTE,\n    r8uint: gl.UNSIGNED_BYTE,\n    r8sint: gl.BYTE,\n    // 16-bit formats\n    r16uint: gl.UNSIGNED_SHORT,\n    r16sint: gl.SHORT,\n    r16float: gl.HALF_FLOAT,\n    rg8unorm: gl.UNSIGNED_BYTE,\n    rg8snorm: gl.BYTE,\n    rg8uint: gl.UNSIGNED_BYTE,\n    rg8sint: gl.BYTE,\n    // 32-bit formats\n    r32uint: gl.UNSIGNED_INT,\n    r32sint: gl.INT,\n    r32float: gl.FLOAT,\n    rg16uint: gl.UNSIGNED_SHORT,\n    rg16sint: gl.SHORT,\n    rg16float: gl.HALF_FLOAT,\n    rgba8unorm: gl.UNSIGNED_BYTE,\n    \"rgba8unorm-srgb\": gl.UNSIGNED_BYTE,\n    // Packed 32-bit formats\n    rgba8snorm: gl.BYTE,\n    rgba8uint: gl.UNSIGNED_BYTE,\n    rgba8sint: gl.BYTE,\n    bgra8unorm: gl.UNSIGNED_BYTE,\n    \"bgra8unorm-srgb\": gl.UNSIGNED_BYTE,\n    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n    // 64-bit formats\n    rg32uint: gl.UNSIGNED_INT,\n    rg32sint: gl.INT,\n    rg32float: gl.FLOAT,\n    rgba16uint: gl.UNSIGNED_SHORT,\n    rgba16sint: gl.SHORT,\n    rgba16float: gl.HALF_FLOAT,\n    // 128-bit formats\n    rgba32uint: gl.UNSIGNED_INT,\n    rgba32sint: gl.INT,\n    rgba32float: gl.FLOAT,\n    // Depth/stencil formats\n    stencil8: gl.UNSIGNED_BYTE,\n    depth16unorm: gl.UNSIGNED_SHORT,\n    depth24plus: gl.UNSIGNED_INT,\n    \"depth24plus-stencil8\": gl.UNSIGNED_INT_24_8,\n    depth32float: gl.FLOAT,\n    \"depth32float-stencil8\": gl.FLOAT_32_UNSIGNED_INT_24_8_REV\n  };\n}\n\nexports.mapFormatToGlType = mapFormatToGlType;\n//# sourceMappingURL=mapFormatToGlType.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst scaleModeToGlFilter = {\n  linear: 9729,\n  nearest: 9728\n};\nconst mipmapScaleModeToGlFilter = {\n  linear: {\n    linear: 9987,\n    nearest: 9985\n  },\n  nearest: {\n    linear: 9986,\n    nearest: 9984\n  }\n};\nconst wrapModeToGlAddress = {\n  \"clamp-to-edge\": 33071,\n  repeat: 10497,\n  \"mirror-repeat\": 33648\n};\nconst compareModeToGlCompare = {\n  never: 512,\n  less: 513,\n  equal: 514,\n  \"less-equal\": 515,\n  greater: 516,\n  \"not-equal\": 517,\n  \"greater-equal\": 518,\n  always: 519\n};\n\nexports.compareModeToGlCompare = compareModeToGlCompare;\nexports.mipmapScaleModeToGlFilter = mipmapScaleModeToGlFilter;\nexports.scaleModeToGlFilter = scaleModeToGlFilter;\nexports.wrapModeToGlAddress = wrapModeToGlAddress;\n//# sourceMappingURL=pixiToGlMaps.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction unpremultiplyAlpha(pixels) {\n  if (pixels instanceof Uint8ClampedArray) {\n    pixels = new Uint8Array(pixels.buffer);\n  }\n  const n = pixels.length;\n  for (let i = 0; i < n; i += 4) {\n    const alpha = pixels[i + 3];\n    if (alpha !== 0) {\n      const a = 255.001 / alpha;\n      pixels[i] = pixels[i] * a + 0.5;\n      pixels[i + 1] = pixels[i + 1] * a + 0.5;\n      pixels[i + 2] = pixels[i + 2] * a + 0.5;\n    }\n  }\n}\n\nexports.unpremultiplyAlpha = unpremultiplyAlpha;\n//# sourceMappingURL=unpremultiplyAlpha.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_hash\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexports.BindGroupSystem = BindGroupSystem;\n//# sourceMappingURL=BindGroupSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexports.GpuColorMaskSystem = GpuColorMaskSystem;\n//# sourceMappingURL=GpuColorMaskSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter$1 = await adapter.DOMAdapter.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter$1.features.has(feature));\n    const device = await adapter$1.requestDevice({\n      requiredFeatures\n    });\n    return { adapter: adapter$1, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexports.GpuDeviceSystem = GpuDeviceSystem;\n//# sourceMappingURL=GpuDeviceSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(i, geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount ?? geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [Extensions.ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexports.GpuEncoderSystem = GpuEncoderSystem;\n//# sourceMappingURL=GpuEncoderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GpuLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n    this.maxBatchableTextures = this.maxTextures;\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGpuLimitsSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"limits\"\n};\n\nexports.GpuLimitsSystem = GpuLimitsSystem;\n//# sourceMappingURL=GpuLimitsSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar _const = __webpack_require__(/*! ../shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: _const.STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexports.GpuStencilSystem = GpuStencilSystem;\n//# sourceMappingURL=GpuStencilSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar UboSystem = __webpack_require__(/*! ../shared/shader/UboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js\");\nvar createUboElementsWGSL = __webpack_require__(/*! ./shader/utils/createUboElementsWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js\");\nvar createUboSyncFunctionWGSL = __webpack_require__(/*! ./shader/utils/createUboSyncFunctionWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js\");\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem.UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL.createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL.createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [Extensions.ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexports.GpuUboSystem = GpuUboSystem;\n//# sourceMappingURL=GpuUboSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Buffer = __webpack_require__(/*! ../shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar BufferResource = __webpack_require__(/*! ../shared/buffer/BufferResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js\");\nvar _const = __webpack_require__(/*! ../shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar UboBatch = __webpack_require__(/*! ./buffer/UboBatch.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js\");\nvar BindGroup = __webpack_require__(/*! ./shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    this._batchBuffer = new UboBatch.UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = _const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= _const.BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer.Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource.BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup.BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexports.GpuUniformBatchPipe = GpuUniformBatchPipe;\n//# sourceMappingURL=GpuUniformBatchPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GpuGraphicsAdaptor = __webpack_require__(/*! ../../../scene/graphics/gpu/GpuGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js\");\nvar GpuMeshAdapter = __webpack_require__(/*! ../../../scene/mesh/gpu/GpuMeshAdapter.js */ \"./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js\");\nvar GpuBatchAdaptor = __webpack_require__(/*! ../../batcher/gpu/GpuBatchAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.js\");\nvar AbstractRenderer = __webpack_require__(/*! ../shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\nvar SharedSystems = __webpack_require__(/*! ../shared/system/SharedSystems.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js\");\nvar types = __webpack_require__(/*! ../types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar BindGroupSystem = __webpack_require__(/*! ./BindGroupSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.js\");\nvar GpuBufferSystem = __webpack_require__(/*! ./buffer/GpuBufferSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js\");\nvar GpuColorMaskSystem = __webpack_require__(/*! ./GpuColorMaskSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.js\");\nvar GpuDeviceSystem = __webpack_require__(/*! ./GpuDeviceSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.js\");\nvar GpuEncoderSystem = __webpack_require__(/*! ./GpuEncoderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.js\");\nvar GpuLimitsSystem = __webpack_require__(/*! ./GpuLimitsSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.js\");\nvar GpuStencilSystem = __webpack_require__(/*! ./GpuStencilSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.js\");\nvar GpuUboSystem = __webpack_require__(/*! ./GpuUboSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.js\");\nvar GpuUniformBatchPipe = __webpack_require__(/*! ./GpuUniformBatchPipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.js\");\nvar PipelineSystem = __webpack_require__(/*! ./pipeline/PipelineSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js\");\nvar GpuRenderTargetSystem = __webpack_require__(/*! ./renderTarget/GpuRenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js\");\nvar GpuShaderSystem = __webpack_require__(/*! ./shader/GpuShaderSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js\");\nvar GpuStateSystem = __webpack_require__(/*! ./state/GpuStateSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js\");\nvar GpuTextureSystem = __webpack_require__(/*! ./texture/GpuTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js\");\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems.SharedSystems,\n  GpuUboSystem.GpuUboSystem,\n  GpuEncoderSystem.GpuEncoderSystem,\n  GpuDeviceSystem.GpuDeviceSystem,\n  GpuLimitsSystem.GpuLimitsSystem,\n  GpuBufferSystem.GpuBufferSystem,\n  GpuTextureSystem.GpuTextureSystem,\n  GpuRenderTargetSystem.GpuRenderTargetSystem,\n  GpuShaderSystem.GpuShaderSystem,\n  GpuStateSystem.GpuStateSystem,\n  PipelineSystem.PipelineSystem,\n  GpuColorMaskSystem.GpuColorMaskSystem,\n  GpuStencilSystem.GpuStencilSystem,\n  BindGroupSystem.BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedSystems.SharedRenderPipes, GpuUniformBatchPipe.GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor.GpuBatchAdaptor, GpuMeshAdapter.GpuMeshAdapter, GpuGraphicsAdaptor.GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGPUSystem, systems);\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGPUPipes, renderPipes);\nExtensions.extensions.handleByNamedList(Extensions.ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nExtensions.extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer.AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: types.RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexports.WebGPURenderer = WebGPURenderer;\n//# sourceMappingURL=WebGPURenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar fastCopy = __webpack_require__(/*! ../../shared/buffer/utils/fastCopy.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js\");\n\n\"use strict\";\nclass GpuBufferSystem {\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n    renderer.renderableGC.addManagedHash(this, \"_gpuBuffers\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n      buffer.on(\"destroy\", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      fastCopy.fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n    buffer.off(\"destroy\", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexports.GpuBufferSystem = GpuBufferSystem;\n//# sourceMappingURL=GpuBufferSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this.data = null;\n  }\n}\n\nexports.UboBatch = UboBatch;\n//# sourceMappingURL=UboBatch.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar ensureAttributes = __webpack_require__(/*! ../../gl/shader/program/ensureAttributes.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.js\");\nvar _const = __webpack_require__(/*! ../../shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\nvar createIdFromString = __webpack_require__(/*! ../../shared/utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar GpuStencilModesToPixi = __webpack_require__(/*! ../state/GpuStencilModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js\");\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(_const.STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi.GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes.ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology || (topology = geometry.topology);\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === _const.STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString.createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString.createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      const attributes = Object.values(data[i].attributes);\n      const shaderLocation = attributes[0].shaderLocation;\n      for (const j in attributeData) {\n        if (attributeData[j].location === shaderLocation) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn.warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [Extensions.ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexports.PipelineSystem = PipelineSystem;\n//# sourceMappingURL=PipelineSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexports.GpuRenderTarget = GpuRenderTarget;\n//# sourceMappingURL=GpuRenderTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../../gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar CanvasSource = __webpack_require__(/*! ../../shared/texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar TextureSource = __webpack_require__(/*! ../../shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar GpuRenderTarget = __webpack_require__(/*! ./GpuRenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.js\");\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? _const.CLEAR.ALL : _const.CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & _const.CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & _const.CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & _const.CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget.GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (colorTexture instanceof CanvasSource.CanvasSource) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource.TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexports.GpuRenderTargetAdaptor = GpuRenderTargetAdaptor;\n//# sourceMappingURL=GpuRenderTargetAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar RenderTargetSystem = __webpack_require__(/*! ../../shared/renderTarget/RenderTargetSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js\");\nvar GpuRenderTargetAdaptor = __webpack_require__(/*! ./GpuRenderTargetAdaptor.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.js\");\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem.RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor.GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [Extensions.ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexports.GpuRenderTargetSystem = GpuRenderTargetSystem;\n//# sourceMappingURL=GpuRenderTargetSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexports.calculateProjection = calculateProjection;\n//# sourceMappingURL=calculateProjection.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexports.BindGroup = BindGroup;\n//# sourceMappingURL=BindGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindResource.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindResource.js ***!
  \*********************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=BindResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createIdFromString = __webpack_require__(/*! ../../shared/utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar extractAttributesFromGpuProgram = __webpack_require__(/*! ./utils/extractAttributesFromGpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js\");\nvar extractStructAndGroups = __webpack_require__(/*! ./utils/extractStructAndGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js\");\nvar generateGpuLayoutGroups = __webpack_require__(/*! ./utils/generateGpuLayoutGroups.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js\");\nvar generateLayoutHash = __webpack_require__(/*! ./utils/generateLayoutHash.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js\");\nvar removeStructAndGroupDuplicates = __webpack_require__(/*! ./utils/removeStructAndGroupDuplicates.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js\");\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /** @internal */\n    this._layoutKey = 0;\n    /** @internal */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups.extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups.extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups.extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates.removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash.generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups.generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString.createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram.extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexports.GpuProgram = GpuProgram;\n//# sourceMappingURL=GpuProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexports.GpuShaderSystem = GpuShaderSystem;\n//# sourceMappingURL=GpuShaderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexports.WGSL_ALIGN_SIZE_DATA = WGSL_ALIGN_SIZE_DATA;\nexports.createUboElementsWGSL = createUboElementsWGSL;\n//# sourceMappingURL=createUboElementsWGSL.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createUboSyncFunction = __webpack_require__(/*! ../../../shared/shader/utils/createUboSyncFunction.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js\");\nvar uboSyncFunctions = __webpack_require__(/*! ../../../shared/shader/utils/uboSyncFunctions.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js\");\nvar generateArraySyncWGSL = __webpack_require__(/*! ./generateArraySyncWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js\");\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction.createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL.generateArraySyncWGSL,\n    uboSyncFunctions.uboSyncFunctionsWGSL\n  );\n}\n\nexports.createUboSyncFunctionWGSL = createUboSyncFunctionWGSL;\n//# sourceMappingURL=createUboSyncFunctionWGSL.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat.getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexports.extractAttributesFromGpuProgram = extractAttributesFromGpuProgram;\n//# sourceMappingURL=extractAttributesFromGpuProgram.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexports.extractStructAndGroups = extractStructAndGroups;\n//# sourceMappingURL=extractStructAndGroups.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createUboElementsWGSL = __webpack_require__(/*! ./createUboElementsWGSL.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.js\");\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = createUboElementsWGSL.WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexports.generateArraySyncWGSL = generateArraySyncWGSL;\n//# sourceMappingURL=generateArraySyncWGSL.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../../../shared/shader/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js\");\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: _const.ShaderStage.VERTEX | _const.ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: _const.ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: _const.ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexports.generateGpuLayoutGroups = generateGpuLayoutGroups;\n//# sourceMappingURL=generateGpuLayoutGroups.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexports.generateLayoutHash = generateLayoutHash;\n//# sourceMappingURL=generateLayoutHash.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexports.removeStructAndGroupDuplicates = removeStructAndGroupDuplicates;\n//# sourceMappingURL=removeStructAndGroupDuplicates.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  }\n};\n\nexports.GpuBlendModesToPixi = GpuBlendModesToPixi;\n//# sourceMappingURL=GpuBlendModesToPixi.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar GpuBlendModesToPixi = __webpack_require__(/*! ./GpuBlendModesToPixi.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.js\");\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State.State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi.GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: \"bgra8unorm\",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexports.GpuStateSystem = GpuStateSystem;\n//# sourceMappingURL=GpuStateSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../../shared/state/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[_const.STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[_const.STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[_const.STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[_const.STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[_const.STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[_const.STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexports.GpuStencilModesToPixi = GpuStencilModesToPixi;\n//# sourceMappingURL=GpuStencilModesToPixi.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar UniformGroup = __webpack_require__(/*! ../../shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar CanvasPool = __webpack_require__(/*! ../../shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar BindGroup = __webpack_require__(/*! ../shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar gpuUploadBufferImageResource = __webpack_require__(/*! ./uploaders/gpuUploadBufferImageResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js\");\nvar gpuUploadCompressedTextureResource = __webpack_require__(/*! ./uploaders/gpuUploadCompressedTextureResource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js\");\nvar gpuUploadImageSource = __webpack_require__(/*! ./uploaders/gpuUploadImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js\");\nvar gpuUploadVideoSource = __webpack_require__(/*! ./uploaders/gpuUploadVideoSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js\");\nvar GpuMipmapGenerator = __webpack_require__(/*! ./utils/GpuMipmapGenerator.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js\");\n\n\"use strict\";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageSource.gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource.gpuUploadBufferImageResource,\n      video: gpuUploadVideoSource.gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource.gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuSources\");\n    renderer.renderableGC.addManagedHash(this, \"_gpuSamplers\");\n    renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    renderer.renderableGC.addManagedHash(this, \"_textureViewHash\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = gpuUploadCompressedTextureResource.blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator.GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup.BindGroup({\n      0: source,\n      1: source.style,\n      2: new UniformGroup.UniformGroup({\n        uTextureMatrix: { type: \"mat3x3<f32>\", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = adapter.DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: adapter.DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexports.GpuTextureSystem = GpuTextureSystem;\n//# sourceMappingURL=GpuTextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/GpuTextureUploader.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/GpuTextureUploader.js ***!
  \**************************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=GpuTextureUploader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/GpuTextureUploader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexports.gpuUploadBufferImageResource = gpuUploadBufferImageResource;\n//# sourceMappingURL=gpuUploadBufferImageResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexports.blockDataMap = blockDataMap;\nexports.gpuUploadCompressedTextureResource = gpuUploadCompressedTextureResource;\n//# sourceMappingURL=gpuUploadCompressedTextureResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar warn = __webpack_require__(/*! ../../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {\n      const canvas = adapter.DOMAdapter.get().createCanvas(resource.width, resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(resource, 0, 0, resource.width, resource.height);\n      source.resource = canvas;\n      warn.warn(\"ImageSource: Image element passed, converting to canvas and replacing resource.\");\n    }\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexports.gpuUploadImageResource = gpuUploadImageResource;\n//# sourceMappingURL=gpuUploadImageSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar gpuUploadImageSource = __webpack_require__(/*! ./gpuUploadImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.js\");\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageSource.gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexports.gpuUploadVideoResource = gpuUploadVideoResource;\n//# sourceMappingURL=gpuUploadVideoSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexports.GpuMipmapGenerator = GpuMipmapGenerator;\n//# sourceMappingURL=GpuMipmapGenerator.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nlet supportedGPUCompressedTextureFormats;\nasync function getSupportedGPUCompressedTextureFormats() {\n  if (supportedGPUCompressedTextureFormats)\n    return supportedGPUCompressedTextureFormats;\n  const adapter$1 = await adapter.DOMAdapter.get().getNavigator().gpu.requestAdapter();\n  supportedGPUCompressedTextureFormats = [\n    ...adapter$1.features.has(\"texture-compression-bc\") ? [\n      // BC compressed formats usable if \"texture-compression-bc\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      \"bc1-rgba-unorm\",\n      \"bc1-rgba-unorm-srgb\",\n      \"bc2-rgba-unorm\",\n      \"bc2-rgba-unorm-srgb\",\n      \"bc3-rgba-unorm\",\n      \"bc3-rgba-unorm-srgb\",\n      \"bc4-r-unorm\",\n      \"bc4-r-snorm\",\n      \"bc5-rg-unorm\",\n      \"bc5-rg-snorm\",\n      \"bc6h-rgb-ufloat\",\n      \"bc6h-rgb-float\",\n      \"bc7-rgba-unorm\",\n      \"bc7-rgba-unorm-srgb\"\n    ] : [],\n    ...adapter$1.features.has(\"texture-compression-etc2\") ? [\n      // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      \"etc2-rgb8unorm\",\n      \"etc2-rgb8unorm-srgb\",\n      \"etc2-rgb8a1unorm\",\n      \"etc2-rgb8a1unorm-srgb\",\n      \"etc2-rgba8unorm\",\n      \"etc2-rgba8unorm-srgb\",\n      \"eac-r11unorm\",\n      \"eac-r11snorm\",\n      \"eac-rg11unorm\",\n      \"eac-rg11snorm\"\n    ] : [],\n    ...adapter$1.features.has(\"texture-compression-astc\") ? [\n      // ASTC compressed formats usable if \"texture-compression-astc\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      \"astc-4x4-unorm\",\n      \"astc-4x4-unorm-srgb\",\n      \"astc-5x4-unorm\",\n      \"astc-5x4-unorm-srgb\",\n      \"astc-5x5-unorm\",\n      \"astc-5x5-unorm-srgb\",\n      \"astc-6x5-unorm\",\n      \"astc-6x5-unorm-srgb\",\n      \"astc-6x6-unorm\",\n      \"astc-6x6-unorm-srgb\",\n      \"astc-8x5-unorm\",\n      \"astc-8x5-unorm-srgb\",\n      \"astc-8x6-unorm\",\n      \"astc-8x6-unorm-srgb\",\n      \"astc-8x8-unorm\",\n      \"astc-8x8-unorm-srgb\",\n      \"astc-10x5-unorm\",\n      \"astc-10x5-unorm-srgb\",\n      \"astc-10x6-unorm\",\n      \"astc-10x6-unorm-srgb\",\n      \"astc-10x8-unorm\",\n      \"astc-10x8-unorm-srgb\",\n      \"astc-10x10-unorm\",\n      \"astc-10x10-unorm-srgb\",\n      \"astc-12x10-unorm\",\n      \"astc-12x10-unorm-srgb\",\n      \"astc-12x12-unorm\",\n      \"astc-12x12-unorm-srgb\"\n    ] : []\n  ];\n  return supportedGPUCompressedTextureFormats;\n}\n\nexports.getSupportedGPUCompressedTextureFormats = getSupportedGPUCompressedTextureFormats;\n//# sourceMappingURL=getSupportedGPUCompressedTextureFormats.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/Renderable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/Renderable.js ***!
  \***************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=Renderable.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/Renderable.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Ticker = __webpack_require__(/*! ../../../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker.Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexports.SchedulerSystem = SchedulerSystem;\n//# sourceMappingURL=SchedulerSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color.Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexports.BackgroundSystem = BackgroundSystem;\n//# sourceMappingURL=BackgroundSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar FilterEffect = __webpack_require__(/*! ../../../../filters/FilterEffect.js */ \"./node_modules/pixi.js/lib/filters/FilterEffect.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nExtensions.extensions.handle(Extensions.ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn.warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect.FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexports.BlendModePipe = BlendModePipe;\n//# sourceMappingURL=BlendModePipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid.uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid.uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /** @internal */\n    this._updateID = 1;\n    this._dataInt32 = null;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size ?? (size = data?.byteLength);\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  get dataInt32() {\n    if (!this._dataInt32) {\n      this._dataInt32 = new Int32Array(this.data.buffer);\n    }\n    return this._dataInt32;\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const.BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const.BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const.BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    this._dataInt32 = null;\n    if (!oldData || oldData.length !== value.length) {\n      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid.uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexports.Buffer = Buffer;\n//# sourceMappingURL=Buffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid.uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid.uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid.uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\n\nexports.BufferResource = BufferResource;\n//# sourceMappingURL=BufferResource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexports.BufferUsage = BufferUsage;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexports.fastCopy = fastCopy;\n//# sourceMappingURL=fastCopy.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Container = __webpack_require__(/*! ../../../../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar Texture = __webpack_require__(/*! ../texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container.Container || options instanceof Texture.Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an HTMLImageElement from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated HTMLImageElement\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: '#ff0000',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn't support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture.Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture.Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container.Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture.Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as 'image.png'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: 'screenshot.png'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: 'region.png',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: 'hd-screenshot.png',\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: 'smooth.png',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * The image will be displayed in the browser's console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = 'webp';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: \"png\",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexports.ExtractSystem = ExtractSystem;\n//# sourceMappingURL=ExtractSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar Bounds = __webpack_require__(/*! ../../../../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getLocalBounds = __webpack_require__(/*! ../../../../scene/container/bounds/getLocalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js\");\nvar Container = __webpack_require__(/*! ../../../../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar RenderTexture = __webpack_require__(/*! ../texture/RenderTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js\");\n\n\"use strict\";\nconst tempRect = new Rectangle.Rectangle();\nconst tempBounds = new Bounds.Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill('red')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: '#ff0000',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container.Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds.getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexports.GenerateTextureSystem = GenerateTextureSystem;\n//# sourceMappingURL=GenerateTextureSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar Bounds = __webpack_require__(/*! ../../../../scene/container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar Buffer = __webpack_require__(/*! ../buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar ensureIsBuffer = __webpack_require__(/*! ./utils/ensureIsBuffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js\");\nvar getGeometryBounds = __webpack_require__(/*! ./utils/getGeometryBounds.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js\");\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer.Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer.ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid.uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds.Bounds();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount ?? 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n      attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer.ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds.getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexports.Geometry = Geometry;\n//# sourceMappingURL=Geometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst DEPRECATED_DRAW_MODES = {\n  POINTS: \"point-list\",\n  LINES: \"line-list\",\n  LINE_STRIP: \"line-strip\",\n  TRIANGLES: \"triangle-list\",\n  TRIANGLE_STRIP: \"triangle-strip\"\n};\nconst DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {\n  get(target, prop) {\n    deprecation.deprecation(deprecation.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);\n    return target[prop];\n  }\n});\n\nexports.DRAW_MODES = DRAW_MODES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexports.buildSimpleUvs = buildSimpleUvs;\nexports.buildUvs = buildUvs;\n//# sourceMappingURL=buildUvs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Buffer = __webpack_require__(/*! ../../buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar _const = __webpack_require__(/*! ../../buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer.Buffer)) {\n    let usage = index ? _const.BufferUsage.INDEX : _const.BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = _const.BufferUsage.INDEX | _const.BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer.Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexports.ensureIsBuffer = ensureIsBuffer;\n//# sourceMappingURL=ensureIsBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexports.getAttributeInfoFromFormat = getAttributeInfoFromFormat;\n//# sourceMappingURL=getAttributeInfoFromFormat.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexports.getGeometryBounds = getGeometryBounds;\n//# sourceMappingURL=getGeometryBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset || (offset = 0);\n  stride || (stride = 2);\n  size || (size = vertices.length / stride - offset);\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexports.transformVertices = transformVertices;\n//# sourceMappingURL=transformVertices.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/Instruction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/Instruction.js ***!
  \*****************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=Instruction.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/Instruction.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\n\n\"use strict\";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid.uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    this.gcTick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexports.InstructionSet = InstructionSet;\n//# sourceMappingURL=InstructionSet.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/RenderPipe.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/RenderPipe.js ***!
  \****************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=RenderPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/RenderPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Point = __webpack_require__(/*! ../../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar colorToUniform = __webpack_require__(/*! ../../../../scene/graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar BindGroup = __webpack_require__(/*! ../../gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar types = __webpack_require__(/*! ../../types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix.Matrix(),\n      worldColor: 4294967295,\n      offset: new Point.Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    colorToUniform.color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup.BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === types.RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup.UniformGroup({\n      uProjectionMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexports.GlobalUniformSystem = GlobalUniformSystem;\n//# sourceMappingURL=GlobalUniformSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar TextureSource = __webpack_require__(/*! ../texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid.uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource.TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture.Texture || descriptor.depthStencilTexture instanceof TextureSource.TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource.TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexports.RenderTarget = RenderTarget;\n//# sourceMappingURL=RenderTarget.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar _const = __webpack_require__(/*! ../../gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar calculateProjection = __webpack_require__(/*! ../../gpu/renderTarget/calculateProjection.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.js\");\nvar SystemRunner = __webpack_require__(/*! ../system/SystemRunner.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js\");\nvar CanvasSource = __webpack_require__(/*! ../texture/sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar TextureSource = __webpack_require__(/*! ../texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar getCanvasTexture = __webpack_require__(/*! ../texture/utils/getCanvasTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js\");\nvar isRenderingToScreen = __webpack_require__(/*! ./isRenderingToScreen.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js\");\nvar RenderTarget = __webpack_require__(/*! ./RenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js\");\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle.Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle.Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner.SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix.Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen.isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture.Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection.calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = _const.CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = _const.CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture.getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget.RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource.TextureSource) {\n      renderTarget = new RenderTarget.RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource.CanvasSource) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexports.RenderTargetSystem = RenderTargetSystem;\n//# sourceMappingURL=RenderTargetSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexports.isRenderingToScreen = isRenderingToScreen;\n//# sourceMappingURL=isRenderingToScreen.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar GlProgram = __webpack_require__(/*! ../../gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar BindGroup = __webpack_require__(/*! ../../gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar GpuProgram = __webpack_require__(/*! ../../gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar types = __webpack_require__(/*! ../../types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar UniformGroup = __webpack_require__(/*! ./UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /** A unique identifier for the shader */\n    this.uid = uid.uid(\"shader\");\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= types.RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= types.RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup.BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup.UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup.BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup.BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexports.Shader = Shader;\n//# sourceMappingURL=Shader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/ShaderSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/ShaderSystem.js ***!
  \************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=ShaderSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/ShaderSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar unsafeEvalSupported = __webpack_require__(/*! ../../../../utils/browser/unsafeEvalSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js\");\nvar Buffer = __webpack_require__(/*! ../buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar _const = __webpack_require__(/*! ../buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported.unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer.Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: _const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer.Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: _const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexports.UboSystem = UboSystem;\n//# sourceMappingURL=UboSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar createIdFromString = __webpack_require__(/*! ../utils/createIdFromString.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js\");\nvar types = __webpack_require__(/*! ./types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js\");\nvar getDefaultUniformValue = __webpack_require__(/*! ./utils/getDefaultUniformValue.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js\");\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid.uid(\"uniform\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"uniformGroup\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid.uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!types.UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${types.UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue.getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString.createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexports.UniformGroup = UniformGroup;\n//# sourceMappingURL=UniformGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexports.ShaderStage = ShaderStage;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\",\n  \"vec2<i32>\",\n  \"vec3<i32>\",\n  \"vec4<i32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexports.UNIFORM_TYPES_MAP = UNIFORM_TYPES_MAP;\nexports.UNIFORM_TYPES_VALUES = UNIFORM_TYPES_VALUES;\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js\");\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {\n      const uniformParser = uniformParsers.uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers.uniformParsers[j][parserCode] || uniformParsers.uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexports.createUboSyncFunction = createUboSyncFunction;\n//# sourceMappingURL=createUboSyncFunction.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexports.getDefaultUniformValue = getDefaultUniformValue;\n//# sourceMappingURL=getDefaultUniformValue.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexports.uboSyncFunctionsSTD40 = uboSyncFunctionsSTD40;\nexports.uboSyncFunctionsWGSL = uboSyncFunctionsWGSL;\n//# sourceMappingURL=uboSyncFunctions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexports.uniformParsers = uniformParsers;\n//# sourceMappingURL=uniformParsers.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar sayHello = __webpack_require__(/*! ../../../../utils/sayHello.js */ \"./node_modules/pixi.js/lib/utils/sayHello.js\");\nvar types = __webpack_require__(/*! ../../types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === types.RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello.sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexports.HelloSystem = HelloSystem;\n//# sourceMappingURL=HelloSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexports.State = State;\n//# sourceMappingURL=State.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexports.BLEND_TO_NPM = BLEND_TO_NPM;\nexports.STENCIL_MODES = STENCIL_MODES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.js\");\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return _const.BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexports.getAdjustedBlendModeBlend = getAdjustedBlendModeBlend;\n//# sourceMappingURL=getAdjustedBlendModeBlend.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar autoDetectEnvironment = __webpack_require__(/*! ../../../../environment/autoDetectEnvironment.js */ \"./node_modules/pixi.js/lib/environment/autoDetectEnvironment.js\");\nvar Container = __webpack_require__(/*! ../../../../scene/container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar unsafeEvalSupported = __webpack_require__(/*! ../../../../utils/browser/unsafeEvalSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n__webpack_require__(/*! ../../../../utils/utils.js */ \"./node_modules/pixi.js/lib/utils/utils.js\");\nvar _const = __webpack_require__(/*! ../../gl/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/const.js\");\nvar SystemRunner = __webpack_require__(/*! ./SystemRunner.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js\");\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\n\n\"use strict\";\nconst defaultRunners = [\n  \"init\",\n  \"destroy\",\n  \"contextChange\",\n  \"resolutionChange\",\n  \"resetState\",\n  \"renderEnd\",\n  \"renderStart\",\n  \"render\",\n  \"update\",\n  \"postrender\",\n  \"prerender\"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends EventEmitter {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    /** @internal */\n    this.uid = uid.uid(\"renderer\");\n    /** @internal */\n    this.runners = /* @__PURE__ */ Object.create(null);\n    /** @internal */\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await autoDetectEnvironment.loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container.Container) {\n      options = { container: options };\n      if (deprecated) {\n        deprecation.deprecation(deprecation.v8_0_0, \"passing a second argument is deprecated, please use render options instead\");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor ?? (options.clearColor = this.background.colorRgba);\n      options.clear ?? (options.clear = this.background.clearBeforeRender);\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color.Color.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    options.container.enableRenderGroup();\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  /**\n   * Clears the render target.\n   * @param options - The options to use when clearing the render target.\n   * @param options.target - The render target to clear.\n   * @param options.clearColor - The color to clear with.\n   * @param options.clear - The clear mode to use.\n   * @advanced\n   */\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = _const.CLEAR.ALL);\n    const { clear, clearColor, target } = options;\n    Color.Color.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color.Color.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @type {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner.SystemRunner(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!unsafeEvalSupported.unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  /**\n   * Resets the rendering state of the renderer.\n   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n   * render will reset all internal caches and ensure it executes correctly.\n   *\n   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n   * ```js\n   * // Reset Three.js state\n   * threeRenderer.resetState();\n   *\n   * // Render a Three.js scene\n   * threeRenderer.render(threeScene, threeCamera);\n   *\n   * // Reset PixiJS state since Three.js modified the WebGL context\n   * pixiRenderer.resetState();\n   *\n   * // Now render Pixi content\n   * pixiRenderer.render(pixiScene);\n   * ```\n   * @advanced\n   */\n  resetState() {\n    this.runners.resetState.emit();\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\nexports.AbstractRenderer = AbstractRenderer;\n//# sourceMappingURL=AbstractRenderer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar CustomRenderPipe = __webpack_require__(/*! ../../../../scene/container/CustomRenderPipe.js */ \"./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js\");\nvar RenderGroupPipe = __webpack_require__(/*! ../../../../scene/container/RenderGroupPipe.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js\");\nvar RenderGroupSystem = __webpack_require__(/*! ../../../../scene/container/RenderGroupSystem.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js\");\nvar SpritePipe = __webpack_require__(/*! ../../../../scene/sprite/SpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js\");\nvar globalHooks = __webpack_require__(/*! ../../../../utils/global/globalHooks.js */ \"./node_modules/pixi.js/lib/utils/global/globalHooks.js\");\nvar BatcherPipe = __webpack_require__(/*! ../../../batcher/shared/BatcherPipe.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.js\");\nvar AlphaMaskPipe = __webpack_require__(/*! ../../../mask/alpha/AlphaMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.js\");\nvar ColorMaskPipe = __webpack_require__(/*! ../../../mask/color/ColorMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.js\");\nvar StencilMaskPipe = __webpack_require__(/*! ../../../mask/stencil/StencilMaskPipe.js */ \"./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.js\");\nvar BackgroundSystem = __webpack_require__(/*! ../background/BackgroundSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.js\");\nvar BlendModePipe = __webpack_require__(/*! ../blendModes/BlendModePipe.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.js\");\nvar ExtractSystem = __webpack_require__(/*! ../extract/ExtractSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.js\");\nvar GenerateTextureSystem = __webpack_require__(/*! ../extract/GenerateTextureSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.js\");\nvar GlobalUniformSystem = __webpack_require__(/*! ../renderTarget/GlobalUniformSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.js\");\nvar SchedulerSystem = __webpack_require__(/*! ../SchedulerSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.js\");\nvar HelloSystem = __webpack_require__(/*! ../startup/HelloSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.js\");\nvar RenderableGCSystem = __webpack_require__(/*! ../texture/RenderableGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js\");\nvar TextureGCSystem = __webpack_require__(/*! ../texture/TextureGCSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js\");\nvar ViewSystem = __webpack_require__(/*! ../view/ViewSystem.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js\");\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem.BackgroundSystem,\n  GlobalUniformSystem.GlobalUniformSystem,\n  HelloSystem.HelloSystem,\n  ViewSystem.ViewSystem,\n  RenderGroupSystem.RenderGroupSystem,\n  TextureGCSystem.TextureGCSystem,\n  GenerateTextureSystem.GenerateTextureSystem,\n  ExtractSystem.ExtractSystem,\n  globalHooks.RendererInitHook,\n  RenderableGCSystem.RenderableGCSystem,\n  SchedulerSystem.SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe.BlendModePipe,\n  BatcherPipe.BatcherPipe,\n  SpritePipe.SpritePipe,\n  RenderGroupPipe.RenderGroupPipe,\n  AlphaMaskPipe.AlphaMaskPipe,\n  StencilMaskPipe.StencilMaskPipe,\n  ColorMaskPipe.ColorMaskPipe,\n  CustomRenderPipe.CustomRenderPipe\n];\n\nexports.SharedRenderPipes = SharedRenderPipes;\nexports.SharedSystems = SharedSystems;\n//# sourceMappingURL=SharedSystems.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/System.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/System.js ***!
  \******************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=System.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/system/System.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /* jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```ts\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\nexports.SystemRunner = SystemRunner;\n//# sourceMappingURL=SystemRunner.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/utils/typeUtils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/utils/typeUtils.js ***!
  \***************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=typeUtils.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/system/utils/typeUtils.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar pow2 = __webpack_require__(/*! ../../../../maths/misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = adapter.DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = pow2.nextPow2(minWidth);\n    minHeight = pow2.nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexports.CanvasPool = CanvasPool;\nexports.CanvasPoolClass = CanvasPoolClass;\n//# sourceMappingURL=CanvasPool.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/GenerateCanvas.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/GenerateCanvas.js ***!
  \***************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=GenerateCanvas.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/GenerateCanvas.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureSource = __webpack_require__(/*! ./sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ./Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nclass RenderTexture extends Texture.Texture {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource.TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexports.RenderTexture = RenderTexture;\n//# sourceMappingURL=RenderTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar clean = __webpack_require__(/*! ../../../../utils/data/clean.js */ \"./node_modules/pixi.js/lib/utils/data/clean.js\");\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = clean.cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            clean.cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexports.RenderableGCSystem = RenderableGCSystem;\n//# sourceMappingURL=RenderableGCSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar groupD8 = __webpack_require__(/*! ../../../../maths/matrix/groupD8.js */ \"./node_modules/pixi.js/lib/maths/matrix/groupD8.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar NOOP = __webpack_require__(/*! ../../../../utils/misc/NOOP.js */ \"./node_modules/pixi.js/lib/utils/misc/NOOP.js\");\nvar BufferImageSource = __webpack_require__(/*! ./sources/BufferImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js\");\nvar TextureSource = __webpack_require__(/*! ./sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar TextureMatrix = __webpack_require__(/*! ./TextureMatrix.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js\");\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid.uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle.Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource.TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix.TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.groupD8.add(rotate, groupD8.groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n   */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation.deprecation(deprecation.v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource.TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP.NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource.BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP.NOOP;\n\nexports.Texture = Texture;\n//# sourceMappingURL=Texture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexports.TextureGCSystem = TextureGCSystem;\n//# sourceMappingURL=TextureGCSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\n\n\"use strict\";\nconst tempMat = new Matrix.Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix.Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexports.TextureMatrix = TextureMatrix;\n//# sourceMappingURL=TextureMatrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar pow2 = __webpack_require__(/*! ../../../../maths/misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\nvar TextureSource = __webpack_require__(/*! ./sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ./Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TextureStyle = __webpack_require__(/*! ./TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n    this.textureStyle = new TextureStyle.TextureStyle(this.textureOptions);\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource.TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: false\n    });\n    return new Texture.Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = pow2.nextPow2(po2Width);\n    po2Height = pow2.nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n   * useful if you modified the style of the texture after getting it from the pool.\n   * @param renderTexture - The renderTexture to free\n   * @param resetStyle - Whether to reset the style of the texture to the default texture style\n   */\n  returnTexture(renderTexture, resetStyle = false) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    if (resetStyle) {\n      renderTexture.source.style = this.textureStyle;\n    }\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexports.TexturePool = TexturePool;\nexports.TexturePoolClass = TexturePoolClass;\n//# sourceMappingURL=TexturePool.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid.uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    /** @internal */\n    this._resourceType = \"textureSampler\";\n    /** @internal */\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation.deprecation(deprecation.v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexports.TextureStyle = TextureStyle;\n//# sourceMappingURL=TextureStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar groupD8 = __webpack_require__(/*! ../../../../maths/matrix/groupD8.js */ \"./node_modules/pixi.js/lib/maths/matrix/groupD8.js\");\n\n\"use strict\";\nclass TextureUvs {\n  constructor() {\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsFloat32 = new Float32Array(8);\n  }\n  /**\n   * Sets the texture Uvs based on the given frame information.\n   * @protected\n   * @param frame - The frame of the texture\n   * @param baseFrame - The base frame of the texture\n   * @param rotate - Rotation of frame, see {@link groupD8}\n   */\n  set(frame, baseFrame, rotate) {\n    const tw = baseFrame.width;\n    const th = baseFrame.height;\n    if (rotate) {\n      const w2 = frame.width / 2 / tw;\n      const h2 = frame.height / 2 / th;\n      const cX = frame.x / tw + w2;\n      const cY = frame.y / th + h2;\n      rotate = groupD8.groupD8.add(rotate, groupD8.groupD8.NW);\n      this.x0 = cX + w2 * groupD8.groupD8.uX(rotate);\n      this.y0 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      this.x1 = cX + w2 * groupD8.groupD8.uX(rotate);\n      this.y1 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      this.x2 = cX + w2 * groupD8.groupD8.uX(rotate);\n      this.y2 = cY + h2 * groupD8.groupD8.uY(rotate);\n      rotate = groupD8.groupD8.add(rotate, 2);\n      this.x3 = cX + w2 * groupD8.groupD8.uX(rotate);\n      this.y3 = cY + h2 * groupD8.groupD8.uY(rotate);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n    this.uvsFloat32[0] = this.x0;\n    this.uvsFloat32[1] = this.y0;\n    this.uvsFloat32[2] = this.x1;\n    this.uvsFloat32[3] = this.y1;\n    this.uvsFloat32[4] = this.x2;\n    this.uvsFloat32[5] = this.y2;\n    this.uvsFloat32[6] = this.x3;\n    this.uvsFloat32[7] = this.y3;\n  }\n  toString() {\n    return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;\n  }\n}\n\nexports.TextureUvs = TextureUvs;\n//# sourceMappingURL=TextureUvs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nvar DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {\n  DEPRECATED_WRAP_MODES2[\"CLAMP\"] = \"clamp-to-edge\";\n  DEPRECATED_WRAP_MODES2[\"REPEAT\"] = \"repeat\";\n  DEPRECATED_WRAP_MODES2[\"MIRRORED_REPEAT\"] = \"mirror-repeat\";\n  return DEPRECATED_WRAP_MODES2;\n})(DEPRECATED_WRAP_MODES || {});\nconst WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {\n  get(target, prop) {\n    deprecation.deprecation(deprecation.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);\n    return target[prop];\n  }\n});\nvar DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {\n  DEPRECATED_SCALE_MODES2[\"NEAREST\"] = \"nearest\";\n  DEPRECATED_SCALE_MODES2[\"LINEAR\"] = \"linear\";\n  return DEPRECATED_SCALE_MODES2;\n})(DEPRECATED_SCALE_MODES || {});\nconst SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {\n  get(target, prop) {\n    deprecation.deprecation(deprecation.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);\n    return target[prop];\n  }\n});\n\nexports.DEPRECATED_SCALE_MODES = DEPRECATED_SCALE_MODES;\nexports.DEPRECATED_WRAP_MODES = DEPRECATED_WRAP_MODES;\nexports.SCALE_MODES = SCALE_MODES;\nexports.WRAP_MODES = WRAP_MODES;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TextureSource = __webpack_require__(/*! ./TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nclass BufferImageSource extends TextureSource.TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = Extensions.ExtensionType.TextureSource;\n\nexports.BufferImageSource = BufferImageSource;\n//# sourceMappingURL=BufferImageSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TextureSource = __webpack_require__(/*! ./TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nclass CanvasSource extends TextureSource.TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = adapter.DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    this.resizeCanvas();\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity && \"style\" in this.resource) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n  /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */\n  get context2D() {\n    return this._context2D || (this._context2D = this.resource.getContext(\"2d\"));\n  }\n}\nCanvasSource.extension = Extensions.ExtensionType.TextureSource;\n\nexports.CanvasSource = CanvasSource;\n//# sourceMappingURL=CanvasSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureSource = __webpack_require__(/*! ./TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nclass CompressedSource extends TextureSource.TextureSource {\n  constructor(options) {\n    super(options);\n    this.uploadMethodId = \"compressed\";\n    this.resource = options.resource;\n    this.mipLevelCount = this.resource.length;\n  }\n}\n\nexports.CompressedSource = CompressedSource;\n//# sourceMappingURL=CompressedSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TextureSource = __webpack_require__(/*! ./TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nclass ImageSource extends TextureSource.TextureSource {\n  constructor(options) {\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = Extensions.ExtensionType.TextureSource;\n\nexports.ImageSource = ImageSource;\n//# sourceMappingURL=ImageSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar pow2 = __webpack_require__(/*! ../../../../../maths/misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\nvar definedProps = __webpack_require__(/*! ../../../../../scene/container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar uid = __webpack_require__(/*! ../../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar TextureStyle = __webpack_require__(/*! ../TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid.uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     * @internal\n     */\n    this._resourceId = uid.uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    /** @internal */\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle.TextureStyle(definedProps.definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid.uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution || (resolution = this._resolution);\n    width || (width = this.width);\n    height || (height = this.height);\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid.uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = pow2.isPow2(this.pixelWidth) && pow2.isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexports.TextureSource = TextureSource;\n//# sourceMappingURL=TextureSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Ticker = __webpack_require__(/*! ../../../../../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\nvar detectVideoAlphaMode = __webpack_require__(/*! ../../../../../utils/browser/detectVideoAlphaMode.js */ \"./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js\");\nvar TextureSource = __webpack_require__(/*! ./TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource.TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode.detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = Extensions.ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexports.VideoSource = VideoSource;\n//# sourceMappingURL=VideoSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar CanvasSource = __webpack_require__(/*! ../sources/CanvasSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.js\");\nvar Texture = __webpack_require__(/*! ../Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture.Texture({\n      source: new CanvasSource.CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexports.getCanvasTexture = getCanvasTexture;\nexports.hasCachedCanvasTexture = hasCachedCanvasTexture;\n//# sourceMappingURL=getCanvasTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isWebGLSupported = __webpack_require__(/*! ../../../../../utils/browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ../../../../../utils/browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\nvar getSupportedGlCompressedTextureFormats = __webpack_require__(/*! ../../../gl/texture/utils/getSupportedGlCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.js\");\nvar getSupportedGPUCompressedTextureFormats = __webpack_require__(/*! ../../../gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.js\");\n\n\"use strict\";\nlet supportedCompressedTextureFormats;\nasync function getSupportedCompressedTextureFormats() {\n  if (supportedCompressedTextureFormats !== void 0)\n    return supportedCompressedTextureFormats;\n  supportedCompressedTextureFormats = await (async () => {\n    const _isWebGPUSupported = await isWebGPUSupported.isWebGPUSupported();\n    const _isWebGLSupported = isWebGLSupported.isWebGLSupported();\n    if (_isWebGPUSupported && _isWebGLSupported) {\n      const gpuTextureFormats = await getSupportedGPUCompressedTextureFormats.getSupportedGPUCompressedTextureFormats();\n      const glTextureFormats = getSupportedGlCompressedTextureFormats.getSupportedGlCompressedTextureFormats();\n      return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));\n    } else if (_isWebGPUSupported) {\n      return await getSupportedGPUCompressedTextureFormats.getSupportedGPUCompressedTextureFormats();\n    } else if (_isWebGLSupported) {\n      return getSupportedGlCompressedTextureFormats.getSupportedGlCompressedTextureFormats();\n    }\n    return [];\n  })();\n  return supportedCompressedTextureFormats;\n}\n\nexports.getSupportedCompressedTextureFormats = getSupportedCompressedTextureFormats;\n//# sourceMappingURL=getSupportedCompressedTextureFormats.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getSupportedCompressedTextureFormats = __webpack_require__(/*! ./getSupportedCompressedTextureFormats.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.js\");\n\n\"use strict\";\nconst nonCompressedFormats = [\n  // 8-bit formats\n  \"r8unorm\",\n  \"r8snorm\",\n  \"r8uint\",\n  \"r8sint\",\n  // 16-bit formats\n  \"r16uint\",\n  \"r16sint\",\n  \"r16float\",\n  \"rg8unorm\",\n  \"rg8snorm\",\n  \"rg8uint\",\n  \"rg8sint\",\n  // 32-bit formats\n  \"r32uint\",\n  \"r32sint\",\n  \"r32float\",\n  \"rg16uint\",\n  \"rg16sint\",\n  \"rg16float\",\n  \"rgba8unorm\",\n  \"rgba8unorm-srgb\",\n  \"rgba8snorm\",\n  \"rgba8uint\",\n  \"rgba8sint\",\n  \"bgra8unorm\",\n  \"bgra8unorm-srgb\",\n  // Packed 32-bit formats\n  \"rgb9e5ufloat\",\n  \"rgb10a2unorm\",\n  \"rg11b10ufloat\",\n  // 64-bit formats\n  \"rg32uint\",\n  \"rg32sint\",\n  \"rg32float\",\n  \"rgba16uint\",\n  \"rgba16sint\",\n  \"rgba16float\",\n  // 128-bit formats\n  \"rgba32uint\",\n  \"rgba32sint\",\n  \"rgba32float\",\n  // Depth/stencil formats\n  \"stencil8\",\n  \"depth16unorm\",\n  \"depth24plus\",\n  \"depth24plus-stencil8\",\n  \"depth32float\",\n  // \"depth32float-stencil8\" feature\n  \"depth32float-stencil8\"\n];\nlet supportedTextureFormats;\nasync function getSupportedTextureFormats() {\n  if (supportedTextureFormats !== void 0)\n    return supportedTextureFormats;\n  const compressedTextureFormats = await getSupportedCompressedTextureFormats.getSupportedCompressedTextureFormats();\n  supportedTextureFormats = [\n    ...nonCompressedFormats,\n    ...compressedTextureFormats\n  ];\n  return supportedTextureFormats;\n}\n\nexports.getSupportedTextureFormats = getSupportedTextureFormats;\nexports.nonCompressedFormats = nonCompressedFormats;\n//# sourceMappingURL=getSupportedTextureFormats.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cache = __webpack_require__(/*! ../../../../../assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar Extensions = __webpack_require__(/*! ../../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TextureSource = __webpack_require__(/*! ../sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst sources = [];\nExtensions.extensions.handleByList(Extensions.ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.Cache.has(resource)) {\n    return Cache.Cache.get(resource);\n  }\n  const texture = new Texture.Texture({ source: textureSourceFrom(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.Cache.has(resource)) {\n      Cache.Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.Cache.get(id);\n  } else if (id instanceof TextureSource.TextureSource) {\n    return new Texture.Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.Texture.from = textureFrom;\nTextureSource.TextureSource.from = textureSourceFrom;\n\nexports.autoDetectSource = autoDetectSource;\nexports.resourceToTexture = resourceToTexture;\nexports.textureFrom = textureFrom;\n//# sourceMappingURL=textureFrom.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexports.createIdFromString = createIdFromString;\n//# sourceMappingURL=createIdFromString.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction parseFunctionBody(fn) {\n  const fnStr = fn.toString();\n  const bodyStart = fnStr.indexOf(\"{\");\n  const bodyEnd = fnStr.lastIndexOf(\"}\");\n  if (bodyStart === -1 || bodyEnd === -1) {\n    throw new Error(\"getFunctionBody: No body found in function definition\");\n  }\n  return fnStr.slice(bodyStart + 1, bodyEnd).trim();\n}\n\nexports.parseFunctionBody = parseFunctionBody;\n//# sourceMappingURL=parseFunctionBody.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/view/View.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/view/View.js ***!
  \**************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=View.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/view/View.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar RenderTarget = __webpack_require__(/*! ../renderTarget/RenderTarget.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.js\");\nvar getCanvasTexture = __webpack_require__(/*! ../texture/utils/getCanvasTexture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.js\");\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @type {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation.deprecation(deprecation.v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle.Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || adapter.DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture.getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget.RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @example\n   * viewSystem.destroy();\n   * viewSystem.destroy(true);\n   * viewSystem.destroy({ removeView: true });\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexports.ViewSystem = ViewSystem;\n//# sourceMappingURL=ViewSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexports.RendererType = RendererType;\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/rendering/renderers/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/Container.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/Container.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar Color = __webpack_require__(/*! ../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar cullingMixin = __webpack_require__(/*! ../../culling/cullingMixin.js */ \"./node_modules/pixi.js/lib/culling/cullingMixin.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar _const = __webpack_require__(/*! ../../maths/misc/const.js */ \"./node_modules/pixi.js/lib/maths/misc/const.js\");\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar uid = __webpack_require__(/*! ../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar PoolGroup = __webpack_require__(/*! ../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar cacheAsTextureMixin = __webpack_require__(/*! ./container-mixins/cacheAsTextureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js\");\nvar childrenHelperMixin = __webpack_require__(/*! ./container-mixins/childrenHelperMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js\");\nvar collectRenderablesMixin = __webpack_require__(/*! ./container-mixins/collectRenderablesMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js\");\nvar effectsMixin = __webpack_require__(/*! ./container-mixins/effectsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js\");\nvar findMixin = __webpack_require__(/*! ./container-mixins/findMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js\");\nvar getFastGlobalBoundsMixin = __webpack_require__(/*! ./container-mixins/getFastGlobalBoundsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js\");\nvar getGlobalMixin = __webpack_require__(/*! ./container-mixins/getGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js\");\nvar measureMixin = __webpack_require__(/*! ./container-mixins/measureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js\");\nvar onRenderMixin = __webpack_require__(/*! ./container-mixins/onRenderMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js\");\nvar sortMixin = __webpack_require__(/*! ./container-mixins/sortMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js\");\nvar toLocalGlobalMixin = __webpack_require__(/*! ./container-mixins/toLocalGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js\");\nvar RenderGroup = __webpack_require__(/*! ./RenderGroup.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroup.js\");\nvar assignWithIgnore = __webpack_require__(/*! ./utils/assignWithIgnore.js */ \"./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js\");\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint.ObservablePoint(null);\nconst defaultPivot = new ObservablePoint.ObservablePoint(null);\nconst defaultScale = new ObservablePoint.ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /**\n     * unique id for this container\n     * @internal\n     */\n    this.uid = uid.uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * // Access children\n     * const firstChild = container.children[0];\n     * const lastChild = container.children[container.children.length - 1];\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    this.children = [];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @example\n     * ```ts\n     * // Basic parent access\n     * const parent = sprite.parent;\n     *\n     * // Walk up the tree\n     * let current = sprite;\n     * while (current.parent) {\n     *     console.log('Level up:', current.parent.constructor.name);\n     *     current = current.parent;\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /** @internal */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * This matrix represents the local transformation without any parent influence.\n     * @example\n     * ```ts\n     * // Basic transform access\n     * const localMatrix = sprite.localTransform;\n     * console.log(localMatrix.toString());\n     * ```\n     * @readonly\n     * @see {@link Container#worldTransform} For global transform\n     * @see {@link Container#groupTransform} For render group transform\n     */\n    this.localTransform = new Matrix.Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     * @advanced\n     */\n    this.relativeGroupTransform = new Matrix.Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     * @advanced\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /**\n     * Whether this object has been destroyed. If true, the object should no longer be used.\n     * After an object is destroyed, all of its functionality is disabled and references are removed.\n     * @example\n     * ```ts\n     * // Cleanup with destroy\n     * sprite.destroy();\n     * console.log(sprite.destroyed); // true\n     * ```\n     * @default false\n     * @see {@link Container#destroy} For destroying objects\n     */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     */\n    this._position = new ObservablePoint.ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    /** @internal */\n    this.localColor = 16777215;\n    /** @internal */\n    this.localAlpha = 1;\n    /** @internal */\n    this.groupAlpha = 1;\n    // A\n    /** @internal */\n    this.groupColor = 16777215;\n    // BGR\n    /** @internal */\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /** @internal */\n    this.localBlendMode = \"inherit\";\n    /** @internal */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /** @internal */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore.assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   * @deprecated since 8.8.0\n   */\n  static mixin(source) {\n    deprecation.deprecation(\"8.8.0\", \"Container.mixin is deprecated, please use extensions.mixin instead.\");\n    Extensions.extensions.mixin(Container, source);\n  }\n  // = 'default';\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  /** @ignore */\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   * The children will be rendered as part of this container's display list.\n   * @example\n   * ```ts\n   * // Add a single child\n   * container.addChild(sprite);\n   *\n   * // Add multiple children\n   * container.addChild(background, player, foreground);\n   *\n   * // Add with type checking\n   * const sprite = container.addChild<Sprite>(new Sprite(texture));\n   * sprite.tint = 'red';\n   * ```\n   * @param children - The Container(s) to add to the container\n   * @returns The first child that was added\n   * @see {@link Container#removeChild} For removing children\n   * @see {@link Container#addChildAt} For adding at specific index\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation.deprecation(deprecation.v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * When removing multiple children, events will be triggered for each child in sequence.\n   * @example\n   * ```ts\n   * // Remove a single child\n   * const removed = container.removeChild(sprite);\n   *\n   * // Remove multiple children\n   * const bg = container.removeChild(background, player, userInterface);\n   *\n   * // Remove with type checking\n   * const sprite = container.removeChild<Sprite>(childSprite);\n   * sprite.texture = newTexture;\n   * ```\n   * @param children - The Container(s) to remove\n   * @returns The first child that was removed\n   * @see {@link Container#addChild} For adding children\n   * @see {@link Container#removeChildren} For removing multiple children\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      if (child.parentRenderLayer) {\n        child.parentRenderLayer.detach(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   * @advanced\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   * @advanced\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = PoolGroup.BigPool.get(RenderGroup.RenderGroup, this);\n    this.groupTransform = Matrix.Matrix.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /**\n   * This will disable the render group for this container.\n   * @advanced\n   */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    PoolGroup.BigPool.return(this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   *\n   * This matrix represents the absolute transformation in the scene graph.\n   * @example\n   * ```ts\n   * // Get world position\n   * const worldPos = container.worldTransform;\n   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n   * ```\n   * @readonly\n   * @see {@link Container#localTransform} For local space transform\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix.Matrix());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   *\n   * An alias to position.x\n   * @example\n   * ```ts\n   * // Basic position\n   * container.x = 100;\n   * ```\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   *\n   * An alias to position.y\n   * @example\n   * ```ts\n   * // Basic position\n   * container.y = 200;\n   * ```\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @example\n   * ```ts\n   * // Basic position setting\n   * container.position.set(100, 200);\n   * container.position.set(100); // Sets both x and y to 100\n   * // Using point data\n   * container.position = { x: 50, y: 75 };\n   * ```\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   *\n   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n   * > rotation is in radians, angle is in degrees.\n   * @example\n   * ```ts\n   * // Basic rotation\n   * container.rotation = Math.PI / 4; // 45 degrees\n   *\n   * // Convert from degrees\n   * const degrees = 45;\n   * container.rotation = degrees * Math.PI / 180;\n   *\n   * // Rotate around center\n   * container.pivot.set(container.width / 2, container.height / 2);\n   * container.rotation = Math.PI; // 180 degrees\n   * ```\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   *\n   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n   * > rotation is in radians, angle is in degrees.\n   @example\n   * ```ts\n   * // Basic angle rotation\n   * sprite.angle = 45; // 45 degrees\n   *\n   * // Rotate around center\n   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n   * sprite.angle = 180; // Half rotation\n   *\n   * // Reset rotation\n   * sprite.angle = 0;\n   * ```\n   */\n  get angle() {\n    return this.rotation * _const.RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * _const.DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space.\n   * The `position` is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @example\n   * ```ts\n   * // Rotate around center\n   * container.pivot.set(container.width / 2, container.height / 2);\n   * container.rotation = Math.PI; // Rotates around center\n   * ```\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint.ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint.ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians. Skewing is a transformation that distorts\n   * the object by rotating it differently at each point, creating a non-uniform shape.\n   * @example\n   * ```ts\n   * // Basic skewing\n   * container.skew.set(0.5, 0); // Skew horizontally\n   * container.skew.set(0, 0.5); // Skew vertically\n   *\n   * // Skew with point data\n   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n   *\n   * // Reset skew\n   * container.skew.set(0, 0);\n   *\n   * // Animate skew\n   * app.ticker.add(() => {\n   *     // Create wave effect\n   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n   * });\n   *\n   * // Combine with rotation\n   * container.rotation = Math.PI / 4; // 45 degrees\n   * container.skew.set(0.2, 0.2); // Skew the rotated object\n   * ```\n   * @since 4.0.0\n   * @type {ObservablePoint} Point-like object with x/y properties in radians\n   * @default {x: 0, y: 0}\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint.ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint.ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @example\n   * ```ts\n   * // Basic scaling\n   * container.scale.set(2, 2); // Scales to double size\n   * container.scale.set(2); // Scales uniformly to double size\n   * container.scale = 2; // Scales uniformly to double size\n   * // Scale to a specific width and height\n   * container.setSize(200, 100); // Sets width to 200 and height to 100\n   * ```\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint.ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint.ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n   * as it is more optimized by not recalculating the local bounds twice.\n   *  @example\n   * ```ts\n   * // Basic width setting\n   * container.width = 100;\n   * // Optimized width setting\n   * container.setSize(100, 100);\n   * ```\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container,\n   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n   * as it is more optimized by not recalculating the local bounds twice.\n   * @example\n   * ```ts\n   * // Basic height setting\n   * container.height = 200;\n   * // Optimized height setting\n   * container.setSize(100, 200);\n   * ```\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   *\n   * This is faster than get the width and height separately.\n   * @example\n   * ```ts\n   * // Basic size retrieval\n   * const size = container.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * container.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is more efficient than setting width and height separately as it only recalculates bounds once.\n   * @example\n   * ```ts\n   * // Basic size setting\n   * container.setSize(100, 200);\n   *\n   * // Set uniform size\n   * container.setSize(100); // Sets both width and height to 100\n   * ```\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container.\n   * Allows partial updates of transform properties for optimized manipulation.\n   * @example\n   * ```ts\n   * // Basic transform update\n   * container.updateTransform({\n   *     x: 100,\n   *     y: 200,\n   *     rotation: Math.PI / 4\n   * });\n   *\n   * // Scale and rotate around center\n   * sprite.updateTransform({\n   *     pivotX: sprite.width / 2,\n   *     pivotY: sprite.height / 2,\n   *     scaleX: 2,\n   *     scaleY: 2,\n   *     rotation: Math.PI\n   * });\n   *\n   * // Update position only\n   * button.updateTransform({\n   *     x: button.x + 10, // Move right\n   *     y: button.y      // Keep same y\n   * });\n   * ```\n   * @param opts - Transform options to update\n   * @param opts.x - The x position\n   * @param opts.y - The y position\n   * @param opts.scaleX - The x-axis scale factor\n   * @param opts.scaleY - The y-axis scale factor\n   * @param opts.rotation - The rotation in radians\n   * @param opts.skewX - The x-axis skew factor\n   * @param opts.skewY - The y-axis skew factor\n   * @param opts.pivotX - The x-axis pivot point\n   * @param opts.pivotY - The y-axis pivot point\n   * @returns This container, for chaining\n   * @see {@link Container#setFromMatrix} For matrix-based transforms\n   * @see {@link Container#position} For direct position access\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform properties by decomposing the given matrix.\n   * Extracts position, scale, rotation, and skew from a transformation matrix.\n   * @example\n   * ```ts\n   * // Basic matrix transform\n   * const matrix = new Matrix()\n   *     .translate(100, 100)\n   *     .rotate(Math.PI / 4)\n   *     .scale(2, 2);\n   *\n   * container.setFromMatrix(matrix);\n   *\n   * // Copy transform from another container\n   * const source = new Container();\n   * source.position.set(100, 100);\n   * source.rotation = Math.PI / 2;\n   *\n   * target.setFromMatrix(source.localTransform);\n   *\n   * // Reset transform\n   * container.setFromMatrix(Matrix.IDENTITY);\n   * ```\n   * @param matrix - The matrix to use for updating the transform\n   * @see {@link Container#updateTransform} For property-based updates\n   * @see {@link Matrix#decompose} For matrix decomposition details\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The opacity of the object relative to its parent's opacity.\n   * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n   * @example\n   * ```ts\n   * // Basic transparency\n   * sprite.alpha = 0.5; // 50% opacity\n   *\n   * // Inherited opacity\n   * container.alpha = 0.5;\n   * const child = new Sprite(texture);\n   * child.alpha = 0.5;\n   * container.addChild(child);\n   * // child's effective opacity is 0.25 (0.5 * 0.5)\n   * ```\n   * @default 1\n   * @see {@link Container#visible} For toggling visibility\n   * @see {@link Container#renderable} For render control\n   */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite.\n   *\n   * This can be any valid {@link ColorSource}.\n   * @example\n   * ```ts\n   * // Basic color tinting\n   * container.tint = 0xff0000; // Red tint\n   * container.tint = 'red';    // Same as above\n   * container.tint = '#00ff00'; // Green\n   * container.tint = 'rgb(0,0,255)'; // Blue\n   *\n   * // Remove tint\n   * container.tint = 0xffffff; // White = no tint\n   * container.tint = null;     // Also removes tint\n   * ```\n   * @default 0xFFFFFF\n   * @see {@link Container#alpha} For transparency\n   * @see {@link Container#visible} For visibility control\n   */\n  get tint() {\n    return getGlobalMixin.bgr2rgb(this.localColor);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n   *\n   * Setting to 'normal' will reset to default blending.\n   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n   * @example\n   * ```ts\n   * // Basic blend modes\n   * sprite.blendMode = 'add';        // Additive blending\n   * sprite.blendMode = 'multiply';   // Multiply colors\n   * sprite.blendMode = 'screen';     // Screen blend\n   *\n   * // Reset blend mode\n   * sprite.blendMode = 'normal';     // Normal blending\n   * ```\n   * @default 'normal'\n   * @see {@link Container#alpha} For transparency\n   * @see {@link Container#tint} For color adjustments\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /**\n   * The visibility of the object. If false the object will not be drawn,\n   * and the transform will not be updated.\n   * @example\n   * ```ts\n   * // Basic visibility toggle\n   * sprite.visible = false; // Hide sprite\n   * sprite.visible = true;  // Show sprite\n   * ```\n   * @default true\n   * @see {@link Container#renderable} For render-only control\n   * @see {@link Container#alpha} For transparency\n   */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /**\n   * Controls whether this object can be rendered. If false the object will not be drawn,\n   * but the transform will still be updated. This is different from visible, which skips\n   * transform updates.\n   * @example\n   * ```ts\n   * // Basic render control\n   * sprite.renderable = false; // Skip rendering\n   * sprite.renderable = true;  // Enable rendering\n   * ```\n   * @default true\n   * @see {@link Container#visible} For skipping transform updates\n   * @see {@link Container#alpha} For transparency\n   */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /**\n   * Whether or not the object should be rendered.\n   * @advanced\n   */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * ```ts\n   * container.destroy();\n   * container.destroy(true);\n   * container.destroy({ children: true });\n   * container.destroy({ children: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    let oldChildren;\n    if (this.children.length) {\n      oldChildren = this.removeChildren(0, this.children.length);\n    }\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    if (destroyChildren && oldChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nExtensions.extensions.mixin(\n  Container,\n  childrenHelperMixin.childrenHelperMixin,\n  getFastGlobalBoundsMixin.getFastGlobalBoundsMixin,\n  toLocalGlobalMixin.toLocalGlobalMixin,\n  onRenderMixin.onRenderMixin,\n  measureMixin.measureMixin,\n  effectsMixin.effectsMixin,\n  findMixin.findMixin,\n  sortMixin.sortMixin,\n  cullingMixin.cullingMixin,\n  cacheAsTextureMixin.cacheAsTextureMixin,\n  getGlobalMixin.getGlobalMixin,\n  collectRenderablesMixin.collectRenderablesMixin\n);\n\nexports.Container = Container;\nexports.UPDATE_BLEND = UPDATE_BLEND;\nexports.UPDATE_COLOR = UPDATE_COLOR;\nexports.UPDATE_TRANSFORM = UPDATE_TRANSFORM;\nexports.UPDATE_VISIBLE = UPDATE_VISIBLE;\n//# sourceMappingURL=Container.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/Container.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexports.CustomRenderPipe = CustomRenderPipe;\n//# sourceMappingURL=CustomRenderPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/Effect.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/Effect.js ***!
  \************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=Effect.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/Effect.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderContainer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderContainer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ViewContainer = __webpack_require__(/*! ../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\n\n\"use strict\";\nclass RenderContainer extends ViewContainer.ViewContainer {\n  /**\n   * @param options - The options for the container.\n   */\n  constructor(options) {\n    if (typeof options === \"function\") {\n      options = { render: options };\n    }\n    const { render, ...rest } = options;\n    super({\n      label: \"RenderContainer\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"customRender\";\n    /** @internal */\n    this.batched = false;\n    if (render)\n      this.render = render;\n    this.containsPoint = options.containsPoint ?? (() => false);\n    this.addBounds = options.addBounds ?? (() => false);\n  }\n  /** @private */\n  updateBounds() {\n    this._bounds.clear();\n    this.addBounds(this._bounds);\n  }\n  /**\n   * An overridable function that can be used to render the object using the current renderer.\n   * @param _renderer - The current renderer\n   */\n  render(_renderer) {\n  }\n}\n\nexports.RenderContainer = RenderContainer;\n//# sourceMappingURL=RenderContainer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/RenderContainer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroup.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroup.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar InstructionSet = __webpack_require__(/*! ../../rendering/renderers/shared/instructions/InstructionSet.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js\");\nvar TexturePool = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\n\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix.Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    this.gcTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet.InstructionSet();\n    this._onRenderContainers = [];\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    this.isCachedAsTexture = false;\n    this._matrixDirty = 7;\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      child._updateFlags = 15;\n      this.addChild(child);\n    }\n  }\n  enableCacheAsTexture(options = {}) {\n    this.textureOptions = options;\n    this.isCachedAsTexture = true;\n    this.textureNeedsUpdate = true;\n  }\n  disableCacheAsTexture() {\n    this.isCachedAsTexture = false;\n    if (this.texture) {\n      TexturePool.TexturePool.returnTexture(this.texture);\n      this.texture = null;\n    }\n  }\n  updateCacheTexture() {\n    this.textureNeedsUpdate = true;\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n    this.disableCacheAsTexture();\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7)\n      return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender(renderer) {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender(renderer);\n    }\n  }\n  destroy() {\n    this.disableCacheAsTexture();\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  invalidateMatrices() {\n    this._matrixDirty = 7;\n  }\n  /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */\n  get inverseWorldTransform() {\n    if ((this._matrixDirty & 1) === 0)\n      return this._inverseWorldTransform;\n    this._matrixDirty &= ~1;\n    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix.Matrix());\n    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n  }\n  /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */\n  get textureOffsetInverseTransform() {\n    if ((this._matrixDirty & 2) === 0)\n      return this._textureOffsetInverseTransform;\n    this._matrixDirty &= ~2;\n    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix.Matrix());\n    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(\n      -this._textureBounds.x,\n      -this._textureBounds.y\n    );\n  }\n  /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */\n  get inverseParentTextureTransform() {\n    if ((this._matrixDirty & 4) === 0)\n      return this._inverseParentTextureTransform;\n    this._matrixDirty &= ~4;\n    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n    if (parentCacheAsTexture) {\n      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix.Matrix());\n      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(\n        -parentCacheAsTexture._textureBounds.x,\n        -parentCacheAsTexture._textureBounds.y\n      );\n    }\n    return this.worldTransform;\n  }\n  /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */\n  get cacheToLocalTransform() {\n    if (!this._parentCacheAsTextureRenderGroup)\n      return null;\n    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n  }\n}\n\nexports.RenderGroup = RenderGroup;\n//# sourceMappingURL=RenderGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/RenderGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar PoolGroup = __webpack_require__(/*! ../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar BatchableSprite = __webpack_require__(/*! ../sprite/BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\nvar executeInstructions = __webpack_require__(/*! ./utils/executeInstructions.js */ \"./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js\");\n\n\"use strict\";\nconst tempMatrix = new Matrix.Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      PoolGroup.BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = PoolGroup.BigPool.get(BatchableSprite.BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295\n      });\n      executeInstructions.executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions.executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexports.RenderGroupPipe = RenderGroupPipe;\n//# sourceMappingURL=RenderGroupPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar TexturePool = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar Bounds = __webpack_require__(/*! ./bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar clearList = __webpack_require__(/*! ./utils/clearList.js */ \"./node_modules/pixi.js/lib/scene/container/utils/clearList.js\");\nvar executeInstructions = __webpack_require__(/*! ./utils/executeInstructions.js */ \"./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js\");\nvar updateRenderGroupTransforms = __webpack_require__(/*! ./utils/updateRenderGroupTransforms.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js\");\nvar validateRenderables = __webpack_require__(/*! ./utils/validateRenderables.js */ \"./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js\");\n\n\"use strict\";\nconst tempMatrix = new Matrix.Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions.executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.updateCacheTexture)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.TexturePool.returnTexture(renderGroup.texture);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        renderGroup.texture = TexturePool.TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds.Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.TexturePool.returnTexture(renderGroup.texture);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables.validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList.clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms.updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList.clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexports.RenderGroupSystem = RenderGroupSystem;\n//# sourceMappingURL=RenderGroupSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Rectangle = __webpack_require__(/*! ../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nconst defaultMatrix = new Matrix.Matrix();\nclass Bounds {\n  /**\n   * Creates a new Bounds object.\n   * @param minX - The minimum X coordinate of the bounds.\n   * @param minY - The minimum Y coordinate of the bounds.\n   * @param maxX - The maximum X coordinate of the bounds.\n   * @param maxY - The maximum Y coordinate of the bounds.\n   */\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /**\n     * The minimum X coordinate of the bounds.\n     * Represents the leftmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set left edge\n     * bounds.minX = 100;\n     * ```\n     * @default Infinity\n     */\n    this.minX = Infinity;\n    /**\n     * The minimum Y coordinate of the bounds.\n     * Represents the topmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set top edge\n     * bounds.minY = 100;\n     * ```\n     * @default Infinity\n     */\n    this.minY = Infinity;\n    /**\n     * The maximum X coordinate of the bounds.\n     * Represents the rightmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set right edge\n     * bounds.maxX = 200;\n     * // Get width\n     * const width = bounds.maxX - bounds.minX;\n     * ```\n     * @default -Infinity\n     */\n    this.maxX = -Infinity;\n    /**\n     * The maximum Y coordinate of the bounds.\n     * Represents the bottommost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set bottom edge\n     * bounds.maxY = 200;\n     * // Get height\n     * const height = bounds.maxY - bounds.minY;\n     * ```\n     * @default -Infinity\n     */\n    this.maxY = -Infinity;\n    /**\n     * The transformation matrix applied to this bounds object.\n     * Used when calculating bounds with transforms.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Apply translation matrix\n     * bounds.matrix = new Matrix()\n     *     .translate(100, 100);\n     *\n     * // Combine transformations\n     * bounds.matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * // Use in bounds calculations\n     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix\n     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix\n     * ```\n     * @advanced\n     */\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty, meaning either width or height is zero or negative.\n   * Empty bounds occur when min values exceed max values on either axis.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   *\n   * // Check if newly created bounds are empty\n   * console.log(bounds.isEmpty()); // true, default bounds are empty\n   *\n   * // Add frame and check again\n   * bounds.addFrame(0, 0, 100, 100);\n   * console.log(bounds.isEmpty()); // false, bounds now have area\n   *\n   * // Clear bounds\n   * bounds.clear();\n   * console.log(bounds.isEmpty()); // true, bounds are empty again\n   * ```\n   * @returns True if bounds are empty (have no area)\n   * @see {@link Bounds#clear} For resetting bounds\n   * @see {@link Bounds#isValid} For checking validity\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /**\n   * The bounding rectangle representation of these bounds.\n   * Lazily creates and updates a Rectangle instance based on the current bounds.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   *\n   * // Get rectangle representation\n   * const rect = bounds.rectangle;\n   * console.log(rect.x, rect.y, rect.width, rect.height);\n   *\n   * // Use for hit testing\n   * if (bounds.rectangle.contains(mouseX, mouseY)) {\n   *     console.log('Mouse is inside bounds!');\n   * }\n   * ```\n   * @see {@link Rectangle} For rectangle methods\n   * @see {@link Bounds.isEmpty} For bounds validation\n   */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle.Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /**\n   * Clears the bounds and resets all coordinates to their default values.\n   * Resets the transformation matrix back to identity.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * console.log(bounds.isEmpty()); // false\n   * // Clear the bounds\n   * bounds.clear();\n   * console.log(bounds.isEmpty()); // true\n   * ```\n   * @returns This bounds object for chaining\n   */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds directly using coordinate values.\n   * Provides a way to set all bounds values at once.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   * bounds.set(0, 0, 100, 100);\n   * ```\n   * @param x0 - Left X coordinate of frame\n   * @param y0 - Top Y coordinate of frame\n   * @param x1 - Right X coordinate of frame\n   * @param y1 - Bottom Y coordinate of frame\n   * @see {@link Bounds#addFrame} For matrix-aware bounds setting\n   * @see {@link Bounds#clear} For resetting bounds\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n   * Updates the bounds to encompass the new frame coordinates.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   * bounds.addFrame(0, 0, 100, 100);\n   *\n   * // Add transformed frame\n   * const matrix = new Matrix()\n   *     .translate(50, 50)\n   *     .rotate(Math.PI / 4);\n   * bounds.addFrame(0, 0, 100, 100, matrix);\n   * ```\n   * @param x0 - Left X coordinate of frame\n   * @param y0 - Top Y coordinate of frame\n   * @param x1 - Right X coordinate of frame\n   * @param y1 - Bottom Y coordinate of frame\n   * @param matrix - Optional transformation matrix\n   * @see {@link Bounds#addRect} For adding Rectangle objects\n   * @see {@link Bounds#addBounds} For adding other Bounds\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds, optionally transformed by a matrix.\n   * Updates the bounds to encompass the given rectangle.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   * // Add simple rectangle\n   * const rect = new Rectangle(0, 0, 100, 100);\n   * bounds.addRect(rect);\n   *\n   * // Add transformed rectangle\n   * const matrix = new Matrix()\n   *     .translate(50, 50)\n   *     .rotate(Math.PI / 4);\n   * bounds.addRect(rect, matrix);\n   * ```\n   * @param rect - The rectangle to be added\n   * @param matrix - Optional transformation matrix\n   * @see {@link Bounds#addFrame} For adding raw coordinates\n   * @see {@link Bounds#addBounds} For adding other bounds\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds another bounds object to this one, optionally transformed by a matrix.\n   * Expands the bounds to include the given bounds' area.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   *\n   * // Add child bounds\n   * const childBounds = sprite.getBounds();\n   * bounds.addBounds(childBounds);\n   *\n   * // Add transformed bounds\n   * const matrix = new Matrix()\n   *     .scale(2, 2);\n   * bounds.addBounds(childBounds, matrix);\n   * ```\n   * @param bounds - The bounds to be added\n   * @param matrix - Optional transformation matrix\n   * @see {@link Bounds#addFrame} For adding raw coordinates\n   * @see {@link Bounds#addRect} For adding rectangles\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds as a mask, creating an intersection of the two bounds.\n   * Only keeps the overlapping region between current bounds and mask bounds.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Create mask bounds\n   * const mask = new Bounds();\n   * mask.addFrame(50, 50, 150, 150);\n   * // Apply mask - results in bounds of (50,50,100,100)\n   * bounds.addBoundsMask(mask);\n   * ```\n   * @param mask - The Bounds to use as a mask\n   * @see {@link Bounds#addBounds} For union operation\n   * @see {@link Bounds#fit} For fitting to rectangle\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Applies a transformation matrix to the bounds, updating its coordinates.\n   * Transforms all corners of the bounds using the given matrix.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Apply translation\n   * const translateMatrix = new Matrix()\n   *     .translate(50, 50);\n   * bounds.applyMatrix(translateMatrix);\n   * ```\n   * @param matrix - The matrix to apply to the bounds\n   * @see {@link Matrix} For matrix operations\n   * @see {@link Bounds#addFrame} For adding transformed frames\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to fit within the given rectangle.\n   * Clips the bounds if they extend beyond the rectangle's edges.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 200, 200);\n   * // Fit within viewport\n   * const viewport = new Rectangle(50, 50, 100, 100);\n   * bounds.fit(viewport);\n   * // bounds are now (50, 50, 150, 150)\n   * ```\n   * @param rect - The rectangle to fit within\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#addBoundsMask} For intersection\n   * @see {@link Bounds#pad} For expanding bounds\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 200, 200);\n   * // Fit to specific coordinates\n   * bounds.fitBounds(50, 150, 50, 150);\n   * // bounds are now (50, 50, 150, 150)\n   * ```\n   * @param left - The left value of the bounds\n   * @param right - The right value of the bounds\n   * @param top - The top value of the bounds\n   * @param bottom - The bottom value of the bounds\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#fit} For fitting to Rectangle\n   * @see {@link Bounds#addBoundsMask} For intersection\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   *\n   * // Add equal padding\n   * bounds.pad(10);\n   * // bounds are now (-10, -10, 110, 110)\n   *\n   * // Add different padding for x and y\n   * bounds.pad(20, 10);\n   * // bounds are now (-30, -20, 130, 120)\n   * ```\n   * @param paddingX - The horizontal padding amount\n   * @param paddingY - The vertical padding amount\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#fit} For constraining bounds\n   * @see {@link Bounds#scale} For uniform scaling\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /**\n   * Ceils the bounds by rounding up max values and rounding down min values.\n   * Useful for pixel-perfect calculations and avoiding fractional pixels.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   * bounds.set(10.2, 10.9, 50.1, 50.8);\n   *\n   * // Round to whole pixels\n   * bounds.ceil();\n   * // bounds are now (10, 10, 51, 51)\n   * ```\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#scale} For size adjustments\n   * @see {@link Bounds#fit} For constraining bounds\n   */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /**\n   * Creates a new Bounds instance with the same values.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   *\n   * // Create a copy\n   * const copy = bounds.clone();\n   *\n   * // Original and copy are independent\n   * bounds.pad(10);\n   * console.log(copy.width === bounds.width); // false\n   * ```\n   * @returns A new Bounds instance with the same values\n   * @see {@link Bounds#copyFrom} For reusing existing bounds\n   */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values, adjusting all edges proportionally.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   *\n   * // Scale uniformly\n   * bounds.scale(2);\n   * // bounds are now (0, 0, 200, 200)\n   *\n   * // Scale non-uniformly\n   * bounds.scale(0.5, 2);\n   * // bounds are now (0, 0, 100, 400)\n   * ```\n   * @param x - The X value to scale by\n   * @param y - The Y value to scale by (defaults to x)\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#pad} For adding padding\n   * @see {@link Bounds#fit} For constraining size\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /**\n   * The x position of the bounds in local space.\n   * Setting this value will move the bounds while maintaining its width.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Get x position\n   * console.log(bounds.x); // 0\n   *\n   * // Move bounds horizontally\n   * bounds.x = 50;\n   * console.log(bounds.minX, bounds.maxX); // 50, 150\n   *\n   * // Width stays the same\n   * console.log(bounds.width); // Still 100\n   * ```\n   */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /**\n   * The y position of the bounds in local space.\n   * Setting this value will move the bounds while maintaining its height.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Get y position\n   * console.log(bounds.y); // 0\n   *\n   * // Move bounds vertically\n   * bounds.y = 50;\n   * console.log(bounds.minY, bounds.maxY); // 50, 150\n   *\n   * // Height stays the same\n   * console.log(bounds.height); // Still 100\n   * ```\n   */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /**\n   * The width value of the bounds.\n   * Represents the distance between minX and maxX coordinates.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Get width\n   * console.log(bounds.width); // 100\n   * // Resize width\n   * bounds.width = 200;\n   * console.log(bounds.maxX - bounds.minX); // 200\n   * ```\n   */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /**\n   * The height value of the bounds.\n   * Represents the distance between minY and maxY coordinates.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Get height\n   * console.log(bounds.height); // 100\n   * // Resize height\n   * bounds.height = 150;\n   * console.log(bounds.maxY - bounds.minY); // 150\n   * ```\n   */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /**\n   * The left edge coordinate of the bounds.\n   * Alias for minX.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(50, 0, 150, 100);\n   * console.log(bounds.left); // 50\n   * console.log(bounds.left === bounds.minX); // true\n   * ```\n   * @readonly\n   */\n  get left() {\n    return this.minX;\n  }\n  /**\n   * The right edge coordinate of the bounds.\n   * Alias for maxX.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * console.log(bounds.right); // 100\n   * console.log(bounds.right === bounds.maxX); // true\n   * ```\n   * @readonly\n   */\n  get right() {\n    return this.maxX;\n  }\n  /**\n   * The top edge coordinate of the bounds.\n   * Alias for minY.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 25, 100, 125);\n   * console.log(bounds.top); // 25\n   * console.log(bounds.top === bounds.minY); // true\n   * ```\n   * @readonly\n   */\n  get top() {\n    return this.minY;\n  }\n  /**\n   * The bottom edge coordinate of the bounds.\n   * Alias for maxY.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 200);\n   * console.log(bounds.bottom); // 200\n   * console.log(bounds.bottom === bounds.maxY); // true\n   * ```\n   * @readonly\n   */\n  get bottom() {\n    return this.maxY;\n  }\n  /**\n   * Whether the bounds has positive width and height.\n   * Checks if both dimensions are greater than zero.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Check if bounds are positive\n   * console.log(bounds.isPositive); // true\n   *\n   * // Negative bounds\n   * bounds.maxX = bounds.minX;\n   * console.log(bounds.isPositive); // false, width is 0\n   * ```\n   * @readonly\n   * @see {@link Bounds#isEmpty} For checking empty state\n   * @see {@link Bounds#isValid} For checking validity\n   */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  /**\n   * Whether the bounds has valid coordinates.\n   * Checks if the bounds has been initialized with real values.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   * console.log(bounds.isValid); // false, default state\n   *\n   * // Set valid bounds\n   * bounds.addFrame(0, 0, 100, 100);\n   * console.log(bounds.isValid); // true\n   * ```\n   * @readonly\n   * @see {@link Bounds#isEmpty} For checking empty state\n   * @see {@link Bounds#isPositive} For checking dimensions\n   */\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n   * Used for efficiently updating bounds from raw vertex data.\n   * @example\n   * ```ts\n   * const bounds = new Bounds();\n   *\n   * // Add vertices from geometry\n   * const vertices = new Float32Array([\n   *     0, 0,    // Vertex 1\n   *     100, 0,  // Vertex 2\n   *     100, 100 // Vertex 3\n   * ]);\n   * bounds.addVertexData(vertices, 0, 6);\n   *\n   * // Add transformed vertices\n   * const matrix = new Matrix()\n   *     .translate(50, 50)\n   *     .rotate(Math.PI / 4);\n   * bounds.addVertexData(vertices, 0, 6, matrix);\n   *\n   * // Add subset of vertices\n   * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n   * ```\n   * @param vertexData - The array of vertices to add\n   * @param beginOffset - Starting index in the vertex array\n   * @param endOffset - Ending index in the vertex array (excluded)\n   * @param matrix - Optional transformation matrix\n   * @see {@link Bounds#addFrame} For adding rectangular frames\n   * @see {@link Matrix} For transformation details\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if a point is contained within the bounds.\n   * Returns true if the point's coordinates fall within the bounds' area.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * // Basic point check\n   * console.log(bounds.containsPoint(50, 50)); // true\n   * console.log(bounds.containsPoint(150, 150)); // false\n   *\n   * // Check edges\n   * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n   * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n   * ```\n   * @param x - x coordinate to check\n   * @param y - y coordinate to check\n   * @returns True if the point is inside the bounds\n   * @see {@link Bounds#isPositive} For valid bounds check\n   * @see {@link Bounds#rectangle} For Rectangle representation\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Returns a string representation of the bounds.\n   * Useful for debugging and logging bounds information.\n   * @example\n   * ```ts\n   * const bounds = new Bounds(0, 0, 100, 100);\n   * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n   * ```\n   * @returns A string describing the bounds\n   * @see {@link Bounds#copyFrom} For copying bounds\n   * @see {@link Bounds#clone} For creating a new instance\n   */\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n  /**\n   * Copies the bounds from another bounds object.\n   * Useful for reusing bounds objects and avoiding allocations.\n   * @example\n   * ```ts\n   * const sourceBounds = new Bounds(0, 0, 100, 100);\n   * // Copy bounds\n   * const targetBounds = new Bounds();\n   * targetBounds.copyFrom(sourceBounds);\n   * ```\n   * @param bounds - The bounds to copy from\n   * @returns This bounds object for chaining\n   * @see {@link Bounds#clone} For creating new instances\n   */\n  copyFrom(bounds) {\n    this.minX = bounds.minX;\n    this.minY = bounds.minY;\n    this.maxX = bounds.maxX;\n    this.maxY = bounds.maxY;\n    return this;\n  }\n}\n\nexports.Bounds = Bounds;\n//# sourceMappingURL=Bounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nfunction getFastGlobalBounds(target, bounds) {\n  deprecation.deprecation(\"8.7.0\", \"Use container.getFastGlobalBounds() instead\");\n  return target.getFastGlobalBounds(true, bounds);\n}\n\nexports.getFastGlobalBounds = getFastGlobalBounds;\n//# sourceMappingURL=getFastGlobalBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ./utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixAndBoundsPool.matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixAndBoundsPool.matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixAndBoundsPool.matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = matrixAndBoundsPool.boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.bounds) {\n      bounds.matrix = worldTransform;\n      bounds.addBounds(target.bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.Matrix.IDENTITY);\n    matrixAndBoundsPool.boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixAndBoundsPool.matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexports.getGlobalBounds = getGlobalBounds;\nexports.updateTransformBackwards = updateTransformBackwards;\n//# sourceMappingURL=getGlobalBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ./utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixAndBoundsPool.matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixAndBoundsPool.matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = matrixAndBoundsPool.boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      bounds.addBounds(target.bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.Matrix.IDENTITY);\n    matrixAndBoundsPool.boundsPool.return(bounds);\n  }\n  matrixAndBoundsPool.matrixPool.return(relativeTransform);\n}\n\nexports.getLocalBounds = getLocalBounds;\n//# sourceMappingURL=getLocalBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\nexports.getGlobalRenderableBounds = getGlobalRenderableBounds;\n//# sourceMappingURL=getRenderableBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Pool = __webpack_require__(/*! ../../../../utils/pool/Pool.js */ \"./node_modules/pixi.js/lib/utils/pool/Pool.js\");\nvar Bounds = __webpack_require__(/*! ../Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\n\n\"use strict\";\nconst matrixPool = new Pool.Pool(Matrix.Matrix);\nconst boundsPool = new Pool.Pool(Bounds.Bounds);\n\nexports.boundsPool = boundsPool;\nexports.matrixPool = matrixPool;\n//# sourceMappingURL=matrixAndBoundsPool.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst cacheAsTextureMixin = {\n  get isCachedAsTexture() {\n    return !!this.renderGroup?.isCachedAsTexture;\n  },\n  cacheAsTexture(val) {\n    if (typeof val === \"boolean\" && val === false) {\n      this.disableRenderGroup();\n    } else {\n      this.enableRenderGroup();\n      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n    }\n  },\n  updateCacheTexture() {\n    this.renderGroup?.updateCacheTexture();\n  },\n  get cacheAsBitmap() {\n    return this.isCachedAsTexture;\n  },\n  set cacheAsBitmap(val) {\n    deprecation.deprecation(\"v8.6.0\", \"cacheAsBitmap is deprecated, use cacheAsTexture instead.\");\n    this.cacheAsTexture(val);\n  }\n};\n\nexports.cacheAsTextureMixin = cacheAsTextureMixin;\n//# sourceMappingURL=cacheAsTextureMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar removeItems = __webpack_require__(/*! ../../../utils/data/removeItems.js */ \"./node_modules/pixi.js/lib/utils/data/removeItems.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems.removeItems(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        const child = removed[i];\n        child.parentRenderLayer?.detach(child);\n        this.emit(\"childRemoved\", child, this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      if (removed.length > 0) {\n        this._didViewChangeTick++;\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation.deprecation(deprecation.v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\nexports.childrenHelperMixin = childrenHelperMixin;\n//# sourceMappingURL=childrenHelperMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst collectRenderablesMixin = {\n  collectRenderables(instructionSet, renderer, currentLayer) {\n    if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)\n      return;\n    if (this.sortableChildren) {\n      this.sortChildren();\n    }\n    if (this.isSimple) {\n      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n    } else if (this.renderGroup) {\n      renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n    } else {\n      this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n    }\n  },\n  collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n  },\n  collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {\n    const { renderPipes } = renderer;\n    for (let i = 0; i < this.effects.length; i++) {\n      const effect = this.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.push(effect, this, instructionSet);\n    }\n    this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n    for (let i = this.effects.length - 1; i >= 0; i--) {\n      const effect = this.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.pop(effect, this, instructionSet);\n    }\n  }\n};\n\nexports.collectRenderablesMixin = collectRenderablesMixin;\n//# sourceMappingURL=collectRenderablesMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FilterEffect = __webpack_require__(/*! ../../../filters/FilterEffect.js */ \"./node_modules/pixi.js/lib/filters/FilterEffect.js\");\nvar MaskEffectManager = __webpack_require__(/*! ../../../rendering/mask/MaskEffectManager.js */ \"./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.js\");\n\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _maskOptions: {\n    inverse: false\n  },\n  _filterEffect: null,\n  effects: [],\n  _markStructureAsChanged() {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n  },\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  setMask(options) {\n    this._maskOptions = {\n      ...this._maskOptions,\n      ...options\n    };\n    if (options.mask) {\n      this.mask = options.mask;\n    }\n    this._markStructureAsChanged();\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect.FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect.FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\nexports.effectsMixin = effectsMixin;\n//# sourceMappingURL=effectsMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst findMixin = {\n  label: null,\n  get name() {\n    deprecation.deprecation(deprecation.v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexports.findMixin = findMixin;\n//# sourceMappingURL=findMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Bounds = __webpack_require__(/*! ../bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\n\n\"use strict\";\nconst tempMatrix = new Matrix.Matrix();\nconst getFastGlobalBoundsMixin = {\n  getFastGlobalBounds(factorRenderLayers, bounds) {\n    bounds || (bounds = new Bounds.Bounds());\n    bounds.clear();\n    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n    if (!bounds.isValid) {\n      bounds.set(0, 0, 0, 0);\n    }\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    bounds.applyMatrix(renderGroup.worldTransform);\n    return bounds;\n  },\n  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {\n    let localBounds = bounds;\n    if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n      return;\n    if (this.localDisplayStatus !== 7 || !this.measurable) {\n      return;\n    }\n    const manageEffects = !!this.effects.length;\n    if (this.renderGroup || manageEffects) {\n      localBounds = matrixAndBoundsPool.boundsPool.get().clear();\n    }\n    if (this.boundsArea) {\n      bounds.addRect(this.boundsArea, this.worldTransform);\n    } else {\n      if (this.renderPipeId) {\n        const viewBounds = this.bounds;\n        localBounds.addFrame(\n          viewBounds.minX,\n          viewBounds.minY,\n          viewBounds.maxX,\n          viewBounds.maxY,\n          this.groupTransform\n        );\n      }\n      const children = this.children;\n      for (let i = 0; i < children.length; i++) {\n        children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n      }\n    }\n    if (manageEffects) {\n      let advanced = false;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      for (let i = 0; i < this.effects.length; i++) {\n        if (this.effects[i].addBounds) {\n          if (!advanced) {\n            advanced = true;\n            localBounds.applyMatrix(renderGroup.worldTransform);\n          }\n          this.effects[i].addBounds(localBounds, true);\n        }\n      }\n      if (advanced) {\n        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n        bounds.addBounds(localBounds, this.relativeGroupTransform);\n      }\n      bounds.addBounds(localBounds);\n      matrixAndBoundsPool.boundsPool.return(localBounds);\n    } else if (this.renderGroup) {\n      bounds.addBounds(localBounds, this.relativeGroupTransform);\n      matrixAndBoundsPool.boundsPool.return(localBounds);\n    }\n  }\n};\n\nexports.getFastGlobalBoundsMixin = getFastGlobalBoundsMixin;\n//# sourceMappingURL=getFastGlobalBoundsMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getGlobalBounds = __webpack_require__(/*! ../bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\nvar multiplyColors = __webpack_require__(/*! ../utils/multiplyColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js\");\n\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = getGlobalBounds.updateTransformBackwards(this, matrixAndBoundsPool.matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixAndBoundsPool.matrixPool.return(parentTransform);\n    return matrix;\n  },\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(\n          multiplyColors.multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n        );\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors.multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\n\nexports.bgr2rgb = bgr2rgb;\nexports.getGlobalMixin = getGlobalMixin;\n//# sourceMappingURL=getGlobalMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Bounds = __webpack_require__(/*! ../bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ../bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\nvar getLocalBounds = __webpack_require__(/*! ../bounds/getLocalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js\");\nvar checkChildrenDidChange = __webpack_require__(/*! ../utils/checkChildrenDidChange.js */ \"./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js\");\n\n\"use strict\";\nconst tempMatrix = new Matrix.Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds.Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange.checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds.getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds.getGlobalBounds(this, skipUpdate, bounds || new Bounds.Bounds());\n  }\n};\n\nexports.measureMixin = measureMixin;\n//# sourceMappingURL=measureMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexports.onRenderMixin = onRenderMixin;\n//# sourceMappingURL=onRenderMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  sortDirty: false,\n  sortableChildren: false,\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexports.sortMixin = sortMixin;\n//# sourceMappingURL=sortMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  getGlobalPosition(point = new Point.Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  toGlobal(position, point, skipUpdate = false) {\n    const globalMatrix = this.getGlobalTransform(matrixAndBoundsPool.matrixPool.get(), skipUpdate);\n    point = globalMatrix.apply(position, point);\n    matrixAndBoundsPool.matrixPool.return(globalMatrix);\n    return point;\n  },\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    const globalMatrix = this.getGlobalTransform(matrixAndBoundsPool.matrixPool.get(), skipUpdate);\n    point = globalMatrix.applyInverse(position, point);\n    matrixAndBoundsPool.matrixPool.return(globalMatrix);\n    return point;\n  }\n};\n\nexports.toLocalGlobalMixin = toLocalGlobalMixin;\n//# sourceMappingURL=toLocalGlobalMixin.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/destroyTypes.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/destroyTypes.js ***!
  \******************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=destroyTypes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/destroyTypes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexports.assignWithIgnore = assignWithIgnore;\n//# sourceMappingURL=assignWithIgnore.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexports.checkChildrenDidChange = checkChildrenDidChange;\n//# sourceMappingURL=checkChildrenDidChange.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/clearList.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/clearList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexports.clearList = clearList;\n//# sourceMappingURL=clearList.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/clearList.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nfunction collectAllRenderables(container, instructionSet, rendererOrPipes) {\n  deprecation.deprecation(\"8.7.0\", \"Please use container.collectRenderables instead.\");\n  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n  return container.collectRenderables(instructionSet, renderer, null);\n}\n\nexports.collectAllRenderables = collectAllRenderables;\n//# sourceMappingURL=collectAllRenderables.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/definedProps.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexports.definedProps = definedProps;\n//# sourceMappingURL=definedProps.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/definedProps.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexports.executeInstructions = executeInstructions;\n//# sourceMappingURL=executeInstructions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar multiplyHexColors = __webpack_require__(/*! ./multiplyHexColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js\");\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction multiplyColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR) {\n    return parentBGRColor;\n  }\n  if (parentBGRColor === WHITE_BGR) {\n    return localBGRColor;\n  }\n  return multiplyHexColors.multiplyHexColors(localBGRColor, parentBGRColor);\n}\n\nexports.multiplyColors = multiplyColors;\n//# sourceMappingURL=multiplyColors.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255 | 0;\n  const g = g1 * g2 / 255 | 0;\n  const b = b1 * b2 / 255 | 0;\n  return (r << 16) + (g << 8) + b;\n}\n\nexports.multiplyHexColors = multiplyHexColors;\n//# sourceMappingURL=multiplyHexColors.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction updateLocalTransform(lt, container) {\n  const scale = container._scale;\n  const pivot = container._pivot;\n  const position = container._position;\n  const sx = scale._x;\n  const sy = scale._y;\n  const px = pivot._x;\n  const py = pivot._y;\n  lt.a = container._cx * sx;\n  lt.b = container._sx * sx;\n  lt.c = container._cy * sy;\n  lt.d = container._sy * sy;\n  lt.tx = position._x - (px * lt.a + py * lt.c);\n  lt.ty = position._y - (px * lt.b + py * lt.d);\n}\n\nexports.updateLocalTransform = updateLocalTransform;\n//# sourceMappingURL=updateLocalTransform.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Container = __webpack_require__(/*! ../Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar clearList = __webpack_require__(/*! ./clearList.js */ \"./node_modules/pixi.js/lib/scene/container/utils/clearList.js\");\nvar multiplyColors = __webpack_require__(/*! ./multiplyColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js\");\n\n\"use strict\";\nconst tempContainer = new Container.Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = Container.UPDATE_VISIBLE | Container.UPDATE_COLOR | Container.UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList.clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors.multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & Container.UPDATE_COLOR) {\n    container.groupColor = multiplyColors.multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & Container.UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & Container.UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexports.updateRenderGroupTransform = updateRenderGroupTransform;\nexports.updateRenderGroupTransforms = updateRenderGroupTransforms;\nexports.updateTransformAndChildren = updateTransformAndChildren;\n//# sourceMappingURL=updateRenderGroupTransforms.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction updateWorldTransform(local, parent, world) {\n  const lta = local.a;\n  const ltb = local.b;\n  const ltc = local.c;\n  const ltd = local.d;\n  const lttx = local.tx;\n  const ltty = local.ty;\n  const pta = parent.a;\n  const ptb = parent.b;\n  const ptc = parent.c;\n  const ptd = parent.d;\n  world.a = lta * pta + ltb * ptc;\n  world.b = lta * ptb + ltb * ptd;\n  world.c = ltc * pta + ltd * ptc;\n  world.d = ltc * ptb + ltd * ptd;\n  world.tx = lttx * pta + ltty * ptc + parent.tx;\n  world.ty = lttx * ptb + ltty * ptd + parent.ty;\n}\n\nexports.updateWorldTransform = updateWorldTransform;\n//# sourceMappingURL=updateWorldTransform.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexports.validateRenderables = validateRenderables;\n//# sourceMappingURL=validateRenderables.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar colorBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar localUniformBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar getBatchSamplersUniformGroup = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\n\n\"use strict\";\nclass GlGraphicsAdaptor {\n  contextChange(renderer) {\n    const uniforms = new UniformGroup.UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const maxTextures = renderer.limits.maxBatchableTextures;\n    const glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit.colorBitGl,\n        generateTextureBatchBit.generateTextureBatchBitGl(maxTextures),\n        localUniformBit.localUniformBitGl,\n        roundPixelsBit.roundPixelsBitGl\n      ]\n    });\n    this.shader = new Shader.Shader({\n      glProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup.getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    shader.groups[0] = renderer.globalUniforms.bindGroup;\n    renderer.state.set(graphicsPipe.state);\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(batcher.geometry, shader.glProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.size) {\n        for (let j = 0; j < batch.textures.count; j++) {\n          renderer.texture.bind(batch.textures.textures[j], j);\n        }\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n      }\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGlGraphicsAdaptor.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexports.GlGraphicsAdaptor = GlGraphicsAdaptor;\n//# sourceMappingURL=GlGraphicsAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar getTextureBatchBindGroup = __webpack_require__(/*! ../../../rendering/batcher/gpu/getTextureBatchBindGroup.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar colorBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar localUniformBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup.UniformGroup({\n      uTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit.colorBit,\n        generateTextureBatchBit.generateTextureBatchBit(this._maxTextures),\n        localUniformBit.localUniformBitGroup2,\n        roundPixelsBit.roundPixelsBit\n      ]\n    });\n    this.shader = new Shader.Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexports.GpuGraphicsAdaptor = GpuGraphicsAdaptor;\n//# sourceMappingURL=GpuGraphicsAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexports.color32BitToUniform = color32BitToUniform;\nexports.colorToUniform = colorToUniform;\n//# sourceMappingURL=colorToUniform.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/init.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/init.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GraphicsContextSystem = __webpack_require__(/*! ./shared/GraphicsContextSystem.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js\");\nvar GraphicsPipe = __webpack_require__(/*! ./shared/GraphicsPipe.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(GraphicsPipe.GraphicsPipe);\nExtensions.extensions.add(GraphicsContextSystem.GraphicsContextSystem);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar multiplyHexColors = __webpack_require__(/*! ../../container/utils/multiplyHexColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js\");\n\n\"use strict\";\nconst identityMatrix = new Matrix.Matrix();\nclass BatchableGraphics {\n  constructor() {\n    this.packAsQuad = false;\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    this.applyTransform = true;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n  }\n  get uvs() {\n    return this.geometryData.uvs;\n  }\n  get positions() {\n    return this.geometryData.vertices;\n  }\n  get indices() {\n    return this.geometryData.indices;\n  }\n  get blendMode() {\n    if (this.renderable && this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  get color() {\n    const rgb = this.baseColor;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    const renderable = this.renderable;\n    if (renderable) {\n      return multiplyHexColors.multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n    }\n    return bgr + (this.alpha * 255 << 24);\n  }\n  get transform() {\n    return this.renderable?.groupTransform || identityMatrix;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.attributeOffset = this.attributeOffset;\n    gpuBuffer.attributeSize = this.attributeSize;\n    gpuBuffer.baseColor = this.baseColor;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n    gpuBuffer.topology = this.topology;\n  }\n  reset() {\n    this.applyTransform = true;\n    this.renderable = null;\n    this.topology = \"triangle-list\";\n  }\n}\n\nexports.BatchableGraphics = BatchableGraphics;\n//# sourceMappingURL=BatchableGraphics.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/FillTypes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/FillTypes.js ***!
  \*********************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=FillTypes.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/FillTypes.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar ViewContainer = __webpack_require__(/*! ../../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar GraphicsContext = __webpack_require__(/*! ./GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\n\n\"use strict\";\nclass Graphics extends ViewContainer.ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext.GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext.GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation.deprecation(deprecation.v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexports.Graphics = Graphics;\n//# sourceMappingURL=Graphics.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Point = __webpack_require__(/*! ../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar uid = __webpack_require__(/*! ../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar Bounds = __webpack_require__(/*! ../../container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar GraphicsPath = __webpack_require__(/*! ./path/GraphicsPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js\");\nvar SVGParser = __webpack_require__(/*! ./svg/SVGParser.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js\");\nvar convertFillInputToFillStyle = __webpack_require__(/*! ./utils/convertFillInputToFillStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js\");\n\n\"use strict\";\nconst tmpPoint = new Point.Point();\nconst tempMatrix = new Matrix.Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    this.uid = uid.uid(\"graphicsContext\");\n    /** @internal */\n    this.dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    this.batchMode = \"auto\";\n    /** @internal */\n    this.instructions = [];\n    this._activePath = new GraphicsPath.GraphicsPath();\n    this._transform = new Matrix.Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds.Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = convertFillInputToFillStyle.toFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = convertFillInputToFillStyle.toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = convertFillInputToFillStyle.toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = convertFillInputToFillStyle.toFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath.GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation.deprecation(deprecation.v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = convertFillInputToFillStyle.toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = convertFillInputToFillStyle.toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser.SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix.Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix.Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const alignment = data.style.alignment;\n        const outerPadding = data.style.width * (1 - alignment);\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - outerPadding,\n          _bounds.minY - outerPadding,\n          _bounds.maxX + outerPadding,\n          _bounds.maxY + outerPadding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          const strokeStyle = style;\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * context.destroy();\n   * context.destroy(true);\n   * context.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** Whether coordinates are 'global' or 'local' */\n  textureSpace: \"local\"\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** Whether coordinates are 'global' or 'local' */\n  textureSpace: \"local\",\n  /** If the stroke is a pixel line. */\n  pixelLine: false\n};\nlet GraphicsContext = _GraphicsContext;\n\nexports.GraphicsContext = GraphicsContext;\n//# sourceMappingURL=GraphicsContext.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar getTextureBatchBindGroup = __webpack_require__(/*! ../../../rendering/batcher/gpu/getTextureBatchBindGroup.js */ \"./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.js\");\nvar DefaultBatcher = __webpack_require__(/*! ../../../rendering/batcher/shared/DefaultBatcher.js */ \"./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.js\");\nvar InstructionSet = __webpack_require__(/*! ../../../rendering/renderers/shared/instructions/InstructionSet.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar PoolGroup = __webpack_require__(/*! ../../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar buildContextBatches = __webpack_require__(/*! ./utils/buildContextBatches.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js\");\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.instructions = new InstructionSet.InstructionSet();\n  }\n  init(maxTextures) {\n    this.batcher = new DefaultBatcher.DefaultBatcher({\n      maxTextures\n    });\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    deprecation.deprecation(deprecation.v8_3_4, \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n    return this.batcher.geometry;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor(renderer) {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuContextHash\");\n    renderer.renderableGC.addManagedHash(this, \"_graphicsDataContextHash\");\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  /**\n   * Returns the render data for a given GraphicsContext.\n   * @param context - The GraphicsContext to get the render data for.\n   * @internal\n   */\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  /**\n   * Updates the GPU context for a given GraphicsContext.\n   * If the context is dirty, it will rebuild the batches and geometry data.\n   * @param context - The GraphicsContext to update.\n   * @returns The updated GpuGraphicsContext.\n   * @internal\n   */\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches.buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      } else {\n        gpuContext.isBatchable = true;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  /**\n   * Returns the GpuGraphicsContext for a given GraphicsContext.\n   * If it does not exist, it will initialize a new one.\n   * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n   * @returns The GpuGraphicsContext for the given GraphicsContext.\n   * @internal\n   */\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup.BigPool.get(GraphicsContextRenderData, {\n      maxTextures: this._renderer.limits.maxBatchableTextures\n    });\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup(\n        batch.textures.textures,\n        batch.textures.count,\n        this._renderer.limits.maxBatchableTextures\n      );\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup.BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup.BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexports.GpuGraphicsContext = GpuGraphicsContext;\nexports.GraphicsContextRenderData = GraphicsContextRenderData;\nexports.GraphicsContextSystem = GraphicsContextSystem;\n//# sourceMappingURL=GraphicsContextSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar State = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar PoolGroup = __webpack_require__(/*! ../../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar colorToUniform = __webpack_require__(/*! ../gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar BatchableGraphics = __webpack_require__(/*! ./BatchableGraphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js\");\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      PoolGroup.BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    colorToUniform.color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexports.GraphicsGpuData = GraphicsGpuData;\nexports.GraphicsPipe = GraphicsPipe;\n//# sourceMappingURL=GraphicsPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/ShapeBuildCommand.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/ShapeBuildCommand.js ***!
  \*******************************************************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=ShapeBuildCommand.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/ShapeBuildCommand.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GraphicsContextSystem = __webpack_require__(/*! ../GraphicsContextSystem.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js\");\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexports.buildAdaptiveBezier = buildAdaptiveBezier;\n//# sourceMappingURL=buildAdaptiveBezier.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GraphicsContextSystem = __webpack_require__(/*! ../GraphicsContextSystem.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js\");\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexports.buildAdaptiveQuadratic = buildAdaptiveQuadratic;\n//# sourceMappingURL=buildAdaptiveQuadratic.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexports.buildArc = buildArc;\n//# sourceMappingURL=buildArc.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar buildArc = __webpack_require__(/*! ./buildArc.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js\");\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc.buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexports.buildArcTo = buildArcTo;\n//# sourceMappingURL=buildArcTo.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar buildAdaptiveBezier = __webpack_require__(/*! ./buildAdaptiveBezier.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js\");\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier.buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexports.buildArcToSvg = buildArcToSvg;\n//# sourceMappingURL=buildArcToSvg.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: Extensions.ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      rx = ry = circle.radius;\n      if (rx <= 0) {\n        return false;\n      }\n      x = circle.x;\n      y = circle.y;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      if (rx <= 0 || ry <= 0) {\n        return false;\n      }\n      x = ellipse.x;\n      y = ellipse.y;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (dx < 0 || dy < 0) {\n      return false;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return false;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return true;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: \"ellipse\" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: \"roundedRectangle\" } };\n\nexports.buildCircle = buildCircle;\nexports.buildEllipse = buildEllipse;\nexports.buildRoundedRectangle = buildRoundedRectangle;\n//# sourceMappingURL=buildCircle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/const.js\");\nvar getOrientationOfPoints = __webpack_require__(/*! ../utils/getOrientationOfPoints.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js\");\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {\n  const eps = _const.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints.getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point.Point(points[0], points[1]);\n  const lastPoint = new Point.Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = _const.curveEps * _const.curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexports.buildLine = buildLine;\n//# sourceMappingURL=buildLine.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/const.js\");\n\n\"use strict\";\nfunction buildPixelLine(points, closed, vertices, indices) {\n  const eps = _const.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const fx = points[0];\n  const fy = points[1];\n  const lx = points[points.length - 2];\n  const ly = points[points.length - 1];\n  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;\n  const verts = vertices;\n  const length = points.length / 2;\n  const indexStart = verts.length / 2;\n  for (let i = 0; i < length; i++) {\n    verts.push(points[i * 2]);\n    verts.push(points[i * 2 + 1]);\n  }\n  for (let i = 0; i < length - 1; i++) {\n    indices.push(indexStart + i, indexStart + i + 1);\n  }\n  if (closePath) {\n    indices.push(indexStart + length - 1, indexStart);\n  }\n}\n\nexports.buildPixelLine = buildPixelLine;\n//# sourceMappingURL=buildPixelLine.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar triangulateWithHoles = __webpack_require__(/*! ../utils/triangulateWithHoles.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js\");\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: Extensions.ExtensionType.ShapeBuilder,\n    name: \"polygon\"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles.triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexports.buildPolygon = buildPolygon;\n//# sourceMappingURL=buildPolygon.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst buildRectangle = {\n  extension: {\n    type: Extensions.ExtensionType.ShapeBuilder,\n    name: \"rectangle\"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width > 0 && height > 0)) {\n      return false;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexports.buildRectangle = buildRectangle;\n//# sourceMappingURL=buildRectangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\n\n\"use strict\";\nconst buildTriangle = {\n  extension: {\n    type: Extensions.ExtensionType.ShapeBuilder,\n    name: \"triangle\"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexports.buildTriangle = buildTriangle;\n//# sourceMappingURL=buildTriangle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/const.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/const.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexports.closePointEps = closePointEps;\nexports.curveEps = curveEps;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar adapter = __webpack_require__(/*! ../../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar ImageSource = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar Texture = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar deprecation = __webpack_require__(/*! ../../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar definedProps = __webpack_require__(/*! ../../../container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\n\n\"use strict\";\nconst emptyColorStops = [{ offset: 0, color: \"white\" }, { offset: 1, color: \"black\" }];\nconst _FillGradient = class _FillGradient {\n  constructor(...args) {\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    this.uid = uid.uid(\"fillGradient\");\n    /** Type of gradient - currently only supports 'linear' */\n    this.type = \"linear\";\n    /** Array of color stops defining the gradient */\n    this.colorStops = [];\n    let options = ensureGradientOptions(args);\n    const defaults = options.type === \"radial\" ? _FillGradient.defaultRadialOptions : _FillGradient.defaultLinearOptions;\n    options = { ...defaults, ...definedProps.definedProps(options) };\n    this._textureSize = options.textureSize;\n    this._wrapMode = options.wrapMode;\n    if (options.type === \"radial\") {\n      this.center = options.center;\n      this.outerCenter = options.outerCenter ?? this.center;\n      this.innerRadius = options.innerRadius;\n      this.outerRadius = options.outerRadius;\n      this.scale = options.scale;\n      this.rotation = options.rotation;\n    } else {\n      this.start = options.start;\n      this.end = options.end;\n    }\n    this.textureSpace = options.textureSpace;\n    this.type = options.type;\n    options.colorStops.forEach((stop) => {\n      this.addColorStop(stop.offset, stop.color);\n    });\n  }\n  /**\n   * Adds a color stop to the gradient\n   * @param offset - Position of the stop (0-1)\n   * @param color - Color of the stop\n   * @returns This gradient instance for chaining\n   */\n  addColorStop(offset, color) {\n    this.colorStops.push({ offset, color: Color.Color.shared.setValue(color).toHexa() });\n    return this;\n  }\n  /**\n   * Builds the internal texture and transform for the gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildLinearGradient() {\n    if (this.texture)\n      return;\n    let { x: x0, y: y0 } = this.start;\n    let { x: x1, y: y1 } = this.end;\n    let dx = x1 - x0;\n    let dy = y1 - y0;\n    const flip = dx < 0 || dy < 0;\n    if (this._wrapMode === \"clamp-to-edge\") {\n      if (dx < 0) {\n        const temp = x0;\n        x0 = x1;\n        x1 = temp;\n        dx *= -1;\n      }\n      if (dy < 0) {\n        const temp = y0;\n        y0 = y1;\n        y1 = temp;\n        dy *= -1;\n      }\n    }\n    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n    const defaultSize = this._textureSize;\n    const { canvas, context } = getCanvas(defaultSize, 1);\n    const gradient = !flip ? context.createLinearGradient(0, 0, this._textureSize, 0) : context.createLinearGradient(this._textureSize, 0, 0, 0);\n    addColorStops(gradient, colorStops);\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, defaultSize, 1);\n    this.texture = new Texture.Texture({\n      source: new ImageSource.ImageSource({\n        resource: canvas,\n        addressMode: this._wrapMode\n      })\n    });\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    const m = new Matrix.Matrix();\n    m.scale(dist / defaultSize, 1);\n    m.rotate(angle);\n    m.translate(x0, y0);\n    if (this.textureSpace === \"local\") {\n      m.scale(defaultSize, defaultSize);\n    }\n    this.transform = m;\n  }\n  /**\n   * Builds the internal texture and transform for the gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildGradient() {\n    if (this.type === \"linear\") {\n      this.buildLinearGradient();\n    } else {\n      this.buildRadialGradient();\n    }\n  }\n  /**\n   * Builds the internal texture and transform for the radial gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildRadialGradient() {\n    if (this.texture)\n      return;\n    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n    const defaultSize = this._textureSize;\n    const { canvas, context } = getCanvas(defaultSize, defaultSize);\n    const { x: x0, y: y0 } = this.center;\n    const { x: x1, y: y1 } = this.outerCenter;\n    const r0 = this.innerRadius;\n    const r1 = this.outerRadius;\n    const ox = x1 - r1;\n    const oy = y1 - r1;\n    const scale = defaultSize / (r1 * 2);\n    const cx = (x0 - ox) * scale;\n    const cy = (y0 - oy) * scale;\n    const gradient = context.createRadialGradient(\n      cx,\n      cy,\n      r0 * scale,\n      (x1 - ox) * scale,\n      (y1 - oy) * scale,\n      r1 * scale\n    );\n    addColorStops(gradient, colorStops);\n    context.fillStyle = colorStops[colorStops.length - 1].color;\n    context.fillRect(0, 0, defaultSize, defaultSize);\n    context.fillStyle = gradient;\n    context.translate(cx, cy);\n    context.rotate(this.rotation);\n    context.scale(1, this.scale);\n    context.translate(-cx, -cy);\n    context.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture.Texture({\n      source: new ImageSource.ImageSource({\n        resource: canvas,\n        addressMode: this._wrapMode\n      })\n    });\n    const m = new Matrix.Matrix();\n    m.scale(1 / scale, 1 / scale);\n    m.translate(ox, oy);\n    if (this.textureSpace === \"local\") {\n      m.scale(defaultSize, defaultSize);\n    }\n    this.transform = m;\n  }\n  /**\n   * Gets a unique key representing the current state of the gradient.\n   * Used internally for caching.\n   * @returns Unique string key\n   */\n  get styleKey() {\n    return this.uid;\n  }\n  destroy() {\n    this.texture?.destroy(true);\n    this.texture = null;\n  }\n};\n/** Default options for creating a gradient fill */\n_FillGradient.defaultLinearOptions = {\n  start: { x: 0, y: 0 },\n  end: { x: 0, y: 1 },\n  colorStops: [],\n  textureSpace: \"local\",\n  type: \"linear\",\n  textureSize: 256,\n  wrapMode: \"clamp-to-edge\"\n};\n/** Default options for creating a radial gradient fill */\n_FillGradient.defaultRadialOptions = {\n  center: { x: 0.5, y: 0.5 },\n  innerRadius: 0,\n  outerRadius: 0.5,\n  colorStops: [],\n  scale: 1,\n  textureSpace: \"local\",\n  type: \"radial\",\n  textureSize: 256,\n  wrapMode: \"clamp-to-edge\"\n};\nlet FillGradient = _FillGradient;\nfunction addColorStops(gradient, colorStops) {\n  for (let i = 0; i < colorStops.length; i++) {\n    const stop = colorStops[i];\n    gradient.addColorStop(stop.offset, stop.color);\n  }\n}\nfunction getCanvas(width, height) {\n  const canvas = adapter.DOMAdapter.get().createCanvas(width, height);\n  const context = canvas.getContext(\"2d\");\n  return { canvas, context };\n}\nfunction ensureGradientOptions(args) {\n  let options = args[0] ?? {};\n  if (typeof options === \"number\" || args[1]) {\n    deprecation.deprecation(\"8.5.2\", `use options object instead`);\n    options = {\n      type: \"linear\",\n      start: { x: args[0], y: args[1] },\n      end: { x: args[2], y: args[3] },\n      textureSpace: args[4],\n      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n    };\n  }\n  return options;\n}\n\nexports.FillGradient = FillGradient;\n//# sourceMappingURL=FillGradient.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    this.uid = uid.uid(\"fillPattern\");\n    /** The transform matrix applied to the pattern */\n    this.transform = new Matrix.Matrix();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  /**\n   * Sets the transform for the pattern\n   * @param transform - The transform matrix to apply to the pattern.\n   * If not provided, the pattern will use the default transform.\n   */\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  /**\n   * Gets a unique key representing the current state of the pattern.\n   * Used internally for caching.\n   * @returns Unique string key\n   */\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n    return this._styleKey;\n  }\n}\n\nexports.FillPattern = FillPattern;\n//# sourceMappingURL=FillPattern.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! ../../../../maths/point/Point.js */ \"./node_modules/pixi.js/lib/maths/point/Point.js\");\nvar uid = __webpack_require__(/*! ../../../../utils/data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar parseSVGPath = __webpack_require__(/*! ../svg/parseSVGPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js\");\nvar ShapePath = __webpack_require__(/*! ./ShapePath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js\");\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   * @param signed\n   */\n  constructor(instructions, signed = false) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid.uid(\"graphicsPath\");\n    this._dirty = true;\n    this.checkForHoles = signed;\n    if (typeof instructions === \"string\") {\n      parseSVGPath.parseSVGPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath.ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius || (innerRadius = radius / 2);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    newGraphicsPath2D.checkForHoles = this.checkForHoles;\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn.warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexports.GraphicsPath = GraphicsPath;\n//# sourceMappingURL=GraphicsPath.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Circle = __webpack_require__(/*! ../../../../maths/shapes/Circle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Circle.js\");\nvar Ellipse = __webpack_require__(/*! ../../../../maths/shapes/Ellipse.js */ \"./node_modules/pixi.js/lib/maths/shapes/Ellipse.js\");\nvar Polygon = __webpack_require__(/*! ../../../../maths/shapes/Polygon.js */ \"./node_modules/pixi.js/lib/maths/shapes/Polygon.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar RoundedRectangle = __webpack_require__(/*! ../../../../maths/shapes/RoundedRectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.js\");\nvar Bounds = __webpack_require__(/*! ../../../container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar buildAdaptiveBezier = __webpack_require__(/*! ../buildCommands/buildAdaptiveBezier.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js\");\nvar buildAdaptiveQuadratic = __webpack_require__(/*! ../buildCommands/buildAdaptiveQuadratic.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js\");\nvar buildArc = __webpack_require__(/*! ../buildCommands/buildArc.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js\");\nvar buildArcTo = __webpack_require__(/*! ../buildCommands/buildArcTo.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js\");\nvar buildArcToSvg = __webpack_require__(/*! ../buildCommands/buildArcToSvg.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js\");\nvar roundShape = __webpack_require__(/*! ./roundShape.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js\");\n\n\"use strict\";\nconst tempRectangle = new Rectangle.Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds.Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n    this.signed = graphicsPath2D.checkForHoles;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc.buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo.buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg.buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier.buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic.buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    const shapePrimitives = this.shapePrimitives;\n    const start = shapePrimitives.length;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    if (path.checkForHoles && shapePrimitives.length - start > 1) {\n      let mainShape = null;\n      for (let i = start; i < shapePrimitives.length; i++) {\n        const shapePrimitive = shapePrimitives[i];\n        if (shapePrimitive.shape.type === \"polygon\") {\n          const polygon = shapePrimitive.shape;\n          const mainPolygon = mainShape?.shape;\n          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {\n            mainShape.holes || (mainShape.holes = []);\n            mainShape.holes.push(shapePrimitive);\n            shapePrimitives.copyWithin(i, i + 1);\n            shapePrimitives.length--;\n            i--;\n          } else {\n            mainShape = shapePrimitive;\n          }\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle.Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle.Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon.Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = startAngle - i * delta;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundShape.roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundShape.roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse.Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle.RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon.Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon.Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexports.ShapePath = ShapePath;\n//# sourceMappingURL=ShapePath.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexports.roundedShapeArc = roundedShapeArc;\nexports.roundedShapeQuadraticCurve = roundedShapeQuadraticCurve;\n//# sourceMappingURL=roundShape.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar GraphicsPath = __webpack_require__(/*! ../path/GraphicsPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js\");\nvar parseSVGDefinitions = __webpack_require__(/*! ./parseSVGDefinitions.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js\");\nvar parseSVGFloatAttribute = __webpack_require__(/*! ./parseSVGFloatAttribute.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js\");\nvar parseSVGStyle = __webpack_require__(/*! ./parseSVGStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js\");\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    defs: {},\n    path: new GraphicsPath.GraphicsPath()\n  };\n  parseSVGDefinitions.parseSVGDefinitions(svg, session);\n  const children = svg.children;\n  const { fillStyle, strokeStyle } = parseSVGStyle.parseSVGStyle(svg, session);\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child.nodeName.toLowerCase() === \"defs\")\n      continue;\n    renderChildren(child, session, fillStyle, strokeStyle);\n  }\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle.parseSVGStyle(svg, session);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  const noStyle = !fillStyle && !strokeStyle;\n  if (noStyle) {\n    fillStyle = { color: 0 };\n  }\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      if (svg.getAttribute(\"fill-rule\") === \"evenodd\") {\n        warn.warn(\"SVG Evenodd fill rule not supported, your svg may render incorrectly\");\n      }\n      graphicsPath = new GraphicsPath.GraphicsPath(d, true);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"circle\":\n      cx = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"cy\", 0);\n      r = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"rect\":\n      x = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"x\", 0);\n      y = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"y\", 0);\n      width = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"width\", 0);\n      height = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"height\", 0);\n      rx = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"ellipse\":\n      cx = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"cy\", 0);\n      rx = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"line\":\n      x1 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"x1\", 0);\n      y1 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"y1\", 0);\n      x2 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"x2\", 0);\n      y2 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      warn.warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  if (noStyle) {\n    fillStyle = null;\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\n\nexports.SVGParser = SVGParser;\n//# sourceMappingURL=SVGParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar FillGradient = __webpack_require__(/*! ../fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar parseSVGFloatAttribute = __webpack_require__(/*! ./parseSVGFloatAttribute.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js\");\n\n\"use strict\";\nfunction parseSVGDefinitions(svg, session) {\n  const definitions = svg.querySelectorAll(\"defs\");\n  for (let i = 0; i < definitions.length; i++) {\n    const definition = definitions[i];\n    for (let j = 0; j < definition.children.length; j++) {\n      const child = definition.children[j];\n      switch (child.nodeName.toLowerCase()) {\n        case \"lineargradient\":\n          session.defs[child.id] = parseLinearGradient(child);\n          break;\n        case \"radialgradient\":\n          session.defs[child.id] = parseRadialGradient(child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n}\nfunction parseLinearGradient(child) {\n  const x0 = parseSVGFloatAttribute.parseSVGFloatAttribute(child, \"x1\", 0);\n  const y0 = parseSVGFloatAttribute.parseSVGFloatAttribute(child, \"y1\", 0);\n  const x1 = parseSVGFloatAttribute.parseSVGFloatAttribute(child, \"x2\", 1);\n  const y1 = parseSVGFloatAttribute.parseSVGFloatAttribute(child, \"y2\", 0);\n  const gradientUnit = child.getAttribute(\"gradientUnits\") || \"objectBoundingBox\";\n  const gradient = new FillGradient.FillGradient(\n    x0,\n    y0,\n    x1,\n    y1,\n    gradientUnit === \"objectBoundingBox\" ? \"local\" : \"global\"\n  );\n  for (let k = 0; k < child.children.length; k++) {\n    const stop = child.children[k];\n    const offset = parseSVGFloatAttribute.parseSVGFloatAttribute(stop, \"offset\", 0);\n    const color = Color.Color.shared.setValue(stop.getAttribute(\"stop-color\")).toNumber();\n    gradient.addColorStop(offset, color);\n  }\n  return gradient;\n}\nfunction parseRadialGradient(_child) {\n  warn.warn(\"[SVG Parser] Radial gradients are not yet supported\");\n  return new FillGradient.FillGradient(0, 0, 1, 0);\n}\n\nexports.parseSVGDefinitions = parseSVGDefinitions;\n//# sourceMappingURL=parseSVGDefinitions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction parseSVGFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\n\nexports.parseSVGFloatAttribute = parseSVGFloatAttribute;\n//# sourceMappingURL=parseSVGFloatAttribute.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar parse = __webpack_require__(/*! parse-svg-path */ \"./node_modules/parse-svg-path/index.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nfunction parseSVGPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          // First control point\n          data[3],\n          data[4],\n          // Second control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          // First control point\n          lastX + data[3],\n          lastY + data[4],\n          // Second control point\n          lastX + data[5],\n          lastY + data[6]\n          // End point\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          // Control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          // Control point\n          lastX + data[3],\n          lastY + data[4]\n          // End point\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          // Control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          // Control point\n          lastX + data[3],\n          lastY + data[4]\n          // End point\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          // rx\n          data[2],\n          // ry\n          data[3],\n          // x-axis-rotation\n          data[4],\n          // large-arc-flag\n          data[5],\n          // sweep-flag\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          // rx\n          data[2],\n          // ry\n          data[3],\n          // x-axis-rotation\n          data[4],\n          // large-arc-flag\n          data[5],\n          // sweep-flag\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn.warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexports.parseSVGPath = parseSVGPath;\n//# sourceMappingURL=parseSVGPath.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar extractSvgUrlId = __webpack_require__(/*! ./utils/extractSvgUrlId.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js\");\n\n\"use strict\";\nconst styleAttributes = {\n  // Fill properties\n  fill: { type: \"paint\", default: 0 },\n  // Fill color/gradient\n  \"fill-opacity\": { type: \"number\", default: 1 },\n  // Fill transparency\n  // Stroke properties\n  stroke: { type: \"paint\", default: 0 },\n  // Stroke color/gradient\n  \"stroke-width\": { type: \"number\", default: 1 },\n  // Width of stroke\n  \"stroke-opacity\": { type: \"number\", default: 1 },\n  // Stroke transparency\n  \"stroke-linecap\": { type: \"string\", default: \"butt\" },\n  // End cap style: butt, round, square\n  \"stroke-linejoin\": { type: \"string\", default: \"miter\" },\n  // Join style: miter, round, bevel\n  \"stroke-miterlimit\": { type: \"number\", default: 10 },\n  // Limit on miter join sharpness\n  \"stroke-dasharray\": { type: \"string\", default: \"none\" },\n  // Dash pattern\n  \"stroke-dashoffset\": { type: \"number\", default: 0 },\n  // Offset for dash pattern\n  // Global properties\n  opacity: { type: \"number\", default: 1 }\n  // Overall opacity\n};\nfunction parseSVGStyle(svg, session) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  const result = {\n    strokeStyle,\n    fillStyle,\n    useFill: false,\n    useStroke: false\n  };\n  for (const key in styleAttributes) {\n    const attribute = svg.getAttribute(key);\n    if (attribute) {\n      parseAttribute(session, result, key, attribute.trim());\n    }\n  }\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i].trim();\n      const [key, value] = stylePart.split(\":\");\n      if (styleAttributes[key]) {\n        parseAttribute(session, result, key, value.trim());\n      }\n    }\n  }\n  return {\n    strokeStyle: result.useStroke ? strokeStyle : null,\n    fillStyle: result.useFill ? fillStyle : null,\n    useFill: result.useFill,\n    useStroke: result.useStroke\n  };\n}\nfunction parseAttribute(session, result, id, value) {\n  switch (id) {\n    case \"stroke\":\n      if (value !== \"none\") {\n        if (value.startsWith(\"url(\")) {\n          const id2 = extractSvgUrlId.extractSvgUrlId(value);\n          result.strokeStyle.fill = session.defs[id2];\n        } else {\n          result.strokeStyle.color = Color.Color.shared.setValue(value).toNumber();\n        }\n        result.useStroke = true;\n      }\n      break;\n    case \"stroke-width\":\n      result.strokeStyle.width = Number(value);\n      break;\n    case \"fill\":\n      if (value !== \"none\") {\n        if (value.startsWith(\"url(\")) {\n          const id2 = extractSvgUrlId.extractSvgUrlId(value);\n          result.fillStyle.fill = session.defs[id2];\n        } else {\n          result.fillStyle.color = Color.Color.shared.setValue(value).toNumber();\n        }\n        result.useFill = true;\n      }\n      break;\n    case \"fill-opacity\":\n      result.fillStyle.alpha = Number(value);\n      break;\n    case \"stroke-opacity\":\n      result.strokeStyle.alpha = Number(value);\n      break;\n    case \"opacity\":\n      result.fillStyle.alpha = Number(value);\n      result.strokeStyle.alpha = Number(value);\n      break;\n  }\n}\n\nexports.parseSVGStyle = parseSVGStyle;\nexports.styleAttributes = styleAttributes;\n//# sourceMappingURL=parseSVGStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction extractSvgUrlId(url) {\n  const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n  return match ? match[1] : \"\";\n}\n\nexports.extractSvgUrlId = extractSvgUrlId;\n//# sourceMappingURL=extractSvgUrlId.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar buildUvs = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/buildUvs.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.js\");\nvar transformVertices = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/transformVertices.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.js\");\nvar Texture = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar PoolGroup = __webpack_require__(/*! ../../../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar BatchableGraphics = __webpack_require__(/*! ../BatchableGraphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js\");\nvar buildCircle = __webpack_require__(/*! ../buildCommands/buildCircle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js\");\nvar buildLine = __webpack_require__(/*! ../buildCommands/buildLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js\");\nvar buildPixelLine = __webpack_require__(/*! ../buildCommands/buildPixelLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js\");\nvar buildPolygon = __webpack_require__(/*! ../buildCommands/buildPolygon.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js\");\nvar buildRectangle = __webpack_require__(/*! ../buildCommands/buildRectangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js\");\nvar buildTriangle = __webpack_require__(/*! ../buildCommands/buildTriangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js\");\nvar generateTextureFillMatrix = __webpack_require__(/*! ./generateTextureFillMatrix.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js\");\nvar triangulateWithHoles = __webpack_require__(/*! ./triangulateWithHoles.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js\");\n\n\"use strict\";\nconst shapeBuilders = {};\nExtensions.extensions.handleByMap(Extensions.ExtensionType.ShapeBuilder, shapeBuilders);\nExtensions.extensions.add(buildRectangle.buildRectangle, buildPolygon.buildPolygon, buildTriangle.buildTriangle, buildCircle.buildCircle, buildCircle.buildEllipse, buildCircle.buildRoundedRectangle);\nconst tempRect = new Rectangle.Rectangle();\nconst tempTextureMatrix = new Matrix.Matrix();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n      }\n      if (hole) {\n        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n      }\n      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  if (!build.build(rect, points)) {\n    return;\n  }\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  if (matrix) {\n    transformVertices.transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const texture = data.image;\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    if (!build.build(shape, points)) {\n      return;\n    }\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    let topology = \"triangle-list\";\n    if (matrix) {\n      transformVertices.transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (holes) {\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(holes);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles.triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      if (!lineStyle.pixelLine) {\n        buildLine.buildLine(points, lineStyle, false, close, vertices, indices);\n      } else {\n        buildPixelLine.buildPixelLine(points, close, vertices, indices);\n        topology = \"line-list\";\n      }\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.Texture.WHITE) {\n      const textureMatrix = generateTextureFillMatrix.generateTextureMatrix(tempTextureMatrix, style, shape, matrix);\n      buildUvs.buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildUvs.buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    graphicsBatch.topology = topology;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(holePrimitives) {\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    if (holeBuilder.build(holePrimitive, holePoints)) {\n      holeArrays.push(holePoints);\n    }\n  }\n  return holeArrays;\n}\n\nexports.buildContextBatches = buildContextBatches;\nexports.shapeBuilders = shapeBuilders;\n//# sourceMappingURL=buildContextBatches.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Texture = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar FillGradient = __webpack_require__(/*! ../fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar FillPattern = __webpack_require__(/*! ../fill/FillPattern.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js\");\n\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern.FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient.FillGradient;\n}\nfunction isTexture(value) {\n  return value instanceof Texture.Texture;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.Texture.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleTexture(fill, value, defaultStyle) {\n  fill.texture = value;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  fill.textureSpace = value.textureSpace;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  const color = Color.Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isTexture(value)) {\n    return handleTexture(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    pixelLine,\n    ...fill\n  };\n}\n\nexports.toFillStyle = toFillStyle;\nexports.toStrokeStyle = toStrokeStyle;\n//# sourceMappingURL=convertFillInputToFillStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Rectangle = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar FillGradient = __webpack_require__(/*! ../fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\n\n\"use strict\";\nconst tempTextureMatrix = new Matrix.Matrix();\nconst tempRect = new Rectangle.Rectangle();\nfunction generateTextureMatrix(out, style, shape, matrix) {\n  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();\n  if (style.textureSpace === \"local\") {\n    const bounds = shape.getBounds(tempRect);\n    if (style.width) {\n      bounds.pad(style.width);\n    }\n    const { x: tx, y: ty } = bounds;\n    const sx = 1 / bounds.width;\n    const sy = 1 / bounds.height;\n    const mTx = -tx * sx;\n    const mTy = -ty * sy;\n    const a1 = textureMatrix.a;\n    const b1 = textureMatrix.b;\n    const c1 = textureMatrix.c;\n    const d1 = textureMatrix.d;\n    textureMatrix.a *= sx;\n    textureMatrix.b *= sx;\n    textureMatrix.c *= sy;\n    textureMatrix.d *= sy;\n    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;\n    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;\n  } else {\n    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n  }\n  const sourceStyle = style.texture.source.style;\n  if (!(style.fill instanceof FillGradient.FillGradient) && sourceStyle.addressMode === \"clamp-to-edge\") {\n    sourceStyle.addressMode = \"repeat\";\n    sourceStyle.update();\n  }\n  if (matrix) {\n    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n  }\n  return textureMatrix;\n}\n\nexports.generateTextureMatrix = generateTextureMatrix;\n//# sourceMappingURL=generateTextureFillMatrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexports.getOrientationOfPoints = getOrientationOfPoints;\n//# sourceMappingURL=getOrientationOfPoints.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../../../../utils/utils.js */ \"./node_modules/pixi.js/lib/utils/utils.js\");\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = utils.earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexports.triangulateWithHoles = triangulateWithHoles;\n//# sourceMappingURL=triangulateWithHoles.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/index.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Bounds = __webpack_require__(/*! ./container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar getFastGlobalBounds = __webpack_require__(/*! ./container/bounds/getFastGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.js\");\nvar getGlobalBounds = __webpack_require__(/*! ./container/bounds/getGlobalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.js\");\nvar getLocalBounds = __webpack_require__(/*! ./container/bounds/getLocalBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.js\");\nvar getRenderableBounds = __webpack_require__(/*! ./container/bounds/getRenderableBounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.js\");\nvar matrixAndBoundsPool = __webpack_require__(/*! ./container/bounds/utils/matrixAndBoundsPool.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.js\");\nvar cacheAsTextureMixin = __webpack_require__(/*! ./container/container-mixins/cacheAsTextureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.js\");\nvar childrenHelperMixin = __webpack_require__(/*! ./container/container-mixins/childrenHelperMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.js\");\nvar collectRenderablesMixin = __webpack_require__(/*! ./container/container-mixins/collectRenderablesMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.js\");\nvar effectsMixin = __webpack_require__(/*! ./container/container-mixins/effectsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.js\");\nvar findMixin = __webpack_require__(/*! ./container/container-mixins/findMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.js\");\nvar getFastGlobalBoundsMixin = __webpack_require__(/*! ./container/container-mixins/getFastGlobalBoundsMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.js\");\nvar getGlobalMixin = __webpack_require__(/*! ./container/container-mixins/getGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js\");\nvar measureMixin = __webpack_require__(/*! ./container/container-mixins/measureMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.js\");\nvar onRenderMixin = __webpack_require__(/*! ./container/container-mixins/onRenderMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.js\");\nvar sortMixin = __webpack_require__(/*! ./container/container-mixins/sortMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.js\");\nvar toLocalGlobalMixin = __webpack_require__(/*! ./container/container-mixins/toLocalGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.js\");\nvar Container = __webpack_require__(/*! ./container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\nvar CustomRenderPipe = __webpack_require__(/*! ./container/CustomRenderPipe.js */ \"./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.js\");\n__webpack_require__(/*! ./container/destroyTypes.js */ \"./node_modules/pixi.js/lib/scene/container/destroyTypes.js\");\n__webpack_require__(/*! ./container/Effect.js */ \"./node_modules/pixi.js/lib/scene/container/Effect.js\");\nvar RenderContainer = __webpack_require__(/*! ./container/RenderContainer.js */ \"./node_modules/pixi.js/lib/scene/container/RenderContainer.js\");\nvar RenderGroup = __webpack_require__(/*! ./container/RenderGroup.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroup.js\");\nvar RenderGroupPipe = __webpack_require__(/*! ./container/RenderGroupPipe.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.js\");\nvar RenderGroupSystem = __webpack_require__(/*! ./container/RenderGroupSystem.js */ \"./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.js\");\nvar assignWithIgnore = __webpack_require__(/*! ./container/utils/assignWithIgnore.js */ \"./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js\");\nvar checkChildrenDidChange = __webpack_require__(/*! ./container/utils/checkChildrenDidChange.js */ \"./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.js\");\nvar clearList = __webpack_require__(/*! ./container/utils/clearList.js */ \"./node_modules/pixi.js/lib/scene/container/utils/clearList.js\");\nvar collectAllRenderables = __webpack_require__(/*! ./container/utils/collectAllRenderables.js */ \"./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.js\");\nvar definedProps = __webpack_require__(/*! ./container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar executeInstructions = __webpack_require__(/*! ./container/utils/executeInstructions.js */ \"./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.js\");\nvar multiplyColors = __webpack_require__(/*! ./container/utils/multiplyColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.js\");\nvar multiplyHexColors = __webpack_require__(/*! ./container/utils/multiplyHexColors.js */ \"./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.js\");\nvar updateLocalTransform = __webpack_require__(/*! ./container/utils/updateLocalTransform.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.js\");\nvar updateRenderGroupTransforms = __webpack_require__(/*! ./container/utils/updateRenderGroupTransforms.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.js\");\nvar updateWorldTransform = __webpack_require__(/*! ./container/utils/updateWorldTransform.js */ \"./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.js\");\nvar validateRenderables = __webpack_require__(/*! ./container/utils/validateRenderables.js */ \"./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.js\");\nvar GlGraphicsAdaptor = __webpack_require__(/*! ./graphics/gl/GlGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.js\");\nvar colorToUniform = __webpack_require__(/*! ./graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar GpuGraphicsAdaptor = __webpack_require__(/*! ./graphics/gpu/GpuGraphicsAdaptor.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.js\");\nvar BatchableGraphics = __webpack_require__(/*! ./graphics/shared/BatchableGraphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.js\");\nvar buildAdaptiveBezier = __webpack_require__(/*! ./graphics/shared/buildCommands/buildAdaptiveBezier.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.js\");\nvar buildAdaptiveQuadratic = __webpack_require__(/*! ./graphics/shared/buildCommands/buildAdaptiveQuadratic.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.js\");\nvar buildArc = __webpack_require__(/*! ./graphics/shared/buildCommands/buildArc.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.js\");\nvar buildArcTo = __webpack_require__(/*! ./graphics/shared/buildCommands/buildArcTo.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.js\");\nvar buildArcToSvg = __webpack_require__(/*! ./graphics/shared/buildCommands/buildArcToSvg.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.js\");\nvar buildCircle = __webpack_require__(/*! ./graphics/shared/buildCommands/buildCircle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.js\");\nvar buildLine = __webpack_require__(/*! ./graphics/shared/buildCommands/buildLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.js\");\nvar buildPixelLine = __webpack_require__(/*! ./graphics/shared/buildCommands/buildPixelLine.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.js\");\nvar buildPolygon = __webpack_require__(/*! ./graphics/shared/buildCommands/buildPolygon.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.js\");\nvar buildRectangle = __webpack_require__(/*! ./graphics/shared/buildCommands/buildRectangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.js\");\nvar buildTriangle = __webpack_require__(/*! ./graphics/shared/buildCommands/buildTriangle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.js\");\n__webpack_require__(/*! ./graphics/shared/buildCommands/ShapeBuildCommand.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/ShapeBuildCommand.js\");\nvar _const = __webpack_require__(/*! ./graphics/shared/const.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/const.js\");\nvar FillGradient = __webpack_require__(/*! ./graphics/shared/fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar FillPattern = __webpack_require__(/*! ./graphics/shared/fill/FillPattern.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js\");\n__webpack_require__(/*! ./graphics/shared/FillTypes.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/FillTypes.js\");\nvar Graphics = __webpack_require__(/*! ./graphics/shared/Graphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js\");\nvar GraphicsContext = __webpack_require__(/*! ./graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar GraphicsContextSystem = __webpack_require__(/*! ./graphics/shared/GraphicsContextSystem.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.js\");\nvar GraphicsPipe = __webpack_require__(/*! ./graphics/shared/GraphicsPipe.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.js\");\nvar GraphicsPath = __webpack_require__(/*! ./graphics/shared/path/GraphicsPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.js\");\nvar roundShape = __webpack_require__(/*! ./graphics/shared/path/roundShape.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.js\");\nvar ShapePath = __webpack_require__(/*! ./graphics/shared/path/ShapePath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.js\");\nvar parseSVGDefinitions = __webpack_require__(/*! ./graphics/shared/svg/parseSVGDefinitions.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.js\");\nvar parseSVGFloatAttribute = __webpack_require__(/*! ./graphics/shared/svg/parseSVGFloatAttribute.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.js\");\nvar parseSVGPath = __webpack_require__(/*! ./graphics/shared/svg/parseSVGPath.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.js\");\nvar parseSVGStyle = __webpack_require__(/*! ./graphics/shared/svg/parseSVGStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.js\");\nvar SVGParser = __webpack_require__(/*! ./graphics/shared/svg/SVGParser.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.js\");\nvar extractSvgUrlId = __webpack_require__(/*! ./graphics/shared/svg/utils/extractSvgUrlId.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.js\");\nvar buildContextBatches = __webpack_require__(/*! ./graphics/shared/utils/buildContextBatches.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.js\");\nvar convertFillInputToFillStyle = __webpack_require__(/*! ./graphics/shared/utils/convertFillInputToFillStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js\");\nvar generateTextureFillMatrix = __webpack_require__(/*! ./graphics/shared/utils/generateTextureFillMatrix.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.js\");\nvar getOrientationOfPoints = __webpack_require__(/*! ./graphics/shared/utils/getOrientationOfPoints.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.js\");\nvar triangulateWithHoles = __webpack_require__(/*! ./graphics/shared/utils/triangulateWithHoles.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.js\");\nvar RenderLayer = __webpack_require__(/*! ./layers/RenderLayer.js */ \"./node_modules/pixi.js/lib/scene/layers/RenderLayer.js\");\nvar PerspectiveMesh = __webpack_require__(/*! ./mesh-perspective/PerspectiveMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.js\");\nvar PerspectivePlaneGeometry = __webpack_require__(/*! ./mesh-perspective/PerspectivePlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js\");\nvar applyProjectiveTransformationToPlane = __webpack_require__(/*! ./mesh-perspective/utils/applyProjectiveTransformationToPlane.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js\");\nvar compute2DProjections = __webpack_require__(/*! ./mesh-perspective/utils/compute2DProjections.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js\");\nvar MeshPlane = __webpack_require__(/*! ./mesh-plane/MeshPlane.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.js\");\nvar PlaneGeometry = __webpack_require__(/*! ./mesh-plane/PlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js\");\nvar MeshRope = __webpack_require__(/*! ./mesh-simple/MeshRope.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.js\");\nvar MeshSimple = __webpack_require__(/*! ./mesh-simple/MeshSimple.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.js\");\nvar RopeGeometry = __webpack_require__(/*! ./mesh-simple/RopeGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js\");\nvar GlMeshAdaptor = __webpack_require__(/*! ./mesh/gl/GlMeshAdaptor.js */ \"./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js\");\nvar GpuMeshAdapter = __webpack_require__(/*! ./mesh/gpu/GpuMeshAdapter.js */ \"./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js\");\nvar BatchableMesh = __webpack_require__(/*! ./mesh/shared/BatchableMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js\");\nvar getTextureDefaultMatrix = __webpack_require__(/*! ./mesh/shared/getTextureDefaultMatrix.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.js\");\nvar Mesh = __webpack_require__(/*! ./mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar MeshGeometry = __webpack_require__(/*! ./mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\nvar MeshPipe = __webpack_require__(/*! ./mesh/shared/MeshPipe.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js\");\nvar GlParticleContainerAdaptor = __webpack_require__(/*! ./particle-container/gl/GlParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js\");\nvar GpuParticleContainerAdaptor = __webpack_require__(/*! ./particle-container/gpu/GpuParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js\");\nvar GlParticleContainerPipe = __webpack_require__(/*! ./particle-container/shared/GlParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js\");\nvar GpuParticleContainerPipe = __webpack_require__(/*! ./particle-container/shared/GpuParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js\");\nvar Particle = __webpack_require__(/*! ./particle-container/shared/Particle.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.js\");\nvar ParticleBuffer = __webpack_require__(/*! ./particle-container/shared/ParticleBuffer.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js\");\nvar ParticleContainer = __webpack_require__(/*! ./particle-container/shared/ParticleContainer.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.js\");\nvar ParticleContainerPipe = __webpack_require__(/*! ./particle-container/shared/ParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js\");\nvar particleData = __webpack_require__(/*! ./particle-container/shared/particleData.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js\");\nvar ParticleShader = __webpack_require__(/*! ./particle-container/shared/shader/ParticleShader.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js\");\nvar createIndicesForQuads = __webpack_require__(/*! ./particle-container/shared/utils/createIndicesForQuads.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js\");\nvar generateParticleUpdateFunction = __webpack_require__(/*! ./particle-container/shared/utils/generateParticleUpdateFunction.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js\");\nvar AnimatedSprite = __webpack_require__(/*! ./sprite-animated/AnimatedSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js\");\nvar NineSliceGeometry = __webpack_require__(/*! ./sprite-nine-slice/NineSliceGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js\");\nvar NineSliceSprite = __webpack_require__(/*! ./sprite-nine-slice/NineSliceSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.js\");\nvar NineSliceSpritePipe = __webpack_require__(/*! ./sprite-nine-slice/NineSliceSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js\");\nvar tilingBit = __webpack_require__(/*! ./sprite-tiling/shader/tilingBit.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js\");\nvar TilingSpriteShader = __webpack_require__(/*! ./sprite-tiling/shader/TilingSpriteShader.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js\");\nvar TilingSprite = __webpack_require__(/*! ./sprite-tiling/TilingSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js\");\nvar TilingSpritePipe = __webpack_require__(/*! ./sprite-tiling/TilingSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js\");\nvar applyMatrix = __webpack_require__(/*! ./sprite-tiling/utils/applyMatrix.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js\");\nvar QuadGeometry = __webpack_require__(/*! ./sprite-tiling/utils/QuadGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js\");\nvar setPositions = __webpack_require__(/*! ./sprite-tiling/utils/setPositions.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js\");\nvar setUvs = __webpack_require__(/*! ./sprite-tiling/utils/setUvs.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js\");\nvar BatchableSprite = __webpack_require__(/*! ./sprite/BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\nvar Sprite = __webpack_require__(/*! ./sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\nvar SpritePipe = __webpack_require__(/*! ./sprite/SpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js\");\nvar AbstractBitmapFont = __webpack_require__(/*! ./text-bitmap/AbstractBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js\");\nvar bitmapFontTextParser = __webpack_require__(/*! ./text-bitmap/asset/bitmapFontTextParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js\");\nvar bitmapFontXMLParser = __webpack_require__(/*! ./text-bitmap/asset/bitmapFontXMLParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js\");\nvar bitmapFontXMLStringParser = __webpack_require__(/*! ./text-bitmap/asset/bitmapFontXMLStringParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js\");\nvar loadBitmapFont = __webpack_require__(/*! ./text-bitmap/asset/loadBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js\");\nvar BitmapFont = __webpack_require__(/*! ./text-bitmap/BitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js\");\nvar BitmapFontManager = __webpack_require__(/*! ./text-bitmap/BitmapFontManager.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js\");\nvar BitmapText = __webpack_require__(/*! ./text-bitmap/BitmapText.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js\");\nvar BitmapTextPipe = __webpack_require__(/*! ./text-bitmap/BitmapTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js\");\nvar DynamicBitmapFont = __webpack_require__(/*! ./text-bitmap/DynamicBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js\");\nvar getBitmapTextLayout = __webpack_require__(/*! ./text-bitmap/utils/getBitmapTextLayout.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js\");\nvar resolveCharacters = __webpack_require__(/*! ./text-bitmap/utils/resolveCharacters.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js\");\nvar BatchableHTMLText = __webpack_require__(/*! ./text-html/BatchableHTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js\");\nvar HTMLText = __webpack_require__(/*! ./text-html/HTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLText.js\");\nvar HTMLTextPipe = __webpack_require__(/*! ./text-html/HTMLTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js\");\nvar HTMLTextRenderData = __webpack_require__(/*! ./text-html/HTMLTextRenderData.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js\");\nvar HTMLTextStyle = __webpack_require__(/*! ./text-html/HTMLTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js\");\nvar HTMLTextSystem = __webpack_require__(/*! ./text-html/HTMLTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js\");\nvar extractFontFamilies = __webpack_require__(/*! ./text-html/utils/extractFontFamilies.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js\");\nvar getFontCss = __webpack_require__(/*! ./text-html/utils/getFontCss.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js\");\nvar getSVGUrl = __webpack_require__(/*! ./text-html/utils/getSVGUrl.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js\");\nvar getTemporaryCanvasFromImage = __webpack_require__(/*! ./text-html/utils/getTemporaryCanvasFromImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js\");\nvar loadFontAsBase64 = __webpack_require__(/*! ./text-html/utils/loadFontAsBase64.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js\");\nvar loadFontCSS = __webpack_require__(/*! ./text-html/utils/loadFontCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js\");\nvar loadSVGImage = __webpack_require__(/*! ./text-html/utils/loadSVGImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js\");\nvar measureHtmlText = __webpack_require__(/*! ./text-html/utils/measureHtmlText.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js\");\nvar textStyleToCSS = __webpack_require__(/*! ./text-html/utils/textStyleToCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js\");\nvar AbstractText = __webpack_require__(/*! ./text/AbstractText.js */ \"./node_modules/pixi.js/lib/scene/text/AbstractText.js\");\nvar BatchableText = __webpack_require__(/*! ./text/canvas/BatchableText.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js\");\nvar CanvasTextGenerator = __webpack_require__(/*! ./text/canvas/CanvasTextGenerator.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ./text/canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar CanvasTextPipe = __webpack_require__(/*! ./text/canvas/CanvasTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js\");\nvar CanvasTextSystem = __webpack_require__(/*! ./text/canvas/CanvasTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js\");\nvar fontStringFromTextStyle = __webpack_require__(/*! ./text/canvas/utils/fontStringFromTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js\");\nvar getCanvasFillStyle = __webpack_require__(/*! ./text/canvas/utils/getCanvasFillStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js\");\nvar SdfShader = __webpack_require__(/*! ./text/sdfShader/SdfShader.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js\");\nvar localUniformMSDFBit = __webpack_require__(/*! ./text/sdfShader/shader-bits/localUniformMSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js\");\nvar mSDFBit = __webpack_require__(/*! ./text/sdfShader/shader-bits/mSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js\");\nvar Text = __webpack_require__(/*! ./text/Text.js */ \"./node_modules/pixi.js/lib/scene/text/Text.js\");\nvar TextStyle = __webpack_require__(/*! ./text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar generateTextStyleKey = __webpack_require__(/*! ./text/utils/generateTextStyleKey.js */ \"./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js\");\nvar getPo2TextureFromSource = __webpack_require__(/*! ./text/utils/getPo2TextureFromSource.js */ \"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js\");\nvar updateTextBounds = __webpack_require__(/*! ./text/utils/updateTextBounds.js */ \"./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js\");\nvar ViewContainer = __webpack_require__(/*! ./view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar particles = __webpack_require__(/*! ./particle-container/shared/shader/particles.frag.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js\");\nvar particles$1 = __webpack_require__(/*! ./particle-container/shared/shader/particles.vert.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js\");\nvar particles$2 = __webpack_require__(/*! ./particle-container/shared/shader/particles.wgsl.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js\");\n\n\"use strict\";\n\nexports.Bounds = Bounds.Bounds;\nexports.getFastGlobalBounds = getFastGlobalBounds.getFastGlobalBounds;\nexports.getGlobalBounds = getGlobalBounds.getGlobalBounds;\nexports.updateTransformBackwards = getGlobalBounds.updateTransformBackwards;\nexports.getLocalBounds = getLocalBounds.getLocalBounds;\nexports.getGlobalRenderableBounds = getRenderableBounds.getGlobalRenderableBounds;\nexports.boundsPool = matrixAndBoundsPool.boundsPool;\nexports.matrixPool = matrixAndBoundsPool.matrixPool;\nexports.cacheAsTextureMixin = cacheAsTextureMixin.cacheAsTextureMixin;\nexports.childrenHelperMixin = childrenHelperMixin.childrenHelperMixin;\nexports.collectRenderablesMixin = collectRenderablesMixin.collectRenderablesMixin;\nexports.effectsMixin = effectsMixin.effectsMixin;\nexports.findMixin = findMixin.findMixin;\nexports.getFastGlobalBoundsMixin = getFastGlobalBoundsMixin.getFastGlobalBoundsMixin;\nexports.bgr2rgb = getGlobalMixin.bgr2rgb;\nexports.getGlobalMixin = getGlobalMixin.getGlobalMixin;\nexports.measureMixin = measureMixin.measureMixin;\nexports.onRenderMixin = onRenderMixin.onRenderMixin;\nexports.sortMixin = sortMixin.sortMixin;\nexports.toLocalGlobalMixin = toLocalGlobalMixin.toLocalGlobalMixin;\nexports.Container = Container.Container;\nexports.UPDATE_BLEND = Container.UPDATE_BLEND;\nexports.UPDATE_COLOR = Container.UPDATE_COLOR;\nexports.UPDATE_TRANSFORM = Container.UPDATE_TRANSFORM;\nexports.UPDATE_VISIBLE = Container.UPDATE_VISIBLE;\nexports.CustomRenderPipe = CustomRenderPipe.CustomRenderPipe;\nexports.RenderContainer = RenderContainer.RenderContainer;\nexports.RenderGroup = RenderGroup.RenderGroup;\nexports.RenderGroupPipe = RenderGroupPipe.RenderGroupPipe;\nexports.RenderGroupSystem = RenderGroupSystem.RenderGroupSystem;\nexports.assignWithIgnore = assignWithIgnore.assignWithIgnore;\nexports.checkChildrenDidChange = checkChildrenDidChange.checkChildrenDidChange;\nexports.clearList = clearList.clearList;\nexports.collectAllRenderables = collectAllRenderables.collectAllRenderables;\nexports.definedProps = definedProps.definedProps;\nexports.executeInstructions = executeInstructions.executeInstructions;\nexports.multiplyColors = multiplyColors.multiplyColors;\nexports.multiplyHexColors = multiplyHexColors.multiplyHexColors;\nexports.updateLocalTransform = updateLocalTransform.updateLocalTransform;\nexports.updateRenderGroupTransform = updateRenderGroupTransforms.updateRenderGroupTransform;\nexports.updateRenderGroupTransforms = updateRenderGroupTransforms.updateRenderGroupTransforms;\nexports.updateTransformAndChildren = updateRenderGroupTransforms.updateTransformAndChildren;\nexports.updateWorldTransform = updateWorldTransform.updateWorldTransform;\nexports.validateRenderables = validateRenderables.validateRenderables;\nexports.GlGraphicsAdaptor = GlGraphicsAdaptor.GlGraphicsAdaptor;\nexports.color32BitToUniform = colorToUniform.color32BitToUniform;\nexports.colorToUniform = colorToUniform.colorToUniform;\nexports.GpuGraphicsAdaptor = GpuGraphicsAdaptor.GpuGraphicsAdaptor;\nexports.BatchableGraphics = BatchableGraphics.BatchableGraphics;\nexports.buildAdaptiveBezier = buildAdaptiveBezier.buildAdaptiveBezier;\nexports.buildAdaptiveQuadratic = buildAdaptiveQuadratic.buildAdaptiveQuadratic;\nexports.buildArc = buildArc.buildArc;\nexports.buildArcTo = buildArcTo.buildArcTo;\nexports.buildArcToSvg = buildArcToSvg.buildArcToSvg;\nexports.buildCircle = buildCircle.buildCircle;\nexports.buildEllipse = buildCircle.buildEllipse;\nexports.buildRoundedRectangle = buildCircle.buildRoundedRectangle;\nexports.buildLine = buildLine.buildLine;\nexports.buildPixelLine = buildPixelLine.buildPixelLine;\nexports.buildPolygon = buildPolygon.buildPolygon;\nexports.buildRectangle = buildRectangle.buildRectangle;\nexports.buildTriangle = buildTriangle.buildTriangle;\nexports.closePointEps = _const.closePointEps;\nexports.curveEps = _const.curveEps;\nexports.FillGradient = FillGradient.FillGradient;\nexports.FillPattern = FillPattern.FillPattern;\nexports.Graphics = Graphics.Graphics;\nexports.GraphicsContext = GraphicsContext.GraphicsContext;\nexports.GpuGraphicsContext = GraphicsContextSystem.GpuGraphicsContext;\nexports.GraphicsContextRenderData = GraphicsContextSystem.GraphicsContextRenderData;\nexports.GraphicsContextSystem = GraphicsContextSystem.GraphicsContextSystem;\nexports.GraphicsGpuData = GraphicsPipe.GraphicsGpuData;\nexports.GraphicsPipe = GraphicsPipe.GraphicsPipe;\nexports.GraphicsPath = GraphicsPath.GraphicsPath;\nexports.roundedShapeArc = roundShape.roundedShapeArc;\nexports.roundedShapeQuadraticCurve = roundShape.roundedShapeQuadraticCurve;\nexports.ShapePath = ShapePath.ShapePath;\nexports.parseSVGDefinitions = parseSVGDefinitions.parseSVGDefinitions;\nexports.parseSVGFloatAttribute = parseSVGFloatAttribute.parseSVGFloatAttribute;\nexports.parseSVGPath = parseSVGPath.parseSVGPath;\nexports.parseSVGStyle = parseSVGStyle.parseSVGStyle;\nexports.styleAttributes = parseSVGStyle.styleAttributes;\nexports.SVGParser = SVGParser.SVGParser;\nexports.extractSvgUrlId = extractSvgUrlId.extractSvgUrlId;\nexports.buildContextBatches = buildContextBatches.buildContextBatches;\nexports.shapeBuilders = buildContextBatches.shapeBuilders;\nexports.toFillStyle = convertFillInputToFillStyle.toFillStyle;\nexports.toStrokeStyle = convertFillInputToFillStyle.toStrokeStyle;\nexports.generateTextureMatrix = generateTextureFillMatrix.generateTextureMatrix;\nexports.getOrientationOfPoints = getOrientationOfPoints.getOrientationOfPoints;\nexports.triangulateWithHoles = triangulateWithHoles.triangulateWithHoles;\nexports.RenderLayer = RenderLayer.RenderLayer;\nexports.PerspectiveMesh = PerspectiveMesh.PerspectiveMesh;\nexports.PerspectivePlaneGeometry = PerspectivePlaneGeometry.PerspectivePlaneGeometry;\nexports.applyProjectiveTransformationToPlane = applyProjectiveTransformationToPlane.applyProjectiveTransformationToPlane;\nexports.compute2DProjection = compute2DProjections.compute2DProjection;\nexports.MeshPlane = MeshPlane.MeshPlane;\nexports.PlaneGeometry = PlaneGeometry.PlaneGeometry;\nexports.MeshRope = MeshRope.MeshRope;\nexports.MeshSimple = MeshSimple.MeshSimple;\nexports.RopeGeometry = RopeGeometry.RopeGeometry;\nexports.GlMeshAdaptor = GlMeshAdaptor.GlMeshAdaptor;\nexports.GpuMeshAdapter = GpuMeshAdapter.GpuMeshAdapter;\nexports.BatchableMesh = BatchableMesh.BatchableMesh;\nexports.getTextureDefaultMatrix = getTextureDefaultMatrix.getTextureDefaultMatrix;\nexports.Mesh = Mesh.Mesh;\nexports.MeshGeometry = MeshGeometry.MeshGeometry;\nexports.MeshGpuData = MeshPipe.MeshGpuData;\nexports.MeshPipe = MeshPipe.MeshPipe;\nexports.GlParticleContainerAdaptor = GlParticleContainerAdaptor.GlParticleContainerAdaptor;\nexports.GpuParticleContainerAdaptor = GpuParticleContainerAdaptor.GpuParticleContainerAdaptor;\nexports.GlParticleContainerPipe = GlParticleContainerPipe.GlParticleContainerPipe;\nexports.GpuParticleContainerPipe = GpuParticleContainerPipe.GpuParticleContainerPipe;\nexports.Particle = Particle.Particle;\nexports.ParticleBuffer = ParticleBuffer.ParticleBuffer;\nexports.ParticleContainer = ParticleContainer.ParticleContainer;\nexports.ParticleContainerPipe = ParticleContainerPipe.ParticleContainerPipe;\nexports.particleData = particleData.particleData;\nexports.ParticleShader = ParticleShader.ParticleShader;\nexports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;\nexports.generateParticleUpdateFunction = generateParticleUpdateFunction.generateParticleUpdateFunction;\nexports.AnimatedSprite = AnimatedSprite.AnimatedSprite;\nexports.NineSliceGeometry = NineSliceGeometry.NineSliceGeometry;\nexports.NineSlicePlane = NineSliceSprite.NineSlicePlane;\nexports.NineSliceSprite = NineSliceSprite.NineSliceSprite;\nexports.NineSliceSpriteGpuData = NineSliceSpritePipe.NineSliceSpriteGpuData;\nexports.NineSliceSpritePipe = NineSliceSpritePipe.NineSliceSpritePipe;\nexports.tilingBit = tilingBit.tilingBit;\nexports.tilingBitGl = tilingBit.tilingBitGl;\nexports.TilingSpriteShader = TilingSpriteShader.TilingSpriteShader;\nexports.TilingSprite = TilingSprite.TilingSprite;\nexports.TilingSpriteGpuData = TilingSpritePipe.TilingSpriteGpuData;\nexports.TilingSpritePipe = TilingSpritePipe.TilingSpritePipe;\nexports.applyMatrix = applyMatrix.applyMatrix;\nexports.QuadGeometry = QuadGeometry.QuadGeometry;\nexports.setPositions = setPositions.setPositions;\nexports.setUvs = setUvs.setUvs;\nexports.BatchableSprite = BatchableSprite.BatchableSprite;\nexports.Sprite = Sprite.Sprite;\nexports.SpritePipe = SpritePipe.SpritePipe;\nexports.AbstractBitmapFont = AbstractBitmapFont.AbstractBitmapFont;\nexports.bitmapFontTextParser = bitmapFontTextParser.bitmapFontTextParser;\nexports.bitmapFontXMLParser = bitmapFontXMLParser.bitmapFontXMLParser;\nexports.bitmapFontXMLStringParser = bitmapFontXMLStringParser.bitmapFontXMLStringParser;\nexports.bitmapFontCachePlugin = loadBitmapFont.bitmapFontCachePlugin;\nexports.loadBitmapFont = loadBitmapFont.loadBitmapFont;\nexports.BitmapFont = BitmapFont.BitmapFont;\nexports.BitmapFontManager = BitmapFontManager.BitmapFontManager;\nexports.BitmapText = BitmapText.BitmapText;\nexports.BitmapTextGraphics = BitmapTextPipe.BitmapTextGraphics;\nexports.BitmapTextPipe = BitmapTextPipe.BitmapTextPipe;\nexports.DynamicBitmapFont = DynamicBitmapFont.DynamicBitmapFont;\nexports.getBitmapTextLayout = getBitmapTextLayout.getBitmapTextLayout;\nexports.resolveCharacters = resolveCharacters.resolveCharacters;\nexports.BatchableHTMLText = BatchableHTMLText.BatchableHTMLText;\nexports.HTMLText = HTMLText.HTMLText;\nexports.HTMLTextPipe = HTMLTextPipe.HTMLTextPipe;\nexports.HTMLTextRenderData = HTMLTextRenderData.HTMLTextRenderData;\nexports.HTMLTextStyle = HTMLTextStyle.HTMLTextStyle;\nexports.HTMLTextSystem = HTMLTextSystem.HTMLTextSystem;\nexports.extractFontFamilies = extractFontFamilies.extractFontFamilies;\nexports.FontStylePromiseCache = getFontCss.FontStylePromiseCache;\nexports.getFontCss = getFontCss.getFontCss;\nexports.getSVGUrl = getSVGUrl.getSVGUrl;\nexports.getTemporaryCanvasFromImage = getTemporaryCanvasFromImage.getTemporaryCanvasFromImage;\nexports.loadFontAsBase64 = loadFontAsBase64.loadFontAsBase64;\nexports.loadFontCSS = loadFontCSS.loadFontCSS;\nexports.loadSVGImage = loadSVGImage.loadSVGImage;\nexports.measureHtmlText = measureHtmlText.measureHtmlText;\nexports.textStyleToCSS = textStyleToCSS.textStyleToCSS;\nexports.AbstractText = AbstractText.AbstractText;\nexports.ensureTextOptions = AbstractText.ensureTextOptions;\nexports.BatchableText = BatchableText.BatchableText;\nexports.CanvasTextGenerator = CanvasTextGenerator.CanvasTextGenerator;\nexports.CanvasTextMetrics = CanvasTextMetrics.CanvasTextMetrics;\nexports.CanvasTextPipe = CanvasTextPipe.CanvasTextPipe;\nexports.CanvasTextSystem = CanvasTextSystem.CanvasTextSystem;\nexports.fontStringFromTextStyle = fontStringFromTextStyle.fontStringFromTextStyle;\nexports.getCanvasFillStyle = getCanvasFillStyle.getCanvasFillStyle;\nexports.SdfShader = SdfShader.SdfShader;\nexports.localUniformMSDFBit = localUniformMSDFBit.localUniformMSDFBit;\nexports.localUniformMSDFBitGl = localUniformMSDFBit.localUniformMSDFBitGl;\nexports.mSDFBit = mSDFBit.mSDFBit;\nexports.mSDFBitGl = mSDFBit.mSDFBitGl;\nexports.Text = Text.Text;\nexports.TextStyle = TextStyle.TextStyle;\nexports.generateTextStyleKey = generateTextStyleKey.generateTextStyleKey;\nexports.getPo2TextureFromSource = getPo2TextureFromSource.getPo2TextureFromSource;\nexports.updateTextBounds = updateTextBounds.updateTextBounds;\nexports.ViewContainer = ViewContainer.ViewContainer;\nexports.particlesFrag = particles.default;\nexports.particlesVert = particles$1.default;\nexports.particlesWgsl = particles$2.default;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/layers/RenderLayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/layers/RenderLayer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar Container = __webpack_require__(/*! ../container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\n\n\"use strict\";\nconst _RenderLayerClass = class _RenderLayerClass extends Container.Container {\n  /**\n   * Creates a new RenderLayer instance\n   * @param options - Configuration options for the RenderLayer\n   * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n   * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n   */\n  constructor(options = {}) {\n    options = { ..._RenderLayerClass.defaultOptions, ...options };\n    super();\n    /**\n     * The list of objects that this layer is responsible for rendering. Objects in this list maintain\n     * their original parent in the scene graph but are rendered as part of this layer.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     * const sprite = new Sprite(texture);\n     *\n     * // Add sprite to scene graph for transforms\n     * container.addChild(sprite);\n     *\n     * // Add to layer for render order control\n     * layer.attach(sprite);\n     * console.log(layer.renderLayerChildren.length); // 1\n     *\n     * // Access objects in the layer\n     * layer.renderLayerChildren.forEach(child => {\n     *     console.log('Layer child:', child);\n     * });\n     *\n     * // Check if object is in layer\n     * const isInLayer = layer.renderLayerChildren.includes(sprite);\n     *\n     * // Clear all objects from layer\n     * layer.detachAll();\n     * console.log(layer.renderLayerChildren.length); // 0\n     * ```\n     * @readonly\n     * @see {@link RenderLayer#attach} For adding objects to the layer\n     * @see {@link RenderLayer#detach} For removing objects from the layer\n     * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n     */\n    this.renderLayerChildren = [];\n    this.sortableChildren = options.sortableChildren;\n    this.sortFunction = options.sortFunction;\n  }\n  /**\n   * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer\n   * while maintaining their original parent in the scene graph.\n   *\n   * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n   * @example\n   * ```ts\n   * const layer = new RenderLayer();\n   * const container = new Container();\n   * const sprite1 = new Sprite(texture1);\n   * const sprite2 = new Sprite(texture2);\n   *\n   * // Add sprites to scene graph for transforms\n   * container.addChild(sprite1, sprite2);\n   *\n   * // Add sprites to layer for render order control\n   * layer.attach(sprite1, sprite2);\n   *\n   * // Add single sprite with type checking\n   * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));\n   * typedSprite.tint = 'red';\n   *\n   * // Automatically removes from previous layer if needed\n   * const otherLayer = new RenderLayer();\n   * otherLayer.attach(sprite1); // Removes from previous layer\n   * ```\n   * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.\n   * @returns The first child that was added, for method chaining\n   * @see {@link RenderLayer#detach} For removing objects from the layer\n   * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n   * @see {@link Container#addChild} For adding to scene graph hierarchy\n   */\n  attach(...children) {\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.parentRenderLayer) {\n        if (child.parentRenderLayer === this)\n          continue;\n        child.parentRenderLayer.detach(child);\n      }\n      this.renderLayerChildren.push(child);\n      child.parentRenderLayer = this;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n    }\n    return children[0];\n  }\n  /**\n   * Removes one or more Containers from this render layer. The Containers will maintain their\n   * original parent in the scene graph but will no longer be rendered as part of this layer.\n   * @example\n   * ```ts\n   * const layer = new RenderLayer();\n   * const container = new Container();\n   * const sprite1 = new Sprite(texture1);\n   * const sprite2 = new Sprite(texture2);\n   *\n   * // Add sprites to scene graph and layer\n   * container.addChild(sprite1, sprite2);\n   * layer.attach(sprite1, sprite2);\n   *\n   * // Remove single sprite from layer\n   * layer.detach(sprite1);\n   * // sprite1 is still child of container but not rendered in layer\n   *\n   * // Remove multiple sprites at once\n   * const otherLayer = new RenderLayer();\n   * otherLayer.attach(sprite3, sprite4);\n   * otherLayer.detach(sprite3, sprite4);\n   *\n   * // Type-safe detachment\n   * const typedSprite = layer.detach<Sprite>(spriteInLayer);\n   * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite\n   * ```\n   * @param children - The Container(s) to remove from this layer\n   * @returns The first child that was removed, for method chaining\n   * @see {@link RenderLayer#attach} For adding objects to the layer\n   * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n   * @see {@link Container#removeChild} For removing from scene graph hierarchy\n   */\n  detach(...children) {\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const index = this.renderLayerChildren.indexOf(child);\n      if (index !== -1) {\n        this.renderLayerChildren.splice(index, 1);\n      }\n      child.parentRenderLayer = null;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n    }\n    return children[0];\n  }\n  /**\n   * Removes all objects from this render layer. Objects will maintain their\n   * original parent in the scene graph but will no longer be rendered as part of this layer.\n   * @example\n   * ```ts\n   * const layer = new RenderLayer();\n   * const container = new Container();\n   *\n   * // Add multiple sprites to scene graph and layer\n   * const sprites = [\n   *     new Sprite(texture1),\n   *     new Sprite(texture2),\n   *     new Sprite(texture3)\n   * ];\n   *\n   * container.addChild(...sprites);  // Add to scene graph\n   * layer.attach(...sprites);       // Add to render layer\n   *\n   * // Later, remove all sprites from layer at once\n   * layer.detachAll();\n   * console.log(layer.renderLayerChildren.length); // 0\n   * console.log(container.children.length);        // 3 (still in scene graph)\n   * ```\n   * @returns The RenderLayer instance for method chaining\n   * @see {@link RenderLayer#attach} For adding objects to the layer\n   * @see {@link RenderLayer#detach} For removing individual objects\n   * @see {@link Container#removeChildren} For removing from scene graph\n   */\n  detachAll() {\n    const layerChildren = this.renderLayerChildren;\n    for (let i = 0; i < layerChildren.length; i++) {\n      layerChildren[i].parentRenderLayer = null;\n    }\n    this.renderLayerChildren.length = 0;\n  }\n  /**\n   * Collects renderables for this layer and its children.\n   * This method is called by the renderer to gather all objects that should be rendered in this layer.\n   * @param instructionSet - The set of instructions to collect renderables into.\n   * @param renderer - The renderer that is collecting renderables.\n   * @param _currentLayer - The current render layer being processed.\n   * @internal\n   */\n  collectRenderables(instructionSet, renderer, _currentLayer) {\n    const layerChildren = this.renderLayerChildren;\n    const length = layerChildren.length;\n    if (this.sortableChildren) {\n      this.sortRenderLayerChildren();\n    }\n    for (let i = 0; i < length; i++) {\n      if (!layerChildren[i].parent) {\n        warn.warn(\n          \"Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)\",\n          layerChildren[i]\n        );\n      }\n      layerChildren[i].collectRenderables(instructionSet, renderer, this);\n    }\n  }\n  /**\n   * Sort the layer's children using the defined sort function. This method allows manual sorting\n   * of layer children and is automatically called during rendering if sortableChildren is true.\n   * @example\n   * ```ts\n   * const layer = new RenderLayer();\n   *\n   * // Add multiple sprites at different depths\n   * const sprite1 = new Sprite(texture);\n   * const sprite2 = new Sprite(texture);\n   * const sprite3 = new Sprite(texture);\n   *\n   * sprite1.zIndex = 3;\n   * sprite2.zIndex = 1;\n   * sprite3.zIndex = 2;\n   *\n   * layer.attach(sprite1, sprite2, sprite3);\n   *\n   * // Manual sorting with default zIndex sort\n   * layer.sortRenderLayerChildren();\n   * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)\n   *\n   * // Custom sort by y position\n   * layer.sortFunction = (a, b) => a.y - b.y;\n   * layer.sortRenderLayerChildren();\n   *\n   * // Automatic sorting\n   * layer.sortableChildren = true; // Will sort each render\n   * ```\n   * @returns The RenderLayer instance for method chaining\n   * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting\n   * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n   */\n  sortRenderLayerChildren() {\n    this.renderLayerChildren.sort(this.sortFunction);\n  }\n  /**\n   * Recursively calculates the global bounds of this RenderLayer and its children.\n   * @param factorRenderLayers\n   * @param bounds\n   * @param _currentLayer\n   * @internal\n   */\n  _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {\n    if (!factorRenderLayers)\n      return;\n    const children = this.renderLayerChildren;\n    for (let i = 0; i < children.length; i++) {\n      children[i]._getGlobalBoundsRecursive(true, bounds, this);\n    }\n  }\n};\n/**\n * Default options for RenderLayer instances. These options control the sorting behavior\n * of objects within the render layer.\n * @example\n * ```ts\n * // Create a custom render layer with modified default options\n * RenderLayer.defaultOptions = {\n *     sortableChildren: true,\n *     sortFunction: (a, b) => a.y - b.y // Sort by vertical position\n * };\n *\n * // All new render layers will use these defaults\n * const layer1 = new RenderLayer();\n * // layer1 will have sortableChildren = true\n * ```\n * @property {boolean} sortableChildren -\n * @property {Function} sortFunction -\n * @see {@link RenderLayer} For the main render layer class\n * @see {@link Container#zIndex} For the default sort property\n * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n */\n_RenderLayerClass.defaultOptions = {\n  /** If true, layer children will be automatically sorted each render. Default is false. */\n  sortableChildren: false,\n  /**\n   * Function used to sort layer children.\n   * Default sorts by zIndex. Accepts two Container objects and returns\n   * a number indicating their relative order.\n   * @param a - First container to compare\n   * @param b - Second container to compare\n   * @returns Negative if a should render before b, positive if b should render before a\n   */\n  sortFunction: (a, b) => a.zIndex - b.zIndex\n};\nlet RenderLayerClass = _RenderLayerClass;\nconst RenderLayer = RenderLayerClass;\n\nexports.RenderLayer = RenderLayer;\n//# sourceMappingURL=RenderLayer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/layers/RenderLayer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar definedProps = __webpack_require__(/*! ../container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar Mesh = __webpack_require__(/*! ../mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar PerspectivePlaneGeometry = __webpack_require__(/*! ./PerspectivePlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js\");\n\n\"use strict\";\nconst _PerspectiveMesh = class _PerspectiveMesh extends Mesh.Mesh {\n  /**\n   * @param options - Options to be applied to PerspectiveMesh\n   */\n  constructor(options) {\n    options = { ..._PerspectiveMesh.defaultOptions, ...options };\n    const { texture, verticesX, verticesY, ...rest } = options;\n    const planeGeometry = new PerspectivePlaneGeometry.PerspectivePlaneGeometry(definedProps.definedProps({\n      width: texture.width,\n      height: texture.height,\n      verticesX,\n      verticesY\n    }));\n    super(definedProps.definedProps({ ...rest, geometry: planeGeometry }));\n    this._texture = texture;\n    this.geometry.setCorners(\n      options.x0,\n      options.y0,\n      options.x1,\n      options.y1,\n      options.x2,\n      options.y2,\n      options.x3,\n      options.y3\n    );\n  }\n  /** Update the geometry when the texture is updated */\n  textureUpdated() {\n    const geometry = this.geometry;\n    if (!geometry)\n      return;\n    const { width, height } = this.texture;\n    if (geometry.width !== width || geometry.height !== height) {\n      geometry.width = width;\n      geometry.height = height;\n      geometry.updateProjection();\n    }\n  }\n  set texture(value) {\n    if (this._texture === value)\n      return;\n    super.texture = value;\n    this.textureUpdated();\n  }\n  /**\n   * The texture that the mesh uses for rendering. When changed, automatically updates\n   * the geometry to match the new texture dimensions.\n   * @example\n   * ```ts\n   * const mesh = new PerspectiveMesh({\n   *     texture: Texture.from('initial.png'),\n   * });\n   *\n   * // Update texture and maintain perspective\n   * mesh.texture = Texture.from('newImage.png');\n   * ```\n   * @see {@link Texture} For texture creation and management\n   * @see {@link PerspectiveMesh#setCorners} For adjusting the mesh perspective\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * Sets the corners of the mesh to create a perspective transformation. The corners should be\n   * specified in clockwise order starting from the top-left.\n   *\n   * The mesh automatically recalculates the UV coordinates to create the perspective effect.\n   * @example\n   * ```ts\n   * const mesh = new PerspectiveMesh({\n   *     texture: Texture.from('myImage.png'),\n   * });\n   *\n   * // Create a basic perspective tilt\n   * mesh.setCorners(\n   *     0, 0,      // Top-left\n   *     100, 20,   // Top-right (raised)\n   *     100, 100,  // Bottom-right\n   *     0, 80      // Bottom-left\n   * );\n   *\n   * // Create a skewed billboard effect\n   * mesh.setCorners(\n   *     0, 30,     // Top-left (shifted down)\n   *     128, 0,    // Top-right (raised)\n   *     128, 128,  // Bottom-right\n   *     0, 98      // Bottom-left (shifted up)\n   * );\n   *\n   * // Animate perspective\n   * app.ticker.add((delta) => {\n   *     const time = performance.now() / 1000;\n   *     const wave = Math.sin(time) * 20;\n   *\n   *     mesh.setCorners(\n   *         0, wave,      // Top-left\n   *         100, -wave,   // Top-right\n   *         100, 100,     // Bottom-right\n   *         0, 100        // Bottom-left\n   *     );\n   * });\n   * ```\n   * @param x0 - x-coordinate of the top-left corner\n   * @param y0 - y-coordinate of the top-left corner\n   * @param x1 - x-coordinate of the top-right corner\n   * @param y1 - y-coordinate of the top-right corner\n   * @param x2 - x-coordinate of the bottom-right corner\n   * @param y2 - y-coordinate of the bottom-right corner\n   * @param x3 - x-coordinate of the bottom-left corner\n   * @param y3 - y-coordinate of the bottom-left corner\n   * @returns The PerspectiveMesh instance for method chaining\n   * @see {@link PerspectivePlaneGeometry} For the underlying geometry calculations\n   */\n  setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {\n    this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);\n  }\n};\n/**\n * Default options for creating a PerspectiveMesh instance.\n *\n * Creates a 100x100 pixel square mesh\n * with a white texture and 10x10 vertex grid for the perspective calculations.\n * @example\n * ```ts\n * // Change defaults globally\n * PerspectiveMesh.defaultOptions = {\n *     ...PerspectiveMesh.defaultOptions,\n *     verticesX: 15,\n *     verticesY: 15,\n *     // Move top edge up for default skew\n *     y0: -20,\n *     y1: -20\n * };\n * ```\n * @see {@link PerspectivePlaneOptions} For all available options\n * @see {@link PerspectivePlaneGeometry} For how vertices affect perspective quality\n */\n_PerspectiveMesh.defaultOptions = {\n  texture: Texture.Texture.WHITE,\n  verticesX: 10,\n  verticesY: 10,\n  x0: 0,\n  y0: 0,\n  x1: 100,\n  y1: 0,\n  x2: 100,\n  y2: 100,\n  x3: 0,\n  y3: 100\n};\nlet PerspectiveMesh = _PerspectiveMesh;\n\nexports.PerspectiveMesh = PerspectiveMesh;\n//# sourceMappingURL=PerspectiveMesh.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar PlaneGeometry = __webpack_require__(/*! ../mesh-plane/PlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js\");\nvar applyProjectiveTransformationToPlane = __webpack_require__(/*! ./utils/applyProjectiveTransformationToPlane.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js\");\nvar compute2DProjections = __webpack_require__(/*! ./utils/compute2DProjections.js */ \"./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js\");\n\n\"use strict\";\nclass PerspectivePlaneGeometry extends PlaneGeometry.PlaneGeometry {\n  /**\n   * @param options - Options to be applied to MeshPlane\n   * @param options.width - The width of the plane\n   * @param options.height - The height of the plane\n   * @param options.verticesX - The amount of vertices on the x axis\n   * @param options.verticesY - The amount of vertices on the y axis\n   */\n  constructor(options) {\n    super(options);\n    this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const { width, height } = options;\n    this.corners = [0, 0, width, 0, width, height, 0, height];\n  }\n  /**\n   * Will set the corners of the quad to the given coordinates\n   * Calculating the perspective so it looks correct!\n   * @param x0 - x coordinate of the first corner\n   * @param y0 - y coordinate of the first corner\n   * @param x1 - x coordinate of the second corner\n   * @param y1 - y coordinate of the second corner\n   * @param x2 - x coordinate of the third corner\n   * @param y2 - y coordinate of the third corner\n   * @param x3 - x coordinate of the fourth corner\n   * @param y3 - y coordinate of the fourth corner\n   */\n  setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const corners = this.corners;\n    corners[0] = x0;\n    corners[1] = y0;\n    corners[2] = x1;\n    corners[3] = y1;\n    corners[4] = x2;\n    corners[5] = y2;\n    corners[6] = x3;\n    corners[7] = y3;\n    this.updateProjection();\n  }\n  /** Update the projection matrix based on the corners */\n  updateProjection() {\n    const { width, height } = this;\n    const corners = this.corners;\n    const projectionMatrix = compute2DProjections.compute2DProjection(\n      this._projectionMatrix,\n      0,\n      0,\n      // top-left source\n      corners[0],\n      corners[1],\n      // top-left dest\n      width,\n      0,\n      // top-right source\n      corners[2],\n      corners[3],\n      // top-right dest\n      width,\n      height,\n      // bottom-right source\n      corners[4],\n      corners[5],\n      // bottom-right dest\n      0,\n      height,\n      // bottom-left source\n      corners[6],\n      corners[7]\n      // bottom-left dest\n    );\n    applyProjectiveTransformationToPlane.applyProjectiveTransformationToPlane(\n      width,\n      height,\n      this,\n      projectionMatrix\n    );\n  }\n}\n\nexports.PerspectivePlaneGeometry = PerspectivePlaneGeometry;\n//# sourceMappingURL=PerspectivePlaneGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {\n  const buffer = geometry.buffers[0];\n  const vertices = buffer.data;\n  const { verticesX, verticesY } = geometry;\n  const sizeX = width / (verticesX - 1);\n  const sizeY = height / (verticesY - 1);\n  let index = 0;\n  const a00 = transformationMatrix[0];\n  const a01 = transformationMatrix[1];\n  const a02 = transformationMatrix[2];\n  const a10 = transformationMatrix[3];\n  const a11 = transformationMatrix[4];\n  const a12 = transformationMatrix[5];\n  const a20 = transformationMatrix[6];\n  const a21 = transformationMatrix[7];\n  const a22 = transformationMatrix[8];\n  for (let i = 0; i < vertices.length; i += 2) {\n    const x = index % verticesX * sizeX;\n    const y = (index / verticesX | 0) * sizeY;\n    const newX = a00 * x + a01 * y + a02;\n    const newY = a10 * x + a11 * y + a12;\n    const w = a20 * x + a21 * y + a22;\n    vertices[i] = newX / w;\n    vertices[i + 1] = newY / w;\n    index++;\n  }\n  buffer.update();\n}\n\nexports.applyProjectiveTransformationToPlane = applyProjectiveTransformationToPlane;\n//# sourceMappingURL=applyProjectiveTransformationToPlane.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction computeAdjugate(out, matrix) {\n  const a00 = matrix[0];\n  const a01 = matrix[1];\n  const a02 = matrix[2];\n  const a10 = matrix[3];\n  const a11 = matrix[4];\n  const a12 = matrix[5];\n  const a20 = matrix[6];\n  const a21 = matrix[7];\n  const a22 = matrix[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\nfunction multiplyMatrix3x3(out, a, b) {\n  const a00 = a[0];\n  const a01 = a[1];\n  const a02 = a[2];\n  const a10 = a[3];\n  const a11 = a[4];\n  const a12 = a[5];\n  const a20 = a[6];\n  const a21 = a[7];\n  const a22 = a[8];\n  const b00 = b[0];\n  const b01 = b[1];\n  const b02 = b[2];\n  const b10 = b[3];\n  const b11 = b[4];\n  const b12 = b[5];\n  const b20 = b[6];\n  const b21 = b[7];\n  const b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\nfunction multiplyMatrixAndVector(out, m, v) {\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n  out[0] = m[0] * x + m[1] * y + m[2] * z;\n  out[1] = m[3] * x + m[4] * y + m[5] * z;\n  out[2] = m[6] * x + m[7] * y + m[8] * z;\n  return out;\n}\nconst tempMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst tempVec = [0, 0, 0];\nconst tempVec2 = [0, 0, 0];\nfunction generateBasisToPointsMatrix(out, x1, y1, x2, y2, x3, y3, x4, y4) {\n  const m = tempMatrix;\n  m[0] = x1;\n  m[1] = x2;\n  m[2] = x3;\n  m[3] = y1;\n  m[4] = y2;\n  m[5] = y3;\n  m[6] = 1;\n  m[7] = 1;\n  m[8] = 1;\n  const adjugateM = computeAdjugate(\n    out,\n    // reusing out as adjugateM is only used once\n    m\n  );\n  tempVec2[0] = x4;\n  tempVec2[1] = y4;\n  tempVec2[2] = 1;\n  const v = multiplyMatrixAndVector(\n    tempVec,\n    adjugateM,\n    tempVec2\n  );\n  const diagonalMatrix = out;\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = v[2];\n  return multiplyMatrix3x3(out, diagonalMatrix, m);\n}\nconst tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];\nfunction compute2DProjection(out, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {\n  const sourceMatrix = generateBasisToPointsMatrix(\n    tempSourceMatrix,\n    x1s,\n    y1s,\n    x2s,\n    y2s,\n    x3s,\n    y3s,\n    x4s,\n    y4s\n  );\n  const destinationMatrix = generateBasisToPointsMatrix(\n    tempDestinationMatrix,\n    x1d,\n    y1d,\n    x2d,\n    y2d,\n    x3d,\n    y3d,\n    x4d,\n    y4d\n  );\n  return multiplyMatrix3x3(\n    out,\n    computeAdjugate(sourceMatrix, sourceMatrix),\n    destinationMatrix\n  );\n}\n\nexports.compute2DProjection = compute2DProjection;\n//# sourceMappingURL=compute2DProjections.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar definedProps = __webpack_require__(/*! ../container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar Mesh = __webpack_require__(/*! ../mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar PlaneGeometry = __webpack_require__(/*! ./PlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js\");\n\n\"use strict\";\nclass MeshPlane extends Mesh.Mesh {\n  /**\n   * @param options - Options to be applied to MeshPlane\n   */\n  constructor(options) {\n    const { texture, verticesX, verticesY, ...rest } = options;\n    const planeGeometry = new PlaneGeometry.PlaneGeometry(definedProps.definedProps({\n      width: texture.width,\n      height: texture.height,\n      verticesX,\n      verticesY\n    }));\n    super(definedProps.definedProps({ ...rest, geometry: planeGeometry, texture }));\n    this.texture = texture;\n    this.autoResize = true;\n  }\n  /**\n   * Method used for overrides, to do something in case texture frame was changed.\n   * Meshes based on plane can override it and change more details based on texture.\n   * @internal\n   */\n  textureUpdated() {\n    const geometry = this.geometry;\n    const { width, height } = this.texture;\n    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {\n      geometry.width = width;\n      geometry.height = height;\n      geometry.build({});\n    }\n  }\n  set texture(value) {\n    this._texture?.off(\"update\", this.textureUpdated, this);\n    super.texture = value;\n    value.on(\"update\", this.textureUpdated, this);\n    this.textureUpdated();\n  }\n  /**\n   * The texture that the mesh plane uses for rendering. When changed, automatically updates\n   * geometry dimensions if autoResize is true and manages texture update event listeners.\n   * @example\n   * ```ts\n   * const plane = new MeshPlane({\n   *     texture: Assets.get('initial.png'),\n   *     verticesX: 10,\n   *     verticesY: 10\n   * });\n   *\n   * // Update texture and auto-resize geometry\n   * plane.texture = Assets.get('larger.png');\n   * ```\n   * @see {@link MeshPlane#autoResize} For controlling automatic geometry updates\n   * @see {@link PlaneGeometry} For manual geometry updates\n   * @see {@link Texture} For texture creation and management\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * meshPlane.destroy();\n   * meshPlane.destroy(true);\n   * meshPlane.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options) {\n    this.texture.off(\"update\", this.textureUpdated, this);\n    super.destroy(options);\n  }\n}\n\nexports.MeshPlane = MeshPlane;\n//# sourceMappingURL=MeshPlane.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar MeshGeometry = __webpack_require__(/*! ../mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry.MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation.deprecation(deprecation.v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexports.PlaneGeometry = PlaneGeometry;\n//# sourceMappingURL=PlaneGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar definedProps = __webpack_require__(/*! ../container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar Mesh = __webpack_require__(/*! ../mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar RopeGeometry = __webpack_require__(/*! ./RopeGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js\");\n\n\"use strict\";\nconst _MeshRope = class _MeshRope extends Mesh.Mesh {\n  /**\n   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n   * @param options\n   * @param options.texture - The texture to use on the rope.\n   * @param options.points - An array of {@link math.Point} objects to construct this rope.\n   * @param {number} options.textureScale - Optional. Positive values scale rope texture\n   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n   * and downsampling here. If set to zero, texture will be stretched instead.\n   */\n  constructor(options) {\n    const { texture, points, textureScale, ...rest } = { ..._MeshRope.defaultOptions, ...options };\n    const ropeGeometry = new RopeGeometry.RopeGeometry(definedProps.definedProps({ width: texture.height, points, textureScale }));\n    if (textureScale > 0) {\n      texture.source.style.addressMode = \"repeat\";\n    }\n    super(definedProps.definedProps({\n      ...rest,\n      texture,\n      geometry: ropeGeometry\n    }));\n    this.autoUpdate = true;\n    this.onRender = this._render;\n  }\n  _render() {\n    const geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.texture.height) {\n      geometry._width = this.texture.height;\n      geometry.update();\n    }\n  }\n};\n/**\n * Default options for creating a MeshRope instance. These values are used when specific\n * options aren't provided in the constructor.\n * @example\n * ```ts\n * // Use default options globally\n * MeshRope.defaultOptions = {\n *     textureScale: 0.5  // Set higher quality texture scaling\n * };\n *\n * // Create rope with modified defaults\n * const rope = new MeshRope({\n *     texture: Texture.from('rope.png'),\n *     points: [\n *         new Point(0, 0),\n *         new Point(100, 0)\n *     ]\n * }); // Will use textureScale: 0.5\n * ```\n * @property {number} textureScale - Controls texture scaling along the rope (0 = stretch)\n * @see {@link MeshRopeOptions} For all available options\n */\n_MeshRope.defaultOptions = {\n  textureScale: 0\n};\nlet MeshRope = _MeshRope;\n\nexports.MeshRope = MeshRope;\n//# sourceMappingURL=MeshRope.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar definedProps = __webpack_require__(/*! ../container/utils/definedProps.js */ \"./node_modules/pixi.js/lib/scene/container/utils/definedProps.js\");\nvar Mesh = __webpack_require__(/*! ../mesh/shared/Mesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js\");\nvar MeshGeometry = __webpack_require__(/*! ../mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\n\n\"use strict\";\nclass MeshSimple extends Mesh.Mesh {\n  /**\n   * @param options - Options to be used for construction\n   */\n  constructor(options) {\n    const { texture, vertices, uvs, indices, topology, ...rest } = options;\n    const geometry = new MeshGeometry.MeshGeometry(definedProps.definedProps({\n      positions: vertices,\n      uvs,\n      indices,\n      topology\n    }));\n    super(definedProps.definedProps({\n      ...rest,\n      texture,\n      geometry\n    }));\n    this.autoUpdate = true;\n    this.onRender = this._render;\n  }\n  /**\n   * The vertex positions of the mesh as a TypedArray. Each vertex is represented by two\n   * consecutive values (x, y) in the array. Changes to these values will update the mesh's shape.\n   * @example\n   * ```ts\n   * // Read vertex positions\n   * const vertices = mesh.vertices;\n   * console.log('First vertex:', vertices[0], vertices[1]);\n   *\n   * // Modify vertices directly\n   * vertices[0] += 10;  // Move first vertex right\n   * vertices[1] -= 20;  // Move first vertex up\n   *\n   * // Animate vertices\n   * app.ticker.add(() => {\n   *     const time = performance.now() / 1000;\n   *     const vertices = mesh.vertices;\n   *\n   *     // Wave motion\n   *     for (let i = 0; i < vertices.length; i += 2) {\n   *         vertices[i + 1] = Math.sin(time + i * 0.5) * 20;\n   *     }\n   * });\n   * ```\n   * @see {@link MeshSimple#autoUpdate} For controlling vertex buffer updates\n   * @see {@link MeshGeometry#getBuffer} For direct buffer access\n   */\n  get vertices() {\n    return this.geometry.getBuffer(\"aPosition\").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer(\"aPosition\").data = value;\n  }\n  _render() {\n    if (this.autoUpdate) {\n      this.geometry.getBuffer(\"aPosition\").update();\n    }\n  }\n}\n\nexports.MeshSimple = MeshSimple;\n//# sourceMappingURL=MeshSimple.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar MeshGeometry = __webpack_require__(/*! ../mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\n\n\"use strict\";\nconst _RopeGeometry = class _RopeGeometry extends MeshGeometry.MeshGeometry {\n  /**\n   * @param options - Options to be applied to rope geometry\n   */\n  constructor(options) {\n    const { width, points, textureScale } = { ..._RopeGeometry.defaultOptions, ...options };\n    super({\n      positions: new Float32Array(points.length * 4),\n      uvs: new Float32Array(points.length * 4),\n      indices: new Uint32Array((points.length - 1) * 6)\n    });\n    this.points = points;\n    this._width = width;\n    this.textureScale = textureScale;\n    this._build();\n  }\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  get width() {\n    return this._width;\n  }\n  /** Refreshes Rope indices and uvs */\n  _build() {\n    const points = this.points;\n    if (!points)\n      return;\n    const vertexBuffer = this.getBuffer(\"aPosition\");\n    const uvBuffer = this.getBuffer(\"aUV\");\n    const indexBuffer = this.getIndex();\n    if (points.length < 1) {\n      return;\n    }\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const textureWidth = this._width * this.textureScale;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const index = i * 4;\n      if (this.textureScale > 0) {\n        const dx = prev.x - points[i].x;\n        const dy = prev.y - points[i].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i];\n        amount += distance / textureWidth;\n      } else {\n        amount = i / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  /** refreshes vertices of Rope mesh */\n  updateVertices() {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      if (perpLength < 1e-6) {\n        perpX = 0;\n        perpY = 0;\n      } else {\n        perpX /= perpLength;\n        perpY /= perpLength;\n        perpX *= halfWidth;\n        perpY *= halfWidth;\n      }\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n  /** Refreshes Rope indices and uvs */\n  update() {\n    if (this.textureScale > 0) {\n      this._build();\n    } else {\n      this.updateVertices();\n    }\n  }\n};\n/** Default options for RopeGeometry constructor. */\n_RopeGeometry.defaultOptions = {\n  /** The width (i.e., thickness) of the rope. */\n  width: 200,\n  /** An array of points that determine the rope. */\n  points: [],\n  /** Rope texture scale, if zero then the rope texture is stretched. */\n  textureScale: 0\n};\nlet RopeGeometry = _RopeGeometry;\n\nexports.RopeGeometry = RopeGeometry;\n//# sourceMappingURL=RopeGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar localUniformBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar textureBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/textureBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar warn = __webpack_require__(/*! ../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nclass GlMeshAdaptor {\n  init() {\n    const glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit.localUniformBitGl,\n        textureBit.textureBitGl,\n        roundPixelsBit.roundPixelsBitGl\n      ]\n    });\n    this._shader = new Shader.Shader({\n      glProgram,\n      resources: {\n        uTexture: Texture.Texture.EMPTY.source,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix.Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      const texture = mesh.texture;\n      const source = texture.source;\n      shader.resources.uTexture = source;\n      shader.resources.uSampler = source.style;\n      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n    } else if (!shader.glProgram) {\n      warn.warn(\"Mesh shader has no glProgram\", mesh.shader);\n      return;\n    }\n    shader.groups[100] = renderer.globalUniforms.bindGroup;\n    shader.groups[101] = meshPipe.localUniformsBindGroup;\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\nGlMeshAdaptor.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexports.GlMeshAdaptor = GlMeshAdaptor;\n//# sourceMappingURL=GlMeshAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar localUniformBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar textureBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/textureBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar warn = __webpack_require__(/*! ../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit.localUniformBit,\n        textureBit.textureBit,\n        roundPixelsBit.roundPixelsBit\n      ]\n    });\n    this._shader = new Shader.Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.Texture.EMPTY._source,\n        uSampler: Texture.Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix.Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      warn.warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexports.GpuMeshAdapter = GpuMeshAdapter;\n//# sourceMappingURL=GpuMeshAdapter.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/init.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/init.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar MeshPipe = __webpack_require__(/*! ./shared/MeshPipe.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(MeshPipe.MeshPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexports.BatchableMesh = BatchableMesh;\n//# sourceMappingURL=BatchableMesh.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar pointInTriangle = __webpack_require__(/*! ../../../maths/point/pointInTriangle.js */ \"./node_modules/pixi.js/lib/maths/point/pointInTriangle.js\");\nvar Geometry = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar State = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar ViewContainer = __webpack_require__(/*! ../../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar MeshGeometry = __webpack_require__(/*! ./MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\n\n\"use strict\";\nclass Mesh extends ViewContainer.ViewContainer {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Geometry.Geometry) {\n      deprecation.deprecation(deprecation.v8_0_0, \"Mesh: use new Mesh({ geometry, shader }) instead\");\n      options = {\n        geometry: options,\n        shader: args[1]\n      };\n      if (args[3]) {\n        deprecation.deprecation(deprecation.v8_0_0, \"Mesh: drawMode argument has been removed, use geometry.topology instead\");\n        options.geometry.topology = args[3];\n      }\n    }\n    const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n    super({\n      label: \"Mesh\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"mesh\";\n    /** @internal */\n    this._shader = null;\n    this.allowChildren = false;\n    this.shader = shader ?? null;\n    this.texture = texture ?? shader?.texture ?? Texture.Texture.WHITE;\n    this.state = state ?? State.State.for2d();\n    this._geometry = geometry;\n    this._geometry.on(\"update\", this.onViewUpdate, this);\n    this.roundPixels = roundPixels ?? false;\n  }\n  /** Alias for {@link Mesh#shader}. */\n  get material() {\n    deprecation.deprecation(deprecation.v8_0_0, \"mesh.material property has been removed, use mesh.shader instead\");\n    return this._shader;\n  }\n  /**\n   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n   * Can be shared between multiple Mesh objects.\n   */\n  set shader(value) {\n    if (this._shader === value)\n      return;\n    this._shader = value;\n    this.onViewUpdate();\n  }\n  get shader() {\n    return this._shader;\n  }\n  /**\n   * Includes vertex positions, face indices, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh objects.\n   */\n  set geometry(value) {\n    if (this._geometry === value)\n      return;\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    value.on(\"update\", this.onViewUpdate, this);\n    this._geometry = value;\n    this.onViewUpdate();\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n  set texture(value) {\n    value || (value = Texture.Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    if (this.shader) {\n      this.shader.texture = value;\n    }\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  get texture() {\n    return this._texture;\n  }\n  get batched() {\n    if (this._shader)\n      return false;\n    if ((this.state.data & 12) !== 0)\n      return false;\n    if (this._geometry instanceof MeshGeometry.MeshGeometry) {\n      if (this._geometry.batchMode === \"auto\") {\n        return this._geometry.positions.length / 2 <= 100;\n      }\n      return this._geometry.batchMode === \"batch\";\n    }\n    return false;\n  }\n  /**\n   * The local bounds of the mesh.\n   * @type {Bounds}\n   */\n  get bounds() {\n    return this._geometry.bounds;\n  }\n  /**\n   * Update local bounds of the mesh.\n   * @private\n   */\n  updateBounds() {\n    this._bounds = this._geometry.bounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const { x, y } = point;\n    if (!this.bounds.containsPoint(x, y))\n      return false;\n    const vertices = this.geometry.getBuffer(\"aPosition\").data;\n    const step = this.geometry.topology === \"triangle-strip\" ? 3 : 1;\n    if (this.geometry.getIndex()) {\n      const indices = this.geometry.getIndex().data;\n      const len = indices.length;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = indices[i] * 2;\n        const ind1 = indices[i + 1] * 2;\n        const ind2 = indices[i + 2] * 2;\n        if (pointInTriangle.pointInTriangle(\n          x,\n          y,\n          vertices[ind0],\n          vertices[ind0 + 1],\n          vertices[ind1],\n          vertices[ind1 + 1],\n          vertices[ind2],\n          vertices[ind2 + 1]\n        )) {\n          return true;\n        }\n      }\n    } else {\n      const len = vertices.length / 2;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = i * 2;\n        const ind1 = (i + 1) * 2;\n        const ind2 = (i + 2) * 2;\n        if (pointInTriangle.pointInTriangle(\n          x,\n          y,\n          vertices[ind0],\n          vertices[ind0 + 1],\n          vertices[ind1],\n          vertices[ind1 + 1],\n          vertices[ind2],\n          vertices[ind2 + 1]\n        )) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * mesh.destroy();\n   * mesh.destroy(true);\n   * mesh.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    this._texture = null;\n    this._geometry = null;\n    this._shader = null;\n    this._gpuData = null;\n  }\n}\n\nexports.Mesh = Mesh;\n//# sourceMappingURL=Mesh.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Buffer = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar _const = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar Geometry = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry.Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation.deprecation(deprecation.v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer.Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer.Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer.Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: _const.BufferUsage.INDEX | _const.BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexports.MeshGeometry = MeshGeometry;\n//# sourceMappingURL=MeshGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar BindGroup = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/BindGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar colorToUniform = __webpack_require__(/*! ../../graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar BatchableMesh = __webpack_require__(/*! ./BatchableMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js\");\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup.UniformGroup({\n      uTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup.BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    colorToUniform.color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh.BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexports.MeshGpuData = MeshGpuData;\nexports.MeshPipe = MeshPipe;\n//# sourceMappingURL=MeshPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getTextureDefaultMatrix(texture, out) {\n  const { width, height } = texture.frame;\n  out.scale(1 / width, 1 / height);\n  return out;\n}\n\nexports.getTextureDefaultMatrix = getTextureDefaultMatrix;\n//# sourceMappingURL=getTextureDefaultMatrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexports.GlParticleContainerAdaptor = GlParticleContainerAdaptor;\n//# sourceMappingURL=GlParticleContainerAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexports.GpuParticleContainerAdaptor = GpuParticleContainerAdaptor;\n//# sourceMappingURL=GpuParticleContainerAdaptor.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/init.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/init.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GlParticleContainerPipe = __webpack_require__(/*! ./shared/GlParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js\");\nvar GpuParticleContainerPipe = __webpack_require__(/*! ./shared/GpuParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(GlParticleContainerPipe.GlParticleContainerPipe);\nExtensions.extensions.add(GpuParticleContainerPipe.GpuParticleContainerPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GlParticleContainerAdaptor = __webpack_require__(/*! ../gl/GlParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.js\");\nvar ParticleContainerPipe = __webpack_require__(/*! ./ParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js\");\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe.ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor.GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexports.GlParticleContainerPipe = GlParticleContainerPipe;\n//# sourceMappingURL=GlParticleContainerPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar GpuParticleContainerAdaptor = __webpack_require__(/*! ../gpu/GpuParticleContainerAdaptor.js */ \"./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.js\");\nvar ParticleContainerPipe = __webpack_require__(/*! ./ParticleContainerPipe.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js\");\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe.ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor.GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexports.GpuParticleContainerPipe = GpuParticleContainerPipe;\n//# sourceMappingURL=GpuParticleContainerPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar getGlobalMixin = __webpack_require__(/*! ../../container/container-mixins/getGlobalMixin.js */ \"./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.js\");\nvar assignWithIgnore = __webpack_require__(/*! ../../container/utils/assignWithIgnore.js */ \"./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.js\");\n\n\"use strict\";\nconst _Particle = class _Particle {\n  constructor(options) {\n    if (options instanceof Texture.Texture) {\n      this.texture = options;\n      assignWithIgnore.assignWithIgnore(this, _Particle.defaultOptions, {});\n    } else {\n      const combined = { ..._Particle.defaultOptions, ...options };\n      assignWithIgnore.assignWithIgnore(this, combined, {});\n    }\n  }\n  /**\n   * The transparency of the particle. Values range from 0 (fully transparent)\n   * to 1 (fully opaque). Values outside this range are clamped.\n   * @example\n   * ```ts\n   * // Create a semi-transparent particle\n   * const particle = new Particle({\n   *     texture: Texture.from('particle.png'),\n   *     alpha: 0.5\n   * });\n   *\n   * // Fade out\n   * particle.alpha *= 0.9;\n   *\n   * // Fade in\n   * particle.alpha = Math.min(particle.alpha + 0.1, 1);\n   *\n   * // Values are clamped to valid range\n   * particle.alpha = 1.5; // Becomes 1.0\n   * particle.alpha = -0.5; // Becomes 0.0\n   *\n   * // Animate transparency\n   * app.ticker.add((delta) => {\n   *     const time = performance.now() / 1000;\n   *     particle.alpha = 0.5 + Math.sin(time) * 0.5; // Pulse between 0-1\n   * });\n   * ```\n   * @default 1\n   * @see {@link Particle#tint} For controlling particle color\n   * @see {@link Particle#color} For the combined color and alpha value\n   */\n  get alpha() {\n    return this._alpha;\n  }\n  set alpha(value) {\n    this._alpha = Math.min(Math.max(value, 0), 1);\n    this._updateColor();\n  }\n  /**\n   * The tint color of the particle. Can be set using hex numbers or CSS color strings.\n   * The tint is multiplied with the texture color to create the final particle color.\n   * @example\n   * ```ts\n   * // Create a red particle\n   * const particle = new Particle({\n   *     texture: Texture.from('particle.png'),\n   *     tint: 0xff0000\n   * });\n   *\n   * // Use CSS color strings\n   * particle.tint = '#00ff00';  // Green\n   * particle.tint = 'blue';     // Blue\n   *\n   * // Animate tint color\n   * app.ticker.add(() => {\n   *     const time = performance.now() / 1000;\n   *\n   *     // Cycle through hues\n   *     const hue = (time * 50) % 360;\n   *     particle.tint = `hsl(${hue}, 100%, 50%)`;\n   * });\n   *\n   * // Reset to white (no tint)\n   * particle.tint = 0xffffff;\n   * ```\n   * @type {ColorSource} Hex number or CSS color string\n   * @default 0xffffff\n   * @see {@link Particle#alpha} For controlling transparency\n   * @see {@link Particle#color} For the combined color and alpha value\n   * @see {@link Color} For supported color formats\n   */\n  get tint() {\n    return getGlobalMixin.bgr2rgb(this._tint);\n  }\n  set tint(value) {\n    if (typeof value === \"number\") {\n      this._tint = value;\n    } else {\n      this._tint = Color.Color.shared.setValue(value ?? 16777215).toBgrNumber();\n    }\n    this._updateColor();\n  }\n  _updateColor() {\n    this.color = this._tint + ((this._alpha * 255 | 0) << 24);\n  }\n};\n/**\n * Default options used when creating new particles. These values are applied when specific\n * options aren't provided in the constructor.\n * @example\n * ```ts\n * // Override defaults globally\n * Particle.defaultOptions = {\n *     ...Particle.defaultOptions,\n *     anchorX: 0.5,\n *     anchorY: 0.5,\n *     alpha: 0.8\n * };\n *\n * // New particles use modified defaults\n * const centeredParticle = new Particle(texture);\n * console.log(centeredParticle.anchorX); // 0.5\n * console.log(centeredParticle.alpha); // 0.8\n * ```\n * @see {@link ParticleOptions} For all available options\n * @see {@link Particle} For the particle implementation\n */\n_Particle.defaultOptions = {\n  anchorX: 0,\n  anchorY: 0,\n  x: 0,\n  y: 0,\n  scaleX: 1,\n  scaleY: 1,\n  rotation: 0,\n  tint: 16777215,\n  alpha: 1\n};\nlet Particle = _Particle;\n\nexports.Particle = Particle;\n//# sourceMappingURL=Particle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Buffer = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/Buffer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.js\");\nvar _const = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/const.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.js\");\nvar Geometry = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.js\");\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\nvar ViewableBuffer = __webpack_require__(/*! ../../../utils/data/ViewableBuffer.js */ \"./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js\");\nvar createIndicesForQuads = __webpack_require__(/*! ./utils/createIndicesForQuads.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js\");\nvar generateParticleUpdateFunction = __webpack_require__(/*! ./utils/generateParticleUpdateFunction.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js\");\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer.ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer.ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads.createIndicesForQuads(size);\n    const geometry = new Geometry.Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer.Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer.Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction.generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer.ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer.ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads.createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexports.ParticleBuffer = ParticleBuffer;\n//# sourceMappingURL=ParticleBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Bounds = __webpack_require__(/*! ../../container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar ViewContainer = __webpack_require__(/*! ../../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar particleData = __webpack_require__(/*! ./particleData.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js\");\n\n\"use strict\";\nconst emptyBounds = new Bounds.Bounds(0, 0, 0, 0);\nconst _ParticleContainer = class _ParticleContainer extends ViewContainer.ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = {}) {\n    options = {\n      ..._ParticleContainer.defaultOptions,\n      ...options,\n      dynamicProperties: {\n        ..._ParticleContainer.defaultOptions.dynamicProperties,\n        ...options?.dynamicProperties\n      }\n    };\n    const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;\n    super({\n      label: \"ParticleContainer\",\n      ...rest\n    });\n    /**\n     * The unique identifier for the render pipe of this ParticleContainer.\n     * @internal\n     */\n    this.renderPipeId = \"particle\";\n    /** @internal */\n    this.batched = false;\n    /**\n     * Indicates if the children of this ParticleContainer have changed and need to be updated.\n     * @internal\n     */\n    this._childrenDirty = false;\n    this.texture = texture || null;\n    this.shader = shader;\n    this._properties = {};\n    for (const key in particleData.particleData) {\n      const property = particleData.particleData[key];\n      const dynamic = dynamicProperties[key];\n      this._properties[key] = {\n        ...property,\n        dynamic\n      };\n    }\n    this.allowChildren = true;\n    this.roundPixels = roundPixels ?? false;\n    this.particleChildren = particles ?? [];\n  }\n  /**\n   * Adds one or more particles to the container. The particles will be rendered using the container's shared texture\n   * and properties. When adding multiple particles, they must all share the same base texture.\n   * @example\n   * ```ts\n   * const container = new ParticleContainer();\n   *\n   * // Add a single particle\n   * const particle = new Particle(Assets.get('particleTexture'));\n   * container.addParticle(particle);\n   *\n   * // Add multiple particles at once\n   * const particles = [\n   *     new Particle(Assets.get('particleTexture')),\n   *     new Particle(Assets.get('particleTexture')),\n   *     new Particle(Assets.get('particleTexture'))\n   * ];\n   *\n   * container.addParticle(...particles);\n   * ```\n   * @param children - The Particle(s) to add to the container\n   * @returns The first particle that was added, for method chaining\n   * @see {@link ParticleContainer#texture} For setting the shared texture\n   * @see {@link ParticleContainer#update} For updating after modifications\n   */\n  addParticle(...children) {\n    for (let i = 0; i < children.length; i++) {\n      this.particleChildren.push(children[i]);\n    }\n    this.onViewUpdate();\n    return children[0];\n  }\n  /**\n   * Removes one or more particles from the container. The particles must already be children\n   * of this container to be removed.\n   * @example\n   * ```ts\n   * // Remove a single particle\n   * container.removeParticle(particle1);\n   *\n   * // Remove multiple particles at once\n   * container.removeParticle(particle2, particle3);\n   * ```\n   * @param children - The Particle(s) to remove from the container\n   * @returns The first particle that was removed, for method chaining\n   * @see {@link ParticleContainer#particleChildren} For accessing all particles\n   * @see {@link ParticleContainer#removeParticles} For removing particles by index\n   * @see {@link ParticleContainer#removeParticleAt} For removing a particle at a specific index\n   */\n  removeParticle(...children) {\n    let didRemove = false;\n    for (let i = 0; i < children.length; i++) {\n      const index = this.particleChildren.indexOf(children[i]);\n      if (index > -1) {\n        this.particleChildren.splice(index, 1);\n        didRemove = true;\n      }\n    }\n    if (didRemove)\n      this.onViewUpdate();\n    return children[0];\n  }\n  /**\n   * Updates the particle container's internal state. Call this method after manually modifying\n   * the particleChildren array or when changing static properties of particles.\n   * @example\n   * ```ts\n   * // Batch modify particles\n   * container.particleChildren.push(...particles);\n   * container.update(); // Required after direct array modification\n   *\n   * // Update static properties\n   * container.particleChildren.forEach(particle => {\n   *     particle.position.set(\n   *         Math.random() * 800,\n   *         Math.random() * 600\n   *     );\n   * });\n   * container.update(); // Required after changing static positions\n   * ```\n   * @see {@link ParticleProperties} For configuring dynamic vs static properties\n   * @see {@link ParticleContainer#particleChildren} For direct array access\n   */\n  update() {\n    this._childrenDirty = true;\n  }\n  onViewUpdate() {\n    this._childrenDirty = true;\n    super.onViewUpdate();\n  }\n  /**\n   * Returns a static empty bounds object since ParticleContainer does not calculate bounds automatically\n   * for performance reasons. Use the `boundsArea` property to manually set container bounds.\n   * @example\n   * ```ts\n   * const container = new ParticleContainer({\n   *     texture: Texture.from('particle.png')\n   * });\n   *\n   * // Default bounds are empty\n   * console.log(container.bounds); // Bounds(0, 0, 0, 0)\n   *\n   * // Set manual bounds for the particle area\n   * container.boundsArea = {\n   *     minX: 0,\n   *     minY: 0,\n   *     maxX: 800,\n   *     maxY: 600\n   * };\n   * ```\n   * @readonly\n   * @returns {Bounds} An empty bounds object (0,0,0,0)\n   * @see {@link Container#boundsArea} For manually setting container bounds\n   * @see {@link Bounds} For bounds object structure\n   */\n  get bounds() {\n    return emptyBounds;\n  }\n  /** @private */\n  updateBounds() {\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * particleContainer.destroy();\n   * particleContainer.destroy(true);\n   * particleContainer.destroy({ texture: true, textureSource: true, children: true });\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      const texture = this.texture ?? this.particleChildren[0]?.texture;\n      if (texture) {\n        texture.destroy(destroyTextureSource);\n      }\n    }\n    this.texture = null;\n    this.shader?.destroy();\n  }\n  /**\n   * Removes all particles from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed particles\n   */\n  removeParticles(beginIndex, endIndex) {\n    beginIndex ?? (beginIndex = 0);\n    endIndex ?? (endIndex = this.particleChildren.length);\n    const children = this.particleChildren.splice(\n      beginIndex,\n      endIndex - beginIndex\n    );\n    this.onViewUpdate();\n    return children;\n  }\n  /**\n   * Removes a particle from the specified index position.\n   * @param index - The index to get the particle from\n   * @returns The particle that was removed.\n   */\n  removeParticleAt(index) {\n    const child = this.particleChildren.splice(index, 1);\n    this.onViewUpdate();\n    return child[0];\n  }\n  /**\n   * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the particle is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The particle to add.\n   * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n   * @returns {Container} The particle that was added.\n   */\n  addParticleAt(child, index) {\n    this.particleChildren.splice(index, 0, child);\n    this.onViewUpdate();\n    return child;\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.\n   * @param {...any} _children\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  addChild(..._children) {\n    throw new Error(\n      \"ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.\n   * @param {...any} _children\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  removeChild(..._children) {\n    throw new Error(\n      \"ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.\n   * @param {number} [_beginIndex]\n   * @param {number} [_endIndex]\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  removeChildren(_beginIndex, _endIndex) {\n    throw new Error(\n      \"ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  removeChildAt(_index) {\n    throw new Error(\n      \"ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  getChildAt(_index) {\n    throw new Error(\n      \"ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.\n   * @param {ContainerChild} _child\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  setChildIndex(_child, _index) {\n    throw new Error(\n      \"ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.\n   * @param {ContainerChild} _child\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  getChildIndex(_child) {\n    throw new Error(\n      \"ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.\n   * @param {ContainerChild} _child\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  addChildAt(_child, _index) {\n    throw new Error(\n      \"ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.\n   * @param {ContainerChild} _child\n   * @param {ContainerChild} _child2\n   * @ignore\n   */\n  swapChildren(_child, _child2) {\n    throw new Error(\n      \"ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()\"\n    );\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error.\n   * @param _child - The child to reparent\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  reparentChild(..._child) {\n    throw new Error(\"ParticleContainer.reparentChild() is not available with the particle container\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error.\n   * @param _child - The child to reparent\n   * @param _index - The index to reparent the child to\n   * @throws {Error} Always throws an error as this method is not available.\n   * @ignore\n   */\n  reparentChildAt(_child, _index) {\n    throw new Error(\"ParticleContainer.reparentChildAt() is not available with the particle container\");\n  }\n};\n/**\n * Defines the default options for creating a ParticleContainer.\n * @example\n * ```ts\n * // Change defaults globally\n * ParticleContainer.defaultOptions = {\n *     dynamicProperties: {\n *         position: true,  // Update positions each frame\n *         rotation: true,  // Update rotations each frame\n *         vertex: false,   // Static vertices\n *         uvs: false,      // Static texture coordinates\n *         color: false     // Static colors\n *     },\n *     roundPixels: true // Enable pixel rounding for crisp rendering\n * };\n * ```\n * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n * @property {boolean} roundPixels - Indicates if pixels should be  rounded.\n */\n_ParticleContainer.defaultOptions = {\n  /** Specifies which properties are dynamic. */\n  dynamicProperties: {\n    /** Indicates if vertex positions are dynamic. */\n    vertex: false,\n    /** Indicates if particle positions are dynamic. */\n    position: true,\n    /** Indicates if particle rotations are dynamic. */\n    rotation: false,\n    /** Indicates if UV coordinates are dynamic. */\n    uvs: false,\n    /** Indicates if particle colors are dynamic. */\n    color: false\n  },\n  /** Indicates if pixels should be rounded for rendering. */\n  roundPixels: false\n};\nlet ParticleContainer = _ParticleContainer;\n\nexports.ParticleContainer = ParticleContainer;\n//# sourceMappingURL=ParticleContainer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar State = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar colorToUniform = __webpack_require__(/*! ../../graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar ParticleBuffer = __webpack_require__(/*! ./ParticleBuffer.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.js\");\nvar ParticleShader = __webpack_require__(/*! ./shader/ParticleShader.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js\");\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup.UniformGroup({\n      uTranslationMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader.ParticleShader();\n    this.state = State.State.for2d();\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer.ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    colorToUniform.color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexports.ParticleContainerPipe = ParticleContainerPipe;\n//# sourceMappingURL=ParticleContainerPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst particleData = {\n  vertex: {\n    attributeName: \"aVertex\",\n    format: \"float32x2\",\n    code: `\n            const texture = p.texture;\n            const sx = p.scaleX;\n            const sy = p.scaleY;\n            const ax = p.anchorX;\n            const ay = p.anchorY;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                w1 = trim.x - (ax * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (ay * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w1 = -ax * (orig.width);\n                w0 = w1 + orig.width;\n\n                h1 = -ay * (orig.height);\n                h0 = h1 + orig.height;\n            }\n\n            f32v[offset] = w1 * sx;\n            f32v[offset + 1] = h1 * sy;\n\n            f32v[offset + stride] = w0 * sx;\n            f32v[offset + stride + 1] = h1 * sy;\n\n            f32v[offset + (stride * 2)] = w0 * sx;\n            f32v[offset + (stride * 2) + 1] = h0 * sy;\n\n            f32v[offset + (stride * 3)] = w1 * sx;\n            f32v[offset + (stride * 3) + 1] = h0 * sy;\n        `,\n    dynamic: false\n  },\n  // positionData\n  position: {\n    attributeName: \"aPosition\",\n    format: \"float32x2\",\n    code: `\n            var x = p.x;\n            var y = p.y;\n\n            f32v[offset] = x;\n            f32v[offset + 1] = y;\n\n            f32v[offset + stride] = x;\n            f32v[offset + stride + 1] = y;\n\n            f32v[offset + (stride * 2)] = x;\n            f32v[offset + (stride * 2) + 1] = y;\n\n            f32v[offset + (stride * 3)] = x;\n            f32v[offset + (stride * 3) + 1] = y;\n        `,\n    dynamic: true\n  },\n  // rotationData\n  rotation: {\n    attributeName: \"aRotation\",\n    format: \"float32\",\n    code: `\n            var rotation = p.rotation;\n\n            f32v[offset] = rotation;\n            f32v[offset + stride] = rotation;\n            f32v[offset + (stride * 2)] = rotation;\n            f32v[offset + (stride * 3)] = rotation;\n        `,\n    dynamic: false\n  },\n  // uvsData\n  uvs: {\n    attributeName: \"aUV\",\n    format: \"float32x2\",\n    code: `\n            var uvs = p.texture.uvs;\n\n            f32v[offset] = uvs.x0;\n            f32v[offset + 1] = uvs.y0;\n\n            f32v[offset + stride] = uvs.x1;\n            f32v[offset + stride + 1] = uvs.y1;\n\n            f32v[offset + (stride * 2)] = uvs.x2;\n            f32v[offset + (stride * 2) + 1] = uvs.y2;\n\n            f32v[offset + (stride * 3)] = uvs.x3;\n            f32v[offset + (stride * 3) + 1] = uvs.y3;\n        `,\n    dynamic: false\n  },\n  // tintData\n  color: {\n    attributeName: \"aColor\",\n    format: \"unorm8x4\",\n    code: `\n            const c = p.color;\n\n            u32v[offset] = c;\n            u32v[offset + stride] = c;\n            u32v[offset + (stride * 2)] = c;\n            u32v[offset + (stride * 3)] = c;\n        `,\n    dynamic: false\n  }\n};\n\nexports.particleData = particleData;\n//# sourceMappingURL=particleData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar GlProgram = __webpack_require__(/*! ../../../../rendering/renderers/gl/shader/GlProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.js\");\nvar GpuProgram = __webpack_require__(/*! ../../../../rendering/renderers/gpu/shader/GpuProgram.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.js\");\nvar Shader = __webpack_require__(/*! ../../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar Texture = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TextureStyle = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar particles$1 = __webpack_require__(/*! ./particles.frag.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js\");\nvar particles = __webpack_require__(/*! ./particles.vert.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js\");\nvar particles$2 = __webpack_require__(/*! ./particles.wgsl.js */ \"./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js\");\n\n\"use strict\";\nclass ParticleShader extends Shader.Shader {\n  constructor() {\n    const glProgram = GlProgram.GlProgram.from({\n      vertex: particles.default,\n      fragment: particles$1.default\n    });\n    const gpuProgram = GpuProgram.GpuProgram.from({\n      fragment: {\n        source: particles$2.default,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: particles$2.default,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle.TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color.Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexports.ParticleShader = ParticleShader;\n//# sourceMappingURL=ParticleShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexports[\"default\"] = fragment;\n//# sourceMappingURL=particles.frag.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexports[\"default\"] = vertex;\n//# sourceMappingURL=particles.vert.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar wgsl = \"\\nstruct ParticleUniforms {\\n  uProjectionMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uResolution:vec2<f32>,\\n  uRoundPixels:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexports[\"default\"] = wgsl;\n//# sourceMappingURL=particles.wgsl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexports.createIndicesForQuads = createIndicesForQuads;\n//# sourceMappingURL=createIndicesForQuads.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getAttributeInfoFromFormat = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.js\");\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexports.generateParticleUpdateFunction = generateParticleUpdateFunction;\n//# sourceMappingURL=generateParticleUpdateFunction.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar _const = __webpack_require__(/*! ../../ticker/const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ../../ticker/Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\nvar Sprite = __webpack_require__(/*! ../sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\n\n\"use strict\";\nclass AnimatedSprite extends Sprite.Sprite {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0];\n    if (Array.isArray(args[0])) {\n      options = {\n        textures: args[0],\n        autoUpdate: args[1]\n      };\n    }\n    const {\n      animationSpeed = 1,\n      autoPlay = false,\n      autoUpdate = true,\n      loop = true,\n      onComplete = null,\n      onFrameChange = null,\n      onLoop = null,\n      textures,\n      updateAnchor = false,\n      ...rest\n    } = options;\n    const [firstFrame] = textures;\n    super({\n      ...rest,\n      texture: firstFrame instanceof Texture.Texture ? firstFrame : firstFrame.texture\n    });\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = animationSpeed;\n    this.loop = loop;\n    this.updateAnchor = updateAnchor;\n    this.onComplete = onComplete;\n    this.onFrameChange = onFrameChange;\n    this.onLoop = onLoop;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n    if (autoPlay) {\n      this.play();\n    }\n  }\n  /**\n   * Stops the animation playback and freezes the current frame.\n   * Does not reset the current frame or animation progress.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png')\n   *     ],\n   *     autoPlay: true\n   * });\n   *\n   * // Stop at current frame\n   * sprite.stop();\n   *\n   * // Stop at specific frame\n   * sprite.gotoAndStop(1); // Stops at second frame\n   *\n   * // Stop and reset\n   * sprite.stop();\n   * sprite.currentFrame = 0;\n   *\n   * // Stop with completion check\n   * if (sprite.playing) {\n   *     sprite.stop();\n   *     sprite.onComplete?.();\n   * }\n   * ```\n   * @see {@link AnimatedSprite#play} For starting playback\n   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n   * @see {@link AnimatedSprite#playing} For checking play state\n   */\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  /**\n   * Starts or resumes the animation playback.\n   * If the animation was previously stopped, it will continue from where it left off.\n   * @example\n   * ```ts\n   * // Basic playback\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *     ],\n   *     autoPlay: false\n   * });\n   * sprite.play();\n   *\n   * // Play after stopping\n   * sprite.stop();\n   * sprite.currentFrame = 0; // Reset to start\n   * sprite.play(); // Play from beginning\n   *\n   * // Play with auto-update disabled\n   * sprite.autoUpdate = false;\n   * sprite.play();\n   * app.ticker.add(() => {\n   *     sprite.update(app.ticker); // Manual updates\n   * });\n   * ```\n   * @see {@link AnimatedSprite#stop} For stopping playback\n   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n   * @see {@link AnimatedSprite#playing} For checking play state\n   */\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.Ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and sets it to a specific frame.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png'),\n   *     ]\n   * });\n   *\n   * // Go to specific frames\n   * sprite.gotoAndStop(0);  // First frame\n   * sprite.gotoAndStop(2);  // Third frame\n   *\n   * // Jump to last frame\n   * sprite.gotoAndStop(sprite.totalFrames - 1);\n   * ```\n   * @param frameNumber - Frame index to stop at (0-based)\n   * @throws {Error} If frameNumber is out of bounds\n   * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing\n   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n   * @see {@link AnimatedSprite#totalFrames} For total number of frames\n   */\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite from that point.\n   * Combines frame navigation and playback start in one operation.\n   * @example\n   * ```ts\n   * // Start from specific frame\n   * sprite.gotoAndPlay(1); // Starts playing from second frame\n   * ```\n   * @param frameNumber - Frame index to start playing from (0-based)\n   * @throws {Error} If frameNumber is out of bounds\n   * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing\n   * @see {@link AnimatedSprite#play} For playing from current frame\n   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n   */\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  /**\n   * Updates the object transform for rendering. This method handles animation timing, frame updates,\n   * and manages looping behavior.\n   * @example\n   * ```ts\n   * // Create an animated sprite with manual updates\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('frame1.png'),\n   *         Texture.from('frame2.png'),\n   *         Texture.from('frame3.png')\n   *     ],\n   *     autoUpdate: false // Disable automatic updates\n   * });\n   *\n   * // Manual update with app ticker\n   * app.ticker.add((ticker) => {\n   *     sprite.update(ticker);\n   * });\n   * ```\n   * @param ticker - The ticker to use for updating the animation timing\n   * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates\n   * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed\n   * @see {@link Ticker} For timing system details\n   */\n  update(ticker) {\n    if (!this._playing) {\n      return;\n    }\n    const deltaTime = ticker.deltaTime;\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this._updateTexture();\n    }\n  }\n  /** Updates the displayed texture to match the current frame index. */\n  _updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this.texture = this._textures[currentFrame];\n    if (this.updateAnchor && this.texture.defaultAnchor) {\n      this.anchor.copyFrom(this.texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and destroys it.\n   * @example\n   * ```ts\n   * // Destroy the sprite when done\n   * sprite.destroy();\n   * ```\n   */\n  destroy() {\n    this.stop();\n    super.destroy();\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   * Uses texture frames from the cache to create an animation sequence.\n   * @example\n   * ```ts\n   * // Create from frame IDs\n   * const frameIds = [\n   *     'walk_001.png',\n   *     'walk_002.png',\n   *     'walk_003.png'\n   * ];\n   *\n   * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);\n   * walkingAnimation.play();\n   * ```\n   * @param frames - The array of frame ids to use for the animation\n   * @returns A new animated sprite using the frames\n   * @see {@link Texture.from} For texture creation from frames\n   * @see {@link Spritesheet} For loading spritesheets\n   */\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image urls.\n   * Each image will be used as a frame in the animation.\n   * @example\n   * ```ts\n   * // Create from image URLs\n   * const images = [\n   *     'assets/walk1.png',\n   *     'assets/walk2.png',\n   *     'assets/walk3.png'\n   * ];\n   *\n   * const walkingSprite = AnimatedSprite.fromImages(images);\n   * walkingSprite.play();\n   * ```\n   * @param images - The array of image urls to use as frames\n   * @returns A new animated sprite using the images as frames\n   * @see {@link Assets} For asset loading and management\n   * @see {@link Texture.from} For texture creation from images\n   */\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('frame1.png'),\n   *         Texture.from('frame2.png'),\n   *         Texture.from('frame3.png')\n   *     ]\n   * });\n   *\n   * // Get total frames\n   * console.log(sprite.totalFrames); // Outputs: 3\n   *\n   * // Use with frame navigation\n   * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame\n   * ```\n   * @readonly\n   * @see {@link AnimatedSprite#currentFrame} For the current frame index\n   * @see {@link AnimatedSprite#textures} For the array of textures\n   * @returns {number} The total number of frames\n   */\n  get totalFrames() {\n    return this._textures.length;\n  }\n  /**\n   * The array of textures or frame objects used for the animation sequence.\n   * Can be set to either an array of Textures or an array of FrameObjects with custom timing.\n   * @example\n   * ```ts\n   * // Update textures at runtime\n   * sprite.textures = [\n   *     Texture.from('run1.png'),\n   *     Texture.from('run2.png')\n   * ];\n   *\n   * // Use custom frame timing\n   * sprite.textures = [\n   *     { texture: Texture.from('explosion1.png'), time: 100 },\n   *     { texture: Texture.from('explosion2.png'), time: 200 },\n   *     { texture: Texture.from('explosion3.png'), time: 300 }\n   * ];\n   *\n   * // Use with spritesheet\n   * const sheet = await Assets.load('animations.json');\n   * sprite.textures = sheet.animations['walk'];\n   * ```\n   * @type {AnimatedSpriteFrames}\n   * @see {@link FrameObject} For frame timing options\n   * @see {@link Spritesheet} For loading from spritesheets\n   */\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture.Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this._updateTexture();\n  }\n  /**\n   * Gets or sets the current frame index of the animation.\n   * When setting, the value will be clamped between 0 and totalFrames - 1.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png')\n   *     ]\n   * });\n   *\n   * // Get current frame\n   * console.log(sprite.currentFrame); // 0\n   *\n   * // Set specific frame\n   * sprite.currentFrame = 1; // Show second frame\n   *\n   * // Use with frame callbacks\n   * sprite.onFrameChange = (frame) => {\n   *     console.log(`Now showing frame: ${frame}`);\n   * };\n   * sprite.currentFrame = 2;\n   * ```\n   * @throws {Error} If attempting to set a frame index out of bounds\n   * @see {@link AnimatedSprite#totalFrames} For the total number of frames\n   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n   */\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this._updateTexture();\n    }\n  }\n  /**\n   * Indicates if the AnimatedSprite is currently playing.\n   * This is a read-only property that reflects the current playback state.\n   * @example\n   * ```ts\n   * // Check if animation is playing\n   * console.log('Playing:', sprite.playing); // true\n   *\n   * // Use with play control\n   * if (!sprite.playing) {\n   *     sprite.play();\n   * }\n   * ```\n   * @readonly\n   * @returns {boolean} True if the animation is currently playing\n   * @see {@link AnimatedSprite#play} For starting playback\n   * @see {@link AnimatedSprite#stop} For stopping playback\n   * @see {@link AnimatedSprite#loop} For controlling looping behavior\n   */\n  get playing() {\n    return this._playing;\n  }\n  /**\n   * Controls whether the animation automatically updates using the shared ticker.\n   * When enabled, the animation will update on each frame. When disabled, you must\n   * manually call update() to advance the animation.\n   * @example\n   * ```ts\n   * // Create sprite with auto-update disabled\n   * const sprite = new AnimatedSprite({\n   *     textures: [],\n   *     autoUpdate: false\n   * });\n   *\n   * // Manual update with app ticker\n   * app.ticker.add((ticker) => {\n   *     sprite.update(ticker);\n   * });\n   *\n   * // Enable auto-update later\n   * sprite.autoUpdate = true;\n   * ```\n   * @default true\n   * @see {@link AnimatedSprite#update} For manual animation updates\n   * @see {@link Ticker} For the timing system\n   */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\n\nexports.AnimatedSprite = AnimatedSprite;\n//# sourceMappingURL=AnimatedSprite.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar PlaneGeometry = __webpack_require__(/*! ../mesh-plane/PlaneGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.js\");\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry.PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexports.NineSliceGeometry = NineSliceGeometry;\n//# sourceMappingURL=NineSliceGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar ViewContainer = __webpack_require__(/*! ../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\nvar NineSliceGeometry = __webpack_require__(/*! ./NineSliceGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js\");\n\n\"use strict\";\nconst _NineSliceSprite = class _NineSliceSprite extends ViewContainer.ViewContainer {\n  constructor(options) {\n    if (options instanceof Texture.Texture) {\n      options = { texture: options };\n    }\n    const {\n      width,\n      height,\n      anchor,\n      leftWidth,\n      rightWidth,\n      topHeight,\n      bottomHeight,\n      texture,\n      roundPixels,\n      ...rest\n    } = options;\n    super({\n      label: \"NineSliceSprite\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"nineSliceSprite\";\n    /** @internal */\n    this.batched = true;\n    this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.leftWidth;\n    this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.topHeight;\n    this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.rightWidth;\n    this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.bottomHeight;\n    this._width = width ?? texture.width ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.width;\n    this._height = height ?? texture.height ?? NineSliceGeometry.NineSliceGeometry.defaultOptions.height;\n    this.allowChildren = false;\n    this.texture = texture ?? _NineSliceSprite.defaultOptions.texture;\n    this.roundPixels = roundPixels ?? false;\n    this._anchor = new ObservablePoint.ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (this.texture.defaultAnchor) {\n      this.anchor = this.texture.defaultAnchor;\n    }\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * - The default is `(0,0)`, this means the sprite's origin is the top left.\n   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * ```ts\n   * // Center the anchor point\n   * sprite.anchor = 0.5; // Sets both x and y to 0.5\n   * sprite.position.set(400, 300); // Sprite will be centered at this position\n   *\n   * // Set specific x/y anchor points\n   * sprite.anchor = {\n   *     x: 1, // Right edge\n   *     y: 0  // Top edge\n   * };\n   *\n   * // Using individual coordinates\n   * sprite.anchor.set(0.5, 1); // Center-bottom\n   *\n   * // For rotation around center\n   * sprite.anchor.set(0.5);\n   * sprite.rotation = Math.PI / 4; // 45 degrees around center\n   *\n   * // For scaling from center\n   * sprite.anchor.set(0.5);\n   * sprite.scale.set(2); // Scales from center point\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n   * The width affects how the middle sections are scaled.\n   * @example\n   * ```ts\n   * // Create a nine-slice sprite with fixed width\n   * const panel = new NineSliceSprite({\n   *     texture: Texture.from('panel.png'),\n   *     width: 200  // Sets initial width\n   * });\n   *\n   * // Adjust width dynamically\n   * panel.width = 300;  // Stretches middle sections\n   * ```\n   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n   * @see {@link NineSliceSprite#height} For setting height\n   */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n   * The height affects how the middle sections are scaled.\n   * @example\n   * ```ts\n   * // Create a nine-slice sprite with fixed height\n   * const panel = new NineSliceSprite({\n   *     texture: Texture.from('panel.png'),\n   *     height: 150  // Sets initial height\n   * });\n   *\n   * // Adjust height dynamically\n   * panel.height = 200;  // Stretches middle sections\n   *\n   * // Create responsive UI element\n   * const dialog = new NineSliceSprite({\n   *     texture: Texture.from('dialog.png'),\n   *     topHeight: 30,\n   *     bottomHeight: 30,\n   *     height: parent.height * 0.5  // 50% of parent height\n   * });\n   * ```\n   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n   * @see {@link NineSliceSprite#width} For setting width\n   */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /**\n   * Sets the size of the NineSliceSprite to the specified width and height.\n   * This method directly modifies the vertices and UV coordinates of the sprite.\n   *\n   * Using this is more efficient than setting width and height separately as it only triggers one update.\n   * @example\n   * ```ts\n   * // Set to specific dimensions\n   * panel.setSize(300, 200); // Width: 300, Height: 200\n   *\n   * // Set uniform size\n   * panel.setSize(200); // Makes a square 200x200\n   *\n   * // Set size using object\n   * panel.setSize({\n   *     width: 400,\n   *     height: 300\n   * });\n   * ```\n   * @param value - This can be either a number or a Size object with width/height properties\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link NineSliceSprite#width} For setting width only\n   * @see {@link NineSliceSprite#height} For setting height only\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    }\n    this._width = value;\n    this._height = height ?? value;\n    this.onViewUpdate();\n  }\n  /**\n   * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.\n   * This method is more efficient than getting width and height separately.\n   * @example\n   * ```ts\n   * // Get basic size\n   * const size = panel.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * panel.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the NineSliceSprite\n   * @see {@link NineSliceSprite#width} For getting just the width\n   * @see {@link NineSliceSprite#height} For getting just the height\n   * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = this._width;\n    out.height = this._height;\n    return out;\n  }\n  /**\n   * Width of the left vertical bar (A).\n   * Controls the size of the left edge that remains unscaled\n   * @example\n   * ```ts\n   * const sprite = new NineSliceSprite({ ..., leftWidth: 20 });\n   * sprite.leftWidth = 20; // Set left border width\n   * ```\n   * @default 10\n   */\n  get leftWidth() {\n    return this._leftWidth;\n  }\n  set leftWidth(value) {\n    this._leftWidth = value;\n    this.onViewUpdate();\n  }\n  /**\n   * Height of the top horizontal bar (C).\n   * Controls the size of the top edge that remains unscaled\n   * @example\n   * ```ts\n   * const sprite = new NineSliceSprite({ ..., topHeight: 20 });\n   * sprite.topHeight = 20; // Set top border height\n   * ```\n   * @default 10\n   */\n  get topHeight() {\n    return this._topHeight;\n  }\n  set topHeight(value) {\n    this._topHeight = value;\n    this.onViewUpdate();\n  }\n  /**\n   * Width of the right vertical bar (B).\n   * Controls the size of the right edge that remains unscaled\n   * @example\n   * ```ts\n   * const sprite = new NineSliceSprite({ ..., rightWidth: 20 });\n   * sprite.rightWidth = 20; // Set right border width\n   * ```\n   * @default 10\n   */\n  get rightWidth() {\n    return this._rightWidth;\n  }\n  set rightWidth(value) {\n    this._rightWidth = value;\n    this.onViewUpdate();\n  }\n  /**\n   * Height of the bottom horizontal bar (D).\n   * Controls the size of the bottom edge that remains unscaled\n   * @example\n   * ```ts\n   * const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });\n   * sprite.bottomHeight = 20; // Set bottom border height\n   * ```\n   * @default 10\n   */\n  get bottomHeight() {\n    return this._bottomHeight;\n  }\n  set bottomHeight(value) {\n    this._bottomHeight = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The texture to use on the NineSliceSprite.\n   * ```ts\n   * // Create a sprite with a texture\n   * const sprite = new NineSliceSprite({\n   *     texture: Texture.from('path/to/image.png')\n   * });\n   * // Update the texture later\n   * sprite.texture = Texture.from('path/to/another-image.png');\n   * ```\n   * @default Texture.EMPTY\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    value || (value = Texture.Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The original width of the texture before any nine-slice scaling.\n   * This is the width of the source texture used to create the nine-slice sprite.\n   * @example\n   * ```ts\n   * // Get original dimensions\n   * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n   *\n   * // Use for relative scaling\n   * sprite.width = sprite.originalWidth * 2; // Double the original width\n   *\n   * // Reset to original size\n   * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n   * ```\n   * @readonly\n   * @see {@link NineSliceSprite#width} For the current displayed width\n   * @see {@link Texture#width} For direct texture width access\n   * @returns The original width of the texture\n   */\n  get originalWidth() {\n    return this._texture.width;\n  }\n  /**\n   * The original height of the texture before any nine-slice scaling.\n   * This is the height of the source texture used to create the nine-slice sprite.\n   * @example\n   * ```ts\n   * // Get original dimensions\n   * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n   *\n   * // Use for relative scaling\n   * sprite.height = sprite.originalHeight * 2; // Double the original height\n   *\n   * // Reset to original size\n   * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n   * ```\n   * @readonly\n   * @see {@link NineSliceSprite#height} For the current displayed height\n   * @see {@link Texture#height} For direct texture height access\n   * @returns The original height of the texture\n   */\n  get originalHeight() {\n    return this._texture.height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * nineSliceSprite.destroy();\n   * nineSliceSprite.destroy(true);\n   * nineSliceSprite.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n};\n/**\n * The default options used to override initial values of any options passed in the constructor.\n * These values are used as fallbacks when specific options are not provided.\n * @example\n * ```ts\n * // Override default options globally\n * NineSliceSprite.defaultOptions.texture = Texture.from('defaultButton.png');\n * // Create sprite with default texture\n * const sprite = new NineSliceSprite({...});\n * // sprite will use 'defaultButton.png' as its texture\n *\n * // Reset to empty texture\n * NineSliceSprite.defaultOptions.texture = Texture.EMPTY;\n * ```\n * @type {NineSliceSpriteOptions}\n * @see {@link NineSliceSpriteOptions} For all available options\n * @see {@link Texture#defaultBorders} For texture-level border settings\n */\n_NineSliceSprite.defaultOptions = {\n  /** @default Texture.EMPTY */\n  texture: Texture.Texture.EMPTY\n};\nlet NineSliceSprite = _NineSliceSprite;\nclass NineSlicePlane extends NineSliceSprite {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Texture.Texture) {\n      deprecation.deprecation(deprecation.v8_0_0, \"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}\");\n      options = {\n        texture: options,\n        leftWidth: args[1],\n        topHeight: args[2],\n        rightWidth: args[3],\n        bottomHeight: args[4]\n      };\n    }\n    deprecation.deprecation(deprecation.v8_0_0, \"NineSlicePlane is deprecated. Use NineSliceSprite instead.\");\n    super(options);\n  }\n}\n\nexports.NineSlicePlane = NineSlicePlane;\nexports.NineSliceSprite = NineSliceSprite;\n//# sourceMappingURL=NineSliceSprite.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BatchableMesh = __webpack_require__(/*! ../mesh/shared/BatchableMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js\");\nvar NineSliceGeometry = __webpack_require__(/*! ./NineSliceGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.js\");\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh.BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry.NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexports.NineSliceSpriteGpuData = NineSliceSpriteGpuData;\nexports.NineSliceSpritePipe = NineSliceSpritePipe;\n//# sourceMappingURL=NineSliceSpritePipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar NineSliceSpritePipe = __webpack_require__(/*! ./NineSliceSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(NineSliceSpritePipe.NineSliceSpritePipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cache = __webpack_require__(/*! ../../assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar Transform = __webpack_require__(/*! ../../utils/misc/Transform.js */ \"./node_modules/pixi.js/lib/utils/misc/Transform.js\");\nvar ViewContainer = __webpack_require__(/*! ../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\n\n\"use strict\";\nconst _TilingSprite = class _TilingSprite extends ViewContainer.ViewContainer {\n  constructor(...args) {\n    let options = args[0] || {};\n    if (options instanceof Texture.Texture) {\n      options = { texture: options };\n    }\n    if (args.length > 1) {\n      deprecation.deprecation(deprecation.v8_0_0, \"use new TilingSprite({ texture, width:100, height:100 }) instead\");\n      options.width = args[1];\n      options.height = args[2];\n    }\n    options = { ..._TilingSprite.defaultOptions, ...options };\n    const {\n      texture,\n      anchor,\n      tilePosition,\n      tileScale,\n      tileRotation,\n      width,\n      height,\n      applyAnchorToTexture,\n      roundPixels,\n      ...rest\n    } = options ?? {};\n    super({\n      label: \"TilingSprite\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"tilingSprite\";\n    /** @advanced */\n    this.batched = true;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint.ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    this.applyAnchorToTexture = applyAnchorToTexture;\n    this.texture = texture;\n    this._width = width ?? texture.width;\n    this._height = height ?? texture.height;\n    this._tileTransform = new Transform.Transform({\n      observer: {\n        _onUpdate: () => this.onViewUpdate()\n      }\n    });\n    if (anchor)\n      this.anchor = anchor;\n    this.tilePosition = tilePosition;\n    this.tileScale = tileScale;\n    this.tileRotation = tileRotation;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   * Creates a new tiling sprite based on a source texture or image path.\n   * This is a convenience method that automatically creates and manages textures.\n   * @example\n   * ```ts\n   * // Create a new tiling sprite from an image path\n   * const pattern = TilingSprite.from('pattern.png');\n   * pattern.width = 300; // Set the width of the tiling area\n   * pattern.height = 200; // Set the height of the tiling area\n   *\n   * // Create from options\n   * const texture = Texture.from('pattern.png');\n   * const pattern = TilingSprite.from(texture, {\n   *     width: 300,\n   *     height: 200,\n   *     tileScale: { x: 0.5, y: 0.5 }\n   * });\n   * ```\n   * @param source - The source to create the sprite from. Can be a path to an image or a texture\n   * @param options - Additional options for the tiling sprite\n   * @returns A new tiling sprite based on the source\n   * @see {@link Texture.from} For texture creation details\n   * @see {@link Assets} For asset loading and management\n   */\n  static from(source, options = {}) {\n    if (typeof source === \"string\") {\n      return new _TilingSprite({\n        texture: Cache.Cache.get(source),\n        ...options\n      });\n    }\n    return new _TilingSprite({\n      texture: source,\n      ...options\n    });\n  }\n  /**\n   * @see {@link TilingSpriteOptions.applyAnchorToTexture}\n   * @deprecated since 8.0.0\n   * @advanced\n   */\n  get uvRespectAnchor() {\n    warn.warn(\"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    return this.applyAnchorToTexture;\n  }\n  /** @advanced */\n  set uvRespectAnchor(value) {\n    warn.warn(\"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    this.applyAnchorToTexture = value;\n  }\n  /**\n   * Changes frame clamping in corresponding textureMatrix\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @type {number}\n   * @advanced\n   */\n  get clampMargin() {\n    return this._texture.textureMatrix.clampMargin;\n  }\n  /** @advanced */\n  set clampMargin(value) {\n    this._texture.textureMatrix.clampMargin = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * - The default is `(0,0)`, this means the sprite's origin is the top left.\n   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * ```ts\n   * // Center the anchor point\n   * sprite.anchor = 0.5; // Sets both x and y to 0.5\n   * sprite.position.set(400, 300); // Sprite will be centered at this position\n   *\n   * // Set specific x/y anchor points\n   * sprite.anchor = {\n   *     x: 1, // Right edge\n   *     y: 0  // Top edge\n   * };\n   *\n   * // Using individual coordinates\n   * sprite.anchor.set(0.5, 1); // Center-bottom\n   *\n   * // For rotation around center\n   * sprite.anchor.set(0.5);\n   * sprite.rotation = Math.PI / 4; // 45 degrees around center\n   *\n   * // For scaling from center\n   * sprite.anchor.set(0.5);\n   * sprite.scale.set(2); // Scales from center point\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The offset of the tiling texture.\n   * Used to scroll or position the repeated pattern.\n   * @example\n   * ```ts\n   * // Offset the tiling pattern by 100 pixels in both x and y directions\n   * tilingSprite.tilePosition = { x: 100, y: 100 };\n   * ```\n   * @default {x: 0, y: 0}\n   */\n  get tilePosition() {\n    return this._tileTransform.position;\n  }\n  set tilePosition(value) {\n    this._tileTransform.position.copyFrom(value);\n  }\n  /**\n   * Scale of the tiling texture.\n   * Affects the size of each repeated instance of the texture.\n   * @example\n   * ```ts\n   * // Scale the texture by 1.5 in both x and y directions\n   * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n   * ```\n   * @default {x: 1, y: 1}\n   */\n  get tileScale() {\n    return this._tileTransform.scale;\n  }\n  set tileScale(value) {\n    typeof value === \"number\" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n  }\n  set tileRotation(value) {\n    this._tileTransform.rotation = value;\n  }\n  /**\n   * Rotation of the tiling texture in radians.\n   * This controls the rotation applied to the texture before tiling.\n   * @example\n   * ```ts\n   * // Rotate the texture by 45 degrees (in radians)\n   * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n   * ```\n   * @default 0\n   */\n  get tileRotation() {\n    return this._tileTransform.rotation;\n  }\n  /**\n   * The transform object that controls the tiling texture's position, scale, and rotation.\n   * This transform is independent of the sprite's own transform properties.\n   * @example\n   * ```ts\n   * // Access transform properties directly\n   * sprite.tileTransform.position.set(100, 50);\n   * sprite.tileTransform.scale.set(2);\n   * sprite.tileTransform.rotation = Math.PI / 4;\n   *\n   * // Create smooth scrolling animation\n   * app.ticker.add(() => {\n   *     sprite.tileTransform.position.x += 1;\n   *     sprite.tileTransform.rotation += 0.01;\n   * });\n   *\n   * // Reset transform\n   * sprite.tileTransform.position.set(0);\n   * sprite.tileTransform.scale.set(1);\n   * sprite.tileTransform.rotation = 0;\n   * ```\n   * @returns {Transform} The transform object for the tiling texture\n   * @see {@link Transform} For transform operations\n   * @see {@link TilingSprite#tilePosition} For position control\n   * @see {@link TilingSprite#tileScale} For scale control\n   * @see {@link TilingSprite#tileRotation} For rotation control\n   * @advanced\n   */\n  get tileTransform() {\n    return this._tileTransform;\n  }\n  set texture(value) {\n    value || (value = Texture.Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The texture to use for tiling.\n   * This is the image that will be repeated across the sprite.\n   * @example\n   * ```ts\n   * // Use a texture from the asset cache\n   * tilingSprite.texture = Texture.from('assets/pattern.png');\n   * ```\n   * @default Texture.WHITE\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 500,\n   *     height: 300\n   * });\n   *\n   * // Adjust width dynamically\n   * sprite.width = 800; // Expands tiling area\n   *\n   * // Update on resize\n   * window.addEventListener('resize', () => {\n   *     sprite.width = app.screen.width;\n   * });\n   * ```\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   * @see {@link TilingSprite#height} For setting height\n   */\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 500,\n   *     height: 300\n   * });\n   *\n   * // Adjust width dynamically\n   * sprite.height = 800; // Expands tiling area\n   *\n   * // Update on resize\n   * window.addEventListener('resize', () => {\n   *     sprite.height = app.screen.height;\n   * });\n   * ```\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   * @see {@link TilingSprite#width} For setting width\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Sets the size of the TilingSprite to the specified width and height.\n   * This is faster than setting width and height separately as it only triggers one update.\n   * @example\n   * ```ts\n   * // Set specific dimensions\n   * sprite.setSize(300, 200); // Width: 300, Height: 200\n   *\n   * // Set uniform size (square)\n   * sprite.setSize(400); // Width: 400, Height: 400\n   *\n   * // Set size using object\n   * sprite.setSize({\n   *     width: 500,\n   *     height: 300\n   * });\n   * ```\n   * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link TilingSprite#width} For setting width only\n   * @see {@link TilingSprite#height} For setting height only\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    }\n    this._width = value;\n    this._height = height ?? value;\n    this.onViewUpdate();\n  }\n  /**\n   * Retrieves the size of the TilingSprite as a {@link Size} object.\n   * This method is more efficient than getting width and height separately as it only allocates one object.\n   * @example\n   * ```ts\n   * // Get basic size\n   * const size = sprite.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * sprite.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the TilingSprite\n   * @see {@link TilingSprite#width} For getting just the width\n   * @see {@link TilingSprite#height} For getting just the height\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = this._width;\n    out.height = this._height;\n    return out;\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Checks if the object contains the given point in local coordinates.\n   * Takes into account the anchor offset when determining boundaries.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 200,\n   *     height: 100,\n   *     anchor: 0.5 // Center anchor\n   * });\n   *\n   * // Basic point check\n   * const contains = sprite.containsPoint({ x: 50, y: 25 });\n   * console.log('Point is inside:', contains);\n   *\n   * // Check with different anchors\n   * sprite.anchor.set(0); // Top-left anchor\n   * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is within the sprite's bounds\n   * @see {@link TilingSprite#toLocal} For converting global coordinates to local\n   * @see {@link TilingSprite#anchor} For understanding boundary calculations\n   */\n  containsPoint(point) {\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this._anchor._x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this._anchor._y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * tilingSprite.destroy();\n   * tilingSprite.destroy(true);\n   * tilingSprite.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._anchor = null;\n    this._tileTransform = null;\n    this._bounds = null;\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n};\n/**\n * Default options used when creating a TilingSprite instance.\n * These values are used as fallbacks when specific options are not provided.\n * @example\n * ```ts\n * // Override default options globally\n * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n *\n * // Create sprite using default options\n * const sprite = new TilingSprite();\n * // Will use defaultPattern.png and scale 2x\n * ```\n * @type {TilingSpriteOptions}\n * @see {@link TilingSpriteOptions} For all available options\n * @see {@link TilingSprite.from} For creating sprites with custom options\n * @see {@link Texture.EMPTY} For the default empty texture\n */\n_TilingSprite.defaultOptions = {\n  /** The texture to use for the sprite. */\n  texture: Texture.Texture.EMPTY,\n  /** The anchor point of the sprite */\n  anchor: { x: 0, y: 0 },\n  /** The offset of the image that is being tiled. */\n  tilePosition: { x: 0, y: 0 },\n  /** Scaling of the image that is being tiled. */\n  tileScale: { x: 1, y: 1 },\n  /** The rotation of the image that is being tiled. */\n  tileRotation: 0,\n  /**\n   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n   * local space.\n   *\n   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n   * this, the top-left corner always gets the (0, 0) texture coordinate.\n   * @default false\n   */\n  applyAnchorToTexture: false\n};\nlet TilingSprite = _TilingSprite;\n\nexports.TilingSprite = TilingSprite;\n//# sourceMappingURL=TilingSprite.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar getAdjustedBlendModeBlend = __webpack_require__(/*! ../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.js\");\nvar State = __webpack_require__(/*! ../../rendering/renderers/shared/state/State.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.js\");\nvar types = __webpack_require__(/*! ../../rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar colorToUniform = __webpack_require__(/*! ../graphics/gpu/colorToUniform.js */ \"./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.js\");\nvar BatchableMesh = __webpack_require__(/*! ../mesh/shared/BatchableMesh.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.js\");\nvar MeshGeometry = __webpack_require__(/*! ../mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\nvar TilingSpriteShader = __webpack_require__(/*! ./shader/TilingSpriteShader.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js\");\nvar QuadGeometry = __webpack_require__(/*! ./utils/QuadGeometry.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js\");\nvar setPositions = __webpack_require__(/*! ./utils/setPositions.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js\");\nvar setUvs = __webpack_require__(/*! ./utils/setUvs.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js\");\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry.QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry.MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh.BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader.TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    colorToUniform.color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs.setUvs(tilingSprite, geometry.uvs);\n    setPositions.setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types.RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexports.TilingSpriteGpuData = TilingSpriteGpuData;\nexports.TilingSpritePipe = TilingSpritePipe;\n//# sourceMappingURL=TilingSpritePipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/init.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/init.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TilingSpritePipe = __webpack_require__(/*! ./TilingSpritePipe.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(TilingSpritePipe.TilingSpritePipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar localUniformBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar Texture = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar tilingBit = __webpack_require__(/*! ./tilingBit.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js\");\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader.Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit.localUniformBit,\n        tilingBit.tilingBit,\n        roundPixelsBit.roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit.localUniformBitGl,\n        tilingBit.tilingBitGl,\n        roundPixelsBit.roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup.UniformGroup({\n      uMapCoord: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup.UniformGroup({\n          uTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.Texture.EMPTY.source,\n        uSampler: Texture.Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexports.TilingSpriteShader = TilingSpriteShader;\n//# sourceMappingURL=TilingSpriteShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexports.tilingBit = tilingBit;\nexports.tilingBitGl = tilingBitGl;\n//# sourceMappingURL=tilingBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar MeshGeometry = __webpack_require__(/*! ../../mesh/shared/MeshGeometry.js */ \"./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.js\");\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry.MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexports.QuadGeometry = QuadGeometry;\n//# sourceMappingURL=QuadGeometry.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexports.applyMatrix = applyMatrix;\n//# sourceMappingURL=applyMatrix.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexports.setPositions = setPositions;\n//# sourceMappingURL=setPositions.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar applyMatrix = __webpack_require__(/*! ./applyMatrix.js */ \"./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.js\");\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix.applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexports.setUvs = setUvs;\n//# sourceMappingURL=setUvs.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexports.BatchableSprite = BatchableSprite;\n//# sourceMappingURL=BatchableSprite.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/Sprite.js":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/Sprite.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar updateQuadBounds = __webpack_require__(/*! ../../utils/data/updateQuadBounds.js */ \"./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar ViewContainer = __webpack_require__(/*! ../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\n\n\"use strict\";\nclass Sprite extends ViewContainer.ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.Texture.EMPTY) {\n    if (options instanceof Texture.Texture) {\n      options = { texture: options };\n    }\n    const { texture = Texture.Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"sprite\";\n    /** @internal */\n    this.batched = true;\n    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._anchor = new ObservablePoint.ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Creates a new sprite based on a source texture, image, video, or canvas element.\n   * This is a convenience method that automatically creates and manages textures.\n   * @example\n   * ```ts\n   * // Create from path or URL\n   * const sprite = Sprite.from('assets/image.png');\n   *\n   * // Create from existing texture\n   * const sprite = Sprite.from(texture);\n   *\n   * // Create from canvas\n   * const canvas = document.createElement('canvas');\n   * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n   * ```\n   * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n   * or any valid texture source (canvas, video, etc.)\n   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n   * @returns A new sprite based on the source\n   * @see {@link Texture.from} For texture creation details\n   * @see {@link Assets} For asset loading and management\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture.Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /**\n   * The texture that is displayed by the sprite. When changed, automatically updates\n   * the sprite dimensions and manages texture event listeners.\n   * @example\n   * ```ts\n   * // Create sprite with texture\n   * const sprite = new Sprite({\n   *     texture: Texture.from('sprite.png')\n   * });\n   *\n   * // Update texture\n   * sprite.texture = Texture.from('newSprite.png');\n   *\n   * // Use texture from spritesheet\n   * const sheet = await Assets.load('spritesheet.json');\n   * sprite.texture = sheet.textures['frame1.png'];\n   *\n   * // Reset to empty texture\n   * sprite.texture = Texture.EMPTY;\n   * ```\n   * @see {@link Texture} For texture creation and management\n   * @see {@link Assets} For asset loading\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The bounds of the sprite, taking into account the texture's trim area.\n   * @example\n   * ```ts\n   * const texture = new Texture({\n   *     source: new TextureSource({ width: 300, height: 300 }),\n   *     frame: new Rectangle(196, 66, 58, 56),\n   *     trim: new Rectangle(4, 4, 58, 56),\n   *     orig: new Rectangle(0, 0, 64, 64),\n   *     rotate: 2,\n   * });\n   * const sprite = new Sprite(texture);\n   * const visualBounds = sprite.visualBounds;\n   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n   */\n  get visualBounds() {\n    updateQuadBounds.updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n    return this._visualBounds;\n  }\n  /**\n   * @deprecated\n   * @ignore\n   */\n  get sourceBounds() {\n    deprecation.deprecation(\"8.6.1\", \"Sprite.sourceBounds is deprecated, use visualBounds instead.\");\n    return this.visualBounds;\n  }\n  /** @private */\n  updateBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const bounds = this._bounds;\n    const { width, height } = texture.orig;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * sprite.destroy();\n   * sprite.destroy(true);\n   * sprite.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._visualBounds = null;\n    this._bounds = null;\n    this._anchor = null;\n    this._gpuData = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * - The default is `(0,0)`, this means the sprite's origin is the top left.\n   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * ```ts\n   * // Center the anchor point\n   * sprite.anchor = 0.5; // Sets both x and y to 0.5\n   * sprite.position.set(400, 300); // Sprite will be centered at this position\n   *\n   * // Set specific x/y anchor points\n   * sprite.anchor = {\n   *     x: 1, // Right edge\n   *     y: 0  // Top edge\n   * };\n   *\n   * // Using individual coordinates\n   * sprite.anchor.set(0.5, 1); // Center-bottom\n   *\n   * // For rotation around center\n   * sprite.anchor.set(0.5);\n   * sprite.rotation = Math.PI / 4; // 45 degrees around center\n   *\n   * // For scaling from center\n   * sprite.anchor.set(0.5);\n   * sprite.scale.set(2); // Scales from center point\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set width directly\n   * sprite.width = 200;\n   * console.log(sprite.scale.x); // Scale adjusted to match width\n   *\n   * // Set width while preserving aspect ratio\n   * const ratio = sprite.height / sprite.width;\n   * sprite.width = 300;\n   * sprite.height = 300 * ratio;\n   *\n   * // For better performance when setting both width and height\n   * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n   *\n   * // Reset to original texture size\n   * sprite.width = sprite.texture.orig.width;\n   * ```\n   */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /**\n   * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set height directly\n   * sprite.height = 150;\n   * console.log(sprite.scale.y); // Scale adjusted to match height\n   *\n   * // Set height while preserving aspect ratio\n   * const ratio = sprite.width / sprite.height;\n   * sprite.height = 200;\n   * sprite.width = 200 * ratio;\n   *\n   * // For better performance when setting both width and height\n   * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n   *\n   * // Reset to original texture size\n   * sprite.height = sprite.texture.orig.height;\n   * ```\n   */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n   * This is faster than getting width and height separately as it only calculates the bounds once.\n   * @example\n   * ```ts\n   * // Basic size retrieval\n   * const sprite = new Sprite(Texture.from('sprite.png'));\n   * const size = sprite.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * sprite.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the Sprite\n   * @see {@link Sprite#width} For getting just the width\n   * @see {@link Sprite#height} For getting just the height\n   * @see {@link Sprite#setSize} For setting both width and height\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting width and height separately as it only recalculates bounds once.\n   * @example\n   * ```ts\n   * // Basic size setting\n   * const sprite = new Sprite(Texture.from('sprite.png'));\n   * sprite.setSize(100, 200); // Width: 100, Height: 200\n   *\n   * // Set uniform size\n   * sprite.setSize(100); // Sets both width and height to 100\n   *\n   * // Set size with object\n   * sprite.setSize({\n   *     width: 200,\n   *     height: 300\n   * });\n   *\n   * // Reset to texture size\n   * sprite.setSize(\n   *     sprite.texture.orig.width,\n   *     sprite.texture.orig.height\n   * );\n   * ```\n   * @param value - This can be either a number or a {@link Size} object\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link Sprite#width} For setting width only\n   * @see {@link Sprite#height} For setting height only\n   * @see {@link Sprite#texture} For the source dimensions\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\nexports.Sprite = Sprite;\n//# sourceMappingURL=Sprite.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite/Sprite.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BatchableSprite = __webpack_require__(/*! ./BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite.BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexports.SpritePipe = SpritePipe;\n//# sourceMappingURL=SpritePipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/sprite/SpritePipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexports.AbstractBitmapFont = AbstractBitmapFont;\n//# sourceMappingURL=AbstractBitmapFont.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar AbstractBitmapFont = __webpack_require__(/*! ./AbstractBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js\");\nvar BitmapFontManager = __webpack_require__(/*! ./BitmapFontManager.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js\");\n\n\"use strict\";\nclass BitmapFont extends AbstractBitmapFont.AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const {\n        frame: textureFrame,\n        source: textureSource\n      } = textures[charData.page];\n      const frameReal = new Rectangle.Rectangle(\n        charData.x + textureFrame.x,\n        charData.y + textureFrame.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture.Texture({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: \"none\",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates and installs a bitmap font with the specified options.\n   * The font will be cached and available for use in BitmapText objects.\n   * @param options - Setup options for font generation\n   * @returns Installed font instance\n   * @example\n   * ```ts\n   * // Install a basic font\n   * BitmapFont.install({\n   *     name: 'Title',\n   *     style: {\n   *         fontFamily: 'Arial',\n   *         fontSize: 32,\n   *         fill: '#ffffff'\n   *     }\n   * });\n   *\n   * // Install with advanced options\n   * BitmapFont.install({\n   *     name: 'Custom',\n   *     style: {\n   *         fontFamily: 'Arial',\n   *         fontSize: 24,\n   *         fill: '#00ff00',\n   *         stroke: { color: '#000000', width: 2 }\n   *     },\n   *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n   *     resolution: 2,\n   *     padding: 4,\n   *     textureStyle: {\n   *         scaleMode: 'nearest'\n   *     }\n   * });\n   * ```\n   */\n  static install(options) {\n    BitmapFontManager.BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * This frees up memory and resources associated with the font.\n   * @param name - The name of the bitmap font to uninstall\n   * @example\n   * ```ts\n   * // Remove a font when it's no longer needed\n   * BitmapFont.uninstall('MyCustomFont');\n   *\n   * // Clear multiple fonts\n   * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n   * ```\n   */\n  static uninstall(name) {\n    BitmapFontManager.BitmapFontManager.uninstall(name);\n  }\n}\n\nexports.BitmapFont = BitmapFont;\n//# sourceMappingURL=BitmapFont.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cache = __webpack_require__(/*! ../../assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ../text/canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar TextStyle = __webpack_require__(/*! ../text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar DynamicBitmapFont = __webpack_require__(/*! ./DynamicBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js\");\nvar getBitmapTextLayout = __webpack_require__(/*! ./utils/getBitmapTextLayout.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js\");\nvar resolveCharacters = __webpack_require__(/*! ./utils/resolveCharacters.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js\");\n\n\"use strict\";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false,\n      textureStyle: null\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf(\"-\"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache.Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont.DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        warn.warn(\"BitmapText\", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n      }\n      fnt.once(\"destroy\", () => {\n        fontCount--;\n        Cache.Cache.remove(fontFamilyKey);\n      });\n      Cache.Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  getLayout(text, style, trimEnd = true) {\n    const bitmapFont = this.getFont(text, style);\n    const segments = CanvasTextMetrics.CanvasTextMetrics.graphemeSegmenter(text);\n    return getBitmapTextLayout.getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  measureText(text, style, trimEnd = true) {\n    return this.getLayout(text, style, trimEnd);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation.deprecation(deprecation.v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle.TextStyle ? textStyle : new TextStyle.TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont.DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false,\n      textureStyle: options.textureStyle\n    });\n    const flatChars = resolveCharacters.resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.Cache.get(cacheKey);\n    if (font) {\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexports.BitmapFontManager = BitmapFontManager;\n//# sourceMappingURL=BitmapFontManager.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar AbstractText = __webpack_require__(/*! ../text/AbstractText.js */ \"./node_modules/pixi.js/lib/scene/text/AbstractText.js\");\nvar TextStyle = __webpack_require__(/*! ../text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar BitmapFontManager = __webpack_require__(/*! ./BitmapFontManager.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js\");\n\n\"use strict\";\nclass BitmapText extends AbstractText.AbstractText {\n  constructor(...args) {\n    var _a;\n    const options = AbstractText.ensureTextOptions(args, \"BitmapText\");\n    options.style ?? (options.style = options.style || {});\n    (_a = options.style).fill ?? (_a.fill = 16777215);\n    super(options, TextStyle.TextStyle);\n    /** @internal */\n    this.renderPipeId = \"bitmapText\";\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const bitmapMeasurement = BitmapFontManager.BitmapFontManager.measureText(this.text, this._style);\n    const scale = bitmapMeasurement.scale;\n    const offset = bitmapMeasurement.offsetY * scale;\n    let width = bitmapMeasurement.width * scale;\n    let height = bitmapMeasurement.height * scale;\n    const stroke = this._style._stroke;\n    if (stroke) {\n      width += stroke.width;\n      height += stroke.width;\n    }\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * (height + offset);\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * The resolution / device pixel ratio for text rendering.\n   * Unlike other text types, BitmapText resolution is managed by the BitmapFont.\n   * Individual resolution changes are not supported.\n   * @example\n   * ```ts\n   * // ❌ Incorrect: Setting resolution directly (will trigger warning)\n   * const text = new BitmapText({\n   *     text: 'Hello',\n   *     resolution: 2 // This will be ignored\n   * });\n   *\n   * // ✅ Correct: Set resolution when installing the font\n   * BitmapFont.install({\n   *     name: 'MyFont',\n   *     style: {\n   *         fontFamily: 'Arial',\n   *     },\n   *     resolution: 2 // Resolution is set here\n   * });\n   *\n   * const text = new BitmapText({\n   *     text: 'Hello',\n   *     style: {\n   *         fontFamily: 'MyFont' // Uses font's resolution\n   *     }\n   * });\n   * ```\n   * @default 1\n   * @see {@link BitmapFont.install} For setting font resolution\n   * @throws {Warning} When attempting to change resolution directly\n   * @readonly\n   */\n  set resolution(value) {\n    if (value !== null) {\n      warn.warn(\n        // eslint-disable-next-line max-len\n        \"[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.\"\n      );\n    }\n  }\n  get resolution() {\n    return this._resolution;\n  }\n}\n\nexports.BitmapText = BitmapText;\n//# sourceMappingURL=BitmapText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cache = __webpack_require__(/*! ../../assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Graphics = __webpack_require__(/*! ../graphics/shared/Graphics.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ../text/canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar SdfShader = __webpack_require__(/*! ../text/sdfShader/SdfShader.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js\");\nvar BitmapFontManager = __webpack_require__(/*! ./BitmapFontManager.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.js\");\nvar getBitmapTextLayout = __webpack_require__(/*! ./utils/getBitmapTextLayout.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js\");\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics.Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuBitmapText\");\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader.SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout.getBitmapTextLayout(chars, style, bitmapFont, true);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexports.BitmapTextGraphics = BitmapTextGraphics;\nexports.BitmapTextPipe = BitmapTextPipe;\n//# sourceMappingURL=BitmapTextPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Rectangle = __webpack_require__(/*! ../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar CanvasPool = __webpack_require__(/*! ../../rendering/renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar ImageSource = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/ImageSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar TextureStyle = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ../text/canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar fontStringFromTextStyle = __webpack_require__(/*! ../text/canvas/utils/fontStringFromTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js\");\nvar getCanvasFillStyle = __webpack_require__(/*! ../text/canvas/utils/getCanvasFillStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js\");\nvar TextStyle = __webpack_require__(/*! ../text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar AbstractBitmapFont = __webpack_require__(/*! ./AbstractBitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.js\");\n\n\"use strict\";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont.AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentMaxCharHeight = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.Texture.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle.fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    if (dynamicOptions.textureStyle) {\n      this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle.TextureStyle ? dynamicOptions.textureStyle : new TextureStyle.TextureStyle(dynamicOptions.textureStyle);\n    }\n    this.fontMetrics = CanvasTextMetrics.CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = CanvasTextMetrics.CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    let currentMaxCharHeight = this._currentMaxCharHeight;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let skipTexture = false;\n    const maxTextureWidth = canvas.width / this.resolution;\n    const maxTextureHeight = canvas.height / this.resolution;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n      }\n      if (currentX + paddedWidth > maxTextureWidth) {\n        currentY += currentMaxCharHeight;\n        currentMaxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + currentMaxCharHeight > maxTextureHeight) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentX = 0;\n          currentY = 0;\n          currentMaxCharHeight = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle.Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture.Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._currentMaxCharHeight = currentMaxCharHeight;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation.deprecation(deprecation.v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.CanvasPool.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture.Texture({\n      source: new ImageSource.ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    if (this._textureStyle) {\n      texture.source.style = this._textureStyle;\n    }\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle.fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle.getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle.getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle.TextStyle(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\nexports.DynamicBitmapFont = DynamicBitmapFont;\n//# sourceMappingURL=DynamicBitmapFont.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\nexports.bitmapFontTextParser = bitmapFontTextParser;\n//# sourceMappingURL=bitmapFontTextParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName(\"info\")[0];\n    const common = xml.getElementsByTagName(\"common\")[0];\n    const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute(\"fieldType\"),\n        range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n    data.fontFamily = info.getAttribute(\"face\");\n    data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute(\"id\"), 10);\n      let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(charNode.getAttribute(\"x\"), 10),\n        y: parseInt(charNode.getAttribute(\"y\"), 10),\n        width: parseInt(charNode.getAttribute(\"width\"), 10),\n        height: parseInt(charNode.getAttribute(\"height\"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n        yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n      const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n      const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\nexports.bitmapFontXMLParser = bitmapFontXMLParser;\n//# sourceMappingURL=bitmapFontXMLParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar bitmapFontXMLParser = __webpack_require__(/*! ./bitmapFontXMLParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.js\");\n\n\"use strict\";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === \"string\" && data.includes(\"<font>\")) {\n      return bitmapFontXMLParser.bitmapFontXMLParser.test(adapter.DOMAdapter.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.bitmapFontXMLParser.parse(adapter.DOMAdapter.get().parseXML(data));\n  }\n};\n\nexports.bitmapFontXMLStringParser = bitmapFontXMLStringParser;\n//# sourceMappingURL=bitmapFontXMLStringParser.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../../../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar copySearchParams = __webpack_require__(/*! ../../../assets/utils/copySearchParams.js */ \"./node_modules/pixi.js/lib/assets/utils/copySearchParams.js\");\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar path = __webpack_require__(/*! ../../../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar BitmapFont = __webpack_require__(/*! ../BitmapFont.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.js\");\nvar bitmapFontTextParser = __webpack_require__(/*! ./bitmapFontTextParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.js\");\nvar bitmapFontXMLStringParser = __webpack_require__(/*! ./bitmapFontXMLStringParser.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.js\");\n\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: {\n    type: Extensions.ExtensionType.CacheParser,\n    name: \"cacheBitmapFont\"\n  },\n  test: (asset) => asset instanceof BitmapFont.BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n      out[`${key}-bitmap`] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions.ExtensionType.LoadParser,\n    priority: LoaderParser.LoaderParserPriority.Normal\n  },\n  name: \"loadBitmapFont\",\n  test(url) {\n    return validExtensions.includes(path.path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.bitmapFontTextParser.test(asset) ? bitmapFontTextParser.bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    const textureOptions = bitmapFontData.distanceField ? {\n      scaleMode: \"linear\",\n      alphaMode: \"premultiply-alpha-on-upload\",\n      autoGenerateMipmaps: false,\n      resolution: 1\n    } : {};\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.path.join(path.path.dirname(src), pageFile);\n      imagePath = copySearchParams.copySearchParams(imagePath, src);\n      textureUrls.push({\n        src: imagePath,\n        data: textureOptions\n      });\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url.src]);\n    const bitmapFont = new BitmapFont.BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter.DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\nexports.bitmapFontCachePlugin = bitmapFontCachePlugin;\nexports.loadBitmapFont = loadBitmapFont;\n//# sourceMappingURL=loadBitmapFont.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/init.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/init.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar BitmapTextPipe = __webpack_require__(/*! ./BitmapTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.js\");\n\n\"use strict\";\nExtensions.extensions.add(BitmapTextPipe.BitmapTextPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getBitmapTextLayout(chars, style, font, trimEnd) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    if (trimEnd) {\n      let lastChar = currentLine.chars[index];\n      while (lastChar === \" \") {\n        currentLine.width -= font.chars[lastChar].xAdvance;\n        lastChar = currentLine.chars[--index];\n      }\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexports.getBitmapTextLayout = getBitmapTextLayout;\n//# sourceMappingURL=getBitmapTextLayout.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexports.resolveCharacters = resolveCharacters;\n//# sourceMappingURL=resolveCharacters.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BatchableSprite = __webpack_require__(/*! ../sprite/BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite.BatchableSprite {\n  /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */\n  constructor(renderer) {\n    super();\n    this.generatingTexture = false;\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n    this.texturePromise = null;\n    this._renderer = null;\n  }\n}\n\nexports.BatchableHTMLText = BatchableHTMLText;\n//# sourceMappingURL=BatchableHTMLText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLText.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLText.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureStyle = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar AbstractText = __webpack_require__(/*! ../text/AbstractText.js */ \"./node_modules/pixi.js/lib/scene/text/AbstractText.js\");\nvar HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js\");\nvar measureHtmlText = __webpack_require__(/*! ./utils/measureHtmlText.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js\");\n\n\"use strict\";\nclass HTMLText extends AbstractText.AbstractText {\n  constructor(...args) {\n    const options = AbstractText.ensureTextOptions(args, \"HtmlText\");\n    super(options, HTMLTextStyle.HTMLTextStyle);\n    /** @internal */\n    this.renderPipeId = \"htmlText\";\n    if (options.textureStyle) {\n      this.textureStyle = options.textureStyle instanceof TextureStyle.TextureStyle ? options.textureStyle : new TextureStyle.TextureStyle(options.textureStyle);\n    }\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const htmlMeasurement = measureHtmlText.measureHtmlText(this.text, this._style);\n    const { width, height } = htmlMeasurement;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexports.HTMLText = HTMLText;\n//# sourceMappingURL=HTMLText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/HTMLText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Texture = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar updateTextBounds = __webpack_require__(/*! ../text/utils/updateTextBounds.js */ \"./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js\");\nvar BatchableHTMLText = __webpack_require__(/*! ./BatchableHTMLText.js */ \"./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.js\");\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    return htmlText._didTextUpdate;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n      htmlText._didTextUpdate = false;\n      updateTextBounds.updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    if (batchableHTMLText.texturePromise) {\n      this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n      batchableHTMLText.texturePromise = null;\n    }\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds.updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText.BatchableHTMLText(this._renderer);\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    return batchableHTMLText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexports.HTMLTextPipe = HTMLTextPipe;\n//# sourceMappingURL=HTMLTextPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\nexports.HTMLTextRenderData = HTMLTextRenderData;\n//# sourceMappingURL=HTMLTextRenderData.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar TextStyle = __webpack_require__(/*! ../text/TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar textStyleToCSS = __webpack_require__(/*! ./utils/textStyleToCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js\");\n\n\"use strict\";\nclass HTMLTextStyle extends TextStyle.TextStyle {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides = options.cssOverrides ?? [];\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /**\n   * List of CSS style overrides to apply to the HTML text.\n   * These styles are added after the built-in styles and can override any default styling.\n   * @advanced\n   */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  /** @advanced */\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  /**\n   * Updates the text style and triggers a refresh of the CSS style cache.\n   * This method is called automatically when style properties are changed.\n   * @example\n   * ```ts\n   * // Update after multiple changes\n   * const text = new HTMLText({\n   *     text: 'Hello World',\n   *     style\n   * });\n   *\n   * style.fontSize = 32;\n   * style.fill = '#00ff00';\n   * style.fontFamily = 'Arial';\n   * style.update(); // Apply all changes at once\n   * ```\n   * @advanced\n   * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n   * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n   */\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * This creates a deep copy of all style properties, including dropShadow and tag styles.\n   * @example\n   * ```ts\n   * // Create original style\n   * const originalStyle = new HTMLTextStyle({\n   *     fontSize: 24,\n   *     fill: '#ff0000',\n   *     tagStyles: {\n   *         header: { fontSize: 32, fill: '#00ff00' }\n   *     }\n   * });\n   *\n   * // Clone the style\n   * const clonedStyle = originalStyle.clone();\n   *\n   * // Modify cloned style independently\n   * clonedStyle.fontSize = 36;\n   * clonedStyle.fill = '#0000ff';\n   *\n   * // Original style remains unchanged\n   * console.log(originalStyle.fontSize); // Still 24\n   * console.log(originalStyle.fill); // Still '#ff0000'\n   * ```\n   *\n   * Properties that are cloned:\n   * - Basic text properties (fontSize, fontFamily, etc.)\n   * - Fill and stroke styles\n   * - Drop shadow configuration\n   * - CSS overrides\n   * - Tag styles (deep copied)\n   * - Word wrap settings\n   * - Alignment and spacing\n   * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n   * @see {@link HTMLTextStyle} For available style properties\n   * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n   * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n   * @standard\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides,\n      tagStyles: { ...this.tagStyles }\n    });\n  }\n  /**\n   * The CSS style string that will be applied to the HTML text.\n   * @advanced\n   */\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS.textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   * @advanced\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   * @advanced\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  /**\n   * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n   * Texture fills are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Colored Text',\n   *     style: {\n   *         fill: 0xff0000 // Red color\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.fill = '#00ff00';     // Hex string (Green)\n   * text.style.fill = 'blue';        // Named color\n   * text.style.fill = 'rgb(255,0,0)' // RGB\n   * text.style.fill = '#f0f';        // Short hex\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.fill = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The fill color to use. Must be a string or number.\n   * @throws {Warning} In debug mode when attempting to use unsupported fill types\n   * @see {@link TextStyle#fill} For full fill options in canvas text\n   * @standard\n   */\n  set fill(value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\") {\n      warn.warn(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n    }\n    super.fill = value;\n  }\n  /**\n   * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n   * Texture strokes are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Outlined Text',\n   *     style: {\n   *         stroke: 0xff0000 // Red outline\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.stroke = '#00ff00';     // Hex string (Green)\n   * text.style.stroke = 'blue';        // Named color\n   * text.style.stroke = 'rgb(255,0,0)' // RGB\n   * text.style.stroke = '#f0f';        // Short hex\n   *\n   * // Using stroke width\n   * text.style = {\n   *     stroke: {\n   *         color: '#ff0000',\n   *         width: 2\n   *     }\n   * };\n   *\n   * // Remove stroke\n   * text.style.stroke = null;\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.stroke = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n   * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n   * @see {@link TextStyle#stroke} For full stroke options in canvas text\n   * @standard\n   */\n  set stroke(value) {\n    if (value && typeof value !== \"string\" && typeof value !== \"number\") {\n      warn.warn(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n    }\n    super.stroke = value;\n  }\n}\n\nexports.HTMLTextStyle = HTMLTextStyle;\n//# sourceMappingURL=HTMLTextStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CanvasPool = __webpack_require__(/*! ../../rendering/renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar TexturePool = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar types = __webpack_require__(/*! ../../rendering/renderers/types.js */ \"./node_modules/pixi.js/lib/rendering/renderers/types.js\");\nvar isSafari = __webpack_require__(/*! ../../utils/browser/isSafari.js */ \"./node_modules/pixi.js/lib/utils/browser/isSafari.js\");\nvar warn = __webpack_require__(/*! ../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar PoolGroup = __webpack_require__(/*! ../../utils/pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar getPo2TextureFromSource = __webpack_require__(/*! ../text/utils/getPo2TextureFromSource.js */ \"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js\");\nvar HTMLTextRenderData = __webpack_require__(/*! ./HTMLTextRenderData.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js\");\nvar HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.js\");\nvar extractFontFamilies = __webpack_require__(/*! ./utils/extractFontFamilies.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js\");\nvar getFontCss = __webpack_require__(/*! ./utils/getFontCss.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js\");\nvar getSVGUrl = __webpack_require__(/*! ./utils/getSVGUrl.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js\");\nvar getTemporaryCanvasFromImage = __webpack_require__(/*! ./utils/getTemporaryCanvasFromImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js\");\nvar loadSVGImage = __webpack_require__(/*! ./utils/loadSVGImage.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js\");\nvar measureHtmlText = __webpack_require__(/*! ./utils/measureHtmlText.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js\");\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types.RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = PoolGroup.BigPool.get(HTMLTextRenderData.HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies.extractFontFamilies(text, style);\n    const fontCSS = await getFontCss.getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText.measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl.getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage.loadSVGImage(image, svgURL, isSafari.isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage.getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource.getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    PoolGroup.BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn.warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexports.HTMLTextSystem = HTMLTextSystem;\n//# sourceMappingURL=HTMLTextSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/init.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/init.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar HTMLTextPipe = __webpack_require__(/*! ./HTMLTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.js\");\nvar HTMLTextSystem = __webpack_require__(/*! ./HTMLTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.js\");\n\n\"use strict\";\nExtensions.extensions.add(HTMLTextSystem.HTMLTextSystem);\nExtensions.extensions.add(HTMLTextPipe.HTMLTextPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexports.extractFontFamilies = extractFontFamilies;\n//# sourceMappingURL=extractFontFamilies.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cache = __webpack_require__(/*! ../../../assets/cache/Cache.js */ \"./node_modules/pixi.js/lib/assets/cache/Cache.js\");\nvar loadFontCSS = __webpack_require__(/*! ./loadFontCSS.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js\");\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache.Cache.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS.loadFontCSS({\n          fontWeight: style.fontWeight,\n          fontStyle: style.fontStyle,\n          fontFamily\n        }, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS.loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexports.FontStylePromiseCache = FontStylePromiseCache;\nexports.getFontCss = getFontCss;\n//# sourceMappingURL=getFontCss.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexports.getSVGUrl = getSVGUrl;\n//# sourceMappingURL=getSVGUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar CanvasPool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexports.getTemporaryCanvasFromImage = getTemporaryCanvasFromImage;\n//# sourceMappingURL=getTemporaryCanvasFromImage.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await adapter.DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexports.loadFontAsBase64 = loadFontAsBase64;\n//# sourceMappingURL=loadFontAsBase64.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar loadFontAsBase64 = __webpack_require__(/*! ./loadFontAsBase64.js */ \"./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.js\");\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64.loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\nexports.loadFontCSS = loadFontCSS;\n//# sourceMappingURL=loadFontCSS.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexports.loadSVGImage = loadSVGImage;\n//# sourceMappingURL=loadSVGImage.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar HTMLTextRenderData = __webpack_require__(/*! ../HTMLTextRenderData.js */ \"./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.js\");\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData.HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexports.measureHtmlText = measureHtmlText;\n//# sourceMappingURL=measureHtmlText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\n\n\"use strict\";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color.Color.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(\";\");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(\" \");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color.Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color.Color.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color.Color.shared.setValue(stroke.color).toHex()}`,\n    \"paint-order: stroke\"\n  ].join(\";\");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color.Color.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n  }\n}\n\nexports.textStyleToCSS = textStyleToCSS;\n//# sourceMappingURL=textStyleToCSS.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/AbstractText.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/AbstractText.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar ViewContainer = __webpack_require__(/*! ../view/ViewContainer.js */ \"./node_modules/pixi.js/lib/scene/view/ViewContainer.js\");\n\n\"use strict\";\nclass AbstractText extends ViewContainer.ViewContainer {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    /** @internal */\n    this.batched = true;\n    /** @internal */\n    this._resolution = null;\n    /** @internal */\n    this._autoResolution = true;\n    /** @internal */\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint.ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * The anchor point of the text that controls the origin point for positioning and rotation.\n   * Can be a number (same value for x/y) or a PointData object.\n   * - (0,0) is top-left\n   * - (0.5,0.5) is center\n   * - (1,1) is bottom-right\n   * ```ts\n   * // Set anchor to center\n   * const text = new Text({\n   *     text: 'Hello Pixi!',\n   *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n   * });\n   * // Set anchor to top-left\n   * const text2 = new Text({\n   *     text: 'Hello Pixi!',\n   *     anchor: { x: 0, y: 0 } // Top-left corner\n   * });\n   * // Set anchor to bottom-right\n   * const text3 = new Text({\n   *     text: 'Hello Pixi!',\n   *     anchor: { x: 1, y: 1 } // Bottom-right corner\n   * });\n   * ```\n   * @default { x: 0, y: 0 }\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The text content to display. Use '\\n' for line breaks.\n   * Accepts strings, numbers, or objects with toString() method.\n   * @example\n   * ```ts\n   * const text = new Text({\n   *     text: 'Hello Pixi!',\n   * });\n   * const multilineText = new Text({\n   *     text: 'Line 1\\nLine 2\\nLine 3',\n   * });\n   * const numberText = new Text({\n   *     text: 12345, // Will be converted to '12345'\n   * });\n   * const objectText = new Text({\n   *     text: { toString: () => 'Object Text' }, // Custom toString\n   * });\n   *\n   * // Update text dynamically\n   * text.text = 'Updated Text'; // Re-renders with new text\n   * text.text = 67890; // Updates to '67890'\n   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n   * // Clear text\n   * text.text = ''; // Clears the text\n   * ```\n   * @default ''\n   */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution/device pixel ratio for rendering.\n   * Higher values result in sharper text at the cost of performance.\n   * Set to null for auto-resolution based on device.\n   * @example\n   * ```ts\n   * const text = new Text({\n   *     text: 'Hello Pixi!',\n   *     resolution: 2 // High DPI for sharper text\n   * });\n   * const autoResText = new Text({\n   *     text: 'Auto Resolution',\n   *     resolution: null // Use device's pixel ratio\n   * });\n   * ```\n   * @default null\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * The style configuration for the text.\n   * Can be a TextStyle instance or a configuration object.\n   * Supports canvas text styles, HTML text styles, and bitmap text styles.\n   * @example\n   * ```ts\n   * const text = new Text({\n   *     text: 'Styled Text',\n   *     style: {\n   *         fontSize: 24,\n   *         fill: 0xff1010, // Red color\n   *         fontFamily: 'Arial',\n   *         align: 'center', // Center alignment\n   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n   *         dropShadow: {\n   *             color: '#000000', // Black shadow\n   *             blur: 4, // Shadow blur\n   *             distance: 6 // Shadow distance\n   *         }\n   *     }\n   * });\n   * const htmlText = new HTMLText({\n   *     text: 'HTML Styled Text',\n   *     style: {\n   *         fontSize: '20px',\n   *         fill: 'blue',\n   *         fontFamily: 'Verdana',\n   *     }\n   * });\n   * const bitmapText = new BitmapText({\n   *     text: 'Bitmap Styled Text',\n   *     style: {\n   *         fontName: 'Arial',\n   *         fontSize: 32,\n   *     }\n   * })\n   *\n   * // Update style dynamically\n   * text.style = {\n   *     fontSize: 30, // Change font size\n   *     fill: 0x00ff00, // Change color to green\n   *     align: 'right', // Change alignment to right\n   *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n   * }\n   */\n  set style(style) {\n    style || (style = {});\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set width directly\n   * texture.width = 200;\n   * console.log(texture.scale.x); // Scale adjusted to match width\n   *\n   * // For better performance when setting both width and height\n   * texture.setSize(300, 400); // Avoids recalculating bounds twice\n   * ```\n   */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /**\n   * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set height directly\n   * texture.height = 200;\n   * console.log(texture.scale.y); // Scale adjusted to match height\n   *\n   * // For better performance when setting both width and height\n   * texture.setSize(300, 400); // Avoids recalculating bounds twice\n   * ```\n   */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.\n   * This is faster than getting width and height separately as it only calculates the bounds once.\n   * @example\n   * ```ts\n   * // Basic size retrieval\n   * const text = new Text({\n   *     text: 'Hello Pixi!',\n   *     style: { fontSize: 24 }\n   * });\n   * const size = text.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * text.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the Sprite\n   * @see {@link Text#width} For getting just the width\n   * @see {@link Text#height} For getting just the height\n   * @see {@link Text#setSize} For setting both width and height\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting width and height separately as it only recalculates bounds once.\n   * @example\n   * ```ts\n   * // Basic size setting\n   * const text = new Text({\n   *    text: 'Hello Pixi!',\n   *    style: { fontSize: 24 }\n   * });\n   * text.setSize(100, 200); // Width: 100, Height: 200\n   *\n   * // Set uniform size\n   * text.setSize(100); // Sets both width and height to 100\n   *\n   * // Set size with object\n   * text.setSize({\n   *     width: 200,\n   *     height: 300\n   * });\n   * ```\n   * @param value - This can be either a number or a {@link Size} object\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link Text#width} For setting width only\n   * @see {@link Text#height} For setting height only\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Checks if the object contains the given point in local coordinates.\n   * Uses the text's bounds for hit testing.\n   * @example\n   * ```ts\n   * // Basic point check\n   * const localPoint = { x: 50, y: 25 };\n   * const contains = text.containsPoint(localPoint);\n   * console.log('Point is inside:', contains);\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is within the text's bounds\n   * @see {@link Container#toLocal} For converting global coordinates to local\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  /** @internal */\n  onViewUpdate() {\n    if (!this.didViewUpdate)\n      this._didTextUpdate = true;\n    super.onViewUpdate();\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * // Destroys the text and its style\n   * text.destroy({ style: true, texture: true, textureSource: true });\n   * text.destroy(true);\n   * text.destroy() // Destroys the text, but not its style\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureTextOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation.deprecation(deprecation.v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\nexports.AbstractText = AbstractText;\nexports.ensureTextOptions = ensureTextOptions;\n//# sourceMappingURL=AbstractText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/AbstractText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/Text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TextureStyle = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar AbstractText = __webpack_require__(/*! ./AbstractText.js */ \"./node_modules/pixi.js/lib/scene/text/AbstractText.js\");\nvar CanvasTextGenerator = __webpack_require__(/*! ./canvas/CanvasTextGenerator.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ./canvas/CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar TextStyle = __webpack_require__(/*! ./TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\n\n\"use strict\";\nclass Text extends AbstractText.AbstractText {\n  constructor(...args) {\n    const options = AbstractText.ensureTextOptions(args, \"Text\");\n    super(options, TextStyle.TextStyle);\n    /** @internal */\n    this.renderPipeId = \"text\";\n    if (options.textureStyle) {\n      this.textureStyle = options.textureStyle instanceof TextureStyle.TextureStyle ? options.textureStyle : new TextureStyle.TextureStyle(options.textureStyle);\n    }\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    let width = 0;\n    let height = 0;\n    if (this._style.trim) {\n      const { frame, canvasAndContext } = CanvasTextGenerator.CanvasTextGenerator.getCanvasAndContext({\n        text: this.text,\n        style: this._style,\n        resolution: 1\n      });\n      CanvasTextGenerator.CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      width = frame.width;\n      height = frame.height;\n    } else {\n      const canvasMeasurement = CanvasTextMetrics.CanvasTextMetrics.measureText(\n        this._text,\n        this._style\n      );\n      width = canvasMeasurement.width;\n      height = canvasMeasurement.height;\n    }\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexports.Text = Text;\n//# sourceMappingURL=Text.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/Text.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/TextStyle.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/TextStyle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\nvar Color = __webpack_require__(/*! ../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar deprecation = __webpack_require__(/*! ../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar FillGradient = __webpack_require__(/*! ../graphics/shared/fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar FillPattern = __webpack_require__(/*! ../graphics/shared/fill/FillPattern.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js\");\nvar GraphicsContext = __webpack_require__(/*! ../graphics/shared/GraphicsContext.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.js\");\nvar convertFillInputToFillStyle = __webpack_require__(/*! ../graphics/shared/utils/convertFillInputToFillStyle.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.js\");\nvar generateTextStyleKey = __webpack_require__(/*! ./utils/generateTextStyleKey.js */ \"./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js\");\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });\n    } else {\n      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value.toLowerCase();\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @type {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /**\n   * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n   * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n   * compared to applying the filter directly to the text object (which would be applied at run time).\n   * @default null\n   */\n  get filters() {\n    return this._filters;\n  }\n  set filters(value) {\n    this._filters = value;\n    this.update();\n  }\n  /**\n   * Trim transparent borders from the text texture.\n   * > [!IMPORTANT] PERFORMANCE WARNING:\n   * > This is a costly operation as it requires scanning pixel alpha values.\n   * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n   */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /**\n   * The fill style that will be used to color the text.\n   * This can be:\n   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n   * - A hex number like 0xff0000 for red\n   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n   * - A FillGradient for gradient fills\n   * - A FillPattern for pattern/texture fills\n   *\n   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n   * while gradients at any other angle are spread across the entire text body as a whole.\n   * @example\n   * // Vertical gradient applied per line\n   * const verticalGradient = new FillGradient(0, 0, 0, 1)\n   *     .addColorStop(0, 0xff0000)\n   *     .addColorStop(1, 0x0000ff);\n   *\n   * const text = new Text({\n   *     text: 'Line 1\\nLine 2',\n   *     style: { fill: verticalGradient }\n   * });\n   *\n   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n   * @type {string|number|FillStyle|FillGradient|FillPattern}\n   */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    if (this._isFillStyle(value)) {\n      this._originalFill = this._createProxy({ ...GraphicsContext.GraphicsContext.defaultFillStyle, ...value }, () => {\n        this._fill = convertFillInputToFillStyle.toFillStyle(\n          { ...this._originalFill },\n          GraphicsContext.GraphicsContext.defaultFillStyle\n        );\n      });\n    }\n    this._fill = convertFillInputToFillStyle.toFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    if (this._isFillStyle(value)) {\n      this._originalStroke = this._createProxy({ ...GraphicsContext.GraphicsContext.defaultStrokeStyle, ...value }, () => {\n        this._stroke = convertFillInputToFillStyle.toStrokeStyle(\n          { ...this._originalStroke },\n          GraphicsContext.GraphicsContext.defaultStrokeStyle\n        );\n      });\n    }\n    this._stroke = convertFillInputToFillStyle.toStrokeStyle(value, GraphicsContext.GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey.generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  /** @internal */\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      filters: this._filters ? [...this._filters] : void 0\n    });\n  }\n  /**\n   * Returns the final padding for the text style, taking into account any filters applied.\n   * Used internally for correct measurements\n   * @internal\n   * @returns {number} The final padding for the text style.\n   */\n  _getFinalPadding() {\n    let filterPadding = 0;\n    if (this._filters) {\n      for (let i = 0; i < this._filters.length; i++) {\n        filterPadding += this._filters[i].padding;\n      }\n    }\n    return Math.max(this._padding, filterPadding);\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * // Destroy the text style and its textures\n   * textStyle.destroy({ texture: true, textureSource: true });\n   * textStyle.destroy(true);\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n  _createProxy(value, cb) {\n    return new Proxy(value, {\n      set: (target, property, newValue) => {\n        target[property] = newValue;\n        cb?.(property, newValue);\n        this.update();\n        return true;\n      }\n    });\n  }\n  _isFillStyle(value) {\n    return (value ?? null) !== null && !(Color.Color.isColorLike(value) || value instanceof FillGradient.FillGradient || value instanceof FillPattern.FillPattern);\n  }\n};\n/**\n * Default drop shadow settings used when enabling drop shadows on text.\n * These values are used as the base configuration when drop shadows are enabled without specific settings.\n * @example\n * ```ts\n * // Customize default settings globally\n * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n * ```\n */\n_TextStyle.defaultDropShadow = {\n  alpha: 1,\n  angle: Math.PI / 6,\n  blur: 0,\n  color: \"black\",\n  distance: 5\n};\n/**\n * Default text style settings used when creating new text objects.\n * These values serve as the base configuration and can be customized globally.\n * @example\n * ```ts\n * // Customize default text style globally\n * TextStyle.defaultTextStyle.fontSize = 16;\n * TextStyle.defaultTextStyle.fill = 0x333333;\n * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n * ```\n */\n_TextStyle.defaultTextStyle = {\n  align: \"left\",\n  breakWords: false,\n  dropShadow: null,\n  fill: \"black\",\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  leading: 0,\n  letterSpacing: 0,\n  lineHeight: 0,\n  padding: 0,\n  stroke: null,\n  textBaseline: \"alphabetic\",\n  trim: false,\n  whiteSpace: \"pre\",\n  wordWrap: false,\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    deprecation.deprecation(deprecation.v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    let obj = {};\n    if (Color.Color.isColorLike(color)) {\n      obj.color = color;\n    } else if (color instanceof FillGradient.FillGradient || color instanceof FillPattern.FillPattern) {\n      obj.fill = color;\n    } else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) {\n      obj = color;\n    } else {\n      throw new Error(\"Invalid stroke value.\");\n    }\n    style.stroke = {\n      ...obj,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fillGradientStops)) {\n    deprecation.deprecation(deprecation.v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    let fontSize;\n    if (style.fontSize == null) {\n      style.fontSize = TextStyle.defaultTextStyle.fontSize;\n    } else if (typeof style.fontSize === \"string\") {\n      fontSize = parseInt(style.fontSize, 10);\n    } else {\n      fontSize = style.fontSize;\n    }\n    const gradientFill = new FillGradient.FillGradient({\n      start: { x: 0, y: 0 },\n      end: { x: 0, y: (fontSize || 0) * 1.7 }\n    });\n    const fills = oldStyle.fillGradientStops.map((color) => Color.Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = index / (fills.length - 1);\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexports.TextStyle = TextStyle;\n//# sourceMappingURL=TextStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/TextStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar BatchableSprite = __webpack_require__(/*! ../../sprite/BatchableSprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.js\");\n\n\"use strict\";\nclass BatchableText extends BatchableSprite.BatchableSprite {\n  constructor(renderer) {\n    super();\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  destroy() {\n    this._renderer.canvasText.returnTexture(this.texture);\n    this._renderer = null;\n  }\n}\n\nexports.BatchableText = BatchableText;\n//# sourceMappingURL=BatchableText.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Rectangle = __webpack_require__(/*! ../../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar CanvasPool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/CanvasPool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.js\");\nvar getCanvasBoundingBox = __webpack_require__(/*! ../../../utils/canvas/getCanvasBoundingBox.js */ \"./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js\");\nvar CanvasTextMetrics = __webpack_require__(/*! ./CanvasTextMetrics.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js\");\nvar fontStringFromTextStyle = __webpack_require__(/*! ./utils/fontStringFromTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js\");\nvar getCanvasFillStyle = __webpack_require__(/*! ./utils/getCanvasFillStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js\");\n\n\"use strict\";\nconst tempRect = new Rectangle.Rectangle();\nclass CanvasTextGeneratorClass {\n  /**\n   * Creates a canvas with the specified text rendered to it.\n   *\n   * Generates a canvas of appropriate size, renders the text with the provided style,\n   * and returns both the canvas/context and a Rectangle representing the text bounds.\n   *\n   * When trim is enabled in the style, the frame will represent the bounds of the\n   * non-transparent pixels, which can be smaller than the full canvas.\n   * @param options - The options for generating the text canvas\n   * @param options.text - The text to render\n   * @param options.style - The style to apply to the text\n   * @param options.resolution - The resolution of the canvas (defaults to 1)\n   * @param options.padding\n   * @returns An object containing the canvas/context and the frame (bounds) of the text\n   */\n  getCanvasAndContext(options) {\n    const { text, style, resolution = 1 } = options;\n    const padding = style._getFinalPadding();\n    const measured = CanvasTextMetrics.CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.CanvasPool.getOptimalCanvasAndContext(width, height);\n    this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n    const frame = style.trim ? getCanvasBoundingBox.getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect }) : tempRect.set(0, 0, width, height);\n    return {\n      canvasAndContext,\n      frame\n    };\n  }\n  /**\n   * Returns a canvas and context to the pool.\n   *\n   * This should be called when you're done with the canvas to allow reuse\n   * and prevent memory leaks.\n   * @param canvasAndContext - The canvas and context to return to the pool\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @param text - The text to render\n   * @param style - The style of the text\n   * @param padding - The padding of the text\n   * @param resolution - The resolution of the text\n   * @param canvasAndContext - The canvas and context to render the text to\n   */\n  _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle.fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.textBaseline = style.textBaseline;\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = style._fill ? getCanvasFillStyle.getCanvasFillStyle(style._fill, context, measured) : null;\n        if (style._stroke?.width) {\n          const padding2 = style._stroke.width * style._stroke.alignment;\n          context.strokeStyle = getCanvasFillStyle.getCanvasFillStyle(style._stroke, context, measured, padding2);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   *\n   * This method handles rendering text with the correct letter spacing, using either:\n   * 1. Native letter spacing if supported by the browser\n   * 2. Manual letter spacing calculation if not natively supported\n   *\n   * For manual letter spacing, it calculates the position of each character\n   * based on its width and the desired spacing.\n   * @param text - The text to draw\n   * @param style - The text style to apply\n   * @param canvasAndContext - The canvas and context to draw to\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Whether to render the stroke (true) or fill (false)\n   * @private\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n}\nconst CanvasTextGenerator = new CanvasTextGeneratorClass();\n\nexports.CanvasTextGenerator = CanvasTextGenerator;\n//# sourceMappingURL=CanvasTextGenerator.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar fontStringFromTextStyle = __webpack_require__(/*! ./utils/fontStringFromTextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js\");\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result === void 0) {\n      const proto = adapter.DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const font = fontStringFromTextStyle.fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = adapter.DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = adapter.DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => {\n      const segments = segmenter.segment(s);\n      const result = [];\n      let i = 0;\n      for (const segment of segments) {\n        result[i++] = segment.segment;\n      }\n      return result;\n    };\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@link TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexports.CanvasTextMetrics = CanvasTextMetrics;\n//# sourceMappingURL=CanvasTextMetrics.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar updateTextBounds = __webpack_require__(/*! ../utils/updateTextBounds.js */ \"./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js\");\nvar BatchableText = __webpack_require__(/*! ./BatchableText.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.js\");\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      this._updateGpuText(text);\n      text._didTextUpdate = false;\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.returnTexture(batchableText.texture);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = batchableText.texture = this._renderer.canvasText.getTexture(text);\n    updateTextBounds.updateTextBounds(batchableText, text);\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText.BatchableText(this._renderer);\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    return batchableText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLPipes,\n    Extensions.ExtensionType.WebGPUPipes,\n    Extensions.ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexports.CanvasTextPipe = CanvasTextPipe;\n//# sourceMappingURL=CanvasTextPipe.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar TexturePool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar TextureStyle = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TextureStyle.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.js\");\nvar deprecation = __webpack_require__(/*! ../../../utils/logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar TextStyle = __webpack_require__(/*! ../TextStyle.js */ \"./node_modules/pixi.js/lib/scene/text/TextStyle.js\");\nvar getPo2TextureFromSource = __webpack_require__(/*! ../utils/getPo2TextureFromSource.js */ \"./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js\");\nvar CanvasTextGenerator = __webpack_require__(/*! ./CanvasTextGenerator.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.js\");\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation.deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle.TextStyle)) {\n      options.style = new TextStyle.TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle.TextureStyle)) {\n      options.textureStyle = new TextureStyle.TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource.getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation.deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem,\n    Extensions.ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexports.CanvasTextSystem = CanvasTextSystem;\n//# sourceMappingURL=CanvasTextSystem.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexports.fontStringFromTextStyle = fontStringFromTextStyle;\n//# sourceMappingURL=fontStringFromTextStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\nvar Matrix = __webpack_require__(/*! ../../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar Texture = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar warn = __webpack_require__(/*! ../../../../utils/logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar FillGradient = __webpack_require__(/*! ../../../graphics/shared/fill/FillGradient.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.js\");\nvar FillPattern = __webpack_require__(/*! ../../../graphics/shared/fill/FillPattern.js */ \"./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.js\");\n\n\"use strict\";\nconst PRECISION = 1e5;\nfunction getCanvasFillStyle(fillStyle, context, textMetrics, padding = 0) {\n  if (fillStyle.texture === Texture.Texture.WHITE && !fillStyle.fill) {\n    return Color.Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern.FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient.FillGradient) {\n    const fillGradient = fillStyle.fill;\n    const isLinear = fillGradient.type === \"linear\";\n    const isLocal = fillGradient.textureSpace === \"local\";\n    let width = 1;\n    let height = 1;\n    if (isLocal && textMetrics) {\n      width = textMetrics.width + padding;\n      height = textMetrics.height + padding;\n    }\n    let gradient;\n    let isNearlyVertical = false;\n    if (isLinear) {\n      const { start, end } = fillGradient;\n      gradient = context.createLinearGradient(\n        start.x * width,\n        start.y * height,\n        end.x * width,\n        end.y * height\n      );\n      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n    } else {\n      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n      gradient = context.createRadialGradient(\n        center.x * width,\n        center.y * height,\n        innerRadius * width,\n        outerCenter.x * width,\n        outerCenter.y * height,\n        outerRadius * width\n      );\n    }\n    if (isNearlyVertical && isLocal && textMetrics) {\n      const ratio = textMetrics.lineHeight / height;\n      for (let i = 0; i < textMetrics.lines.length; i++) {\n        const start = (i * textMetrics.lineHeight + padding / 2) / height;\n        fillGradient.colorStops.forEach((stop) => {\n          const globalStop = start + stop.offset * ratio;\n          gradient.addColorStop(\n            // fix to 5 decimal places to avoid floating point precision issues\n            Math.floor(globalStop * PRECISION) / PRECISION,\n            Color.Color.shared.setValue(stop.color).toHex()\n          );\n        });\n      }\n    } else {\n      fillGradient.colorStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.Color.shared.setValue(stop.color).toHex());\n      });\n    }\n    return gradient;\n  }\n  warn.warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexports.getCanvasFillStyle = getCanvasFillStyle;\n//# sourceMappingURL=getCanvasFillStyle.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/init.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/init.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar CanvasTextPipe = __webpack_require__(/*! ./canvas/CanvasTextPipe.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.js\");\nvar CanvasTextSystem = __webpack_require__(/*! ./canvas/CanvasTextSystem.js */ \"./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.js\");\n\n\"use strict\";\nExtensions.extensions.add(CanvasTextSystem.CanvasTextSystem);\nExtensions.extensions.add(CanvasTextPipe.CanvasTextPipe);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar compileHighShaderToProgram = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.js\");\nvar colorBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.js\");\nvar generateTextureBatchBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.js\");\nvar roundPixelsBit = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.js */ \"./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.js\");\nvar getBatchSamplersUniformGroup = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.js\");\nvar Shader = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.js\");\nvar UniformGroup = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.js\");\nvar localUniformMSDFBit = __webpack_require__(/*! ./shader-bits/localUniformMSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js\");\nvar mSDFBit = __webpack_require__(/*! ./shader-bits/mSDFBit.js */ \"./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js\");\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader.Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup.UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix.Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit.colorBit,\n        generateTextureBatchBit.generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit.localUniformMSDFBit,\n        mSDFBit.mSDFBit,\n        roundPixelsBit.roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit.colorBitGl,\n        generateTextureBatchBit.generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBit.localUniformMSDFBitGl,\n        mSDFBit.mSDFBitGl,\n        roundPixelsBit.roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup.getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexports.SdfShader = SdfShader;\n//# sourceMappingURL=SdfShader.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexports.localUniformMSDFBit = localUniformMSDFBit;\nexports.localUniformMSDFBitGl = localUniformMSDFBitGl;\n//# sourceMappingURL=localUniformMSDFBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexports.mSDFBit = mSDFBit;\nexports.mSDFBitGl = mSDFBitGl;\n//# sourceMappingURL=mSDFBit.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Color = __webpack_require__(/*! ../../../color/Color.js */ \"./node_modules/pixi.js/lib/color/Color.js\");\n\n\"use strict\";\nconst valuesToIterateForKeys = [\n  \"align\",\n  \"breakWords\",\n  \"cssOverrides\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"leading\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"padding\",\n  \"textBaseline\",\n  \"trim\",\n  \"whiteSpace\",\n  \"wordWrap\",\n  \"wordWrapWidth\",\n  \"fontFamily\",\n  \"fontStyle\",\n  \"fontSize\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = `_${valuesToIterateForKeys[i]}`;\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  index = addDropShadowKey(style.dropShadow, key, index);\n  index = addFiltersKey(style.filters, key, index);\n  return key.join(\"-\");\n}\nfunction addFiltersKey(filters, key, index) {\n  if (!filters)\n    return index;\n  for (const filter of filters) {\n    key[index++] = filter.uid;\n  }\n  return index;\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.styleKey;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\nfunction addDropShadowKey(dropShadow, key, index) {\n  if (!dropShadow)\n    return index;\n  key[index++] = dropShadow.alpha;\n  key[index++] = dropShadow.angle;\n  key[index++] = dropShadow.blur;\n  key[index++] = dropShadow.distance;\n  key[index++] = Color.Color.shared.setValue(dropShadow.color).toNumber();\n  return index;\n}\n\nexports.generateTextStyleKey = generateTextStyleKey;\n//# sourceMappingURL=generateTextStyleKey.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar TexturePool = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.js\");\nvar Bounds = __webpack_require__(/*! ../../container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\n\n\"use strict\";\nconst tempBounds = new Bounds.Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexports.getPo2TextureFromSource = getPo2TextureFromSource;\n//# sourceMappingURL=getPo2TextureFromSource.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar updateQuadBounds = __webpack_require__(/*! ../../../utils/data/updateQuadBounds.js */ \"./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js\");\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  updateQuadBounds.updateQuadBounds(bounds, text._anchor, texture);\n  const padding = text._style._getFinalPadding();\n  bounds.minX -= padding;\n  bounds.minY -= padding;\n  bounds.maxX -= padding;\n  bounds.maxY -= padding;\n}\n\nexports.updateTextBounds = updateTextBounds;\n//# sourceMappingURL=updateTextBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/view/ViewContainer.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/view/ViewContainer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Bounds = __webpack_require__(/*! ../container/bounds/Bounds.js */ \"./node_modules/pixi.js/lib/scene/container/bounds/Bounds.js\");\nvar Container = __webpack_require__(/*! ../container/Container.js */ \"./node_modules/pixi.js/lib/scene/container/Container.js\");\n\n\"use strict\";\nclass ViewContainer extends Container.Container {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(options) {\n    super(options);\n    /** @internal */\n    this.canBundle = true;\n    /** @internal */\n    this.allowChildren = false;\n    /** @internal */\n    this._roundPixels = 0;\n    /** @internal */\n    this._lastUsed = -1;\n    /** @internal */\n    this._gpuData = /* @__PURE__ */ Object.create(null);\n    this._bounds = new Bounds.Bounds(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /**\n   * The local bounds of the view in its own coordinate space.\n   * Bounds are automatically updated when the view's content changes.\n   * @example\n   * ```ts\n   * // Get bounds dimensions\n   * const bounds = view.bounds;\n   * console.log(`Width: ${bounds.maxX - bounds.minX}`);\n   * console.log(`Height: ${bounds.maxY - bounds.minY}`);\n   * ```\n   * @returns The rectangular bounds of the view\n   * @see {@link Bounds} For bounds operations\n   */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this.updateBounds();\n    this._boundsDirty = false;\n    return this._bounds;\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @example\n   * ```ts\n   * // Enable pixel rounding for crisp rendering\n   * view.roundPixels = true;\n   * ```\n   * @default false\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point in local coordinates.\n   * Uses the view's bounds for hit testing.\n   * @example\n   * ```ts\n   * // Basic point check\n   * const localPoint = { x: 50, y: 25 };\n   * const contains = view.containsPoint(localPoint);\n   * console.log('Point is inside:', contains);\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is within the view's bounds\n   * @see {@link ViewContainer#bounds} For the bounds used in hit testing\n   * @see {@link Container#toLocal} For converting global coordinates to local\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  /** @private */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n    for (const key in this._gpuData) {\n      this._gpuData[key].destroy?.();\n    }\n    this._gpuData = null;\n  }\n  /**\n   * Collects renderables for the view container.\n   * @param instructionSet - The instruction set to collect renderables for.\n   * @param renderer - The renderer to collect renderables for.\n   * @param currentLayer - The current render layer.\n   * @internal\n   */\n  collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n    const { renderPipes } = renderer;\n    renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n    const rp = renderPipes;\n    rp[this.renderPipeId].addRenderable(this, instructionSet);\n    this.didViewUpdate = false;\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n  }\n}\n\nexports.ViewContainer = ViewContainer;\n//# sourceMappingURL=ViewContainer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/scene/view/ViewContainer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/Spritesheet.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/Spritesheet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Rectangle = __webpack_require__(/*! ../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\nvar TextureSource = __webpack_require__(/*! ../rendering/renderers/shared/texture/sources/TextureSource.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.js\");\nvar Texture = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /** @ignore */\n  constructor(optionsOrTexture, arg1) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    let options = optionsOrTexture;\n    if (optionsOrTexture?.source instanceof TextureSource.TextureSource) {\n      options = {\n        texture: optionsOrTexture,\n        data: arg1\n      };\n    }\n    const { texture, data, cachePrefix = \"\" } = options;\n    this.cachePrefix = cachePrefix;\n    this._texture = texture instanceof Texture.Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle.Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle.Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle.Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle.Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture.Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/**\n * The maximum number of Textures to build per process.\n * @advanced\n */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexports.Spritesheet = Spritesheet;\n//# sourceMappingURL=Spritesheet.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/spritesheet/Spritesheet.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ \"./node_modules/pixi.js/lib/spritesheet/Spritesheet.js\");\nvar spritesheetAsset = __webpack_require__(/*! ./spritesheetAsset.js */ \"./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js\");\n\n\"use strict\";\n\nexports.Spritesheet = Spritesheet.Spritesheet;\nexports.spritesheetAsset = spritesheetAsset.spritesheetAsset;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/spritesheet/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/init.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/init.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar spritesheetAsset = __webpack_require__(/*! ./spritesheetAsset.js */ \"./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js\");\n\n\"use strict\";\nExtensions.extensions.add(spritesheetAsset.spritesheetAsset);\n//# sourceMappingURL=init.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/spritesheet/init.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar LoaderParser = __webpack_require__(/*! ../assets/loader/parsers/LoaderParser.js */ \"./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.js\");\nvar Resolver = __webpack_require__(/*! ../assets/resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\nvar copySearchParams = __webpack_require__(/*! ../assets/utils/copySearchParams.js */ \"./node_modules/pixi.js/lib/assets/utils/copySearchParams.js\");\nvar Extensions = __webpack_require__(/*! ../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar Texture = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.js\");\nvar path = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ \"./node_modules/pixi.js/lib/spritesheet/Spritesheet.js\");\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: Extensions.ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet.Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: Extensions.ExtensionType.ResolveParser,\n      name: \"resolveSpritesheet\"\n    },\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: Extensions.ExtensionType.LoadParser,\n      priority: LoaderParser.LoaderParserPriority.Normal,\n      name: \"spritesheetLoader\"\n    },\n    async testParse(asset, options) {\n      return path.path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename,\n        // if user need to use custom filename (not from jsonFile.meta.image)\n        textureOptions,\n        // if user need to set texture options on texture\n        cachePrefix\n        // if user need to use custom cache prefix\n      } = options?.data ?? {};\n      let basePath = path.path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture.Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams.copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet.Spritesheet({\n        texture: texture.source,\n        data: asset,\n        cachePrefix\n      });\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams.copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              textureOptions,\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexports.spritesheetAsset = spritesheetAsset;\n//# sourceMappingURL=spritesheetAsset.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/Ticker.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/Ticker.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar TickerListener = __webpack_require__(/*! ./TickerListener.js */ \"./node_modules/pixi.js/lib/ticker/TickerListener.js\");\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n     * automatically when a listener is added.\n     * @example\n     * ```ts\n     * // Default behavior (manual start)\n     * const ticker = new Ticker();\n     * ticker.autoStart = false;\n     * ticker.add(() => {\n     *     // Won't run until ticker.start() is called\n     * });\n     *\n     * // Auto-start behavior\n     * const autoTicker = new Ticker();\n     * autoTicker.autoStart = true;\n     * autoTicker.add(() => {\n     *     // Runs immediately when added\n     * });\n     * ```\n     * @default false\n     * @see {@link Ticker#start} For manually starting the ticker\n     * @see {@link Ticker#stop} For manually stopping the ticker\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * Used for frame-based animations and updates.\n     *\n     * This value is capped by setting {@link Ticker#minFPS|minFPS}\n     * and is scaled with {@link Ticker#speed|speed}.\n     * > [!NOTE] The cap may be exceeded by scaling.\n     * @example\n     * ```ts\n     * // Basic animation\n     * ticker.add((ticker) => {\n     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     * });\n     * ```\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link Ticker#update|update} was invoked.\n     * Used for calculating time deltas between frames.\n     *\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     *\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * @example\n     * ```ts\n     * // Basic timing check\n     * ticker.add(() => {\n     *     const timeSinceStart = performance.now() - ticker.lastTime;\n     *     console.log(`Time running: ${timeSinceStart}ms`);\n     * });\n     * ```\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link Ticker#deltaTime|deltaTime}.\n     * Used to scale time for slow motion or fast-forward effects.\n     * @example\n     * ```ts\n     * // Basic speed adjustment\n     * ticker.speed = 0.5; // Half speed (slow motion)\n     * ticker.speed = 2.0; // Double speed (fast forward)\n     *\n     * // Temporary speed changes\n     * function slowMotion() {\n     *     const normalSpeed = ticker.speed;\n     *     ticker.speed = 0.2;\n     *     setTimeout(() => {\n     *         ticker.speed = normalSpeed;\n     *     }, 1000);\n     * }\n     * ```\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     *\n     * `true` if {@link Ticker#start|start} has been called.\n     * `false` if {@link Ticker#stop|Stop} has been called.\n     *\n     * While `false`, this value may change to `true` in the\n     * event of {@link Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     * @example\n     * ```ts\n     * // Check ticker state\n     * const ticker = new Ticker();\n     * console.log(ticker.started); // false\n     *\n     * // Start and verify\n     * ticker.start();\n     * console.log(ticker.started); // true\n     * ```\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener.TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /** Conditionally cancels a pending animation frame. */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @example\n   * ```ts\n   * // Basic update handler\n   * ticker.add((ticker) => {\n   *     // Update every frame\n   *     sprite.rotation += 0.1 * ticker.deltaTime;\n   * });\n   *\n   * // With specific context\n   * const game = {\n   *     update(ticker) {\n   *         this.physics.update(ticker.deltaTime);\n   *     }\n   * };\n   * ticker.add(game.update, game);\n   *\n   * // With priority\n   * ticker.add(\n   *     (ticker) => {\n   *         // Runs before normal priority updates\n   *         physics.update(ticker.deltaTime);\n   *     },\n   *     undefined,\n   *     UPDATE_PRIORITY.HIGH\n   * );\n   * ```\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n   * @returns This instance of a ticker\n   * @see {@link Ticker#addOnce} For one-time handlers\n   * @see {@link Ticker#remove} For removing handlers\n   */\n  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only executed once on the next frame.\n   * @example\n   * ```ts\n   * // Basic one-time update\n   * ticker.addOnce(() => {\n   *     console.log('Runs next frame only');\n   * });\n   *\n   * // With specific context\n   * const game = {\n   *     init(ticker) {\n   *         this.loadResources();\n   *         console.log('Game initialized');\n   *     }\n   * };\n   * ticker.addOnce(game.init, game);\n   *\n   * // With priority\n   * ticker.addOnce(\n   *     () => {\n   *         // High priority one-time setup\n   *         physics.init();\n   *     },\n   *     undefined,\n   *     UPDATE_PRIORITY.HIGH\n   * );\n   * ```\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n   * @returns This instance of a ticker\n   * @see {@link Ticker#add} For continuous updates\n   * @see {@link Ticker#remove} For removing handlers\n   */\n  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @example\n   * ```ts\n   * // Basic removal\n   * const onTick = () => {\n   *     sprite.rotation += 0.1;\n   * };\n   * ticker.add(onTick);\n   * ticker.remove(onTick);\n   *\n   * // Remove with context\n   * const game = {\n   *     update(ticker) {\n   *         this.physics.update(ticker.deltaTime);\n   *     }\n   * };\n   * ticker.add(game.update, game);\n   * ticker.remove(game.update, game);\n   *\n   * // Remove all matching handlers\n   * // (if same function was added multiple times)\n   * ticker.add(onTick);\n   * ticker.add(onTick);\n   * ticker.remove(onTick); // Removes all instances\n   * ```\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   * @see {@link Ticker#add} For adding handlers\n   * @see {@link Ticker#addOnce} For one-time handlers\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list.\n   * @example\n   * ```ts\n   * // Check number of active listeners\n   * const ticker = new Ticker();\n   * console.log(ticker.count); // 0\n   *\n   * // Add some listeners\n   * ticker.add(() => {});\n   * ticker.add(() => {});\n   * console.log(ticker.count); // 2\n   *\n   * // Check after cleanup\n   * ticker.destroy();\n   * console.log(ticker.count); // 0\n   * ```\n   * @readonly\n   * @see {@link Ticker#add} For adding listeners\n   * @see {@link Ticker#remove} For removing listeners\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /**\n   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n   * @example\n   * ```ts\n   * // Basic manual start\n   * const ticker = new Ticker();\n   * ticker.add(() => {\n   *     // Animation code here\n   * });\n   * ticker.start();\n   * ```\n   * @see {@link Ticker#stop} For stopping the ticker\n   * @see {@link Ticker#autoStart} For automatic starting\n   * @see {@link Ticker#started} For checking ticker state\n   */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /**\n   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n   * @example\n   * ```ts\n   * // Basic stop\n   * const ticker = new Ticker();\n   * ticker.stop();\n   * ```\n   * @see {@link Ticker#start} For starting the ticker\n   * @see {@link Ticker#started} For checking ticker state\n   * @see {@link Ticker#destroy} For cleaning up the ticker\n   */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /**\n   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n   * @example\n   * ```ts\n   * // Clean up with active listeners\n   * const ticker = new Ticker();\n   * ticker.add(() => {});\n   * ticker.destroy(); // Removes all listeners\n   * ```\n   * @see {@link Ticker#stop} For stopping without destroying\n   * @see {@link Ticker#remove} For removing specific listeners\n   */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update.\n   *\n   * An update entails setting the\n   * current {@link Ticker#elapsedMS|elapsedMS},\n   * the current {@link Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   *\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @example\n   * ```ts\n   * // Basic manual update\n   * const ticker = new Ticker();\n   * ticker.update(performance.now());\n   * ```\n   * @param currentTime - The current time of execution (defaults to performance.now())\n   * @see {@link Ticker#deltaTime} For frame delta value\n   * @see {@link Ticker#elapsedMS} For raw elapsed time\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * > [!NOTE] This does not factor in the value of\n   * > {@link Ticker#speed|speed}, which is specific\n   * > to scaling {@link Ticker#deltaTime|deltaTime}.\n   * @example\n   * ```ts\n   * // Basic FPS monitoring\n   * ticker.add(() => {\n   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n   * });\n   * ```\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link Ticker#update|update}.\n   *\n   * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n   *\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @example\n   * ```ts\n   * // Set minimum acceptable frame rate\n   * const ticker = new Ticker();\n   * ticker.minFPS = 30; // Never go below 30 FPS\n   *\n   * // Use with maxFPS for frame rate clamping\n   * ticker.minFPS = 30;\n   * ticker.maxFPS = 60;\n   *\n   * // Monitor delta capping\n   * ticker.add(() => {\n   *     // Delta time will be capped based on minFPS\n   *     console.log(`Delta time: ${ticker.deltaTime}`);\n   * });\n   * ```\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link Ticker#update|update}.\n   *\n   * This will effect the measured value of {@link Ticker#FPS|FPS}.\n   *\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @example\n   * ```ts\n   * // Set minimum acceptable frame rate\n   * const ticker = new Ticker();\n   * ticker.maxFPS = 60; // Never go above 60 FPS\n   *\n   * // Use with maxFPS for frame rate clamping\n   * ticker.minFPS = 30;\n   * ticker.maxFPS = 60;\n   *\n   * // Monitor delta capping\n   * ticker.add(() => {\n   *     // Delta time will be capped based on maxFPS\n   *     console.log(`Delta time: ${ticker.deltaTime}`);\n   * });\n   * ```\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoSource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @type {Ticker}\n   * @readonly\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link PrepareBase} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @type {Ticker}\n   * @readonly\n   * @advanced\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frame rate in frames per millisecond.\n * Used for converting deltaTime to a scalar time delta.\n * @example\n * ```ts\n * // Default is 0.06 (60 FPS)\n * console.log(Ticker.targetFPMS); // 0.06\n *\n * // Calculate target frame duration\n * const frameDuration = 1 / Ticker.targetFPMS; // ≈ 16.67ms\n *\n * // Use in custom timing calculations\n * const deltaTime = elapsedMS * Ticker.targetFPMS;\n * ```\n * @remarks\n * - Default is 0.06 (equivalent to 60 FPS)\n * - Used in deltaTime calculations\n * - Affects all ticker instances\n * @default 0.06\n * @see {@link Ticker#deltaTime} For time scaling\n * @see {@link Ticker#FPS} For actual frame rate\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexports.Ticker = Ticker;\n//# sourceMappingURL=Ticker.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/ticker/Ticker.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/TickerListener.js":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/TickerListener.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexports.TickerListener = TickerListener;\n//# sourceMappingURL=TickerListener.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/ticker/TickerListener.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/const.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/const.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexports.UPDATE_PRIORITY = UPDATE_PRIORITY;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/ticker/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/index.js":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/ticker/const.js\");\nvar Ticker = __webpack_require__(/*! ./Ticker.js */ \"./node_modules/pixi.js/lib/ticker/Ticker.js\");\nvar TickerListener = __webpack_require__(/*! ./TickerListener.js */ \"./node_modules/pixi.js/lib/ticker/TickerListener.js\");\n\n\"use strict\";\n\nexports.UPDATE_PRIORITY = _const.UPDATE_PRIORITY;\nexports.Ticker = Ticker.Ticker;\nexports.TickerListener = TickerListener.TickerListener;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/ticker/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexports.detectVideoAlphaMode = detectVideoAlphaMode;\n//# sourceMappingURL=detectVideoAlphaMode.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isMobile.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isMobile.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isMobileJs = __webpack_require__(/*! ismobilejs */ \"./node_modules/ismobilejs/esm/index.js\");\n\n\"use strict\";\nconst isMobileCall = isMobileJs.default ?? isMobileJs;\nconst isMobile = isMobileCall(globalThis.navigator);\n\nexports.isMobile = isMobile;\n//# sourceMappingURL=isMobile.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/isMobile.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isSafari.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isSafari.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = adapter.DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexports.isSafari = isSafari;\n//# sourceMappingURL=isSafari.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/isSafari.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar AbstractRenderer = __webpack_require__(/*! ../../rendering/renderers/shared/system/AbstractRenderer.js */ \"./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.js\");\n\n\"use strict\";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!adapter.DOMAdapter.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = adapter.DOMAdapter.get().createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\nexports.isWebGLSupported = isWebGLSupported;\n//# sourceMappingURL=isWebGLSupported.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = adapter.DOMAdapter.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\nexports.isWebGPUSupported = isWebGPUSupported;\n//# sourceMappingURL=isWebGPUSupported.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (_e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\nexports.unsafeEvalSupported = unsafeEvalSupported;\n//# sourceMappingURL=unsafeEvalSupported.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar pow2 = __webpack_require__(/*! ../../maths/misc/pow2.js */ \"./node_modules/pixi.js/lib/maths/misc/pow2.js\");\nvar Rectangle = __webpack_require__(/*! ../../maths/shapes/Rectangle.js */ \"./node_modules/pixi.js/lib/maths/shapes/Rectangle.js\");\n\n\"use strict\";\nlet _internalCanvas = null;\nlet _internalContext = null;\nfunction ensureInternalCanvas(width, height) {\n  if (!_internalCanvas) {\n    _internalCanvas = adapter.DOMAdapter.get().createCanvas(256, 128);\n    _internalContext = _internalCanvas.getContext(\"2d\", { willReadFrequently: true });\n    _internalContext.globalCompositeOperation = \"copy\";\n    _internalContext.globalAlpha = 1;\n  }\n  if (_internalCanvas.width < width || _internalCanvas.height < height) {\n    _internalCanvas.width = pow2.nextPow2(width);\n    _internalCanvas.height = pow2.nextPow2(height);\n  }\n}\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(...args) {\n  let options = args[0];\n  if (!options.canvas) {\n    options = { canvas: args[0], resolution: args[1] };\n  }\n  const { canvas } = options;\n  const resolution = Math.min(options.resolution ?? 1, 1);\n  const width = options.width ?? canvas.width;\n  const height = options.height ?? canvas.height;\n  let output = options.output;\n  ensureInternalCanvas(width, height);\n  if (!_internalContext) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  _internalContext.drawImage(\n    canvas,\n    0,\n    0,\n    width,\n    height,\n    0,\n    0,\n    width * resolution,\n    height * resolution\n  );\n  const imageData = _internalContext.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle.Rectangle.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  _internalContext.globalCompositeOperation = \"source-over\";\n  _internalContext.strokeRect(left, top, right - left, bottom - top);\n  _internalContext.globalCompositeOperation = \"copy\";\n  output ?? (output = new Rectangle.Rectangle());\n  output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n  return output;\n}\n\nexports.getCanvasBoundingBox = getCanvasBoundingBox;\n//# sourceMappingURL=getCanvasBoundingBox.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/const.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/const.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\n\n\"use strict\";\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nconst VERSION = \"8.10.2\";\n\nexports.EventEmitter = EventEmitter;\nexports.DATA_URI = DATA_URI;\nexports.VERSION = VERSION;\n//# sourceMappingURL=const.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/const.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexports.ViewableBuffer = ViewableBuffer;\n//# sourceMappingURL=ViewableBuffer.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/clean.js":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/clean.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexports.cleanArray = cleanArray;\nexports.cleanHash = cleanHash;\n//# sourceMappingURL=clean.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/data/clean.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/removeItems.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/removeItems.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexports.removeItems = removeItems;\n//# sourceMappingURL=removeItems.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/data/removeItems.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/uid.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/uid.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexports.resetUids = resetUids;\nexports.uid = uid;\n//# sourceMappingURL=uid.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/data/uid.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexports.updateQuadBounds = updateQuadBounds;\n//# sourceMappingURL=updateQuadBounds.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/global/globalHooks.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/global/globalHooks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Extensions = __webpack_require__(/*! ../../extensions/Extensions.js */ \"./node_modules/pixi.js/lib/extensions/Extensions.js\");\nvar _const = __webpack_require__(/*! ../const.js */ \"./node_modules/pixi.js/lib/utils/const.js\");\n\n\"use strict\";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this, _const.VERSION);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = Extensions.ExtensionType.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, _const.VERSION);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    Extensions.ExtensionType.WebGLSystem,\n    Extensions.ExtensionType.WebGPUSystem\n  ],\n  name: \"initHook\",\n  priority: -10\n};\n\nexports.ApplicationInitHook = ApplicationInitHook;\nexports.RendererInitHook = RendererInitHook;\n//# sourceMappingURL=globalHooks.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/global/globalHooks.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/index.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar detectVideoAlphaMode = __webpack_require__(/*! ./browser/detectVideoAlphaMode.js */ \"./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.js\");\nvar isMobile = __webpack_require__(/*! ./browser/isMobile.js */ \"./node_modules/pixi.js/lib/utils/browser/isMobile.js\");\nvar isSafari = __webpack_require__(/*! ./browser/isSafari.js */ \"./node_modules/pixi.js/lib/utils/browser/isSafari.js\");\nvar isWebGLSupported = __webpack_require__(/*! ./browser/isWebGLSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.js\");\nvar isWebGPUSupported = __webpack_require__(/*! ./browser/isWebGPUSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.js\");\nvar unsafeEvalSupported = __webpack_require__(/*! ./browser/unsafeEvalSupported.js */ \"./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.js\");\nvar getCanvasBoundingBox = __webpack_require__(/*! ./canvas/getCanvasBoundingBox.js */ \"./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.js\");\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/utils/const.js\");\nvar clean = __webpack_require__(/*! ./data/clean.js */ \"./node_modules/pixi.js/lib/utils/data/clean.js\");\nvar removeItems = __webpack_require__(/*! ./data/removeItems.js */ \"./node_modules/pixi.js/lib/utils/data/removeItems.js\");\nvar uid = __webpack_require__(/*! ./data/uid.js */ \"./node_modules/pixi.js/lib/utils/data/uid.js\");\nvar updateQuadBounds = __webpack_require__(/*! ./data/updateQuadBounds.js */ \"./node_modules/pixi.js/lib/utils/data/updateQuadBounds.js\");\nvar ViewableBuffer = __webpack_require__(/*! ./data/ViewableBuffer.js */ \"./node_modules/pixi.js/lib/utils/data/ViewableBuffer.js\");\nvar globalHooks = __webpack_require__(/*! ./global/globalHooks.js */ \"./node_modules/pixi.js/lib/utils/global/globalHooks.js\");\nvar deprecation = __webpack_require__(/*! ./logging/deprecation.js */ \"./node_modules/pixi.js/lib/utils/logging/deprecation.js\");\nvar logDebugTexture = __webpack_require__(/*! ./logging/logDebugTexture.js */ \"./node_modules/pixi.js/lib/utils/logging/logDebugTexture.js\");\nvar logScene = __webpack_require__(/*! ./logging/logScene.js */ \"./node_modules/pixi.js/lib/utils/logging/logScene.js\");\nvar warn = __webpack_require__(/*! ./logging/warn.js */ \"./node_modules/pixi.js/lib/utils/logging/warn.js\");\nvar NOOP = __webpack_require__(/*! ./misc/NOOP.js */ \"./node_modules/pixi.js/lib/utils/misc/NOOP.js\");\nvar Transform = __webpack_require__(/*! ./misc/Transform.js */ \"./node_modules/pixi.js/lib/utils/misc/Transform.js\");\nvar getResolutionOfUrl = __webpack_require__(/*! ./network/getResolutionOfUrl.js */ \"./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js\");\nvar path = __webpack_require__(/*! ./path.js */ \"./node_modules/pixi.js/lib/utils/path.js\");\nvar Pool = __webpack_require__(/*! ./pool/Pool.js */ \"./node_modules/pixi.js/lib/utils/pool/Pool.js\");\nvar PoolGroup = __webpack_require__(/*! ./pool/PoolGroup.js */ \"./node_modules/pixi.js/lib/utils/pool/PoolGroup.js\");\nvar sayHello = __webpack_require__(/*! ./sayHello.js */ \"./node_modules/pixi.js/lib/utils/sayHello.js\");\n__webpack_require__(/*! ./types.js */ \"./node_modules/pixi.js/lib/utils/types.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"./node_modules/pixi.js/lib/utils/utils.js\");\n\n\"use strict\";\n\nexports.detectVideoAlphaMode = detectVideoAlphaMode.detectVideoAlphaMode;\nexports.isMobile = isMobile.isMobile;\nexports.isSafari = isSafari.isSafari;\nexports.isWebGLSupported = isWebGLSupported.isWebGLSupported;\nexports.isWebGPUSupported = isWebGPUSupported.isWebGPUSupported;\nexports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;\nexports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;\nexports.DATA_URI = _const.DATA_URI;\nexports.VERSION = _const.VERSION;\nexports.cleanArray = clean.cleanArray;\nexports.cleanHash = clean.cleanHash;\nexports.removeItems = removeItems.removeItems;\nexports.resetUids = uid.resetUids;\nexports.uid = uid.uid;\nexports.updateQuadBounds = updateQuadBounds.updateQuadBounds;\nexports.ViewableBuffer = ViewableBuffer.ViewableBuffer;\nexports.ApplicationInitHook = globalHooks.ApplicationInitHook;\nexports.RendererInitHook = globalHooks.RendererInitHook;\nexports.deprecation = deprecation.deprecation;\nexports.v8_0_0 = deprecation.v8_0_0;\nexports.v8_3_4 = deprecation.v8_3_4;\nexports.logDebugTexture = logDebugTexture.logDebugTexture;\nexports.logRenderGroupScene = logScene.logRenderGroupScene;\nexports.logScene = logScene.logScene;\nexports.warn = warn.warn;\nexports.NOOP = NOOP.NOOP;\nexports.Transform = Transform.Transform;\nexports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;\nexports.path = path.path;\nexports.Pool = Pool.Pool;\nexports.BigPool = PoolGroup.BigPool;\nexports.PoolGroupClass = PoolGroup.PoolGroupClass;\nexports.sayHello = sayHello.sayHello;\nexports.earcut = utils.earcut;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/index.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/deprecation.js":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/deprecation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nconst v8_3_4 = \"8.3.4\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexports.deprecation = deprecation;\nexports.v8_0_0 = v8_0_0;\nexports.v8_3_4 = v8_3_4;\n//# sourceMappingURL=deprecation.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/logging/deprecation.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/logDebugTexture.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/logDebugTexture.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nasync function logDebugTexture(texture, renderer, size = 200) {\n  const base64 = await renderer.extract.base64(texture);\n  await renderer.encoder.commandFinished;\n  const width = size;\n  console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);\n  const style = [\n    \"font-size: 1px;\",\n    `padding: ${width}px ${300}px;`,\n    `background: url(${base64}) no-repeat;`,\n    \"background-size: contain;\"\n  ].join(\" \");\n  console.log(\"%c \", style);\n}\n\nexports.logDebugTexture = logDebugTexture;\n//# sourceMappingURL=logDebugTexture.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/logging/logDebugTexture.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/logScene.js":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/logScene.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Sprite = __webpack_require__(/*! ../../scene/sprite/Sprite.js */ \"./node_modules/pixi.js/lib/scene/sprite/Sprite.js\");\n\n\"use strict\";\nconst colors = [\n  \"#000080\",\n  // Navy Blue\n  \"#228B22\",\n  // Forest Green\n  \"#8B0000\",\n  // Dark Red\n  \"#4169E1\",\n  // Royal Blue\n  \"#008080\",\n  // Teal\n  \"#800000\",\n  // Maroon\n  \"#9400D3\",\n  // Dark Violet\n  \"#FF8C00\",\n  // Dark Orange\n  \"#556B2F\",\n  // Olive Green\n  \"#8B008B\"\n  // Dark Magenta\n];\nlet colorTick = 0;\nfunction logScene(container, depth = 0, data = { color: \"#000000\" }) {\n  if (container.renderGroup) {\n    data.color = colors[colorTick++];\n  }\n  let spaces = \"\";\n  for (let i = 0; i < depth; i++) {\n    spaces += \"    \";\n  }\n  let label = container.label;\n  if (!label && container instanceof Sprite.Sprite) {\n    label = `sprite:${container.texture.label}`;\n  }\n  let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;\n  if (container.renderGroup) {\n    output += \" (RenderGroup)\";\n  }\n  if (container.filters) {\n    output += \"(*filters)\";\n  }\n  console.log(output, `color:${data.color}; font-weight:bold;`);\n  depth++;\n  for (let i = 0; i < container.children.length; i++) {\n    const child = container.children[i];\n    logScene(child, depth, { ...data });\n  }\n}\nfunction logRenderGroupScene(renderGroup, depth = 0, data = { index: 0, color: \"#000000\" }) {\n  let spaces = \"\";\n  for (let i = 0; i < depth; i++) {\n    spaces += \"    \";\n  }\n  const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;\n  console.log(output, `color:${data.color}; font-weight:bold;`);\n  depth++;\n  for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n    const child = renderGroup.renderGroupChildren[i];\n    logRenderGroupScene(child, depth, { ...data, index: i });\n  }\n}\n\nexports.logRenderGroupScene = logRenderGroupScene;\nexports.logScene = logScene;\n//# sourceMappingURL=logScene.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/logging/logScene.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/warn.js":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/warn.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexports.warn = warn;\n//# sourceMappingURL=warn.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/logging/warn.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/misc/NOOP.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/misc/NOOP.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nconst NOOP = () => {\n};\n\nexports.NOOP = NOOP;\n//# sourceMappingURL=NOOP.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/misc/NOOP.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/misc/Transform.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/misc/Transform.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Matrix = __webpack_require__(/*! ../../maths/matrix/Matrix.js */ \"./node_modules/pixi.js/lib/maths/matrix/Matrix.js\");\nvar ObservablePoint = __webpack_require__(/*! ../../maths/point/ObservablePoint.js */ \"./node_modules/pixi.js/lib/maths/point/ObservablePoint.js\");\n\n\"use strict\";\nclass Transform {\n  /**\n   * @param options - Options for the transform.\n   * @param options.matrix - The matrix to use.\n   * @param options.observer - The observer to use.\n   */\n  constructor({ matrix, observer } = {}) {\n    this.dirty = true;\n    this._matrix = matrix ?? new Matrix.Matrix();\n    this.observer = observer;\n    this.position = new ObservablePoint.ObservablePoint(this, 0, 0);\n    this.scale = new ObservablePoint.ObservablePoint(this, 1, 1);\n    this.pivot = new ObservablePoint.ObservablePoint(this, 0, 0);\n    this.skew = new ObservablePoint.ObservablePoint(this, 0, 0);\n    this._rotation = 0;\n    this._cx = 1;\n    this._sx = 0;\n    this._cy = 0;\n    this._sy = 1;\n  }\n  /**\n   * The transformation matrix computed from the transform's properties.\n   * Combines position, scale, rotation, skew, and pivot into a single matrix.\n   * @example\n   * ```ts\n   * // Get current matrix\n   * const matrix = transform.matrix;\n   * console.log(matrix.toString());\n   * ```\n   * @readonly\n   * @see {@link Matrix} For matrix operations\n   * @see {@link Transform.setFromMatrix} For setting transform from matrix\n   */\n  get matrix() {\n    const lt = this._matrix;\n    if (!this.dirty)\n      return lt;\n    lt.a = this._cx * this.scale.x;\n    lt.b = this._sx * this.scale.x;\n    lt.c = this._cy * this.scale.y;\n    lt.d = this._sy * this.scale.y;\n    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n    this.dirty = false;\n    return lt;\n  }\n  /**\n   * Called when a value changes.\n   * @param point\n   * @internal\n   */\n  _onUpdate(point) {\n    this.dirty = true;\n    if (point === this.skew) {\n      this.updateSkew();\n    }\n    this.observer?._onUpdate(this);\n  }\n  /** Called when the skew or the rotation changes. */\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y);\n    this._sx = Math.sin(this._rotation + this.skew.y);\n    this._cy = -Math.sin(this._rotation - this.skew.x);\n    this._sy = Math.cos(this._rotation - this.skew.x);\n    this.dirty = true;\n  }\n  toString() {\n    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;\n  }\n  /**\n   * Decomposes a matrix and sets the transforms properties based on it.\n   * @example\n   * ```ts\n   * // Basic matrix decomposition\n   * const transform = new Transform();\n   * const matrix = new Matrix()\n   *     .translate(100, 100)\n   *     .rotate(Math.PI / 4)\n   *     .scale(2, 2);\n   *\n   * transform.setFromMatrix(matrix);\n   * console.log(transform.position.x); // 100\n   * console.log(transform.rotation); // ~0.785 (π/4)\n   * ```\n   * @param matrix - The matrix to decompose\n   * @see {@link Matrix#decompose} For the decomposition logic\n   * @see {@link Transform#matrix} For getting the current matrix\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n    this.dirty = true;\n  }\n  /**\n   * The rotation of the object in radians.\n   * @example\n   * ```ts\n   * // Basic rotation\n   * transform.rotation = Math.PI / 4; // 45 degrees\n   *\n   * // Rotate around pivot point\n   * transform.pivot.set(50, 50);\n   * transform.rotation = Math.PI; // 180 degrees around pivot\n   *\n   * // Animate rotation\n   * app.ticker.add(() => {\n   *     transform.rotation += 0.1;\n   * });\n   * ```\n   * @see {@link Transform#pivot} For rotation point\n   * @see {@link Transform#skew} For skew effects\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this.skew);\n    }\n  }\n}\n\nexports.Transform = Transform;\n//# sourceMappingURL=Transform.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/misc/Transform.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Resolver = __webpack_require__(/*! ../../assets/resolver/Resolver.js */ \"./node_modules/pixi.js/lib/assets/resolver/Resolver.js\");\n\n\"use strict\";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver.Resolver.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\nexports.getResolutionOfUrl = getResolutionOfUrl;\n//# sourceMappingURL=getResolutionOfUrl.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/path.js":
/*!************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/path.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   * @example\n   * ```ts\n   * // Convert a Windows path to POSIX format\n   * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n   * // -> 'C:/Users/User/Documents/file.txt'\n   * ```\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   * @example\n   * ```ts\n   * // Check if a path is a URL\n   * path.isUrl('http://www.example.com');\n   * // -> true\n   * path.isUrl('C:/Users/User/Documents/file.txt');\n   * // -> false\n   * ```\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   * @example\n   * ```ts\n   * // Check if a path is a data URL\n   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n   * // -> true\n   * ```\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   * @example\n   * ```ts\n   * // Check if a path is a blob URL\n   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n   * // -> true\n   * ```\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   * @example\n   * ```ts\n   * // Check if a path has a protocol\n   * path.hasProtocol('http://www.example.com');\n   * // -> true\n   * path.hasProtocol('C:/Users/User/Documents/file.txt');\n   * // -> true\n   * ```\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   * @example\n   * ```ts\n   * // Get the protocol from a URL\n   * path.getProtocol('http://www.example.com/path/to/resource');\n   * // -> 'http://'\n   * // Get the protocol from a file path\n   * path.getProtocol('C:/Users/User/Documents/file.txt');\n   * // -> 'C:/'\n   * ```\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   * @example\n   * ```ts\n   * // Convert a relative URL to an absolute path\n   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n   * // -> 'http://example.com/assets/images/texture.png'\n   * ```\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? adapter.DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   * @example\n   * ```ts\n   * // Normalize a path with relative segments\n   * path.normalize('http://www.example.com/foo/bar/../baz');\n   * // -> 'http://www.example.com/foo/baz'\n   * // Normalize a file path with relative segments\n   * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n   * // -> 'C:/Users/User/file.txt'\n   * ```\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   * @example\n   * ```ts\n   * // Check if a path is absolute\n   * path.isAbsolute('http://www.example.com/foo/bar');\n   * // -> true\n   * path.isAbsolute('C:/Users/User/Documents/file.txt');\n   * // -> true\n   * ```\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   * @example\n   * ```ts\n   * // Join multiple path segments\n   * path.join('assets', 'images', 'sprite.png');\n   * // -> 'assets/images/sprite.png'\n   * // Join with relative segments\n   * path.join('assets', 'images', '../textures', 'sprite.png');\n   * // -> 'assets/textures/sprite.png'\n   * ```\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   * @example\n   * ```ts\n   * // Get the directory name of a path\n   * path.dirname('http://www.example.com/foo/bar/baz.png');\n   * // -> 'http://www.example.com/foo/bar'\n   * // Get the directory name of a file path\n   * path.dirname('C:/Users/User/Documents/file.txt');\n   * // -> 'C:/Users/User/Documents'\n   * ```\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   * @example\n   * ```ts\n   * // Get the root of a URL\n   * path.rootname('http://www.example.com/foo/bar/baz.png');\n   * // -> 'http://www.example.com/'\n   * // Get the root of a file path\n   * path.rootname('C:/Users/User/Documents/file.txt');\n   * // -> 'C:/'\n   * ```\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   * @example\n   * ```ts\n   * // Get the basename of a URL\n   * path.basename('http://www.example.com/foo/bar/baz.png');\n   * // -> 'baz.png'\n   * // Get the basename of a file path\n   * path.basename('C:/Users/User/Documents/file.txt');\n   * // -> 'file.txt'\n   * ```\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   * @example\n   * ```ts\n   * // Get the extension of a URL\n   * path.extname('http://www.example.com/foo/bar/baz.png');\n   * // -> '.png'\n   * // Get the extension of a file path\n   * path.extname('C:/Users/User/Documents/file.txt');\n   * // -> '.txt'\n   * ```\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   * @example\n   * ```ts\n   * // Parse a URL\n   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n   * // -> {\n   * //   root: 'http://www.example.com/',\n   * //   dir: 'http://www.example.com/foo/bar',\n   * //   base: 'baz.png',\n   * //   ext: '.png',\n   * //   name: 'baz'\n   * // }\n   * // Parse a file path\n   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n   * // -> {\n   * //   root: 'C:/',\n   * //   dir: 'C:/Users/User/Documents',\n   * //   base: 'file.txt',\n   * //   ext: '.txt',\n   * //   name: 'file'\n   * // }\n   * ```\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexports.path = path;\n//# sourceMappingURL=path.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/path.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/pool/Pool.js":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/pool/Pool.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\nexports.Pool = Pool;\n//# sourceMappingURL=Pool.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/pool/Pool.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.js":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/pool/PoolGroup.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Pool = __webpack_require__(/*! ./Pool.js */ \"./node_modules/pixi.js/lib/utils/pool/Pool.js\");\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool.Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexports.BigPool = BigPool;\nexports.PoolGroupClass = PoolGroupClass;\n//# sourceMappingURL=PoolGroup.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/pool/PoolGroup.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/sayHello.js":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/sayHello.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! ../environment/adapter.js */ \"./node_modules/pixi.js/lib/environment/adapter.js\");\nvar _const = __webpack_require__(/*! ./const.js */ \"./node_modules/pixi.js/lib/utils/const.js\");\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (adapter.DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${_const.VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${_const.VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexports.sayHello = sayHello;\n//# sourceMappingURL=sayHello.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/sayHello.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/types.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/types.js ***!
  \*************************************************/
/***/ (() => {

"use strict";
eval("\n\n\"use strict\";\n//# sourceMappingURL=types.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/types.js?");

/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar earcutModule = __webpack_require__(/*! earcut */ \"./node_modules/pixi.js/node_modules/earcut/src/earcut.js\");\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/pixi.js/node_modules/eventemitter3/index.js\");\n\n\"use strict\";\nconst earcut = earcutModule.default || earcutModule;\n\nexports.EventEmitter = EventEmitter;\nexports.earcut = earcut;\n//# sourceMappingURL=utils.js.map\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/lib/utils/utils.js?");

/***/ }),

/***/ "./node_modules/pixi.js/node_modules/earcut/src/earcut.js":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/earcut/src/earcut.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ earcut),\n/* harmony export */   deviation: () => (/* binding */ deviation),\n/* harmony export */   flatten: () => (/* binding */ flatten)\n/* harmony export */ });\n\nfunction earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = Infinity;\n        minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nfunction deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nfunction flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/pixi.js/node_modules/eventemitter3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/node_modules/eventemitter3/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/pixi.js/node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else // removed by dead control flow\n{}\n\n}(this));\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = {\n    'default': Format.RFC3986,\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return String(value);\n        }\n    },\n    RFC1738: Format.RFC1738,\n    RFC3986: Format.RFC3986\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/qs/lib/formats.js?");

/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/qs/lib/stringify.js\");\nvar parse = __webpack_require__(/*! ./parse */ \"./node_modules/qs/lib/parse.js\");\nvar formats = __webpack_require__(/*! ./formats */ \"./node_modules/qs/lib/formats.js\");\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/qs/lib/index.js?");

/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/qs/lib/utils.js\");\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowEmptyArrays: false,\n    allowPrototypes: false,\n    allowSparse: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decodeDotInKeys: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    duplicates: 'combine',\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictDepth: false,\n    strictNullHandling: false,\n    throwOnLimitExceeded: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\nvar parseArrayValue = function (val, options, currentArrayLength) {\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n        return val.split(',');\n    }\n\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n\n    return val;\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = { __proto__: null };\n\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(\n        options.delimiter,\n        options.throwOnLimitExceeded ? limit + 1 : limit\n    );\n\n    if (options.throwOnLimitExceeded && parts.length > limit) {\n        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');\n    }\n\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key;\n        var val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n\n            val = utils.maybeMap(\n                parseArrayValue(\n                    part.slice(pos + 1),\n                    options,\n                    isArray(obj[key]) ? obj[key].length : 0\n                ),\n                function (encodedVal) {\n                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n                }\n            );\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(String(val));\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        var existing = has.call(obj, key);\n        if (existing && options.duplicates === 'combine') {\n            obj[key] = utils.combine(obj[key], val);\n        } else if (!existing || options.duplicates === 'last') {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options, valuesParsed) {\n    var currentArrayLength = 0;\n    if (chain.length > 0 && chain[chain.length - 1] === '[]') {\n        var parentKey = chain.slice(0, -1).join('');\n        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;\n    }\n\n    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n                ? []\n                : utils.combine([], leaf);\n        } else {\n            obj = options.plainObjects ? { __proto__: null } : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;\n            var index = parseInt(decodedRoot, 10);\n            if (!options.parseArrays && decodedRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== decodedRoot\n                && String(index) === decodedRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else if (decodedRoot !== '__proto__') {\n                obj[decodedRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, check strictDepth option for throw, else just add whatever is left\n\n    if (segment) {\n        if (options.strictDepth === true) {\n            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');\n        }\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options, valuesParsed);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {\n        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {\n        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');\n    }\n\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;\n\n    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {\n        throw new TypeError('The duplicates option must be either combine, first, or last');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        duplicates: duplicates,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,\n        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? { __proto__: null } : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? { __proto__: null } : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    if (options.allowSparse === true) {\n        return obj;\n    }\n\n    return utils.compact(obj);\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/qs/lib/parse.js?");

/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getSideChannel = __webpack_require__(/*! side-channel */ \"./node_modules/side-channel/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/qs/lib/utils.js\");\nvar formats = __webpack_require__(/*! ./formats */ \"./node_modules/qs/lib/formats.js\");\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    allowEmptyArrays: false,\n    arrayFormat: 'indices',\n    charset: 'utf-8',\n    charsetSentinel: false,\n    commaRoundTrip: false,\n    delimiter: '&',\n    encode: true,\n    encodeDotInKeys: false,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    filter: void undefined,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar sentinel = {};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    commaRoundTrip,\n    allowEmptyArrays,\n    strictNullHandling,\n    skipNulls,\n    encodeDotInKeys,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    format,\n    formatter,\n    encodeValuesOnly,\n    charset,\n    sideChannel\n) {\n    var obj = object;\n\n    var tmpSc = sideChannel;\n    var step = 0;\n    var findFlag = false;\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n        // Where object last appeared in the ref tree\n        var pos = tmpSc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            } else {\n                findFlag = true; // Break while\n            }\n        }\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = utils.maybeMap(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            return value;\n        });\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            obj = utils.maybeMap(obj, encoder);\n        }\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    } else if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\\./g, '%2E') : String(prefix);\n\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;\n\n    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {\n        return adjustedPrefix + '[]';\n    }\n\n    for (var j = 0; j < objKeys.length; ++j) {\n        var key = objKeys[j];\n        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'\n            ? key.value\n            : obj[key];\n\n        if (skipNulls && value === null) {\n            continue;\n        }\n\n        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\\./g, '%2E') : String(key);\n        var keyPrefix = isArray(obj)\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix\n            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');\n\n        sideChannel.set(object, step);\n        var valueSideChannel = getSideChannel();\n        valueSideChannel.set(sentinel, sideChannel);\n        pushToArray(values, stringify(\n            value,\n            keyPrefix,\n            generateArrayPrefix,\n            commaRoundTrip,\n            allowEmptyArrays,\n            strictNullHandling,\n            skipNulls,\n            encodeDotInKeys,\n            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            format,\n            formatter,\n            encodeValuesOnly,\n            charset,\n            valueSideChannel\n        ));\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {\n        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');\n    }\n\n    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {\n        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');\n    }\n\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    var arrayFormat;\n    if (opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if ('indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = defaults.arrayFormat;\n    }\n\n    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n\n    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: allowDots,\n        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,\n        arrayFormat: arrayFormat,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        commaRoundTrip: !!opts.commaRoundTrip,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];\n    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    var sideChannel = getSideChannel();\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n        var value = obj[key];\n\n        if (options.skipNulls && value === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            value,\n            key,\n            generateArrayPrefix,\n            commaRoundTrip,\n            options.allowEmptyArrays,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encodeDotInKeys,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.format,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset,\n            sideChannel\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/qs/lib/stringify.js?");

/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar formats = __webpack_require__(/*! ./formats */ \"./node_modules/qs/lib/formats.js\");\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? { __proto__: null } : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object' && typeof source !== 'function') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if (\n                (options && (options.plainObjects || options.allowPrototypes))\n                || !has.call(Object.prototype, source)\n            ) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, defaultDecoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar limit = 1024;\n\n/* eslint operator-linebreak: [2, \"before\"] */\n\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var j = 0; j < string.length; j += limit) {\n        var segment = string.length >= limit ? string.slice(j, j + limit) : string;\n        var arr = [];\n\n        for (var i = 0; i < segment.length; ++i) {\n            var c = segment.charCodeAt(i);\n            if (\n                c === 0x2D // -\n                || c === 0x2E // .\n                || c === 0x5F // _\n                || c === 0x7E // ~\n                || (c >= 0x30 && c <= 0x39) // 0-9\n                || (c >= 0x41 && c <= 0x5A) // a-z\n                || (c >= 0x61 && c <= 0x7A) // A-Z\n                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n            ) {\n                arr[arr.length] = segment.charAt(i);\n                continue;\n            }\n\n            if (c < 0x80) {\n                arr[arr.length] = hexTable[c];\n                continue;\n            }\n\n            if (c < 0x800) {\n                arr[arr.length] = hexTable[0xC0 | (c >> 6)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            if (c < 0xD800 || c >= 0xE000) {\n                arr[arr.length] = hexTable[0xE0 | (c >> 12)]\n                    + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                    + hexTable[0x80 | (c & 0x3F)];\n                continue;\n            }\n\n            i += 1;\n            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));\n\n            arr[arr.length] = hexTable[0xF0 | (c >> 18)]\n                + hexTable[0x80 | ((c >> 12) & 0x3F)]\n                + hexTable[0x80 | ((c >> 6) & 0x3F)]\n                + hexTable[0x80 | (c & 0x3F)];\n        }\n\n        out += arr.join('');\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nvar maybeMap = function maybeMap(val, fn) {\n    if (isArray(val)) {\n        var mapped = [];\n        for (var i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    maybeMap: maybeMap,\n    merge: merge\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/qs/lib/utils.js?");

/***/ }),

/***/ "./node_modules/side-channel-list/index.js":
/*!*************************************************!*\
  !*** ./node_modules/side-channel-list/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar inspect = __webpack_require__(/*! object-inspect */ \"./node_modules/object-inspect/index.js\");\n\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/side-channel-list/index.js?");

/***/ }),

/***/ "./node_modules/side-channel-map/index.js":
/*!************************************************!*\
  !*** ./node_modules/side-channel-map/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\nvar callBound = __webpack_require__(/*! call-bound */ \"./node_modules/call-bound/index.js\");\nvar inspect = __webpack_require__(/*! object-inspect */ \"./node_modules/object-inspect/index.js\");\n\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\nvar $Map = GetIntrinsic('%Map%', true);\n\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */\nvar $mapGet = callBound('Map.prototype.get', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */\nvar $mapSet = callBound('Map.prototype.set', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapHas = callBound('Map.prototype.has', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapDelete = callBound('Map.prototype.delete', true);\n/** @type {<K, V>(thisArg: Map<K, V>) => number} */\nvar $mapSize = callBound('Map.prototype.size', true);\n\n/** @type {import('.')} */\nmodule.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {\n\t/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {Map<K, V> | undefined} */ var $m;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tif ($m) {\n\t\t\t\tvar result = $mapDelete($m, key);\n\t\t\t\tif ($mapSize($m) === 0) {\n\t\t\t\t\t$m = void undefined;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($m) {\n\t\t\t\treturn $mapGet($m, key);\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($m) {\n\t\t\t\treturn $mapHas($m, key);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$m) {\n\t\t\t\t// @ts-expect-error TS can't handle narrowing a variable inside a closure\n\t\t\t\t$m = new $Map();\n\t\t\t}\n\t\t\t$mapSet($m, key, value);\n\t\t}\n\t};\n\n\t// @ts-expect-error TODO: figure out why TS is erroring here\n\treturn channel;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/side-channel-map/index.js?");

/***/ }),

/***/ "./node_modules/side-channel-weakmap/index.js":
/*!****************************************************!*\
  !*** ./node_modules/side-channel-weakmap/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\nvar callBound = __webpack_require__(/*! call-bound */ \"./node_modules/call-bound/index.js\");\nvar inspect = __webpack_require__(/*! object-inspect */ \"./node_modules/object-inspect/index.js\");\nvar getSideChannelMap = __webpack_require__(/*! side-channel-map */ \"./node_modules/side-channel-map/index.js\");\n\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapDelete = callBound('WeakMap.prototype.delete', true);\n\n/** @type {import('.')} */\nmodule.exports = $WeakMap\n\t? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {\n\t\t/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */\n\t\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t\t/** @type {WeakMap<K & object, V> | undefined} */ var $wm;\n\t\t/** @type {Channel | undefined} */ var $m;\n\n\t\t/** @type {Channel} */\n\t\tvar channel = {\n\t\t\tassert: function (key) {\n\t\t\t\tif (!channel.has(key)) {\n\t\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t\t}\n\t\t\t},\n\t\t\t'delete': function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapDelete($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $m['delete'](key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tget: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $m && $m.get(key);\n\t\t\t},\n\t\t\thas: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!$m && $m.has(key);\n\t\t\t},\n\t\t\tset: function (key, value) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif (!$wm) {\n\t\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t\t}\n\t\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif (!$m) {\n\t\t\t\t\t\t$m = getSideChannelMap();\n\t\t\t\t\t}\n\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\t/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// @ts-expect-error TODO: figure out why this is erroring\n\t\treturn channel;\n\t}\n\t: getSideChannelMap;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/side-channel-weakmap/index.js?");

/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar $TypeError = __webpack_require__(/*! es-errors/type */ \"./node_modules/es-errors/type.js\");\nvar inspect = __webpack_require__(/*! object-inspect */ \"./node_modules/object-inspect/index.js\");\nvar getSideChannelList = __webpack_require__(/*! side-channel-list */ \"./node_modules/side-channel-list/index.js\");\nvar getSideChannelMap = __webpack_require__(/*! side-channel-map */ \"./node_modules/side-channel-map/index.js\");\nvar getSideChannelWeakMap = __webpack_require__(/*! side-channel-weakmap */ \"./node_modules/side-channel-weakmap/index.js\");\n\nvar makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannel() {\n\t/** @typedef {ReturnType<typeof getSideChannel>} Channel */\n\n\t/** @type {Channel | undefined} */ var $channelData;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\treturn !!$channelData && $channelData['delete'](key);\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn $channelData && $channelData.get(key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn !!$channelData && $channelData.has(key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$channelData) {\n\t\t\t\t$channelData = makeChannel();\n\t\t\t}\n\n\t\t\t$channelData.set(key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/side-channel/index.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\nvar punycode = __webpack_require__(/*! punycode/ */ \"./node_modules/punycode/punycode.js\");\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n/*\n * define these here so at least they only have to be\n * compiled once on the first module load.\n */\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/,\n\n  /*\n   * RFC 2396: characters reserved for delimiting URLs.\n   * We actually just auto-escape these.\n   */\n  delims = [\n    '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'\n  ],\n\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [\n    '{', '}', '|', '\\\\', '^', '`'\n  ].concat(delims),\n\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  /*\n   * Characters that are never ever allowed in a hostname.\n   * Note that any invalid chars are also handled, but these\n   * are the ones that are *expected* to be seen, so we fast-path\n   * them.\n   */\n  nonHostChars = [\n    '%', '/', '?', ';', '#'\n  ].concat(autoEscape),\n  hostEndingChars = [\n    '/', '?', '#'\n  ],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = __webpack_require__(/*! qs */ \"./node_modules/qs/lib/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === 'object' && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  /*\n   * Copy chrome, IE, opera backslash-handling behavior.\n   * Back slashes before the query string get converted to forward slashes\n   * See: https://code.google.com/p/chromium/issues/detail?id=25916\n   */\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  /*\n   * trim before proceeding.\n   * This is to support parse stuff like \"  http://foo.com  \\n\"\n   */\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  /*\n   * figure out if it's got a host\n   * user@server is *always* interpreted as a hostname, and url\n   * resolution will treat //foo/bar as host=foo,path=bar because that's\n   * how the browser resolves relative URLs.\n   */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\n\n    /*\n     * there's a hostname.\n     * the first instance of /, ?, ;, or # ends the host.\n     *\n     * If there is an @ in the hostname, then non-host chars *are* allowed\n     * to the left of the last @ sign, unless some host-ending character\n     * comes *before* the @-sign.\n     * URLs are obnoxious.\n     *\n     * ex:\n     * http://a@b@c/ => user:a@b host:c\n     * http://a@b?@c => user:a host:c path:/?@c\n     */\n\n    /*\n     * v0.12 TODO(isaacs): This is not quite how Chrome does things.\n     * Review our test case against browsers more comprehensively.\n     */\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n\n    /*\n     * at this point, either we have an explicit point where the\n     * auth portion cannot go past, or the last @ char is the decider.\n     */\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      /*\n       * atSign must be in auth portion.\n       * http://a@b/c@d => host:b auth:a path:/c@d\n       */\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    /*\n     * Now we have a portion which is definitely the auth.\n     * Pull that off.\n     */\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    /*\n     * we've indicated that there is a hostname,\n     * so even if it's empty, it has to be present.\n     */\n    this.hostname = this.hostname || '';\n\n    /*\n     * if hostname begins with [ and ends with ]\n     * assume that it's an IPv6 address.\n     */\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              /*\n               * we replace non-ASCII char with a temporary placeholder\n               * we need this to make sure size of hostname is not\n               * broken by replacing non-ASCII by nothing\n               */\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      /*\n       * IDNA Support: Returns a punycoded representation of \"domain\".\n       * It only converts parts of the domain name that\n       * have non-ASCII characters, i.e. it doesn't matter if\n       * you call it with a domain that already is ASCII-only.\n       */\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    /*\n     * strip [ and ] from the hostname\n     * the host field still retains them, though\n     */\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  /*\n   * now rest is set to the post-host stuff.\n   * chop off any delim chars.\n   */\n  if (!unsafeProtocol[lowerProto]) {\n\n    /*\n     * First, make 100% sure that any \"autoEscape\" chars get\n     * escaped, even if encodeURIComponent doesn't think they\n     * need to be.\n     */\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  /*\n   * ensure it's an object, and not a string url.\n   * If it's an obj, this is a no-op.\n   * this way, you can call url_format() on strings\n   * to clean up potentially wonky urls.\n   */\n  if (typeof obj === 'string') { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query, {\n      arrayFormat: 'repeat',\n      addQueryPrefix: false\n    });\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  /*\n   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   * unless they had them to begin with.\n   */\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  /*\n   * hash is always overridden, no matter what.\n   * even href=\"\" will remove it.\n   */\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.pathname = '/';\n      result.path = result.pathname;\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    /*\n     * if it's a known url protocol, then changing\n     * the protocol does weird things\n     * first, if it's not file:, then we MUST have a host,\n     * and if there was a path\n     * to begin with, then we MUST have a path.\n     * if it is file:, then the host is dropped,\n     * because that's known to be hostless.\n     * anything else is assumed to be absolute.\n     */\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())) { }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  /*\n   * if the url is a non-slashed url, then relative\n   * links like ../.. should be able\n   * to crawl up to the hostname, as well.  This is strange.\n   * result.protocol has already been set by now.\n   * Later on, put the first path part into the host field.\n   */\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    /*\n     * it's relative\n     * throw away the existing file, and take the new path instead.\n     */\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search != null) {\n    /*\n     * just pull out the search.\n     * like href='?foo'.\n     * Put this after the other two cases because it simplifies the booleans\n     */\n    if (psychotic) {\n      result.host = srcPath.shift();\n      result.hostname = result.host;\n      /*\n       * occationaly the auth can get stuck only in host\n       * this especially happens in cases like\n       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n       */\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.hostname = authInHost.shift();\n        result.host = result.hostname;\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    /*\n     * no path at all.  easy.\n     * we've already handled the other stuff above.\n     */\n    result.pathname = null;\n    // to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  /*\n   * if a url ENDs in . or .., then it must get a trailing slash.\n   * however, if it ends in anything else non-slashy,\n   * then it must NOT get a trailing slash.\n   */\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  /*\n   * strip single dots, resolve double dots to parent dir\n   * if the path tries to go above the root, `up` ends up > 0\n   */\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    result.host = result.hostname;\n    /*\n     * occationaly the auth can get stuck only in host\n     * this especially happens in cases like\n     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n     */\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.hostname = authInHost.shift();\n      result.host = result.hostname;\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (srcPath.length > 0) {\n    result.pathname = srcPath.join('/');\n  } else {\n    result.pathname = null;\n    result.path = null;\n  }\n\n  // to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\n\n//# sourceURL=webpack://pixi-playground/./node_modules/url/url.js?");

/***/ }),

/***/ "./src/boundary.ts":
/*!*************************!*\
  !*** ./src/boundary.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/** Class to represent a boundary within the world\n *  Jimy Houlbrook\n *  17/11/23\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/index.js\");\nclass Boundary extends pixi_js_1.Graphics {\n    constructor(x1, y1, x2, y2) {\n        super();\n        this.start = new pixi_js_1.Point(x1, y1);\n        this.fin = new pixi_js_1.Point(x2, y2);\n        this.moveTo(this.start.x, this.start.y);\n        this.lineTo(this.fin.x, this.fin.y);\n        this.stroke({ width: 5, color: 0xffffff });\n    }\n}\nexports[\"default\"] = Boundary;\n\n\n//# sourceURL=webpack://pixi-playground/./src/boundary.ts?");

/***/ }),

/***/ "./src/caster.ts":
/*!***********************!*\
  !*** ./src/caster.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/** Class to represent ball that is casting rays\n *  Jimy Houlbrook\n *  16/11/23\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/index.js\");\nconst ray_1 = __importDefault(__webpack_require__(/*! ./ray */ \"./src/ray.ts\"));\nclass Caster extends pixi_js_1.Graphics {\n    constructor(x = 0, y = 0, r = 30, game) {\n        super();\n        this.game = game;\n        this.pos = new pixi_js_1.Point(x, y);\n        this.r = r;\n        // this.circle(x, y, r);\n        // this.stroke({width: 5, color: 0xffffff})\n        this.rays = new Array();\n        let hue = 0;\n        const angleDelta = 0.5;\n        for (let i = 0; i < 360; i += angleDelta) {\n            const ray = new ray_1.default(this.pos, this.degreeToRadian(i), hue);\n            hue += angleDelta;\n            this.rays.push(ray);\n        }\n        window.addEventListener('mousemove', e => this.updatePos(e.clientX, e.clientY));\n    }\n    updatePos(x, y) {\n        this.pos.x = x;\n        this.pos.y = y;\n        for (const ray of this.rays) {\n            ray.pos.x = x;\n            ray.pos.y = y;\n            ray.draw();\n        }\n        // this.clear();\n        // this.circle(this.pos.x, this.pos.y, this.r);\n        // this.stroke({width: 5, color: 0xffffff});\n    }\n    look(boundaries) {\n        for (const ray of this.rays) {\n            let closest;\n            let max = Infinity;\n            for (const boundary of boundaries) {\n                const pt = ray.pointWillIntersect(boundary);\n                if (pt != undefined) {\n                    const d = this.distanceBetweenPoints(pt);\n                    if (d <= max) {\n                        max = d;\n                        closest = pt;\n                    }\n                }\n            }\n            if (closest) {\n                ray.lookAt(closest);\n                this.addChildAt(ray, 0);\n            }\n            else {\n                ray.clear();\n            }\n        }\n    }\n    distanceBetweenPoints(pt) {\n        const x1 = this.pos.x;\n        const y1 = this.pos.y;\n        const x2 = pt.x;\n        const y2 = pt.y;\n        const xd = x2 - x1;\n        const yd = y2 - y1;\n        return Math.sqrt(xd ** 2 + yd ** 2);\n    }\n    degreeToRadian(d) {\n        return d * (Math.PI / 180);\n    }\n}\nexports[\"default\"] = Caster;\n\n\n//# sourceURL=webpack://pixi-playground/./src/caster.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/** Application to demonstrate raycasting in pixijs\n *  Jimy Houlbrook\n *  16/11/23\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PIXI = __importStar(__webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/index.js\"));\nconst caster_1 = __importDefault(__webpack_require__(/*! ./caster */ \"./src/caster.ts\"));\nconst boundary_1 = __importDefault(__webpack_require__(/*! ./boundary */ \"./src/boundary.ts\"));\nclass Application {\n    constructor() {\n        this.app = new PIXI.Application();\n        //@ts-expect-error\n        globalThis.__PIXI_APP__ = this.app;\n        this.boundaries = new Array();\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.app.init({\n                resizeTo: window,\n                backgroundColor: 0x000000,\n                hello: true,\n                view: document.getElementById('cont'),\n                antialias: true\n            });\n            const backgroundTexture = yield PIXI.Assets.load('/data/images/real.png');\n            console.log(backgroundTexture);\n            this.worldContainer = new PIXI.Container();\n            this.app.stage.addChild(this.worldContainer);\n            const background = new PIXI.Sprite(backgroundTexture);\n            this.worldContainer.addChild(background);\n            // Screen boundaries\n            const w = this.app.screen.width;\n            const h = this.app.screen.height;\n            this.boundaries.push(new boundary_1.default(0, 0, w, 0), new boundary_1.default(w, 0, w, h), new boundary_1.default(w, h, 0, h), new boundary_1.default(0, h, 0, 0));\n            // Create randomised boundaries\n            for (let i = 0; i < 3; i++) {\n                let p1 = new PIXI.Point(Math.floor(Math.random() * this.app.screen.width), Math.floor(Math.random() * this.app.screen.height));\n                let p2 = new PIXI.Point(Math.floor(Math.random() * this.app.screen.width), Math.floor(Math.random() * this.app.screen.height));\n                const bound = new boundary_1.default(p1.x, p1.y, p2.x, p2.y);\n                this.boundaries.push(bound);\n                this.worldContainer.addChild(bound);\n            }\n            this.caster = new caster_1.default(this.app.screen.width, this.app.screen.height, 30, this.app);\n            this.worldContainer.addChild(this.caster);\n            this.worldContainer.mask = this.caster;\n            this.app.ticker.add(this.onTick.bind(this));\n        });\n    }\n    onTick() {\n        this.caster.look(this.boundaries);\n    }\n}\nexports[\"default\"] = Application;\nwindow.addEventListener('DOMContentLoaded', () => new Application);\n\n\n//# sourceURL=webpack://pixi-playground/./src/index.ts?");

/***/ }),

/***/ "./src/ray.ts":
/*!********************!*\
  !*** ./src/ray.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/** Class to represent ray\n *  17/11/23\n *  Jimy Houlbrook\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/index.js\");\n__webpack_require__(/*! @pixi/math-extras */ \"./node_modules/@pixi/math-extras/lib/index.js\");\nclass Ray extends pixi_js_1.Graphics {\n    constructor(pos, angle, hue) {\n        super();\n        this.pos = pos;\n        this.dir = this.vectorFromAngle(angle);\n        const tint = new pixi_js_1.Color({ h: hue, s: 100, v: 100 });\n        // this.lineStyle(5, \"#FFFFFF\");\n        // this.tint = tint;\n        this.moveTo(this.pos.x, this.pos.y);\n        this.lineTo(this.pos.x + this.dir.x, this.pos.y + this.dir.y);\n        this.stroke({ width: 5, color: 0xFF0000 });\n    }\n    vectorFromAngle(a) {\n        return new pixi_js_1.Point(Math.cos(a), Math.sin(a));\n    }\n    pointWillIntersect(b) {\n        // Im not gonna pretend to understand this maths,\n        // it has convinced me that maths is infact dark magic.\n        // REF: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n        // Position of boundary\n        const x1 = b.start.x;\n        const y1 = b.start.y;\n        const x2 = b.fin.x;\n        const y2 = b.fin.y;\n        // Position of ray given that it goes on for infinite length\n        const x3 = this.pos.x;\n        const y3 = this.pos.y;\n        const x4 = this.pos.x + this.dir.x;\n        const y4 = this.pos.y + this.dir.y;\n        const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        // If the denominator is 0 the points will not intersect\n        if (den === 0)\n            return;\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n        if (!(t > 0 && t < 1 && u > 0))\n            return;\n        return new pixi_js_1.Point(x1 + t * (x2 - x1), y1 + t * (y2 - y1));\n    }\n    draw() {\n        this.clear();\n        this.moveTo(this.pos.x, this.pos.y);\n        this.lineTo(this.pos.x + this.dir.x, this.pos.y + this.dir.y);\n        this.stroke({ width: 5, color: 0xff0000 });\n    }\n    lookAt(p) {\n        this.dir.x = p.x - this.pos.x;\n        this.dir.y = p.y - this.pos.y;\n        this.draw();\n    }\n}\nexports[\"default\"] = Ray;\n\n\n//# sourceURL=webpack://pixi-playground/./src/ray.ts?");

/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://pixi-playground/./util.inspect_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;